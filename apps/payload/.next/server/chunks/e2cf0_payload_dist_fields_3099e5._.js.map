{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/config/types.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { EditorProps } from '@monaco-editor/react'\nimport type { JSONSchema4 } from 'json-schema'\nimport type { CSSProperties } from 'react'\nimport type { DeepUndefinable, MarkRequired } from 'ts-essentials'\n\nimport type {\n  JoinFieldClientProps,\n  JoinFieldErrorClientComponent,\n  JoinFieldErrorServerComponent,\n  JoinFieldLabelClientComponent,\n  JoinFieldLabelServerComponent,\n} from '../../admin/fields/Join.js'\nimport type { FieldClientComponent, FieldServerComponent } from '../../admin/forms/Field.js'\nimport type { RichTextAdapter, RichTextAdapterProvider } from '../../admin/RichText.js'\nimport type {\n  ArrayFieldClientProps,\n  ArrayFieldErrorClientComponent,\n  ArrayFieldErrorServerComponent,\n  ArrayFieldLabelClientComponent,\n  ArrayFieldLabelServerComponent,\n  BlocksFieldClientProps,\n  BlocksFieldErrorClientComponent,\n  BlocksFieldErrorServerComponent,\n  BlocksFieldLabelClientComponent,\n  BlocksFieldLabelServerComponent,\n  CheckboxFieldClientProps,\n  CheckboxFieldErrorClientComponent,\n  CheckboxFieldErrorServerComponent,\n  CheckboxFieldLabelClientComponent,\n  CheckboxFieldLabelServerComponent,\n  ClientTab,\n  CodeFieldClientProps,\n  CodeFieldErrorClientComponent,\n  CodeFieldErrorServerComponent,\n  CodeFieldLabelClientComponent,\n  CodeFieldLabelServerComponent,\n  CollapsibleFieldClientProps,\n  CollapsibleFieldLabelClientComponent,\n  CollapsibleFieldLabelServerComponent,\n  ConditionalDateProps,\n  DateFieldClientProps,\n  DateFieldErrorClientComponent,\n  DateFieldErrorServerComponent,\n  DateFieldLabelClientComponent,\n  DateFieldLabelServerComponent,\n  DefaultCellComponentProps,\n  DefaultServerCellComponentProps,\n  Description,\n  EmailFieldClientProps,\n  EmailFieldErrorClientComponent,\n  EmailFieldErrorServerComponent,\n  EmailFieldLabelClientComponent,\n  EmailFieldLabelServerComponent,\n  FieldDescriptionClientProps,\n  FieldDescriptionServerProps,\n  FieldDiffClientComponent,\n  FieldDiffServerProps,\n  GroupFieldClientProps,\n  GroupFieldLabelClientComponent,\n  GroupFieldLabelServerComponent,\n  HiddenFieldProps,\n  JSONFieldClientProps,\n  JSONFieldErrorClientComponent,\n  JSONFieldErrorServerComponent,\n  JSONFieldLabelClientComponent,\n  JSONFieldLabelServerComponent,\n  NumberFieldClientProps,\n  NumberFieldErrorClientComponent,\n  NumberFieldErrorServerComponent,\n  NumberFieldLabelClientComponent,\n  NumberFieldLabelServerComponent,\n  PointFieldClientProps,\n  PointFieldErrorClientComponent,\n  PointFieldErrorServerComponent,\n  PointFieldLabelClientComponent,\n  PointFieldLabelServerComponent,\n  RadioFieldClientProps,\n  RadioFieldErrorClientComponent,\n  RadioFieldErrorServerComponent,\n  RadioFieldLabelClientComponent,\n  RadioFieldLabelServerComponent,\n  RelationshipFieldClientProps,\n  RelationshipFieldErrorClientComponent,\n  RelationshipFieldErrorServerComponent,\n  RelationshipFieldLabelClientComponent,\n  RelationshipFieldLabelServerComponent,\n  RichTextFieldClientProps,\n  RowFieldClientProps,\n  RowLabelComponent,\n  SelectFieldClientProps,\n  SelectFieldErrorClientComponent,\n  SelectFieldErrorServerComponent,\n  SelectFieldLabelClientComponent,\n  SelectFieldLabelServerComponent,\n  StaticDescription,\n  TabsFieldClientProps,\n  TextareaFieldClientProps,\n  TextareaFieldErrorClientComponent,\n  TextareaFieldErrorServerComponent,\n  TextareaFieldLabelClientComponent,\n  TextareaFieldLabelServerComponent,\n  TextFieldClientProps,\n  TextFieldErrorClientComponent,\n  TextFieldErrorServerComponent,\n  TextFieldLabelClientComponent,\n  TextFieldLabelServerComponent,\n  UploadFieldClientProps,\n} from '../../admin/types.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'\nimport type {\n  CustomComponent,\n  LabelFunction,\n  PayloadComponent,\n  StaticLabel,\n} from '../../config/types.js'\nimport type { DBIdentifierName } from '../../database/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type {\n  ArrayFieldValidation,\n  BlocksFieldValidation,\n  CheckboxFieldValidation,\n  CodeFieldValidation,\n  CollectionSlug,\n  DateFieldValidation,\n  EmailFieldValidation,\n  JSONFieldValidation,\n  PointFieldValidation,\n  RadioFieldValidation,\n  RequestContext,\n  Sort,\n  TextareaFieldValidation,\n} from '../../index.js'\nimport type { DocumentPreferences } from '../../preferences/types.js'\nimport type {\n  DefaultValue,\n  JsonObject,\n  Operation,\n  PayloadRequest,\n  Where,\n} from '../../types/index.js'\nimport type {\n  NumberFieldManyValidation,\n  NumberFieldSingleValidation,\n  RelationshipFieldManyValidation,\n  RelationshipFieldSingleValidation,\n  SelectFieldManyValidation,\n  SelectFieldSingleValidation,\n  TextFieldManyValidation,\n  TextFieldSingleValidation,\n  UploadFieldManyValidation,\n  UploadFieldSingleValidation,\n} from '../validations.js'\n\nexport type FieldHookArgs<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = {\n  /**\n   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n   */\n  blockData: JsonObject | undefined\n  /** The collection which the field belongs to. If the field belongs to a global, this will be null. */\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  /**\n   * Only available in `afterRead` hooks\n   */\n  currentDepth?: number /**\n   * Only available in `afterRead` hooks\n   */\n  /** The data passed to update the document within create and update operations, and the full document itself in the afterRead hook. */\n  data?: Partial<TData>\n  /**\n   * Only available in the `afterRead` hook.\n   */\n  depth?: number\n  draft?: boolean\n  /** The field which the hook is running against. */\n  field: FieldAffectingData\n  /** Boolean to denote if this hook is running against finding one, or finding many within the afterRead hook. */\n  findMany?: boolean\n  /** The global which the field belongs to. If the field belongs to a collection, this will be null. */\n  global: null | SanitizedGlobalConfig\n  indexPath: number[]\n  /** A string relating to which operation the field type is currently executing within. Useful within beforeValidate, beforeChange, and afterChange hooks to differentiate between create and update operations. */\n  operation?: 'create' | 'delete' | 'read' | 'update'\n  /** The full original document in `update` operations. In the `afterChange` hook, this is the resulting document of the operation. */\n  originalDoc?: TData\n  overrideAccess?: boolean\n  /**\n   * The path of the field, e.g. [\"group\", \"myArray\", 1, \"textField\"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.\n   */\n  path: (number | string)[]\n  /** The document before changes were applied, only in `afterChange` hooks. */\n  previousDoc?: TData\n  /** The sibling data of the document before changes being applied, only in `beforeChange`, `beforeValidate`, `beforeDuplicate` and `afterChange` field hooks. */\n  previousSiblingDoc?: TData\n  /** The previous value of the field, before changes, only in `beforeChange`, `afterChange`, `beforeDuplicate` and `beforeValidate` field hooks. */\n  previousValue?: TValue\n  /** The Express request object. It is mocked for Local API operations. */\n  req: PayloadRequest\n  /**\n   * The schemaPath of the field, e.g. [\"group\", \"myArray\", \"textField\"]. The schemaPath is the path but without indexes and would be used in the context of field schemas, not field data.\n   */\n  schemaPath: string[]\n  /**\n   * Only available in the `afterRead` hook.\n   */\n  showHiddenFields?: boolean\n  /** The sibling data passed to a field that the hook is running against. */\n  siblingData: Partial<TSiblingData>\n  /**\n   * The original siblingData with locales (not modified by any hooks). Only available in `beforeChange` and `beforeDuplicate` field hooks.\n   */\n  siblingDocWithLocales?: Record<string, unknown>\n  /** The value of the field. */\n  value?: TValue\n}\n\nexport type FieldHook<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = (\n  args: FieldHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type FieldAccess<TData extends TypeWithID = any, TSiblingData = any> = (args: {\n  /**\n   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n   */\n  blockData?: JsonObject | undefined\n  /**\n   * The incoming, top-level document data used to `create` or `update` the document with.\n   */\n  data?: Partial<TData>\n  /**\n   * The original data of the document before the `update` is applied. `doc` is undefined during the `create` operation.\n   */\n  doc?: TData\n  /**\n   * The `id` of the current document being read or updated. `id` is undefined during the `create` operation.\n   */\n  id?: number | string\n  /** The `payload` object to interface with the payload API */\n  req: PayloadRequest\n  /**\n   * Immediately adjacent data to this field. For example, if this is a `group` field, then `siblingData` will be the other fields within the group.\n   */\n  siblingData?: Partial<TSiblingData>\n}) => boolean | Promise<boolean>\n\n//TODO: In 4.0, we should replace the three parameters of the condition function with a single, named parameter object\nexport type Condition<TData extends TypeWithID = any, TSiblingData = any> = (\n  /**\n   * The top-level document data\n   */\n  data: Partial<TData>,\n  /**\n   * Immediately adjacent data to this field. For example, if this is a `group` field, then `siblingData` will be the other fields within the group.\n   */\n  siblingData: Partial<TSiblingData>,\n  {\n    blockData,\n    user,\n  }: {\n    /**\n     * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n     */\n    blockData: Partial<TData>\n    user: PayloadRequest['user']\n  },\n) => boolean\n\nexport type FilterOptionsProps<TData = any> = {\n  /**\n   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n   */\n  blockData: TData\n  /**\n   * An object containing the full collection or global document currently being edited.\n   */\n  data: TData\n  /**\n   * The `id` of the current document being edited. `id` is undefined during the `create` operation.\n   */\n  id: number | string\n  /**\n   * The collection `slug` to filter against, limited to this field's `relationTo` property.\n   */\n  relationTo: CollectionSlug\n  req: PayloadRequest\n  /**\n   * An object containing document data that is scoped to only fields within the same parent of this field.\n   */\n  siblingData: unknown\n  /**\n   * An object containing the currently authenticated user.\n   */\n  user: Partial<PayloadRequest['user']>\n}\n\nexport type FilterOptionsFunc<TData = any> = (\n  options: FilterOptionsProps<TData>,\n) => boolean | Promise<boolean | Where> | Where\n\nexport type FilterOptions<TData = any> =\n  | ((options: FilterOptionsProps<TData>) => boolean | Promise<boolean | Where> | Where)\n  | null\n  | Where\n\ntype Admin = {\n  className?: string\n  components?: {\n    Cell?: PayloadComponent<DefaultServerCellComponentProps, DefaultCellComponentProps>\n    Description?: PayloadComponent<FieldDescriptionServerProps, FieldDescriptionClientProps>\n    Diff?: PayloadComponent<FieldDiffServerProps, FieldDiffClientComponent>\n    Field?: PayloadComponent<FieldClientComponent | FieldServerComponent>\n    /**\n     * The Filter component has to be a client component\n     */\n    Filter?: PayloadComponent\n  }\n  /**\n   * You can programmatically show / hide fields based on what other fields are doing.\n   * This is also run on the server, to determine if the field should be validated.\n   */\n  condition?: Condition\n  /** Extension point to add your custom data. Available in server and client. */\n  custom?: Record<string, any>\n  /**\n   * The field description will be displayed next to the field in the admin UI. Additionally,\n   * we use the field description to generate JSDoc comments for the generated TypeScript types.\n   */\n  description?: Description\n  disableBulkEdit?: boolean\n  disabled?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view column selector.\n   * @type boolean\n   */\n  disableListColumn?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view filter options.\n   * @type boolean\n   */\n  disableListFilter?: boolean\n  hidden?: boolean\n  position?: 'sidebar'\n  readOnly?: boolean\n  style?: CSSProperties\n  width?: CSSProperties['width']\n}\n\nexport type AdminClient = {\n  className?: string\n  /** Extension point to add your custom data. Available in server and client. */\n  custom?: Record<string, any>\n  description?: StaticDescription\n  disableBulkEdit?: boolean\n  disabled?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view column selector.\n   * @type boolean\n   */\n  disableListColumn?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view filter options.\n   * @type boolean\n   */\n  disableListFilter?: boolean\n  hidden?: boolean\n  position?: 'sidebar'\n  readOnly?: boolean\n  style?: { '--field-width'?: CSSProperties['width'] } & CSSProperties\n  width?: CSSProperties['width']\n}\n\nexport type Labels = {\n  plural: LabelFunction | StaticLabel\n  singular: LabelFunction | StaticLabel\n}\n\nexport type LabelsClient = {\n  plural: StaticLabel\n  singular: StaticLabel\n}\n\nexport type BaseValidateOptions<TData, TSiblingData, TValue> = {\n  /**\n  /**\n   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n   */\n  blockData: Partial<TData>\n  collectionSlug?: string\n  data: Partial<TData>\n  event?: 'onChange' | 'submit'\n  id?: number | string\n  operation?: Operation\n  preferences: DocumentPreferences\n  previousValue?: TValue\n  req: PayloadRequest\n  required?: boolean\n  siblingData: Partial<TSiblingData>\n}\n\nexport type ValidateOptions<\n  TData,\n  TSiblingData,\n  TFieldConfig extends object,\n  TValue,\n> = BaseValidateOptions<TData, TSiblingData, TValue> & TFieldConfig\n\nexport type Validate<\n  TValue = any,\n  TData = any,\n  TSiblingData = any,\n  TFieldConfig extends object = object,\n> = (\n  value: null | TValue | undefined,\n  options: ValidateOptions<TData, TSiblingData, TFieldConfig, TValue>,\n) => Promise<string | true> | string | true\n\nexport type OptionObject = {\n  label: LabelFunction | StaticLabel\n  value: string\n}\n\nexport type Option = OptionObject | string\n\nexport type FieldGraphQLType = {\n  graphQL?: {\n    /**\n     * Complexity for the query. This is used to limit the complexity of the join query.\n     *\n     * @default 10\n     */\n    complexity?: number\n  }\n}\n\nexport interface FieldBase {\n  /**\n   * Do not set this property manually. This is set to true during sanitization, to avoid\n   * sanitizing the same field multiple times.\n   */\n  _sanitized?: boolean\n  access?: {\n    create?: FieldAccess\n    read?: FieldAccess\n    update?: FieldAccess\n  }\n  admin?: Admin\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  defaultValue?: DefaultValue\n  hidden?: boolean\n  hooks?: {\n    afterChange?: FieldHook[]\n    afterRead?: FieldHook[]\n    beforeChange?: FieldHook[]\n    /**\n     * Runs before a document is duplicated to prevent errors in unique fields or return null to use defaultValue.\n     */\n    beforeDuplicate?: FieldHook[]\n    beforeValidate?: FieldHook[]\n  }\n  index?: boolean\n  label?: false | LabelFunction | StaticLabel\n  localized?: boolean\n  /**\n   * The name of the field. Must be alphanumeric and cannot contain ' . '\n   *\n   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']\n   * @link https://payloadcms.com/docs/fields/overview#field-names\n   */\n  name: string\n  required?: boolean\n  saveToJWT?: boolean | string\n  /**\n   * Allows you to modify the base JSON schema that is generated during generate:types for this field.\n   * This JSON schema will be used to generate the TypeScript interface of this field.\n   */\n  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  unique?: boolean\n  validate?: Validate\n  /**\n   * Pass `true` to disable field in the DB\n   * for [Virtual Fields](https://payloadcms.com/blog/learn-how-virtual-fields-can-help-solve-common-cms-challenges):\n   * A virtual field cannot be used in `admin.useAsTitle`\n   */\n  virtual?: boolean\n}\n\nexport interface FieldBaseClient {\n  admin?: AdminClient\n  hidden?: boolean\n  index?: boolean\n  label?: StaticLabel\n  localized?: boolean\n  /**\n   * The name of the field. Must be alphanumeric and cannot contain ' . '\n   *\n   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']\n   * @link https://payloadcms.com/docs/fields/overview#field-names\n   */\n  name: string\n  required?: boolean\n  saveToJWT?: boolean | string\n  /**\n   * Allows you to modify the base JSON schema that is generated during generate:types for this field.\n   * This JSON schema will be used to generate the TypeScript interface of this field.\n   */\n  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  unique?: boolean\n}\n\nexport type NumberField = {\n  admin?: {\n    /** Set this property to a string that will be used for browser autocomplete. */\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<NumberFieldErrorClientComponent | NumberFieldErrorServerComponent>\n      Label?: CustomComponent<NumberFieldLabelClientComponent | NumberFieldLabelServerComponent>\n    } & Admin['components']\n    /** Set this property to define a placeholder string for the field. */\n    placeholder?: Record<string, string> | string\n    /** Set a value for the number field to increment / decrement using browser controls. */\n    step?: number\n  } & Admin\n  /** Maximum value accepted. Used in the default `validate` function. */\n  max?: number\n  /** Minimum value accepted. Used in the default `validate` function. */\n  min?: number\n  type: 'number'\n} & (\n  | {\n      /** Makes this field an ordered array of numbers instead of just a single number. */\n      hasMany: true\n      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */\n      maxRows?: number\n      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */\n      minRows?: number\n      validate?: NumberFieldManyValidation\n    }\n  | {\n      /** Makes this field an ordered array of numbers instead of just a single number. */\n      hasMany?: false | undefined\n      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */\n      maxRows?: undefined\n      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */\n      minRows?: undefined\n      validate?: NumberFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type NumberFieldClient = {\n  admin?: AdminClient & Pick<NumberField['admin'], 'autoComplete' | 'placeholder' | 'step'>\n} & FieldBaseClient &\n  Pick<NumberField, 'hasMany' | 'max' | 'maxRows' | 'min' | 'minRows' | 'type'>\n\nexport type TextField = {\n  admin?: {\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<TextFieldErrorClientComponent | TextFieldErrorServerComponent>\n      Label?: CustomComponent<TextFieldLabelClientComponent | TextFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    rtl?: boolean\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'text'\n} & (\n  | {\n      /** Makes this field an ordered array of strings instead of just a single string. */\n      hasMany: true\n      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */\n      maxRows?: number\n      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */\n      minRows?: number\n      validate?: TextFieldManyValidation\n    }\n  | {\n      /** Makes this field an ordered array of strings instead of just a single string. */\n      hasMany?: false | undefined\n      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */\n      maxRows?: undefined\n      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */\n      minRows?: undefined\n      validate?: TextFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type TextFieldClient = {\n  admin?: AdminClient & Pick<TextField['admin'], 'autoComplete' | 'placeholder' | 'rtl'>\n} & FieldBaseClient &\n  Pick<TextField, 'hasMany' | 'maxLength' | 'maxRows' | 'minLength' | 'minRows' | 'type'>\n\nexport type EmailField = {\n  admin?: {\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<EmailFieldErrorClientComponent | EmailFieldErrorServerComponent>\n      Label?: CustomComponent<EmailFieldLabelClientComponent | EmailFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n  } & Admin\n  type: 'email'\n  validate?: EmailFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type EmailFieldClient = {\n  admin?: AdminClient & Pick<EmailField['admin'], 'autoComplete' | 'placeholder'>\n} & FieldBaseClient &\n  Pick<EmailField, 'type'>\n\nexport type TextareaField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<TextareaFieldErrorClientComponent | TextareaFieldErrorServerComponent>\n      Label?: CustomComponent<TextareaFieldLabelClientComponent | TextareaFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    rows?: number\n    rtl?: boolean\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'textarea'\n  validate?: TextareaFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type TextareaFieldClient = {\n  admin?: AdminClient & Pick<TextareaField['admin'], 'placeholder' | 'rows' | 'rtl'>\n} & FieldBaseClient &\n  Pick<TextareaField, 'maxLength' | 'minLength' | 'type'>\n\nexport type CheckboxField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<CheckboxFieldErrorClientComponent | CheckboxFieldErrorServerComponent>\n      Label?: CustomComponent<CheckboxFieldLabelClientComponent | CheckboxFieldLabelServerComponent>\n    } & Admin['components']\n  } & Admin\n  type: 'checkbox'\n  validate?: CheckboxFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type CheckboxFieldClient = {\n  admin?: AdminClient\n} & FieldBaseClient &\n  Pick<CheckboxField, 'type'>\n\nexport type DateField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<DateFieldErrorClientComponent | DateFieldErrorServerComponent>\n      Label?: CustomComponent<DateFieldLabelClientComponent | DateFieldLabelServerComponent>\n    } & Admin['components']\n    date?: ConditionalDateProps\n    placeholder?: Record<string, string> | string\n  } & Admin\n  /**\n   * Enable timezone selection in the admin interface.\n   */\n  timezone?: true\n  type: 'date'\n  validate?: DateFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type DateFieldClient = {\n  admin?: AdminClient & Pick<DateField['admin'], 'date' | 'placeholder'>\n} & FieldBaseClient &\n  Pick<DateField, 'timezone' | 'type'>\n\nexport type GroupField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Label?: CustomComponent<GroupFieldLabelClientComponent | GroupFieldLabelServerComponent>\n    } & Admin['components']\n    hideGutter?: boolean\n  } & Admin\n  fields: Field[]\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  type: 'group'\n  validate?: Validate<unknown, unknown, unknown, GroupField>\n} & Omit<FieldBase, 'required' | 'validate'>\n\nexport type GroupFieldClient = {\n  admin?: AdminClient & Pick<GroupField['admin'], 'hideGutter'>\n  fields: ClientField[]\n} & Omit<FieldBaseClient, 'required'> &\n  Pick<GroupField, 'interfaceName' | 'type'>\n\nexport type RowField = {\n  admin?: Omit<Admin, 'description'>\n  fields: Field[]\n  type: 'row'\n} & Omit<FieldBase, 'admin' | 'label' | 'localized' | 'name' | 'validate' | 'virtual'>\n\nexport type RowFieldClient = {\n  admin?: Omit<AdminClient, 'description'>\n  fields: ClientField[]\n} & Omit<FieldBaseClient, 'admin' | 'label' | 'name'> &\n  Pick<RowField, 'type'>\n\nexport type CollapsibleField = {\n  fields: Field[]\n  type: 'collapsible'\n} & (\n  | {\n      admin: {\n        components: {\n          afterInput?: CustomComponent[]\n          beforeInput?: CustomComponent[]\n          Label: CustomComponent<\n            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent\n          >\n        } & Admin['components']\n        initCollapsed?: boolean\n      } & Admin\n      label?: Required<FieldBase['label']>\n    }\n  | {\n      admin?: {\n        components?: {\n          afterInput?: CustomComponent[]\n          beforeInput?: CustomComponent[]\n          Label?: CustomComponent<\n            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent\n          >\n        } & Admin['components']\n        initCollapsed?: boolean\n      } & Admin\n      label: Required<FieldBase['label']>\n    }\n) &\n  Omit<FieldBase, 'label' | 'localized' | 'name' | 'validate' | 'virtual'>\n\nexport type CollapsibleFieldClient = {\n  admin?: {\n    initCollapsed?: boolean\n  } & AdminClient\n  fields: ClientField[]\n  label: StaticLabel\n} & Omit<FieldBaseClient, 'label' | 'name' | 'validate'> &\n  Pick<CollapsibleField, 'type'>\n\ntype TabBase = {\n  /**\n   * @deprecated\n   * Use `admin.description` instead. This will be removed in a future major version.\n   */\n  description?: LabelFunction | StaticDescription\n  fields: Field[]\n  interfaceName?: string\n  saveToJWT?: boolean | string\n} & Omit<FieldBase, 'required' | 'validate'>\n\nexport type NamedTab = {\n  /** Customize generated GraphQL and Typescript schema names.\n   * The slug is used by default.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n} & TabBase\n\nexport type UnnamedTab = {\n  interfaceName?: never\n  /**\n   * Can be either:\n   * - A string, which will be used as the tab's label.\n   * - An object, where the key is the language code and the value is the label.\n   */\n  label:\n    | {\n        [selectedLanguage: string]: string\n      }\n    | LabelFunction\n    | string\n  localized?: never\n} & Omit<TabBase, 'name' | 'virtual'>\n\nexport type Tab = NamedTab | UnnamedTab\n\nexport type TabsField = {\n  admin?: Omit<Admin, 'description'>\n  tabs: Tab[]\n  type: 'tabs'\n} & Omit<FieldBase, 'admin' | 'localized' | 'name' | 'saveToJWT' | 'virtual'>\n\nexport type TabsFieldClient = {\n  admin?: Omit<AdminClient, 'description'>\n  tabs: ClientTab[]\n} & Omit<FieldBaseClient, 'admin' | 'localized' | 'name' | 'saveToJWT'> &\n  Pick<TabsField, 'type'>\n\nexport type TabAsField = {\n  name?: string\n  type: 'tab'\n} & Tab\n\nexport type TabAsFieldClient = ClientTab & Pick<TabAsField, 'name' | 'type'>\n\nexport type UIField = {\n  admin: {\n    components?: {\n      /**\n       * Allow any custom components to be added to the UI field. This allows\n       * the UI field to be used as a vessel for getting components rendered.\n       */\n      [key: string]: PayloadComponent | undefined\n      Cell?: CustomComponent\n      // Can be optional, in case the UI field is just used as a vessel for custom components\n      Field?: CustomComponent\n      /**\n       * The Filter component has to be a client component\n       */\n      Filter?: PayloadComponent\n    } & Admin['components']\n    condition?: Condition\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n    /**\n     * Set `false` make the UI field appear in the list view column selector. `true` by default for UI fields.\n     * @default true\n     */\n    disableBulkEdit?: boolean\n    /**\n     * Shows / hides fields from appearing in the list view column selector.\n     * @type boolean\n     */\n    disableListColumn?: boolean\n    position?: string\n    width?: CSSProperties['width']\n  }\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  label?: Record<string, string> | string\n  name: string\n  type: 'ui'\n}\n\nexport type UIFieldClient = {\n  // still include FieldBaseClient.admin (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))\n\n  admin: DeepUndefinable<FieldBaseClient['admin']> &\n    Pick<\n      UIField['admin'],\n      'custom' | 'disableBulkEdit' | 'disableListColumn' | 'position' | 'width'\n    >\n} & Omit<DeepUndefinable<FieldBaseClient>, 'admin'> & // still include FieldBaseClient (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))\n  Pick<UIField, 'label' | 'name' | 'type'>\n\ntype SharedUploadProperties = {\n  /**\n   * Toggle the preview in the admin interface.\n   */\n  displayPreview?: boolean\n  filterOptions?: FilterOptions\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'upload'\n} & (\n  | {\n      hasMany: true\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: number\n      maxRows?: number\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: number\n      minRows?: number\n      validate?: UploadFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: undefined\n      maxRows?: undefined\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: undefined\n      minRows?: undefined\n      validate?: UploadFieldSingleValidation\n    }\n) &\n  FieldGraphQLType &\n  Omit<FieldBase, 'validate'>\n\ntype SharedUploadPropertiesClient = FieldBaseClient &\n  Pick<\n    SharedUploadProperties,\n    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'\n  >\n\ntype UploadAdmin = {\n  allowCreate?: boolean\n  components?: {\n    Error?: CustomComponent<\n      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent\n    >\n    Label?: CustomComponent<\n      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent\n    >\n  } & Admin['components']\n  isSortable?: boolean\n} & Admin\n\ntype UploadAdminClient = AdminClient & Pick<UploadAdmin, 'allowCreate' | 'isSortable'>\n\nexport type PolymorphicUploadField = {\n  admin?: {\n    sortOptions?: Partial<Record<CollectionSlug, string>>\n  } & UploadAdmin\n  relationTo: CollectionSlug[]\n} & SharedUploadProperties\n\nexport type PolymorphicUploadFieldClient = {\n  admin?: {\n    sortOptions?: Pick<PolymorphicUploadField['admin'], 'sortOptions'>\n  } & UploadAdminClient\n} & Pick<PolymorphicUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &\n  SharedUploadPropertiesClient\n\nexport type SingleUploadField = {\n  admin?: {\n    sortOptions?: string\n  } & UploadAdmin\n  relationTo: CollectionSlug\n} & SharedUploadProperties\n\nexport type SingleUploadFieldClient = {\n  admin?: Pick<SingleUploadField['admin'], 'sortOptions'> & UploadAdminClient\n} & Pick<SingleUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &\n  SharedUploadPropertiesClient\n\nexport type UploadField = /* PolymorphicUploadField | */ SingleUploadField\n\nexport type UploadFieldClient = /* PolymorphicUploadFieldClient | */ SingleUploadFieldClient\n\nexport type CodeField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<CodeFieldErrorClientComponent | CodeFieldErrorServerComponent>\n      Label?: CustomComponent<CodeFieldLabelClientComponent | CodeFieldLabelServerComponent>\n    } & Admin['components']\n    editorOptions?: EditorProps['options']\n    language?: string\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'code'\n  validate?: CodeFieldValidation\n} & Omit<FieldBase, 'admin' | 'validate'>\n\nexport type CodeFieldClient = {\n  admin?: AdminClient & Pick<CodeField['admin'], 'editorOptions' | 'language'>\n} & Omit<FieldBaseClient, 'admin'> &\n  Pick<CodeField, 'maxLength' | 'minLength' | 'type'>\n\nexport type JSONField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<JSONFieldErrorClientComponent | JSONFieldErrorServerComponent>\n      Label?: CustomComponent<JSONFieldLabelClientComponent | JSONFieldLabelServerComponent>\n    } & Admin['components']\n    editorOptions?: EditorProps['options']\n    maxHeight?: number\n  } & Admin\n\n  jsonSchema?: {\n    fileMatch: string[]\n    schema: JSONSchema4\n    uri: string\n  }\n  type: 'json'\n  validate?: JSONFieldValidation\n} & Omit<FieldBase, 'admin' | 'validate'>\n\nexport type JSONFieldClient = {\n  admin?: AdminClient & Pick<JSONField['admin'], 'editorOptions' | 'maxHeight'>\n} & Omit<FieldBaseClient, 'admin'> &\n  Pick<JSONField, 'jsonSchema' | 'type'>\n\nexport type SelectField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<SelectFieldErrorClientComponent | SelectFieldErrorServerComponent>\n      Label?: CustomComponent<SelectFieldLabelClientComponent | SelectFieldLabelServerComponent>\n    } & Admin['components']\n    isClearable?: boolean\n    isSortable?: boolean\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  /**\n   * Customize the DB enum name\n   */\n  enumName?: DBIdentifierName\n  hasMany?: boolean\n  options: Option[]\n  type: 'select'\n} & (\n  | {\n      hasMany: true\n      validate?: SelectFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      validate?: SelectFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type SelectFieldClient = {\n  admin?: AdminClient & Pick<SelectField['admin'], 'isClearable' | 'isSortable'>\n} & FieldBaseClient &\n  Pick<SelectField, 'hasMany' | 'options' | 'type'>\n\ntype SharedRelationshipProperties = {\n  filterOptions?: FilterOptions\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'relationship'\n} & (\n  | {\n      hasMany: true\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: number\n      maxRows?: number\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: number\n      minRows?: number\n      validate?: RelationshipFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: undefined\n      maxRows?: undefined\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: undefined\n      minRows?: undefined\n      validate?: RelationshipFieldSingleValidation\n    }\n) &\n  FieldGraphQLType &\n  Omit<FieldBase, 'validate'>\n\ntype SharedRelationshipPropertiesClient = FieldBaseClient &\n  Pick<\n    SharedRelationshipProperties,\n    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'\n  >\n\ntype RelationshipAdmin = {\n  allowCreate?: boolean\n  allowEdit?: boolean\n  components?: {\n    afterInput?: CustomComponent[]\n    beforeInput?: CustomComponent[]\n    Error?: CustomComponent<\n      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent\n    >\n    Label?: CustomComponent<\n      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent\n    >\n  } & Admin['components']\n  isSortable?: boolean\n} & Admin\n\ntype RelationshipAdminClient = AdminClient &\n  Pick<RelationshipAdmin, 'allowCreate' | 'allowEdit' | 'isSortable'>\n\nexport type PolymorphicRelationshipField = {\n  admin?: {\n    sortOptions?: Partial<Record<CollectionSlug, string>>\n  } & RelationshipAdmin\n  relationTo: CollectionSlug[]\n} & SharedRelationshipProperties\n\nexport type PolymorphicRelationshipFieldClient = {\n  admin?: {\n    sortOptions?: Pick<PolymorphicRelationshipField['admin'], 'sortOptions'>\n  } & RelationshipAdminClient\n} & Pick<PolymorphicRelationshipField, 'relationTo'> &\n  SharedRelationshipPropertiesClient\n\nexport type SingleRelationshipField = {\n  admin?: {\n    sortOptions?: string\n  } & RelationshipAdmin\n  relationTo: CollectionSlug\n} & SharedRelationshipProperties\n\nexport type SingleRelationshipFieldClient = {\n  admin?: Partial<Pick<SingleRelationshipField['admin'], 'sortOptions'>> & RelationshipAdminClient\n} & Pick<SingleRelationshipField, 'relationTo'> &\n  SharedRelationshipPropertiesClient\n\nexport type RelationshipField = PolymorphicRelationshipField | SingleRelationshipField\n\nexport type RelationshipFieldClient =\n  | PolymorphicRelationshipFieldClient\n  | SingleRelationshipFieldClient\n\nexport type ValueWithRelation = {\n  relationTo: CollectionSlug\n  value: number | string\n}\n\nexport function valueIsValueWithRelation(value: unknown): value is ValueWithRelation {\n  return value !== null && typeof value === 'object' && 'relationTo' in value && 'value' in value\n}\n\nexport type RelationshipValue = RelationshipValueMany | RelationshipValueSingle\n\nexport type RelationshipValueMany = (number | string)[] | ValueWithRelation[]\n\nexport type RelationshipValueSingle = number | string | ValueWithRelation\n\nexport type RichTextField<\n  TValue extends object = any,\n  TAdapterProps = any,\n  TExtraProperties = object,\n> = {\n  admin?: {\n    components?: {\n      Error?: CustomComponent\n      Label?: CustomComponent\n    } & Admin['components']\n  } & Admin\n  editor?:\n    | RichTextAdapter<TValue, TAdapterProps, TExtraProperties>\n    | RichTextAdapterProvider<TValue, TAdapterProps, TExtraProperties>\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'richText'\n} & FieldBase &\n  TExtraProperties\n\nexport type RichTextFieldClient<\n  TValue extends object = any,\n  TAdapterProps = any,\n  TExtraProperties = object,\n> = FieldBaseClient &\n  Pick<RichTextField<TValue, TAdapterProps, TExtraProperties>, 'maxDepth' | 'type'> &\n  TExtraProperties\n\nexport type ArrayField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<ArrayFieldErrorClientComponent | ArrayFieldErrorServerComponent>\n      Label?: CustomComponent<ArrayFieldLabelClientComponent | ArrayFieldLabelServerComponent>\n      RowLabel?: RowLabelComponent\n    } & Admin['components']\n    initCollapsed?: boolean\n    /**\n     * Disable drag and drop sorting\n     */\n    isSortable?: boolean\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  fields: Field[]\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  labels?: Labels\n  maxRows?: number\n  minRows?: number\n  type: 'array'\n  validate?: ArrayFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type ArrayFieldClient = {\n  admin?: AdminClient & Pick<ArrayField['admin'], 'initCollapsed' | 'isSortable'>\n  fields: ClientField[]\n  labels?: LabelsClient\n} & FieldBaseClient &\n  Pick<ArrayField, 'interfaceName' | 'maxRows' | 'minRows' | 'type'>\n\nexport type RadioField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<RadioFieldErrorClientComponent | RadioFieldErrorServerComponent>\n      Label?: CustomComponent<RadioFieldLabelClientComponent | RadioFieldLabelServerComponent>\n    } & Admin['components']\n    layout?: 'horizontal' | 'vertical'\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  /**\n   * Customize the DB enum name\n   */\n  enumName?: DBIdentifierName\n  options: Option[]\n  type: 'radio'\n  validate?: RadioFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type RadioFieldClient = {\n  admin?: AdminClient & Pick<RadioField['admin'], 'layout'>\n} & FieldBaseClient &\n  Pick<RadioField, 'options' | 'type'>\n\ntype BlockFields = {\n  [key: string]: any\n  blockName?: string\n  blockType?: string\n}\n\nexport type BlockJSX = {\n  /**\n   * Override the default regex used to search for the start of the block in the JSX.\n   * By default, it's <BlockSlugHere\n   */\n  customEndRegex?:\n    | {\n        /**\n         * Whether the end match is optional. If true, the end match is\n         * not required to match for the transformer to be triggered.\n         * The entire text from regexpStart to the end of the document will then be matched.\n         */\n        optional?: true\n        regExp: RegExp\n      }\n    | RegExp\n  /**\n   * Override the default regex used to search for the start of the block in the JSX.\n   * By default, it's <BlockSlugHere/>\n   */\n  customStartRegex?: RegExp\n  /**\n   * By default, all spaces at the beginning and end of every line of the\n   * children (text between the open and close match) are removed.\n   * Set this to true to disable this behavior.\n   */\n  doNotTrimChildren?: boolean\n  /**\n   * Function that receives the data for a given block and returns a JSX representation of it.\n   *\n   * This is used to convert Lexical => JSX\n   */\n  export: (props: {\n    fields: BlockFields\n    lexicalToMarkdown?: (props: { editorState: Record<string, any> }) => string\n  }) =>\n    | {\n        children?: string\n        props?: object\n      }\n    | false\n    | string\n  /**\n   * Function that receives the markdown string and parsed\n   * JSX props for a given matched block and returns a Lexical representation of it.\n   *\n   * This is used to convert JSX => Lexical\n   */\n  import: (props: {\n    children: string\n    closeMatch: null | RegExpMatchArray // Only available when customEndRegex is set\n    htmlToLexical?: ((props: { html: string }) => any) | null\n    markdownToLexical?: (props: { markdown: string }) => Record<string, any>\n    openMatch?: RegExpMatchArray\n    props: Record<string, any>\n  }) => BlockFields | false\n}\n\nexport type Block = {\n  /**\n   * Do not set this property manually. This is set to true during sanitization, to avoid\n   * sanitizing the same block multiple times.\n   */\n  _sanitized?: boolean\n  admin?: {\n    components?: {\n      /**\n       * This will replace the entire block component, including the block header / collapsible.\n       */\n      Block?: PayloadComponent<any, any>\n      Label?: PayloadComponent<any, any>\n    }\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n    jsx?: PayloadComponent\n  }\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  fields: Field[]\n  /** @deprecated - please migrate to the interfaceName property instead. */\n  graphQL?: {\n    singularName?: string\n  }\n  imageAltText?: string\n  imageURL?: string\n  /** Customize generated GraphQL and Typescript schema names.\n   * The slug is used by default.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  jsx?: BlockJSX\n  labels?: Labels\n  slug: string\n}\n\nexport type ClientBlock = {\n  admin?: Pick<Block['admin'], 'custom'>\n  fields: ClientField[]\n  labels?: LabelsClient\n} & Pick<Block, 'imageAltText' | 'imageURL' | 'jsx' | 'slug'>\n\nexport type BlocksField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<BlocksFieldErrorClientComponent | BlocksFieldErrorServerComponent>\n      Label?: CustomComponent<BlocksFieldLabelClientComponent | BlocksFieldLabelServerComponent>\n    } & Admin['components']\n    initCollapsed?: boolean\n    /**\n     * Disable drag and drop sorting\n     */\n    isSortable?: boolean\n  } & Admin\n  blocks: Block[]\n  defaultValue?: DefaultValue\n  labels?: Labels\n  maxRows?: number\n  minRows?: number\n  type: 'blocks'\n  validate?: BlocksFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type BlocksFieldClient = {\n  admin?: AdminClient & Pick<BlocksField['admin'], 'initCollapsed' | 'isSortable'>\n  blocks: ClientBlock[]\n  labels?: LabelsClient\n} & FieldBaseClient &\n  Pick<BlocksField, 'maxRows' | 'minRows' | 'type'>\n\nexport type PointField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<PointFieldErrorClientComponent | PointFieldErrorServerComponent>\n      Label?: CustomComponent<PointFieldLabelClientComponent | PointFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    step?: number\n  } & Admin\n  type: 'point'\n  validate?: PointFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type PointFieldClient = {\n  admin?: AdminClient & Pick<PointField['admin'], 'placeholder' | 'step'>\n} & FieldBaseClient &\n  Pick<PointField, 'type'>\n\n/**\n * A virtual field that loads in related collections by querying a relationship or upload field.\n */\nexport type JoinField = {\n  access?: {\n    create?: never\n    read?: FieldAccess\n    update?: never\n  }\n  admin?: {\n    allowCreate?: boolean\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<JoinFieldErrorClientComponent | JoinFieldErrorServerComponent>\n      Label?: CustomComponent<JoinFieldLabelClientComponent | JoinFieldLabelServerComponent>\n    } & Admin['components']\n    defaultColumns?: string[]\n    disableBulkEdit?: never\n    readOnly?: never\n  } & Admin\n  /**\n   * The slug of the collection to relate with.\n   */\n  collection: CollectionSlug\n  defaultLimit?: number\n  defaultSort?: Sort\n  defaultValue?: never\n  /**\n   * This does not need to be set and will be overridden by the relationship field's hasMany property.\n   */\n  hasMany?: boolean\n  hidden?: false\n  index?: never\n  /**\n   * This does not need to be set and will be overridden by the relationship field's localized property.\n   */\n  localized?: boolean\n  /**\n   * The maximum allowed depth to be permitted application-wide. This setting helps prevent against malicious queries.\n   *\n   * @see https://payloadcms.com/docs/getting-started/concepts#depth\n   *\n   * @default 1\n   */\n  maxDepth?: number\n  /**\n   * A string for the field in the collection being joined to.\n   */\n  on: string\n  type: 'join'\n  validate?: never\n  where?: Where\n} & FieldBase &\n  FieldGraphQLType\n\nexport type JoinFieldClient = {\n  admin?: AdminClient &\n    Pick<JoinField['admin'], 'allowCreate' | 'defaultColumns' | 'disableBulkEdit' | 'readOnly'>\n} & { targetField: Pick<RelationshipFieldClient, 'relationTo'> } & FieldBaseClient &\n  Pick<\n    JoinField,\n    'collection' | 'defaultLimit' | 'defaultSort' | 'index' | 'maxDepth' | 'on' | 'type' | 'where'\n  >\n\nexport type FlattenedBlock = {\n  flattenedFields: FlattenedField[]\n} & Block\n\nexport type FlattenedBlocksField = {\n  blocks: FlattenedBlock[]\n} & BlocksField\n\nexport type FlattenedGroupField = {\n  flattenedFields: FlattenedField[]\n} & GroupField\n\nexport type FlattenedArrayField = {\n  flattenedFields: FlattenedField[]\n} & ArrayField\n\nexport type FlattenedTabAsField = {\n  flattenedFields: FlattenedField[]\n} & MarkRequired<TabAsField, 'name'>\n\nexport type FlattenedJoinField = {\n  targetField: RelationshipField | UploadField\n} & JoinField\n\nexport type FlattenedField =\n  | CheckboxField\n  | CodeField\n  | DateField\n  | EmailField\n  | FlattenedArrayField\n  | FlattenedBlocksField\n  | FlattenedGroupField\n  | FlattenedJoinField\n  | FlattenedTabAsField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | SelectField\n  | TextareaField\n  | TextField\n  | UploadField\nexport type Field =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | CollapsibleField\n  | DateField\n  | EmailField\n  | GroupField\n  | JoinField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | RowField\n  | SelectField\n  | TabsField\n  | TextareaField\n  | TextField\n  | UIField\n  | UploadField\n\nexport type ClientField =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | CollapsibleFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JoinFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | RowFieldClient\n  | SelectFieldClient\n  | TabsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UIFieldClient\n  | UploadFieldClient\n\nexport type ClientFieldProps =\n  | ArrayFieldClientProps\n  | BlocksFieldClientProps\n  | CheckboxFieldClientProps\n  | CodeFieldClientProps\n  | CollapsibleFieldClientProps\n  | DateFieldClientProps\n  | EmailFieldClientProps\n  | GroupFieldClientProps\n  | HiddenFieldProps\n  | JoinFieldClientProps\n  | JSONFieldClientProps\n  | NumberFieldClientProps\n  | PointFieldClientProps\n  | RadioFieldClientProps\n  | RelationshipFieldClientProps\n  | RichTextFieldClientProps\n  | RowFieldClientProps\n  | SelectFieldClientProps\n  | TabsFieldClientProps\n  | TextareaFieldClientProps\n  | TextFieldClientProps\n  | UploadFieldClientProps\n\ntype ExtractFieldTypes<T> = T extends { type: infer U } ? U : never\n\nexport type FieldTypes = ExtractFieldTypes<Field>\n\nexport type FieldAffectingData =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | DateField\n  | EmailField\n  | GroupField\n  | JoinField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | SelectField\n  | TabAsField\n  | TextareaField\n  | TextField\n  | UploadField\n\nexport type FieldAffectingDataClient =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JoinFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | SelectFieldClient\n  | TabAsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UploadFieldClient\n\nexport type NonPresentationalField =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | CollapsibleField\n  | DateField\n  | EmailField\n  | GroupField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | RowField\n  | SelectField\n  | TabsField\n  | TextareaField\n  | TextField\n  | UploadField\n\nexport type NonPresentationalFieldClient =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | CollapsibleFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | RowFieldClient\n  | SelectFieldClient\n  | TabsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UploadFieldClient\n\nexport type FieldWithPath = {\n  path?: string\n} & Field\n\nexport type FieldWithPathClient = {\n  path?: string\n} & ClientField\n\nexport type FieldWithSubFields = ArrayField | CollapsibleField | GroupField | RowField\n\nexport type FieldWithSubFieldsClient =\n  | ArrayFieldClient\n  | CollapsibleFieldClient\n  | GroupFieldClient\n  | RowFieldClient\n\nexport type FieldPresentationalOnly = UIField\nexport type FieldPresentationalOnlyClient = UIFieldClient\n\nexport type FieldWithMany = RelationshipField | SelectField\nexport type FieldWithManyClient = RelationshipFieldClient | SelectFieldClient\n\nexport type FieldWithMaxDepth = RelationshipField | UploadField\nexport type FieldWithMaxDepthClient = JoinFieldClient | RelationshipFieldClient | UploadFieldClient\n\nexport function fieldHasSubFields<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithSubFieldsClient : FieldWithSubFields) {\n  return (\n    field.type === 'group' ||\n    field.type === 'array' ||\n    field.type === 'row' ||\n    field.type === 'collapsible'\n  )\n}\n\nexport function fieldIsArrayType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? ArrayFieldClient : ArrayField) {\n  return field.type === 'array'\n}\n\nexport function fieldIsBlockType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? BlocksFieldClient : BlocksField) {\n  return field.type === 'blocks'\n}\n\nexport function fieldIsGroupType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? GroupFieldClient : GroupField) {\n  return field.type === 'group'\n}\n\nexport function optionIsObject(option: Option): option is OptionObject {\n  return typeof option === 'object'\n}\n\nexport function optionsAreObjects(options: Option[]): options is OptionObject[] {\n  return Array.isArray(options) && typeof options?.[0] === 'object'\n}\n\nexport function optionIsValue(option: Option): option is string {\n  return typeof option === 'string'\n}\n\nexport function fieldSupportsMany<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithManyClient : FieldWithMany) {\n  return field.type === 'select' || field.type === 'relationship' || field.type === 'upload'\n}\n\nexport function fieldHasMaxDepth<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithMaxDepthClient : FieldWithMaxDepth) {\n  return (\n    (field.type === 'upload' || field.type === 'relationship' || field.type === 'join') &&\n    typeof field.maxDepth === 'number'\n  )\n}\n\nexport function fieldIsPresentationalOnly<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(\n  field: TField,\n): field is TField & (TField extends ClientField | TabAsFieldClient ? UIFieldClient : UIField) {\n  return field.type === 'ui'\n}\n\nexport function fieldIsSidebar<TField extends ClientField | Field | TabAsField | TabAsFieldClient>(\n  field: TField,\n): field is { admin: { position: 'sidebar' } } & TField {\n  return 'admin' in field && 'position' in field.admin && field.admin.position === 'sidebar'\n}\n\nexport function fieldIsID<TField extends ClientField | Field>(\n  field: TField,\n): field is { name: 'id' } & TField {\n  return 'name' in field && field.name === 'id'\n}\n\nexport function fieldIsHiddenOrDisabled<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(field: TField): field is { admin: { hidden: true } } & TField {\n  return (\n    ('hidden' in field && field.hidden) ||\n    ('admin' in field && 'disabled' in field.admin && field.admin.disabled)\n  )\n}\n\nexport function fieldAffectsData<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(\n  field: TField,\n): field is TField &\n  (TField extends ClientField | TabAsFieldClient ? FieldAffectingDataClient : FieldAffectingData) {\n  return 'name' in field && !fieldIsPresentationalOnly(field)\n}\n\nexport function tabHasName<TField extends ClientTab | Tab>(tab: TField): tab is NamedTab & TField {\n  return 'name' in tab\n}\n\nexport function fieldIsLocalized(field: Field | Tab): boolean {\n  return 'localized' in field && field.localized\n}\n\nexport function fieldIsVirtual(field: Field | Tab): boolean {\n  return 'virtual' in field && field.virtual\n}\n\nexport type HookName =\n  | 'afterChange'\n  | 'afterRead'\n  | 'beforeChange'\n  | 'beforeRead'\n  | 'beforeValidate'\n"],"names":["valueIsValueWithRelation","value","fieldHasSubFields","field","type","fieldIsArrayType","fieldIsBlockType","fieldIsGroupType","optionIsObject","option","optionsAreObjects","options","Array","isArray","optionIsValue","fieldSupportsMany","fieldHasMaxDepth","maxDepth","fieldIsPresentationalOnly","fieldIsSidebar","admin","position","fieldIsID","name","fieldIsHiddenOrDisabled","hidden","disabled","fieldAffectsData","tabHasName","tab","fieldIsLocalized","localized","fieldIsVirtual","virtual"],"mappings":"AAAA,qDAAqD,GA2oCrD;;;;;;;;;;;;;;;;;;;;AAAO,SAASA,yBAAyBC,KAAc;IACrD,OAAOA,UAAU,QAAQ,OAAOA,UAAU,YAAY,gBAAgBA,SAAS,WAAWA;AAC5F;AAwjBO,SAASC,kBACdC,KAAa;IAEb,OACEA,MAAMC,IAAI,KAAK,WACfD,MAAMC,IAAI,KAAK,WACfD,MAAMC,IAAI,KAAK,SACfD,MAAMC,IAAI,KAAK;AAEnB;AAEO,SAASC,iBACdF,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASE,iBACdH,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASG,iBACdJ,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASI,eAAeC,MAAc;IAC3C,OAAO,OAAOA,WAAW;AAC3B;AAEO,SAASC,kBAAkBC,OAAiB;IACjD,OAAOC,MAAMC,OAAO,CAACF,YAAY,OAAOA,SAAS,CAAC,EAAE,KAAK;AAC3D;AAEO,SAASG,cAAcL,MAAc;IAC1C,OAAO,OAAOA,WAAW;AAC3B;AAEO,SAASM,kBACdZ,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK,YAAYD,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK;AACpF;AAEO,SAASY,iBACdb,KAAa;IAEb,OACGA,CAAAA,MAAMC,IAAI,KAAK,YAAYD,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK,MAAK,KACjF,OAAOD,MAAMc,QAAQ,KAAK;AAE9B;AAEO,SAASC,0BAGdf,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASe,eACdhB,KAAa;IAEb,OAAO,WAAWA,SAAS,cAAcA,MAAMiB,KAAK,IAAIjB,MAAMiB,KAAK,CAACC,QAAQ,KAAK;AACnF;AAEO,SAASC,UACdnB,KAAa;IAEb,OAAO,UAAUA,SAASA,MAAMoB,IAAI,KAAK;AAC3C;AAEO,SAASC,wBAEdrB,KAAa;IACb,OACG,YAAYA,SAASA,MAAMsB,MAAM,IACjC,WAAWtB,SAAS,cAAcA,MAAMiB,KAAK,IAAIjB,MAAMiB,KAAK,CAACM,QAAQ;AAE1E;AAEO,SAASC,iBAGdxB,KAAa;IAGb,OAAO,UAAUA,SAAS,CAACe,0BAA0Bf;AACvD;AAEO,SAASyB,WAA2CC,GAAW;IACpE,OAAO,UAAUA;AACnB;AAEO,SAASC,iBAAiB3B,KAAkB;IACjD,OAAO,eAAeA,SAASA,MAAM4B,SAAS;AAChD;AAEO,SAASC,eAAe7B,KAAkB;IAC/C,OAAO,aAAaA,SAASA,MAAM8B,OAAO;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/baseFields/timezone/defaultTimezones.ts"],"sourcesContent":["import type { Timezone } from '../../../config/types.js'\n\n/**\n * List of supported timezones\n *\n * label: UTC offset and location\n * value: IANA timezone name\n *\n * @example\n * { label: '(UTC-12:00) International Date Line West', value: 'Dateline Standard Time' }\n */\nexport const defaultTimezones: Timezone[] = [\n  { label: '(UTC-11:00) Midway Island, Samoa', value: 'Pacific/Midway' },\n  { label: '(UTC-11:00) Niue', value: 'Pacific/Niue' },\n  { label: '(UTC-10:00) Hawaii', value: 'Pacific/Honolulu' },\n  { label: '(UTC-10:00) Cook Islands', value: 'Pacific/Rarotonga' },\n  { label: '(UTC-09:00) Alaska', value: 'America/Anchorage' },\n  { label: '(UTC-09:00) Gambier Islands', value: 'Pacific/Gambier' },\n  { label: '(UTC-08:00) Pacific Time (US & Canada)', value: 'America/Los_Angeles' },\n  { label: '(UTC-08:00) Tijuana, Baja California', value: 'America/Tijuana' },\n  { label: '(UTC-07:00) Mountain Time (US & Canada)', value: 'America/Denver' },\n  { label: '(UTC-07:00) Arizona (No DST)', value: 'America/Phoenix' },\n  { label: '(UTC-06:00) Central Time (US & Canada)', value: 'America/Chicago' },\n  { label: '(UTC-06:00) Central America', value: 'America/Guatemala' },\n  { label: '(UTC-05:00) Eastern Time (US & Canada)', value: 'America/New_York' },\n  { label: '(UTC-05:00) Bogota, Lima, Quito', value: 'America/Bogota' },\n  { label: '(UTC-04:00) Caracas', value: 'America/Caracas' },\n  { label: '(UTC-04:00) Santiago', value: 'America/Santiago' },\n  { label: '(UTC-03:00) Buenos Aires', value: 'America/Buenos_Aires' },\n  { label: '(UTC-03:00) Brasilia', value: 'America/Sao_Paulo' },\n  { label: '(UTC-02:00) South Georgia', value: 'Atlantic/South_Georgia' },\n  { label: '(UTC-01:00) Azores', value: 'Atlantic/Azores' },\n  { label: '(UTC-01:00) Cape Verde', value: 'Atlantic/Cape_Verde' },\n  { label: '(UTC+00:00) London (GMT)', value: 'Europe/London' },\n  { label: '(UTC+01:00) Berlin, Paris', value: 'Europe/Berlin' },\n  { label: '(UTC+01:00) Lagos', value: 'Africa/Lagos' },\n  { label: '(UTC+02:00) Athens, Bucharest', value: 'Europe/Athens' },\n  { label: '(UTC+02:00) Cairo', value: 'Africa/Cairo' },\n  { label: '(UTC+03:00) Moscow, St. Petersburg', value: 'Europe/Moscow' },\n  { label: '(UTC+03:00) Riyadh', value: 'Asia/Riyadh' },\n  { label: '(UTC+04:00) Dubai', value: 'Asia/Dubai' },\n  { label: '(UTC+04:00) Baku', value: 'Asia/Baku' },\n  { label: '(UTC+05:00) Islamabad, Karachi', value: 'Asia/Karachi' },\n  { label: '(UTC+05:00) Tashkent', value: 'Asia/Tashkent' },\n  { label: '(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi', value: 'Asia/Calcutta' },\n  { label: '(UTC+06:00) Dhaka', value: 'Asia/Dhaka' },\n  { label: '(UTC+06:00) Almaty', value: 'Asia/Almaty' },\n  { label: '(UTC+07:00) Jakarta', value: 'Asia/Jakarta' },\n  { label: '(UTC+07:00) Bangkok', value: 'Asia/Bangkok' },\n  { label: '(UTC+08:00) Beijing, Shanghai', value: 'Asia/Shanghai' },\n  { label: '(UTC+08:00) Singapore', value: 'Asia/Singapore' },\n  { label: '(UTC+09:00) Tokyo, Osaka, Sapporo', value: 'Asia/Tokyo' },\n  { label: '(UTC+09:00) Seoul', value: 'Asia/Seoul' },\n  { label: '(UTC+10:00) Sydney, Melbourne', value: 'Australia/Sydney' },\n  { label: '(UTC+10:00) Guam, Port Moresby', value: 'Pacific/Guam' },\n  { label: '(UTC+11:00) New Caledonia', value: 'Pacific/Noumea' },\n  { label: '(UTC+12:00) Auckland, Wellington', value: 'Pacific/Auckland' },\n  { label: '(UTC+12:00) Fiji', value: 'Pacific/Fiji' },\n]\n"],"names":["defaultTimezones","label","value"],"mappings":"AAEA;;;;;;;;CAQC,GACD;;;AAAO,MAAMA,mBAA+B;IAC1C;QAAEC,OAAO;QAAoCC,OAAO;IAAiB;IACrE;QAAED,OAAO;QAAoBC,OAAO;IAAe;IACnD;QAAED,OAAO;QAAsBC,OAAO;IAAmB;IACzD;QAAED,OAAO;QAA4BC,OAAO;IAAoB;IAChE;QAAED,OAAO;QAAsBC,OAAO;IAAoB;IAC1D;QAAED,OAAO;QAA+BC,OAAO;IAAkB;IACjE;QAAED,OAAO;QAA0CC,OAAO;IAAsB;IAChF;QAAED,OAAO;QAAwCC,OAAO;IAAkB;IAC1E;QAAED,OAAO;QAA2CC,OAAO;IAAiB;IAC5E;QAAED,OAAO;QAAgCC,OAAO;IAAkB;IAClE;QAAED,OAAO;QAA0CC,OAAO;IAAkB;IAC5E;QAAED,OAAO;QAA+BC,OAAO;IAAoB;IACnE;QAAED,OAAO;QAA0CC,OAAO;IAAmB;IAC7E;QAAED,OAAO;QAAmCC,OAAO;IAAiB;IACpE;QAAED,OAAO;QAAuBC,OAAO;IAAkB;IACzD;QAAED,OAAO;QAAwBC,OAAO;IAAmB;IAC3D;QAAED,OAAO;QAA4BC,OAAO;IAAuB;IACnE;QAAED,OAAO;QAAwBC,OAAO;IAAoB;IAC5D;QAAED,OAAO;QAA6BC,OAAO;IAAyB;IACtE;QAAED,OAAO;QAAsBC,OAAO;IAAkB;IACxD;QAAED,OAAO;QAA0BC,OAAO;IAAsB;IAChE;QAAED,OAAO;QAA4BC,OAAO;IAAgB;IAC5D;QAAED,OAAO;QAA6BC,OAAO;IAAgB;IAC7D;QAAED,OAAO;QAAqBC,OAAO;IAAe;IACpD;QAAED,OAAO;QAAiCC,OAAO;IAAgB;IACjE;QAAED,OAAO;QAAqBC,OAAO;IAAe;IACpD;QAAED,OAAO;QAAsCC,OAAO;IAAgB;IACtE;QAAED,OAAO;QAAsBC,OAAO;IAAc;IACpD;QAAED,OAAO;QAAqBC,OAAO;IAAa;IAClD;QAAED,OAAO;QAAoBC,OAAO;IAAY;IAChD;QAAED,OAAO;QAAkCC,OAAO;IAAe;IACjE;QAAED,OAAO;QAAwBC,OAAO;IAAgB;IACxD;QAAED,OAAO;QAAmDC,OAAO;IAAgB;IACnF;QAAED,OAAO;QAAqBC,OAAO;IAAa;IAClD;QAAED,OAAO;QAAsBC,OAAO;IAAc;IACpD;QAAED,OAAO;QAAuBC,OAAO;IAAe;IACtD;QAAED,OAAO;QAAuBC,OAAO;IAAe;IACtD;QAAED,OAAO;QAAiCC,OAAO;IAAgB;IACjE;QAAED,OAAO;QAAyBC,OAAO;IAAiB;IAC1D;QAAED,OAAO;QAAqCC,OAAO;IAAa;IAClE;QAAED,OAAO;QAAqBC,OAAO;IAAa;IAClD;QAAED,OAAO;QAAiCC,OAAO;IAAmB;IACpE;QAAED,OAAO;QAAkCC,OAAO;IAAe;IACjE;QAAED,OAAO;QAA6BC,OAAO;IAAiB;IAC9D;QAAED,OAAO;QAAoCC,OAAO;IAAmB;IACvE;QAAED,OAAO;QAAoBC,OAAO;IAAe;CACpD,CAAA","ignoreList":[0]}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 290, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/getFieldPaths.ts"],"sourcesContent":["import type { ClientField, Field, Tab, TabAsFieldClient } from './config/types.js'\n\ntype Args = {\n  field: ClientField | Field | Tab | TabAsFieldClient\n  index: number\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n}\n\ntype FieldPaths = {\n  /**\n   * A string of '-' separated indexes representing where\n   * to find this field in a given field schema array.\n   * It will always be complete and accurate.\n   */\n  indexPath: string\n  /**\n   * Path for this field relative to its position in the data.\n   */\n  path: string\n  /**\n   * Path for this field relative to its position in the schema.\n   */\n  schemaPath: string\n}\n\nexport function getFieldPaths({\n  field,\n  index,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n}: Args): FieldPaths {\n  if ('name' in field) {\n    return {\n      indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,\n      path: `${parentPath ? parentPath + '.' : ''}${field.name}`,\n      schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${field.name}`,\n    }\n  }\n\n  const indexSuffix = `_index-${`${parentIndexPath ? parentIndexPath + '-' : ''}${index}`}`\n\n  return {\n    indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,\n    path: `${parentPath ? parentPath + '.' : ''}${indexSuffix}`,\n    schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${indexSuffix}`,\n  }\n}\n\nexport function getFieldPathsModified({\n  field,\n  index,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n}: Args): FieldPaths {\n  const parentPathSegments = parentPath.split('.')\n\n  const parentIsUnnamed = parentPathSegments[parentPathSegments.length - 1].startsWith('_index-')\n\n  const parentWithoutIndex = parentIsUnnamed\n    ? parentPathSegments.slice(0, -1).join('.')\n    : parentPath\n\n  const parentPathToUse = parentIsUnnamed ? parentWithoutIndex : parentPath\n\n  if ('name' in field) {\n    return {\n      indexPath: '',\n      path: `${parentPathToUse ? parentPathToUse + '.' : ''}${field.name}`,\n      schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${field.name}`,\n    }\n  }\n\n  const indexSuffix = `_index-${`${parentIndexPath ? parentIndexPath + '-' : ''}${index}`}`\n\n  return {\n    indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,\n    path: `${parentPathToUse ? parentPathToUse + '.' : ''}${indexSuffix}`,\n    schemaPath: `${!parentIsUnnamed && parentSchemaPath ? parentSchemaPath + '.' : ''}${indexSuffix}`,\n  }\n}\n"],"names":["getFieldPaths","field","index","parentIndexPath","parentPath","parentSchemaPath","indexPath","path","name","schemaPath","indexSuffix","getFieldPathsModified","parentPathSegments","split","parentIsUnnamed","length","startsWith","parentWithoutIndex","slice","join","parentPathToUse"],"mappings":";;;;AA2BO,SAASA,cAAc,EAC5BC,KAAK,EACLC,KAAK,EACLC,eAAe,EACfC,UAAU,EACVC,gBAAgB,EACX;IACL,IAAI,UAAUJ,OAAO;QACnB,OAAO;YACLK,WAAW,GAAGH,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO;YACpEK,MAAM,GAAGH,aAAaA,aAAa,MAAM,KAAKH,MAAMO,IAAI,EAAE;YAC1DC,YAAY,GAAGJ,mBAAmBA,mBAAmB,MAAM,KAAKJ,MAAMO,IAAI,EAAE;QAC9E;IACF;IAEA,MAAME,cAAc,CAAC,OAAO,EAAE,GAAGP,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO,EAAE;IAEzF,OAAO;QACLI,WAAW,GAAGH,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO;QACpEK,MAAM,GAAGH,aAAaA,aAAa,MAAM,KAAKM,aAAa;QAC3DD,YAAY,GAAGJ,mBAAmBA,mBAAmB,MAAM,KAAKK,aAAa;IAC/E;AACF;AAEO,SAASC,sBAAsB,EACpCV,KAAK,EACLC,KAAK,EACLC,eAAe,EACfC,UAAU,EACVC,gBAAgB,EACX;IACL,MAAMO,qBAAqBR,WAAWS,KAAK,CAAC;IAE5C,MAAMC,kBAAkBF,kBAAkB,CAACA,mBAAmBG,MAAM,GAAG,EAAE,CAACC,UAAU,CAAC;IAErF,MAAMC,qBAAqBH,kBACvBF,mBAAmBM,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC,OACrCf;IAEJ,MAAMgB,kBAAkBN,kBAAkBG,qBAAqBb;IAE/D,IAAI,UAAUH,OAAO;QACnB,OAAO;YACLK,WAAW;YACXC,MAAM,GAAGa,kBAAkBA,kBAAkB,MAAM,KAAKnB,MAAMO,IAAI,EAAE;YACpEC,YAAY,GAAGJ,mBAAmBA,mBAAmB,MAAM,KAAKJ,MAAMO,IAAI,EAAE;QAC9E;IACF;IAEA,MAAME,cAAc,CAAC,OAAO,EAAE,GAAGP,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO,EAAE;IAEzF,OAAO;QACLI,WAAW,GAAGH,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO;QACpEK,MAAM,GAAGa,kBAAkBA,kBAAkB,MAAM,KAAKV,aAAa;QACrED,YAAY,GAAG,CAACK,mBAAmBT,mBAAmBA,mBAAmB,MAAM,KAAKK,aAAa;IACnG;AACF","ignoreList":[0]}},
    {"offset": {"line": 328, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 334, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/getDefaultValue.ts"],"sourcesContent":["import type { DefaultValue, JsonValue, PayloadRequest } from '../types/index.js'\n\nimport { deepCopyObjectSimple } from '../utilities/deepCopyObject.js'\n\ntype Args = {\n  defaultValue: DefaultValue\n  locale: string | undefined\n  req: PayloadRequest\n  user: PayloadRequest['user']\n  value?: JsonValue\n}\n\nexport const getDefaultValue = async ({\n  defaultValue,\n  locale,\n  req,\n  user,\n  value,\n}: Args): Promise<JsonValue> => {\n  if (typeof value !== 'undefined') {\n    return value\n  }\n\n  if (defaultValue && typeof defaultValue === 'function') {\n    return await defaultValue({ locale, req, user })\n  }\n\n  if (typeof defaultValue === 'object') {\n    return deepCopyObjectSimple(defaultValue)\n  }\n\n  return defaultValue\n}\n"],"names":["deepCopyObjectSimple","getDefaultValue","defaultValue","locale","req","user","value"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,iCAAgC;;AAU9D,MAAMC,kBAAkB,OAAO,EACpCC,YAAY,EACZC,MAAM,EACNC,GAAG,EACHC,IAAI,EACJC,KAAK,EACA;IACL,IAAI,OAAOA,UAAU,aAAa;QAChC,OAAOA;IACT;IAEA,IAAIJ,gBAAgB,OAAOA,iBAAiB,YAAY;QACtD,OAAO,MAAMA,aAAa;YAAEC;YAAQC;YAAKC;QAAK;IAChD;IAEA,IAAI,OAAOH,iBAAiB,UAAU;QACpC,kYAAOF,uBAAAA,EAAqBE;IAC9B;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 361, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterRead/relationshipPopulationPromise.ts"],"sourcesContent":["import type { PayloadRequest, PopulateType } from '../../../types/index.js'\nimport type { JoinField, RelationshipField, UploadField } from '../../config/types.js'\n\nimport { createDataloaderCacheKey } from '../../../collections/dataloader.js'\nimport { fieldHasMaxDepth, fieldSupportsMany } from '../../config/types.js'\n\ntype PopulateArgs = {\n  currentDepth: number\n  data: Record<string, unknown>\n  dataReference: Record<string, any>\n  depth: number\n  draft: boolean\n  fallbackLocale: null | string\n  field: JoinField | RelationshipField | UploadField\n  index?: number\n  key?: string\n  locale: null | string\n  overrideAccess: boolean\n  populateArg?: PopulateType\n  req: PayloadRequest\n  showHiddenFields: boolean\n}\n\nconst populate = async ({\n  currentDepth,\n  data,\n  dataReference,\n  depth,\n  draft,\n  fallbackLocale,\n  field,\n  index,\n  key,\n  locale,\n  overrideAccess,\n  populateArg,\n  req,\n  showHiddenFields,\n}: PopulateArgs) => {\n  const dataToUpdate = dataReference\n  let relation\n  if (field.type === 'join') {\n    relation = field.collection\n  } else {\n    relation = Array.isArray(field.relationTo) ? (data.relationTo as string) : field.relationTo\n  }\n  const relatedCollection = req.payload.collections[relation]\n\n  if (relatedCollection) {\n    let id = field.type !== 'join' && Array.isArray(field.relationTo) ? data.value : data\n    let relationshipValue\n    const shouldPopulate = depth && currentDepth <= depth\n\n    if (\n      typeof id !== 'string' &&\n      typeof id !== 'number' &&\n      typeof id?.toString === 'function' &&\n      typeof id !== 'object'\n    ) {\n      id = id.toString()\n    }\n\n    if (shouldPopulate) {\n      relationshipValue = await req.payloadDataLoader.load(\n        createDataloaderCacheKey({\n          collectionSlug: relatedCollection.config.slug,\n          currentDepth: currentDepth + 1,\n          depth,\n          docID: id as string,\n          draft,\n          fallbackLocale,\n          locale,\n          overrideAccess,\n          select:\n            populateArg?.[relatedCollection.config.slug] ??\n            relatedCollection.config.defaultPopulate,\n          showHiddenFields,\n          transactionID: req.transactionID,\n        }),\n      )\n    }\n\n    if (!relationshipValue) {\n      // ids are visible regardless of access controls\n      relationshipValue = id\n    }\n    if (typeof index === 'number' && typeof key === 'string') {\n      if (field.type !== 'join' && Array.isArray(field.relationTo)) {\n        dataToUpdate[field.name][key][index].value = relationshipValue\n      } else {\n        dataToUpdate[field.name][key][index] = relationshipValue\n      }\n    } else if (typeof index === 'number' || typeof key === 'string') {\n      if (field.type === 'join') {\n        dataToUpdate[field.name].docs[index ?? key] = relationshipValue\n      } else if (Array.isArray(field.relationTo)) {\n        dataToUpdate[field.name][index ?? key].value = relationshipValue\n      } else {\n        dataToUpdate[field.name][index ?? key] = relationshipValue\n      }\n    } else if (field.type !== 'join' && Array.isArray(field.relationTo)) {\n      dataToUpdate[field.name].value = relationshipValue\n    } else {\n      dataToUpdate[field.name] = relationshipValue\n    }\n  }\n}\n\ntype PromiseArgs = {\n  currentDepth: number\n  depth: number\n  draft: boolean\n  fallbackLocale: null | string\n  field: JoinField | RelationshipField | UploadField\n  locale: null | string\n  overrideAccess: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields: boolean\n  siblingDoc: Record<string, any>\n}\n\nexport const relationshipPopulationPromise = async ({\n  currentDepth,\n  depth,\n  draft,\n  fallbackLocale,\n  field,\n  locale,\n  overrideAccess,\n  populate: populateArg,\n  req,\n  showHiddenFields,\n  siblingDoc,\n}: PromiseArgs): Promise<void> => {\n  const resultingDoc = siblingDoc\n  const populateDepth = fieldHasMaxDepth(field) && field.maxDepth < depth ? field.maxDepth : depth\n  const rowPromises = []\n\n  if (field.type === 'join' || (fieldSupportsMany(field) && field.hasMany)) {\n    if (\n      field.localized &&\n      locale === 'all' &&\n      typeof siblingDoc[field.name] === 'object' &&\n      siblingDoc[field.name] !== null\n    ) {\n      Object.keys(siblingDoc[field.name]).forEach((localeKey) => {\n        if (Array.isArray(siblingDoc[field.name][localeKey])) {\n          siblingDoc[field.name][localeKey].forEach((relatedDoc, index) => {\n            const rowPromise = async () => {\n              await populate({\n                currentDepth,\n                data: siblingDoc[field.name][localeKey][index],\n                dataReference: resultingDoc,\n                depth: populateDepth,\n                draft,\n                fallbackLocale,\n                field,\n                index,\n                key: localeKey,\n                locale,\n                overrideAccess,\n                populateArg,\n                req,\n                showHiddenFields,\n              })\n            }\n            rowPromises.push(rowPromise())\n          })\n        }\n      })\n    } else if (\n      Array.isArray(siblingDoc[field.name]) ||\n      Array.isArray(siblingDoc[field.name]?.docs)\n    ) {\n      ;(Array.isArray(siblingDoc[field.name])\n        ? siblingDoc[field.name]\n        : siblingDoc[field.name].docs\n      ).forEach((relatedDoc, index) => {\n        const rowPromise = async () => {\n          if (relatedDoc) {\n            await populate({\n              currentDepth,\n              data: relatedDoc?.id ? relatedDoc.id : relatedDoc,\n              dataReference: resultingDoc,\n              depth: populateDepth,\n              draft,\n              fallbackLocale,\n              field,\n              index,\n              locale,\n              overrideAccess,\n              populateArg,\n              req,\n              showHiddenFields,\n            })\n          }\n        }\n\n        rowPromises.push(rowPromise())\n      })\n    }\n  } else if (\n    field.localized &&\n    locale === 'all' &&\n    typeof siblingDoc[field.name] === 'object' &&\n    siblingDoc[field.name] !== null\n  ) {\n    Object.keys(siblingDoc[field.name]).forEach((localeKey) => {\n      const rowPromise = async () => {\n        await populate({\n          currentDepth,\n          data: siblingDoc[field.name][localeKey],\n          dataReference: resultingDoc,\n          depth: populateDepth,\n          draft,\n          fallbackLocale,\n          field,\n          key: localeKey,\n          locale,\n          overrideAccess,\n          populateArg,\n          req,\n          showHiddenFields,\n        })\n      }\n      rowPromises.push(rowPromise())\n    })\n\n    await Promise.all(rowPromises)\n  } else if (siblingDoc[field.name]) {\n    await populate({\n      currentDepth,\n      data: siblingDoc[field.name],\n      dataReference: resultingDoc,\n      depth: populateDepth,\n      draft,\n      fallbackLocale,\n      field,\n      locale,\n      overrideAccess,\n      populateArg,\n      req,\n      showHiddenFields,\n    })\n  }\n  await Promise.all(rowPromises)\n}\n"],"names":["createDataloaderCacheKey","fieldHasMaxDepth","fieldSupportsMany","populate","currentDepth","data","dataReference","depth","draft","fallbackLocale","field","index","key","locale","overrideAccess","populateArg","req","showHiddenFields","dataToUpdate","relation","type","collection","Array","isArray","relationTo","relatedCollection","payload","collections","id","value","relationshipValue","shouldPopulate","toString","payloadDataLoader","load","collectionSlug","config","slug","docID","select","defaultPopulate","transactionID","name","docs","relationshipPopulationPromise","siblingDoc","resultingDoc","populateDepth","maxDepth","rowPromises","hasMany","localized","Object","keys","forEach","localeKey","relatedDoc","rowPromise","push","Promise","all"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 520, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterRead/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectMode,\n  SelectType,\n} from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { relationshipPopulationPromise } from './relationshipPopulationPromise.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: null | string\n  field: Field | TabAsField\n  fieldIndex: number\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n  populate?: PopulateType\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  select?: SelectType\n  selectMode?: SelectMode\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Remove hidden fields from response\n// - Flatten locales into requested locale\n// - Sanitize outgoing data (point field, etc.)\n// - Execute field hooks\n// - Execute read access control\n// - Populate relationships\n\nexport const promise = async ({\n  blockData,\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  field,\n  fieldIndex,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n  populate,\n  populationPromises,\n  req,\n  select,\n  selectMode,\n  showHiddenFields,\n  siblingDoc,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (\n    fieldAffectsData(field) &&\n    field.hidden &&\n    typeof siblingDoc[field.name] !== 'undefined' &&\n    !showHiddenFields\n  ) {\n    delete siblingDoc[field.name]\n  }\n\n  // Strip unselected fields\n  if (fieldAffectsData(field) && select && selectMode) {\n    if (selectMode === 'include') {\n      if (!select[field.name]) {\n        delete siblingDoc[field.name]\n        return\n      }\n    }\n\n    if (selectMode === 'exclude') {\n      if (select[field.name] === false) {\n        delete siblingDoc[field.name]\n        return\n      }\n    }\n  }\n\n  const shouldHoistLocalizedValue =\n    flattenLocales &&\n    fieldAffectsData(field) &&\n    typeof siblingDoc[field.name] === 'object' &&\n    siblingDoc[field.name] !== null &&\n    field.localized &&\n    locale !== 'all' &&\n    req.payload.config.localization\n\n  if (shouldHoistLocalizedValue) {\n    // replace actual value with localized value before sanitizing\n    // { [locale]: fields } -> fields\n    const value = siblingDoc[field.name][locale]\n\n    let hoistedValue = value\n\n    if (fallbackLocale && fallbackLocale !== locale) {\n      const fallbackValue = siblingDoc[field.name][fallbackLocale]\n      const isNullOrUndefined = typeof value === 'undefined' || value === null\n\n      if (fallbackValue) {\n        switch (field.type) {\n          case 'text':\n          case 'textarea': {\n            if (value === '' || isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n\n          default: {\n            if (isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n        }\n      }\n    }\n\n    siblingDoc[field.name] = hoistedValue\n  }\n\n  // Sanitize outgoing field value\n  switch (field.type) {\n    case 'group': {\n      // Fill groups with empty objects so fields with hooks within groups can populate\n      // themselves virtually as necessary\n      if (typeof siblingDoc[field.name] === 'undefined') {\n        siblingDoc[field.name] = {}\n      }\n\n      break\n    }\n    case 'point': {\n      const pointDoc = siblingDoc[field.name] as Record<string, unknown>\n      if (Array.isArray(pointDoc?.coordinates) && pointDoc.coordinates.length === 2) {\n        siblingDoc[field.name] = pointDoc.coordinates\n      } else {\n        siblingDoc[field.name] = undefined\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      // Rich Text fields should use afterRead hooks to do population. The previous editor.populationPromises have been renamed to editor.graphQLPopulationPromises\n      break\n    }\n\n    case 'tabs': {\n      field.tabs.forEach((tab) => {\n        if (\n          tabHasName(tab) &&\n          (typeof siblingDoc[tab.name] === 'undefined' || siblingDoc[tab.name] === null)\n        ) {\n          siblingDoc[tab.name] = {}\n        }\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (triggerHooks && field.hooks?.afterRead) {\n      await field.hooks.afterRead.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const shouldRunHookOnAllLocales =\n          field.localized &&\n          (locale === 'all' || !flattenLocales) &&\n          typeof siblingDoc[field.name] === 'object'\n\n        if (shouldRunHookOnAllLocales) {\n          const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value]) =>\n            (async () => {\n              const hookedValue = await currentHook({\n                blockData,\n                collection,\n                context,\n                currentDepth,\n                data: doc,\n                depth,\n                draft,\n                field,\n                findMany,\n                global,\n                indexPath: indexPathSegments,\n                operation: 'read',\n                originalDoc: doc,\n                overrideAccess,\n                path: pathSegments,\n                req,\n                schemaPath: schemaPathSegments,\n                showHiddenFields,\n                siblingData: siblingDoc,\n                value,\n              })\n\n              if (hookedValue !== undefined) {\n                siblingDoc[field.name][locale] = hookedValue\n              }\n            })(),\n          )\n\n          await Promise.all(hookPromises)\n        } else {\n          const hookedValue = await currentHook({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            data: doc,\n            depth,\n            draft,\n            field,\n            findMany,\n            global,\n            indexPath: indexPathSegments,\n            operation: 'read',\n            originalDoc: doc,\n            overrideAccess,\n            path: pathSegments,\n            req,\n            schemaPath: schemaPathSegments,\n            showHiddenFields,\n            siblingData: siblingDoc,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }\n      }, Promise.resolve())\n    }\n\n    // Execute access control\n    let allowDefaultValue = true\n    if (triggerAccessControl && field.access && field.access.read) {\n      const result = overrideAccess\n        ? true\n        : await field.access.read({\n            id: doc.id as number | string,\n            blockData,\n            data: doc,\n            doc,\n            req,\n            siblingData: siblingDoc,\n          })\n\n      if (!result) {\n        allowDefaultValue = false\n        delete siblingDoc[field.name]\n      }\n    }\n\n    // Set defaultValue on the field for globals being returned without being first created\n    // or collection documents created prior to having a default\n    if (\n      allowDefaultValue &&\n      typeof siblingDoc[field.name] === 'undefined' &&\n      typeof field.defaultValue !== 'undefined'\n    ) {\n      siblingDoc[field.name] = await getDefaultValue({\n        defaultValue: field.defaultValue,\n        locale,\n        req,\n        user: req.user,\n        value: siblingDoc[field.name],\n      })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload' || field.type === 'join') {\n      populationPromises.push(\n        relationshipPopulationPromise({\n          currentDepth,\n          depth,\n          draft,\n          fallbackLocale,\n          field,\n          locale,\n          overrideAccess,\n          populate,\n          req,\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name] as JsonObject\n\n      let arraySelect = select?.[field.name]\n\n      if (selectMode === 'include' && typeof arraySelect === 'object') {\n        arraySelect = {\n          ...arraySelect,\n          id: true,\n        }\n      }\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, rowIndex) => {\n          traverseFields({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            depth,\n            doc,\n            draft,\n            fallbackLocale,\n            fieldPromises,\n            fields: field.fields,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            parentIndexPath: '',\n            parentPath: path + '.' + rowIndex,\n            parentSchemaPath: schemaPath,\n            populate,\n            populationPromises,\n            req,\n            select: typeof arraySelect === 'object' ? arraySelect : undefined,\n            selectMode,\n            showHiddenFields,\n            siblingDoc: row || {},\n            triggerAccessControl,\n            triggerHooks,\n          })\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, rowIndex) => {\n              traverseFields({\n                blockData,\n                collection,\n                context,\n                currentDepth,\n                depth,\n                doc,\n                draft,\n                fallbackLocale,\n                fieldPromises,\n                fields: field.fields,\n                findMany,\n                flattenLocales,\n                global,\n                locale,\n                overrideAccess,\n                parentIndexPath: '',\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath,\n                populate,\n                populationPromises,\n                req,\n                showHiddenFields,\n                siblingDoc: (row as JsonObject) || {},\n                triggerAccessControl,\n                triggerHooks,\n              })\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      let blocksSelect = select?.[field.name]\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, rowIndex) => {\n          const block = field.blocks.find(\n            (blockType) => blockType.slug === (row as JsonObject).blockType,\n          )\n\n          let blockSelectMode = selectMode\n\n          if (typeof blocksSelect === 'object') {\n            blocksSelect = {\n              ...blocksSelect,\n            }\n\n            // sanitize blocks: {cta: false} to blocks: {cta: {id: true, blockType: true}}\n            if (selectMode === 'exclude' && blocksSelect[block.slug] === false) {\n              blockSelectMode = 'include'\n              blocksSelect[block.slug] = {\n                id: true,\n                blockType: true,\n              }\n            } else if (selectMode === 'include') {\n              if (!blocksSelect[block.slug]) {\n                blocksSelect[block.slug] = {}\n              }\n\n              if (typeof blocksSelect[block.slug] === 'object') {\n                blocksSelect[block.slug] = {\n                  ...(blocksSelect[block.slug] as object),\n                }\n\n                blocksSelect[block.slug]['id'] = true\n                blocksSelect[block.slug]['blockType'] = true\n              }\n            }\n          }\n\n          const blockSelect = blocksSelect?.[block.slug]\n\n          if (block) {\n            traverseFields({\n              blockData: row,\n              collection,\n              context,\n              currentDepth,\n              depth,\n              doc,\n              draft,\n              fallbackLocale,\n              fieldPromises,\n              fields: block.fields,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              parentIndexPath: '',\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath + '.' + block.slug,\n              populate,\n              populationPromises,\n              req,\n              select: typeof blockSelect === 'object' ? blockSelect : undefined,\n              selectMode: blockSelectMode,\n              showHiddenFields,\n              siblingDoc: (row as JsonObject) || {},\n              triggerAccessControl,\n              triggerHooks,\n            })\n          }\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, rowIndex) => {\n              const block = field.blocks.find(\n                (blockType) => blockType.slug === (row as JsonObject).blockType,\n              )\n\n              if (block) {\n                traverseFields({\n                  blockData: row,\n                  collection,\n                  context,\n                  currentDepth,\n                  depth,\n                  doc,\n                  draft,\n                  fallbackLocale,\n                  fieldPromises,\n                  fields: block.fields,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentPath: path + '.' + rowIndex,\n                  parentSchemaPath: schemaPath + '.' + block.slug,\n                  populate,\n                  populationPromises,\n                  req,\n                  showHiddenFields,\n                  siblingDoc: (row as JsonObject) || {},\n                  triggerAccessControl,\n                  triggerHooks,\n                })\n              }\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'group': {\n      let groupDoc = siblingDoc[field.name] as JsonObject\n\n      if (typeof siblingDoc[field.name] !== 'object') {\n        groupDoc = {}\n      }\n\n      const groupSelect = select?.[field.name]\n\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: '',\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select: typeof groupSelect === 'object' ? groupSelect : undefined,\n        selectMode,\n        showHiddenFields,\n        siblingDoc: groupDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterRead?.length) {\n        await editor.hooks.afterRead.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const shouldRunHookOnAllLocales =\n            field.localized &&\n            (locale === 'all' || !flattenLocales) &&\n            typeof siblingDoc[field.name] === 'object'\n\n          if (shouldRunHookOnAllLocales) {\n            const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value]) =>\n              (async () => {\n                const hookedValue = await currentHook({\n                  collection,\n                  context,\n                  currentDepth,\n                  data: doc,\n                  depth,\n                  draft,\n                  fallbackLocale,\n                  field,\n                  fieldPromises,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  indexPath: indexPathSegments,\n                  locale,\n                  operation: 'read',\n                  originalDoc: doc,\n                  overrideAccess,\n                  path: pathSegments,\n                  populate,\n                  populationPromises,\n                  req,\n                  schemaPath: schemaPathSegments,\n                  showHiddenFields,\n                  siblingData: siblingDoc,\n                  triggerAccessControl,\n                  triggerHooks,\n                  value,\n                })\n\n                if (hookedValue !== undefined) {\n                  siblingDoc[field.name][locale] = hookedValue\n                }\n              })(),\n            )\n\n            await Promise.all(hookPromises)\n          } else {\n            const hookedValue = await currentHook({\n              collection,\n              context,\n              currentDepth,\n              data: doc,\n              depth,\n              draft,\n              fallbackLocale,\n              field,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              indexPath: indexPathSegments,\n              locale,\n              operation: 'read',\n              originalDoc: doc,\n              overrideAccess,\n              path: pathSegments,\n              populate,\n              populationPromises,\n              req,\n              schemaPath: schemaPathSegments,\n              showHiddenFields,\n              siblingData: siblingDoc,\n              triggerAccessControl,\n              triggerHooks,\n              value: siblingDoc[field.name],\n            })\n\n            if (hookedValue !== undefined) {\n              siblingDoc[field.name] = hookedValue\n            }\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabDoc = siblingDoc\n      let tabSelect: SelectType | undefined\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        tabDoc = siblingDoc[field.name] as JsonObject\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          tabDoc = {}\n        }\n\n        if (typeof select?.[field.name] === 'object') {\n          tabSelect = select?.[field.name] as SelectType\n        }\n      } else {\n        tabSelect = select\n      }\n\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select: tabSelect,\n        selectMode,\n        showHiddenFields,\n        siblingDoc: tabDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getDefaultValue","getFieldPathsModified","getFieldPaths","relationshipPopulationPromise","traverseFields","promise","blockData","collection","context","currentDepth","depth","doc","draft","fallbackLocale","field","fieldIndex","fieldPromises","findMany","flattenLocales","global","locale","overrideAccess","parentIndexPath","parentPath","parentSchemaPath","populate","populationPromises","req","select","selectMode","showHiddenFields","siblingDoc","triggerAccessControl","triggerHooks","indexPath","path","schemaPath","index","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","hidden","name","shouldHoistLocalizedValue","localized","payload","config","localization","value","hoistedValue","fallbackValue","isNullOrUndefined","type","pointDoc","Array","isArray","coordinates","length","undefined","editor","Error","tabs","forEach","tab","hooks","afterRead","reduce","priorHook","currentHook","shouldRunHookOnAllLocales","hookPromises","Object","entries","hookedValue","data","operation","originalDoc","siblingData","Promise","all","resolve","allowDefaultValue","access","read","result","id","defaultValue","user","push","rows","arraySelect","row","rowIndex","fields","values","localeRows","blocksSelect","block","blocks","find","blockType","slug","blockSelectMode","blockSelect","groupDoc","groupSelect","tabDoc","tabSelect","isNamedTab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1192, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1198, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterRead/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectMode,\n  SelectType,\n} from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: null | string\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  fields: (Field | TabAsField)[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n  populate?: PopulateType\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  select?: SelectType\n  selectMode?: SelectMode\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\nexport const traverseFields = ({\n  blockData,\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  fieldPromises,\n  fields,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n  populate,\n  populationPromises,\n  req,\n  select,\n  selectMode,\n  showHiddenFields,\n  siblingDoc,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): void => {\n  fields.forEach((field, fieldIndex) => {\n    fieldPromises.push(\n      promise({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        field,\n        fieldIndex,\n        fieldPromises,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath,\n        parentPath,\n        parentSchemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      }),\n    )\n  })\n}\n"],"names":["promise","traverseFields","blockData","collection","context","currentDepth","depth","doc","draft","fallbackLocale","fieldPromises","fields","findMany","flattenLocales","global","locale","overrideAccess","parentIndexPath","parentPath","parentSchemaPath","populate","populationPromises","req","select","selectMode","showHiddenFields","siblingDoc","triggerAccessControl","triggerHooks","forEach","field","fieldIndex","push"],"mappings":";;;AAYA,SAASA,OAAO,QAAQ,eAAc;;AAsC/B,MAAMC,iBAAiB,CAAC,EAC7BC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,GAAG,EACHC,KAAK,EACLC,cAAc,EACdC,aAAa,EACbC,MAAM,EACNC,QAAQ,EACRC,cAAc,EACdC,MAAM,EACNC,MAAM,EACNC,cAAc,EACdC,eAAe,EACfC,UAAU,EACVC,gBAAgB,EAChBC,QAAQ,EACRC,kBAAkB,EAClBC,GAAG,EACHC,MAAM,EACNC,UAAU,EACVC,gBAAgB,EAChBC,UAAU,EACVC,uBAAuB,IAAI,EAC3BC,eAAe,IAAI,EACd;IACLjB,OAAOkB,OAAO,CAAC,CAACC,OAAOC;QACrBrB,cAAcsB,IAAI,wYAChBhC,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAqB;YACAC;YACArB;YACAE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1237, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1243, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterRead/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'\n\nimport { getSelectMode } from '../../../utilities/getSelectMode.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth?: number\n  depth: number\n  doc: T\n  draft: boolean\n  fallbackLocale: null | string\n  findMany?: boolean\n  flattenLocales?: boolean\n  global: null | SanitizedGlobalConfig\n  locale: string\n  overrideAccess: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  select?: SelectType\n  showHiddenFields: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Remove hidden fields from response\n * - Flatten locales into requested locale. If the input doc contains all locales, the output doc after this function will only contain the requested locale.\n * - Sanitize outgoing data (point field, etc.)\n * - Execute field hooks\n * - Execute read access control\n * - Populate relationships\n */\n\nexport async function afterRead<T extends JsonObject>(args: Args<T>): Promise<T> {\n  const {\n    collection,\n    context,\n    currentDepth: incomingCurrentDepth,\n    depth: incomingDepth,\n    doc: incomingDoc,\n    draft,\n    fallbackLocale,\n    findMany,\n    flattenLocales = true,\n    global,\n    locale,\n    overrideAccess,\n    populate,\n    req,\n    select,\n    showHiddenFields,\n  } = args\n\n  const fieldPromises = []\n  const populationPromises = []\n\n  let depth =\n    incomingDepth || incomingDepth === 0\n      ? parseInt(String(incomingDepth), 10)\n      : req.payload.config.defaultDepth\n  if (depth > req.payload.config.maxDepth) {\n    depth = req.payload.config.maxDepth\n  }\n\n  const currentDepth = incomingCurrentDepth || 1\n\n  traverseFields({\n    collection,\n    context,\n    currentDepth,\n    depth,\n    doc: incomingDoc,\n    draft,\n    fallbackLocale,\n    fieldPromises,\n    fields: collection?.fields || global?.fields,\n    findMany,\n    flattenLocales,\n    global,\n    locale,\n    overrideAccess,\n    parentIndexPath: '',\n    parentPath: '',\n    parentSchemaPath: '',\n    populate,\n    populationPromises,\n    req,\n    select,\n    selectMode: select ? getSelectMode(select) : undefined,\n    showHiddenFields,\n    siblingDoc: incomingDoc,\n  })\n\n  /**\n   * Await all field and population promises in parallel.\n   * A field promise is able to add more field promises to the fieldPromises array, which will not be\n   * awaited in the first run.\n   * This is why we need to loop again to process the new field promises, until there are no more field promises left.\n   */\n  let iterations = 0\n  while (fieldPromises.length > 0 || populationPromises.length > 0) {\n    const currentFieldPromises = fieldPromises.splice(0, fieldPromises.length)\n    const currentPopulationPromises = populationPromises.splice(0, populationPromises.length)\n\n    await Promise.all(currentFieldPromises)\n    await Promise.all(currentPopulationPromises)\n\n    iterations++\n    if (iterations >= 100) {\n      throw new Error(\n        'Infinite afterRead promise loop detected. A hook is likely adding field promises in an infinitely recursive way.',\n      )\n    }\n  }\n  return incomingDoc\n}\n"],"names":["getSelectMode","traverseFields","afterRead","args","collection","context","currentDepth","incomingCurrentDepth","depth","incomingDepth","doc","incomingDoc","draft","fallbackLocale","findMany","flattenLocales","global","locale","overrideAccess","populate","req","select","showHiddenFields","fieldPromises","populationPromises","parseInt","String","payload","config","defaultDepth","maxDepth","fields","parentIndexPath","parentPath","parentSchemaPath","selectMode","undefined","siblingDoc","iterations","length","currentFieldPromises","splice","currentPopulationPromises","Promise","all","Error"],"mappings":";;;AAMA,SAASC,cAAc,QAAQ,sBAAqB;AADpD,SAASD,aAAa,QAAQ,sCAAqC;;;AAgC5D,eAAeE,UAAgCC,IAAa;IACjE,MAAM,EACJC,UAAU,EACVC,OAAO,EACPC,cAAcC,oBAAoB,EAClCC,OAAOC,aAAa,EACpBC,KAAKC,WAAW,EAChBC,KAAK,EACLC,cAAc,EACdC,QAAQ,EACRC,iBAAiB,IAAI,EACrBC,MAAM,EACNC,MAAM,EACNC,cAAc,EACdC,QAAQ,EACRC,GAAG,EACHC,MAAM,EACNC,gBAAgB,EACjB,GAAGnB;IAEJ,MAAMoB,gBAAgB,EAAE;IACxB,MAAMC,qBAAqB,EAAE;IAE7B,IAAIhB,QACFC,iBAAiBA,kBAAkB,IAC/BgB,SAASC,OAAOjB,gBAAgB,MAChCW,IAAIO,OAAO,CAACC,MAAM,CAACC,YAAY;IACrC,IAAIrB,QAAQY,IAAIO,OAAO,CAACC,MAAM,CAACE,QAAQ,EAAE;QACvCtB,QAAQY,IAAIO,OAAO,CAACC,MAAM,CAACE,QAAQ;IACrC;IAEA,MAAMxB,eAAeC,wBAAwB;kZAE7CN,iBAAAA,EAAe;QACbG;QACAC;QACAC;QACAE;QACAE,KAAKC;QACLC;QACAC;QACAU;QACAQ,QAAQ3B,YAAY2B,UAAUf,QAAQe;QACtCjB;QACAC;QACAC;QACAC;QACAC;QACAc,iBAAiB;QACjBC,YAAY;QACZC,kBAAkB;QAClBf;QACAK;QACAJ;QACAC;QACAc,YAAYd,mYAASrB,gBAAAA,EAAcqB,UAAUe;QAC7Cd;QACAe,YAAY1B;IACd;IAEA;;;;;GAKC,GACD,IAAI2B,aAAa;IACjB,MAAOf,cAAcgB,MAAM,GAAG,KAAKf,mBAAmBe,MAAM,GAAG,EAAG;QAChE,MAAMC,uBAAuBjB,cAAckB,MAAM,CAAC,GAAGlB,cAAcgB,MAAM;QACzE,MAAMG,4BAA4BlB,mBAAmBiB,MAAM,CAAC,GAAGjB,mBAAmBe,MAAM;QAExF,MAAMI,QAAQC,GAAG,CAACJ;QAClB,MAAMG,QAAQC,GAAG,CAACF;QAElBJ;QACA,IAAIA,cAAc,KAAK;YACrB,MAAM,IAAIO,MACR;QAEJ;IACF;IACA,OAAOlC;AACT","ignoreList":[0]}},
    {"offset": {"line": 1303, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1309, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/validations.ts"],"sourcesContent":["import Ajv from 'ajv'\nimport ObjectIdImport from 'bson-objectid'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nimport type { RichTextAdapter } from '../admin/types.js'\nimport type { CollectionSlug } from '../index.js'\nimport type { Where } from '../types/index.js'\nimport type {\n  ArrayField,\n  BlocksField,\n  CheckboxField,\n  CodeField,\n  DateField,\n  EmailField,\n  JSONField,\n  NumberField,\n  PointField,\n  RadioField,\n  RelationshipField,\n  RelationshipValue,\n  RelationshipValueMany,\n  RelationshipValueSingle,\n  RichTextField,\n  SelectField,\n  TextareaField,\n  TextField,\n  UploadField,\n  Validate,\n} from './config/types.js'\n\nimport { isNumber } from '../utilities/isNumber.js'\nimport { isValidID } from '../utilities/isValidID.js'\n\nexport type TextFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport type TextFieldManyValidation = Validate<string[], unknown, unknown, TextField>\n\nexport type TextFieldSingleValidation = Validate<string, unknown, unknown, TextField>\n\nexport const text: TextFieldValidation = (\n  value,\n  {\n    hasMany,\n    maxLength: fieldMaxLength,\n    maxRows,\n    minLength,\n    minRows,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (!required) {\n    if (!value) {\n      return true\n    }\n  }\n\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  const stringsToValidate: string[] = Array.isArray(value) ? value : [value]\n\n  for (const stringValue of stringsToValidate) {\n    const length = stringValue?.length || 0\n\n    if (typeof maxLength === 'number' && length > maxLength) {\n      return t('validation:shorterThanMax', { label: t('general:value'), maxLength, stringValue })\n    }\n\n    if (typeof minLength === 'number' && length < minLength) {\n      return t('validation:longerThanMin', { label: t('general:value'), minLength, stringValue })\n    }\n  }\n\n  if (required) {\n    if (!(typeof value === 'string' || Array.isArray(value)) || value?.length === 0) {\n      return t('validation:required')\n    }\n  }\n\n  return true\n}\n\nexport type PasswordFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport const password: PasswordFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength = 3,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type ConfirmPasswordFieldValidation = Validate<\n  string,\n  unknown,\n  { password: string },\n  TextField\n>\n\nexport const confirmPassword: ConfirmPasswordFieldValidation = (\n  value,\n  { req: { t }, required, siblingData },\n) => {\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (value && value !== siblingData.password) {\n    return t('fields:passwordsDoNotMatch')\n  }\n\n  return true\n}\n\nexport type EmailFieldValidation = Validate<string, unknown, { username?: string }, EmailField>\n\nexport const email: EmailFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { collections, config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  if (collectionSlug) {\n    const collection =\n      collections?.[collectionSlug]?.config ??\n      config.collections.find(({ slug }) => slug === collectionSlug) // If this is run on the client, `collections` will be undefined, but `config.collections` will be available\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.username) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  if ((value && !/\\S[^\\s@]*@\\S+\\.\\S+/.test(value)) || (!value && required)) {\n    return t('validation:emailAddress')\n  }\n\n  return true\n}\n\nexport type UsernameFieldValidation = Validate<string, unknown, { email?: string }, TextField>\n\nexport const username: UsernameFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { collections, config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  let maxLength: number\n\n  if (collectionSlug) {\n    const collection =\n      collections?.[collectionSlug]?.config ??\n      config.collections.find(({ slug }) => slug === collectionSlug) // If this is run on the client, `collections` will be undefined, but `config.collections` will be available\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.email) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (!value && required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type TextareaFieldValidation = Validate<string, unknown, unknown, TextareaField>\n\nexport const textarea: TextareaFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type CodeFieldValidation = Validate<string, unknown, unknown, CodeField>\n\nexport const code: CodeFieldValidation = (value, { req: { t }, required }) => {\n  if (required && value === undefined) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type JSONFieldValidation = Validate<\n  string,\n  unknown,\n  unknown,\n  { jsonError?: string } & JSONField\n>\n\nexport const json: JSONFieldValidation = async (\n  value,\n  { jsonError, jsonSchema, req: { t }, required },\n) => {\n  const isNotEmpty = (value) => {\n    if (value === undefined || value === null) {\n      return false\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false\n    }\n\n    if (typeof value === 'object' && Object.keys(value).length === 0) {\n      return false\n    }\n\n    return true\n  }\n\n  const fetchSchema = ({ schema, uri }: Record<string, unknown>) => {\n    if (uri && schema) {\n      return schema\n    }\n    // @ts-expect-error\n    return fetch(uri)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok')\n        }\n        return response.json()\n      })\n      .then((json) => {\n        const jsonSchemaSanitizations = {\n          id: undefined,\n          $id: json.id,\n          $schema: 'http://json-schema.org/draft-07/schema#',\n        }\n\n        return Object.assign(json, jsonSchemaSanitizations)\n      })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (jsonError !== undefined) {\n    return t('validation:invalidInput')\n  }\n\n  if (jsonSchema && isNotEmpty(value)) {\n    try {\n      jsonSchema.schema = await fetchSchema(jsonSchema)\n      const { schema } = jsonSchema\n      // @ts-expect-error\n      const ajv = new Ajv()\n\n      if (!ajv.validate(schema, value)) {\n        return t(ajv.errorsText())\n      }\n    } catch (error) {\n      return t(error.message)\n    }\n  }\n  return true\n}\n\nexport type CheckboxFieldValidation = Validate<boolean, unknown, unknown, CheckboxField>\n\nexport const checkbox: CheckboxFieldValidation = (value, { req: { t }, required }) => {\n  if ((value && typeof value !== 'boolean') || (required && typeof value !== 'boolean')) {\n    return t('validation:trueOrFalse')\n  }\n\n  return true\n}\n\nexport type DateFieldValidation = Validate<Date, unknown, unknown, DateField>\n\nexport const date: DateFieldValidation = (\n  value,\n  { name, req: { t }, required, siblingData, timezone },\n) => {\n  const validDate = value && !isNaN(Date.parse(value.toString()))\n\n  // We need to also check for the timezone data based on this field's config\n  // We cannot do this inside the timezone field validation as it's visually hidden\n  const hasRequiredTimezone = timezone && required\n  const selectedTimezone: string = siblingData?.[`${name}_tz`]\n  // Always resolve to true if the field is not required, as timezone may be optional too then\n  const validTimezone = hasRequiredTimezone ? Boolean(selectedTimezone) : true\n\n  if (validDate && validTimezone) {\n    return true\n  }\n\n  if (validDate && !validTimezone) {\n    return t('validation:timezoneRequired')\n  }\n\n  if (value) {\n    return t('validation:notValidDate', { value })\n  }\n\n  if (required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RichTextFieldValidation = Validate<object, unknown, unknown, RichTextField>\n\nexport const richText: RichTextFieldValidation = async (value, options) => {\n  if (!options?.editor) {\n    throw new Error('richText field has no editor property.')\n  }\n  if (typeof options?.editor === 'function') {\n    throw new Error('Attempted to access unsanitized rich text editor.')\n  }\n\n  const editor: RichTextAdapter = options?.editor\n\n  return editor.validate(value, options)\n}\n\nconst validateArrayLength = (\n  value,\n  options: {\n    maxRows?: number\n    minRows?: number\n    required?: boolean\n    t: (key: string, options?: { [key: string]: number | string }) => string\n  },\n) => {\n  const { maxRows, minRows, required, t } = options\n\n  const arrayLength = Array.isArray(value) ? value.length : value || 0\n\n  if (!required && arrayLength === 0) {\n    return true\n  }\n\n  if (minRows && arrayLength < minRows) {\n    return t('validation:requiresAtLeast', { count: minRows, label: t('general:rows') })\n  }\n\n  if (maxRows && arrayLength > maxRows) {\n    return t('validation:requiresNoMoreThan', { count: maxRows, label: t('general:rows') })\n  }\n\n  if (required && !arrayLength) {\n    return t('validation:requiresAtLeast', { count: 1, label: t('general:row') })\n  }\n\n  return true\n}\n\nexport type NumberFieldValidation = Validate<number | number[], unknown, unknown, NumberField>\n\nexport type NumberFieldManyValidation = Validate<number[], unknown, unknown, NumberField>\n\nexport type NumberFieldSingleValidation = Validate<number, unknown, unknown, NumberField>\n\nexport const number: NumberFieldValidation = (\n  value,\n  { hasMany, max, maxRows, min, minRows, req: { t }, required },\n) => {\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (!value && !isNumber(value)) {\n    // if no value is present, validate based on required\n    if (required) {\n      return t('validation:required')\n    }\n    if (!required) {\n      return true\n    }\n  }\n\n  const numbersToValidate: number[] = Array.isArray(value) ? value : [value]\n\n  for (const number of numbersToValidate) {\n    if (!isNumber(number)) {\n      return t('validation:enterNumber')\n    }\n\n    const numberValue = parseFloat(number as unknown as string)\n\n    if (typeof max === 'number' && numberValue > max) {\n      return t('validation:greaterThanMax', { label: t('general:value'), max, value })\n    }\n\n    if (typeof min === 'number' && numberValue < min) {\n      return t('validation:lessThanMin', { label: t('general:value'), min, value })\n    }\n  }\n\n  return true\n}\n\nexport type ArrayFieldValidation = Validate<unknown[], unknown, unknown, ArrayField>\n\nexport const array: ArrayFieldValidation = (value, { maxRows, minRows, req: { t }, required }) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nexport type BlocksFieldValidation = Validate<unknown, unknown, unknown, BlocksField>\n\nexport const blocks: BlocksFieldValidation = (\n  value,\n  { maxRows, minRows, req: { t }, required },\n) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nconst validateFilterOptions: Validate<\n  unknown,\n  unknown,\n  unknown,\n  RelationshipField | UploadField\n> = async (\n  value,\n  { id, blockData, data, filterOptions, relationTo, req, req: { payload, t, user }, siblingData },\n) => {\n  if (typeof filterOptions !== 'undefined' && value) {\n    const options: {\n      [collection: string]: (number | string)[]\n    } = {}\n\n    const falseCollections: CollectionSlug[] = []\n    const collections = !Array.isArray(relationTo) ? [relationTo] : relationTo\n    const values = Array.isArray(value) ? value : [value]\n\n    for (const collection of collections) {\n      try {\n        let optionFilter =\n          typeof filterOptions === 'function'\n            ? await filterOptions({\n                id,\n                blockData,\n                data,\n                relationTo: collection,\n                req,\n                siblingData,\n                user,\n              })\n            : filterOptions\n\n        if (optionFilter === true) {\n          optionFilter = null\n        }\n\n        const valueIDs: (number | string)[] = []\n\n        values.forEach((val) => {\n          if (typeof val === 'object') {\n            if (val?.value) {\n              valueIDs.push(val.value)\n            } else if (ObjectId.isValid(val)) {\n              valueIDs.push(new ObjectId(val).toHexString())\n            }\n          }\n\n          if (typeof val === 'string' || typeof val === 'number') {\n            valueIDs.push(val)\n          }\n        })\n\n        if (valueIDs.length > 0) {\n          const findWhere: Where = {\n            and: [{ id: { in: valueIDs } }],\n          }\n\n          if (optionFilter && optionFilter !== true) {\n            findWhere.and.push(optionFilter)\n          }\n\n          if (optionFilter === false) {\n            falseCollections.push(collection)\n          }\n\n          const result = await payload.find({\n            collection,\n            depth: 0,\n            limit: 0,\n            pagination: false,\n            req,\n            where: findWhere,\n          })\n\n          options[collection] = result.docs.map((doc) => doc.id)\n        } else {\n          options[collection] = []\n        }\n      } catch (err) {\n        req.payload.logger.error({\n          err,\n          msg: `Error validating filter options for collection ${collection}`,\n        })\n        options[collection] = []\n      }\n    }\n\n    const invalidRelationships = values.filter((val) => {\n      let collection: string\n      let requestedID: number | string\n\n      if (typeof relationTo === 'string') {\n        collection = relationTo\n\n        if (typeof val === 'string' || typeof val === 'number') {\n          requestedID = val\n        }\n\n        if (typeof val === 'object' && ObjectId.isValid(val)) {\n          requestedID = new ObjectId(val).toHexString()\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collection = val.relationTo\n        requestedID = val.value\n      }\n\n      if (falseCollections.find((slug) => relationTo === slug)) {\n        return true\n      }\n\n      if (!options[collection]) {\n        return true\n      }\n\n      return options[collection].indexOf(requestedID) === -1\n    })\n\n    if (invalidRelationships.length > 0) {\n      return invalidRelationships.reduce((err, invalid, i) => {\n        return `${err} ${JSON.stringify(invalid)}${\n          invalidRelationships.length === i + 1 ? ',' : ''\n        } `\n      }, t('validation:invalidSelections')) as string\n    }\n\n    return true\n  }\n\n  return true\n}\n\nexport type UploadFieldValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport type UploadFieldManyValidation = Validate<unknown[], unknown, unknown, UploadField>\n\nexport type UploadFieldSingleValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport const upload: UploadFieldValidation = async (value, options) => {\n  const {\n    event,\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  if (event === 'onChange') {\n    return true\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type RelationshipFieldValidation = Validate<\n  RelationshipValue,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldManyValidation = Validate<\n  RelationshipValueMany,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldSingleValidation = Validate<\n  RelationshipValueSingle,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport const relationship: RelationshipFieldValidation = async (value, options) => {\n  const {\n    event,\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  if (event === 'onChange') {\n    return true\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type SelectFieldValidation = Validate<string | string[], unknown, unknown, SelectField>\n\nexport type SelectFieldManyValidation = Validate<string[], unknown, unknown, SelectField>\n\nexport type SelectFieldSingleValidation = Validate<string, unknown, unknown, SelectField>\n\nexport const select: SelectFieldValidation = (\n  value,\n  { hasMany, options, req: { t }, required },\n) => {\n  if (\n    Array.isArray(value) &&\n    value.some(\n      (input) =>\n        !options.some(\n          (option) => option === input || (typeof option !== 'string' && option?.value === input),\n        ),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    typeof value === 'string' &&\n    !options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    required &&\n    (typeof value === 'undefined' ||\n      value === null ||\n      (hasMany && Array.isArray(value) && (value as [])?.length === 0))\n  ) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RadioFieldValidation = Validate<unknown, unknown, unknown, RadioField>\n\nexport const radio: RadioFieldValidation = (value, { options, req: { t }, required }) => {\n  if (value) {\n    const valueMatchesOption = options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n    return valueMatchesOption || t('validation:invalidSelection')\n  }\n\n  return required ? t('validation:required') : true\n}\n\nexport type PointFieldValidation = Validate<\n  [number | string, number | string],\n  unknown,\n  unknown,\n  PointField\n>\n\nexport const point: PointFieldValidation = (value = ['', ''], { req: { t }, required }) => {\n  const lng = parseFloat(String(value[0]))\n  const lat = parseFloat(String(value[1]))\n  if (\n    required &&\n    ((value[0] && value[1] && typeof lng !== 'number' && typeof lat !== 'number') ||\n      Number.isNaN(lng) ||\n      Number.isNaN(lat) ||\n      (Array.isArray(value) && value.length !== 2))\n  ) {\n    return t('validation:requiresTwoNumbers')\n  }\n\n  if ((value[1] && Number.isNaN(lng)) || (value[0] && Number.isNaN(lat))) {\n    return t('validation:invalidInput')\n  }\n\n  return true\n}\n\n/**\n * Built-in field validations used by Payload\n *\n * These can be re-used in custom validations\n */\nexport const validations = {\n  array,\n  blocks,\n  checkbox,\n  code,\n  confirmPassword,\n  date,\n  email,\n  json,\n  number,\n  password,\n  point,\n  radio,\n  relationship,\n  richText,\n  select,\n  text,\n  textarea,\n  upload,\n}\n"],"names":["Ajv","ObjectIdImport","ObjectId","default","isNumber","isValidID","text","value","hasMany","maxLength","fieldMaxLength","maxRows","minLength","minRows","req","payload","config","t","required","lengthValidationResult","validateArrayLength","defaultMaxTextLength","stringsToValidate","Array","isArray","stringValue","length","label","password","confirmPassword","siblingData","email","collectionSlug","collections","collection","find","slug","auth","loginWithUsername","requireUsername","requireEmail","username","test","textarea","code","undefined","json","jsonError","jsonSchema","isNotEmpty","Object","keys","fetchSchema","schema","uri","fetch","then","response","ok","Error","jsonSchemaSanitizations","id","$id","$schema","assign","ajv","validate","errorsText","error","message","checkbox","date","name","timezone","validDate","isNaN","Date","parse","toString","hasRequiredTimezone","selectedTimezone","validTimezone","Boolean","richText","options","editor","arrayLength","count","number","max","min","numbersToValidate","numberValue","parseFloat","array","blocks","validateFilterOptions","blockData","data","filterOptions","relationTo","user","falseCollections","values","optionFilter","valueIDs","forEach","val","push","isValid","toHexString","findWhere","and","in","result","depth","limit","pagination","where","docs","map","doc","err","logger","msg","invalidRelationships","filter","requestedID","indexOf","reduce","invalid","i","JSON","stringify","upload","event","idType","customIDType","db","defaultIDType","join","relationship","select","some","input","option","radio","valueMatchesOption","point","lng","String","lat","Number","validations"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1943, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1949, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/config/sanitizeJoinField.ts"],"sourcesContent":["import type { SanitizedJoin, SanitizedJoins } from '../../collections/config/types.js'\nimport type { Config } from '../../config/types.js'\nimport type { FlattenedJoinField, JoinField, RelationshipField, UploadField } from './types.js'\n\nimport { APIError } from '../../errors/index.js'\nimport { InvalidFieldJoin } from '../../errors/InvalidFieldJoin.js'\nimport { traverseFields } from '../../utilities/traverseFields.js'\nexport const sanitizeJoinField = ({\n  config,\n  field,\n  joinPath,\n  joins,\n}: {\n  config: Config\n  field: FlattenedJoinField | JoinField\n  joinPath?: string\n  joins?: SanitizedJoins\n}) => {\n  // the `joins` arg is not passed for globals or when recursing on fields that do not allow a join field\n  if (typeof joins === 'undefined') {\n    throw new APIError('Join fields cannot be added to arrays, blocks or globals.')\n  }\n  if (typeof field.maxDepth === 'undefined') {\n    field.maxDepth = 1\n  }\n  const join: SanitizedJoin = {\n    field,\n    joinPath: `${joinPath ? joinPath + '.' : ''}${field.name}`,\n    targetField: undefined,\n  }\n  const joinCollection = config.collections.find(\n    (collection) => collection.slug === field.collection,\n  )\n  if (!joinCollection) {\n    throw new InvalidFieldJoin(field)\n  }\n  let joinRelationship: RelationshipField | UploadField\n\n  const pathSegments = field.on.split('.') // Split the schema path into segments\n  let currentSegmentIndex = 0\n\n  let localized = false\n  // Traverse fields and match based on the schema path\n  traverseFields({\n    callback: ({ field, next }) => {\n      if (!('name' in field) || !field.name) {\n        return\n      }\n      const currentSegment = pathSegments[currentSegmentIndex]\n      // match field on path segments\n      if ('name' in field && field.name === currentSegment) {\n        if ('localized' in field && field.localized) {\n          localized = true\n          const fieldIndex = currentSegmentIndex\n\n          join.getForeignPath = ({ locale }) => {\n            return pathSegments.reduce((acc, segment, index) => {\n              let result = `${acc}${segment}`\n\n              if (index === fieldIndex) {\n                result = `${result}.${locale}`\n              }\n\n              if (index !== pathSegments.length - 1) {\n                result = `${result}.`\n              }\n\n              return result\n            }, '')\n          }\n        }\n\n        // Check if this is the last segment in the path\n        if (\n          (currentSegmentIndex === pathSegments.length - 1 &&\n            'type' in field &&\n            field.type === 'relationship') ||\n          field.type === 'upload'\n        ) {\n          joinRelationship = field // Return the matched field\n          next()\n          return true\n        } else {\n          // Move to the next path segment and continue traversal\n          currentSegmentIndex++\n        }\n      } else {\n        // skip fields in non-matching path segments\n        next()\n        return\n      }\n    },\n    fields: joinCollection.fields,\n  })\n\n  if (!joinRelationship) {\n    throw new InvalidFieldJoin(join.field)\n  }\n\n  join.targetField = joinRelationship\n\n  // override the join field localized property to use whatever the relationship field has\n  // or if it's nested to a localized array / blocks / tabs / group\n  field.localized = localized\n  // override the join field hasMany property to use whatever the relationship field has\n  field.hasMany = joinRelationship.hasMany\n\n  // @ts-expect-error converting JoinField to FlattenedJoinField to track targetField\n  field.targetField = join.targetField\n\n  if (!joins[field.collection]) {\n    joins[field.collection] = [join]\n  } else {\n    joins[field.collection].push(join)\n  }\n}\n"],"names":["APIError","InvalidFieldJoin","traverseFields","sanitizeJoinField","config","field","joinPath","joins","maxDepth","join","name","targetField","undefined","joinCollection","collections","find","collection","slug","joinRelationship","pathSegments","on","split","currentSegmentIndex","localized","callback","next","currentSegment","fieldIndex","getForeignPath","locale","reduce","acc","segment","index","result","length","type","fields","hasMany","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2042, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2048, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/baseFields/baseIDField.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { TextField } from '../config/types.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport const baseIDField: TextField = {\n  name: 'id',\n  type: 'text',\n  admin: {\n    hidden: true,\n  },\n  defaultValue: () => new ObjectId().toHexString(),\n  hooks: {\n    beforeChange: [({ value }) => value || new ObjectId().toHexString()],\n    beforeDuplicate: [() => new ObjectId().toHexString()],\n  },\n  label: 'ID',\n}\n"],"names":["ObjectIdImport","ObjectId","default","baseIDField","name","type","admin","hidden","defaultValue","toHexString","hooks","beforeChange","value","beforeDuplicate","label"],"mappings":";;;AAAA,OAAOA,oBAAoB,gBAAe;;AAI1C,MAAMC,uNAAYD,UAAAA,CAAeE,OAAO,gNACtCF,UAAAA;AAEK,MAAMG,cAAyB;IACpCC,MAAM;IACNC,MAAM;IACNC,OAAO;QACLC,QAAQ;IACV;IACAC,cAAc,IAAM,IAAIP,WAAWQ,WAAW;IAC9CC,OAAO;QACLC,cAAc;YAAC,CAAC,EAAEC,KAAK,EAAE,GAAKA,SAAS,IAAIX,WAAWQ,WAAW;SAAG;QACpEI,iBAAiB;YAAC,IAAM,IAAIZ,WAAWQ,WAAW;SAAG;IACvD;IACAK,OAAO;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2071, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2077, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/setDefaultBeforeDuplicate.ts"],"sourcesContent":["// default beforeDuplicate hook for required and unique fields\nimport type { FieldAffectingData, FieldHook } from './config/types.js'\n\nconst unique: FieldHook = ({ value }) => (typeof value === 'string' ? `${value} - Copy` : undefined)\nconst localizedUnique: FieldHook = ({ req, value }) =>\n  value ? `${value} - ${req?.t('general:copy') ?? 'Copy'}` : undefined\nconst uniqueRequired: FieldHook = ({ value }) => `${value} - Copy`\nconst localizedUniqueRequired: FieldHook = ({ req, value }) =>\n  `${value} - ${req?.t('general:copy') ?? 'Copy'}`\n\nexport const setDefaultBeforeDuplicate = (field: FieldAffectingData) => {\n  if (\n    (('required' in field && field.required) || field.unique) &&\n    (!field.hooks?.beforeDuplicate ||\n      (Array.isArray(field.hooks.beforeDuplicate) && field.hooks.beforeDuplicate.length === 0))\n  ) {\n    if ((field.type === 'text' || field.type === 'textarea') && field.required && field.unique) {\n      field.hooks.beforeDuplicate = [field.localized ? localizedUniqueRequired : uniqueRequired]\n    } else if (field.unique) {\n      field.hooks.beforeDuplicate = [field.localized ? localizedUnique : unique]\n    }\n  }\n}\n"],"names":["unique","value","undefined","localizedUnique","req","t","uniqueRequired","localizedUniqueRequired","setDefaultBeforeDuplicate","field","required","hooks","beforeDuplicate","Array","isArray","length","type","localized"],"mappings":"AAAA,8DAA8D;;;;AAG9D,MAAMA,SAAoB,CAAC,EAAEC,KAAK,EAAE,GAAM,OAAOA,UAAU,WAAW,GAAGA,MAAM,OAAO,CAAC,GAAGC;AAC1F,MAAMC,kBAA6B,CAAC,EAAEC,GAAG,EAAEH,KAAK,EAAE,GAChDA,QAAQ,GAAGA,MAAM,GAAG,EAAEG,KAAKC,EAAE,mBAAmB,QAAQ,GAAGH;AAC7D,MAAMI,iBAA4B,CAAC,EAAEL,KAAK,EAAE,GAAK,GAAGA,MAAM,OAAO,CAAC;AAClE,MAAMM,0BAAqC,CAAC,EAAEH,GAAG,EAAEH,KAAK,EAAE,GACxD,GAAGA,MAAM,GAAG,EAAEG,KAAKC,EAAE,mBAAmB,QAAQ;AAE3C,MAAMG,4BAA4B,CAACC;IACxC,IACG,CAAC,cAAcA,SAASA,MAAMC,QAAQ,IAAKD,MAAMT,MAAK,KACtD,CAAA,CAACS,MAAME,KAAK,EAAEC,mBACZC,MAAMC,OAAO,CAACL,MAAME,KAAK,CAACC,eAAe,KAAKH,MAAME,KAAK,CAACC,eAAe,CAACG,MAAM,KAAK,CAAC,GACzF;QACA,IAAKN,CAAAA,MAAMO,IAAI,KAAK,UAAUP,MAAMO,IAAI,KAAK,UAAS,KAAMP,MAAMC,QAAQ,IAAID,MAAMT,MAAM,EAAE;YAC1FS,MAAME,KAAK,CAACC,eAAe,GAAG;gBAACH,MAAMQ,SAAS,GAAGV,0BAA0BD;aAAe;QAC5F,OAAO,IAAIG,MAAMT,MAAM,EAAE;YACvBS,MAAME,KAAK,CAACC,eAAe,GAAG;gBAACH,MAAMQ,SAAS,GAAGd,kBAAkBH;aAAO;QAC5E;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2098, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2104, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/baseFields/baseBlockFields.ts"],"sourcesContent":["import type { Field } from '../config/types.js'\n\nimport { baseIDField } from './baseIDField.js'\n\nexport const baseBlockFields: Field[] = [\n  baseIDField,\n  {\n    name: 'blockName',\n    type: 'text',\n    admin: {\n      disabled: true,\n    },\n    label: 'Block Name',\n    required: false,\n  },\n]\n"],"names":["baseIDField","baseBlockFields","name","type","admin","disabled","label","required"],"mappings":";;;AAEA,SAASA,WAAW,QAAQ,mBAAkB;;AAEvC,MAAMC,kBAA2B;mYACtCD,cAAAA;IACA;QACEE,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,UAAU;QACZ;QACAC,OAAO;QACPC,UAAU;IACZ;CACD,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2121, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2127, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/baseFields/timezone/baseField.ts"],"sourcesContent":["import type { SelectField } from '../../config/types.js'\n\nexport const baseTimezoneField: (args: Partial<SelectField>) => SelectField = ({\n  name,\n  defaultValue,\n  options,\n  required,\n}) => {\n  return {\n    name,\n    type: 'select',\n    admin: {\n      hidden: true,\n    },\n    defaultValue,\n    options,\n    required,\n  }\n}\n"],"names":["baseTimezoneField","name","defaultValue","options","required","type","admin","hidden"],"mappings":";;;AAEO,MAAMA,oBAAiE,CAAC,EAC7EC,IAAI,EACJC,YAAY,EACZC,OAAO,EACPC,QAAQ,EACT;IACC,OAAO;QACLH;QACAI,MAAM;QACNC,OAAO;YACLC,QAAQ;QACV;QACAL;QACAC;QACAC;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2142, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2148, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/config/sanitize.ts"],"sourcesContent":["import { deepMergeSimple } from '@payloadcms/translations/utilities'\n\nimport type { CollectionConfig, SanitizedJoins } from '../../collections/config/types.js'\nimport type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { Field } from './types.js'\n\nimport {\n  DuplicateFieldName,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  MissingEditorProp,\n  MissingFieldType,\n} from '../../errors/index.js'\nimport { formatLabels, toWords } from '../../utilities/formatLabels.js'\nimport { baseBlockFields } from '../baseFields/baseBlockFields.js'\nimport { baseIDField } from '../baseFields/baseIDField.js'\nimport { baseTimezoneField } from '../baseFields/timezone/baseField.js'\nimport { defaultTimezones } from '../baseFields/timezone/defaultTimezones.js'\nimport { setDefaultBeforeDuplicate } from '../setDefaultBeforeDuplicate.js'\nimport { validations } from '../validations.js'\nimport { sanitizeJoinField } from './sanitizeJoinField.js'\nimport { fieldAffectsData, fieldIsLocalized, tabHasName } from './types.js'\n\ntype Args = {\n  collectionConfig?: CollectionConfig\n  config: Config\n  existingFieldNames?: Set<string>\n  fields: Field[]\n  joinPath?: string\n  /**\n   * When not passed in, assume that join are not supported (globals, arrays, blocks)\n   */\n  joins?: SanitizedJoins\n  parentIsLocalized: boolean\n\n  /**\n   * If true, a richText field will require an editor property to be set, as the sanitizeFields function will not add it from the payload config if not present.\n   *\n   * @default false\n   */\n  requireFieldLevelRichTextEditor?: boolean\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>\n  /**\n   * If not null, will validate that upload and relationship fields do not relate to a collection that is not in this array.\n   * This validation will be skipped if validRelationships is null.\n   */\n  validRelationships: null | string[]\n}\n\nexport const sanitizeFields = async ({\n  config,\n  existingFieldNames = new Set(),\n  fields,\n  joinPath = '',\n  joins,\n  parentIsLocalized,\n  requireFieldLevelRichTextEditor = false,\n  richTextSanitizationPromises,\n  validRelationships,\n}: Args): Promise<Field[]> => {\n  if (!fields) {\n    return []\n  }\n\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i]\n\n    if ('_sanitized' in field && field._sanitized === true) {\n      continue\n    }\n\n    if (!field.type) {\n      throw new MissingFieldType(field)\n    }\n\n    // assert that field names do not contain forbidden characters\n    if (fieldAffectsData(field) && field.name.includes('.')) {\n      throw new InvalidFieldName(field, field.name)\n    }\n\n    // Auto-label\n    if (\n      'name' in field &&\n      field.name &&\n      typeof field.label !== 'object' &&\n      typeof field.label !== 'string' &&\n      typeof field.label !== 'function' &&\n      field.label !== false\n    ) {\n      field.label = toWords(field.name)\n    }\n\n    if (\n      field.type === 'checkbox' &&\n      typeof field.defaultValue === 'undefined' &&\n      field.required === true\n    ) {\n      field.defaultValue = false\n    }\n\n    if (field.type === 'join') {\n      sanitizeJoinField({ config, field, joinPath, joins })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (validRelationships) {\n        const relationships = Array.isArray(field.relationTo)\n          ? field.relationTo\n          : [field.relationTo]\n        relationships.forEach((relationship: string) => {\n          if (!validRelationships.includes(relationship)) {\n            throw new InvalidFieldRelationship(field, relationship)\n          }\n        })\n      }\n\n      if (field.min && !field.minRows) {\n        console.warn(\n          `(payload): The \"min\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"minRows\" instead.`,\n        )\n        field.minRows = field.min\n      }\n      if (field.max && !field.maxRows) {\n        console.warn(\n          `(payload): The \"max\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"maxRows\" instead.`,\n        )\n        field.maxRows = field.max\n      }\n    }\n\n    if (field.type === 'upload') {\n      if (!field.admin || !('isSortable' in field.admin)) {\n        field.admin = {\n          isSortable: true,\n          ...field.admin,\n        }\n      }\n    }\n\n    if (field.type === 'array' && field.fields) {\n      field.fields.push(baseIDField)\n    }\n\n    if ((field.type === 'blocks' || field.type === 'array') && field.label) {\n      field.labels = field.labels || formatLabels(field.name)\n    }\n\n    if (fieldAffectsData(field)) {\n      if (existingFieldNames.has(field.name)) {\n        throw new DuplicateFieldName(field.name)\n      } else if (!['blockName', 'id'].includes(field.name)) {\n        existingFieldNames.add(field.name)\n      }\n\n      if (typeof field.localized !== 'undefined') {\n        let shouldDisableLocalized = !config.localization\n\n        if (!config.compatibility?.allowLocalizedWithinLocalized && parentIsLocalized) {\n          shouldDisableLocalized = true\n        }\n\n        if (shouldDisableLocalized) {\n          delete field.localized\n        }\n      }\n\n      if (typeof field.validate === 'undefined') {\n        const defaultValidate = validations[field.type]\n        if (defaultValidate) {\n          field.validate = (val, options) => defaultValidate(val, { ...field, ...options })\n        } else {\n          field.validate = (): true => true\n        }\n      }\n\n      if (!field.hooks) {\n        field.hooks = {}\n      }\n      if (!field.access) {\n        field.access = {}\n      }\n\n      setDefaultBeforeDuplicate(field)\n    }\n\n    if (!field.admin) {\n      field.admin = {}\n    }\n\n    // Make sure that the richText field has an editor\n    if (field.type === 'richText') {\n      const sanitizeRichText = async (_config: SanitizedConfig) => {\n        if (!field.editor) {\n          if (_config.editor && !requireFieldLevelRichTextEditor) {\n            // config.editor should be sanitized at this point\n            field.editor = _config.editor\n          } else {\n            throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n          }\n        }\n\n        if (typeof field.editor === 'function') {\n          field.editor = await field.editor({\n            config: _config,\n            isRoot: requireFieldLevelRichTextEditor,\n            parentIsLocalized: parentIsLocalized || field.localized,\n          })\n        }\n\n        if (field.editor.i18n && Object.keys(field.editor.i18n).length >= 0) {\n          config.i18n.translations = deepMergeSimple(config.i18n.translations, field.editor.i18n)\n        }\n      }\n      if (richTextSanitizationPromises) {\n        richTextSanitizationPromises.push(sanitizeRichText)\n      } else {\n        await sanitizeRichText(config as unknown as SanitizedConfig)\n      }\n    }\n\n    if (field.type === 'blocks' && field.blocks) {\n      for (const block of field.blocks) {\n        if (block._sanitized === true) {\n          continue\n        }\n        block._sanitized = true\n        block.fields = block.fields.concat(baseBlockFields)\n        block.labels = !block.labels ? formatLabels(block.slug) : block.labels\n        block.fields = await sanitizeFields({\n          config,\n          existingFieldNames: new Set(),\n          fields: block.fields,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n      }\n    }\n\n    if ('fields' in field && field.fields) {\n      field.fields = await sanitizeFields({\n        config,\n        existingFieldNames: fieldAffectsData(field) ? new Set() : existingFieldNames,\n        fields: field.fields,\n        joinPath: fieldAffectsData(field)\n          ? `${joinPath ? joinPath + '.' : ''}${field.name}`\n          : joinPath,\n        joins,\n        parentIsLocalized: parentIsLocalized || fieldIsLocalized(field),\n        requireFieldLevelRichTextEditor,\n        richTextSanitizationPromises,\n        validRelationships,\n      })\n    }\n\n    if (field.type === 'tabs') {\n      for (let j = 0; j < field.tabs.length; j++) {\n        const tab = field.tabs[j]\n        if (tabHasName(tab) && typeof tab.label === 'undefined') {\n          tab.label = toWords(tab.name)\n        }\n\n        tab.fields = await sanitizeFields({\n          config,\n          existingFieldNames: tabHasName(tab) ? new Set() : existingFieldNames,\n          fields: tab.fields,\n          joinPath: tabHasName(tab) ? `${joinPath ? joinPath + '.' : ''}${tab.name}` : joinPath,\n          joins,\n          parentIsLocalized: parentIsLocalized || (tabHasName(tab) && tab.localized),\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n        field.tabs[j] = tab\n      }\n    }\n\n    if (field.type === 'ui' && typeof field.admin.disableBulkEdit === 'undefined') {\n      field.admin.disableBulkEdit = true\n    }\n\n    if ('_sanitized' in field) {\n      field._sanitized = true\n    }\n\n    fields[i] = field\n\n    // Insert our field after assignment\n    if (field.type === 'date' && field.timezone) {\n      const name = field.name + '_tz'\n      const defaultTimezone = config.admin.timezones.defaultTimezone\n\n      const supportedTimezones = config.admin.timezones.supportedTimezones\n\n      const options =\n        typeof supportedTimezones === 'function'\n          ? supportedTimezones({ defaultTimezones })\n          : supportedTimezones\n\n      // Need to set the options here manually so that any database enums are generated correctly\n      // The UI component will import the options from the config\n      const timezoneField = baseTimezoneField({\n        name,\n        defaultValue: defaultTimezone,\n        options,\n        required: field.required,\n      })\n\n      fields.splice(++i, 0, timezoneField)\n    }\n  }\n\n  return fields\n}\n"],"names":["deepMergeSimple","DuplicateFieldName","InvalidFieldName","InvalidFieldRelationship","MissingEditorProp","MissingFieldType","formatLabels","toWords","baseBlockFields","baseIDField","baseTimezoneField","defaultTimezones","setDefaultBeforeDuplicate","validations","sanitizeJoinField","fieldAffectsData","fieldIsLocalized","tabHasName","sanitizeFields","config","existingFieldNames","Set","fields","joinPath","joins","parentIsLocalized","requireFieldLevelRichTextEditor","richTextSanitizationPromises","validRelationships","i","length","field","_sanitized","type","name","includes","label","defaultValue","required","relationships","Array","isArray","relationTo","forEach","relationship","min","minRows","console","warn","max","maxRows","admin","isSortable","push","labels","has","add","localized","shouldDisableLocalized","localization","compatibility","allowLocalizedWithinLocalized","validate","defaultValidate","val","options","hooks","access","sanitizeRichText","_config","editor","isRoot","i18n","Object","keys","translations","blocks","block","concat","slug","j","tabs","tab","disableBulkEdit","timezone","defaultTimezone","timezones","supportedTimezones","timezoneField","splice"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2392, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2398, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeDuplicate/runHook.ts"],"sourcesContent":["import type { FieldHookArgs } from '../../config/types.js'\n\nexport const runBeforeDuplicateHooks = async (args: FieldHookArgs) =>\n  await args.field.hooks.beforeDuplicate.reduce(async (priorHook, currentHook) => {\n    await priorHook\n    return await currentHook(args)\n  }, Promise.resolve())\n"],"names":["runBeforeDuplicateHooks","args","field","hooks","beforeDuplicate","reduce","priorHook","currentHook","Promise","resolve"],"mappings":";;;AAEO,MAAMA,0BAA0B,OAAOC,OAC5C,MAAMA,KAAKC,KAAK,CAACC,KAAK,CAACC,eAAe,CAACC,MAAM,CAAC,OAAOC,WAAWC;QAC9D,MAAMD;QACN,OAAO,MAAMC,YAAYN;IAC3B,GAAGO,QAAQC,OAAO,IAAG","ignoreList":[0]}},
    {"offset": {"line": 2405, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2411, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeDuplicate/promise.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, FieldHookArgs, TabAsField } from '../../config/types.js'\n\nimport { fieldAffectsData } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { runBeforeDuplicateHooks } from './runHook.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc: T\n  field: Field | TabAsField\n  fieldIndex: number\n  id?: number | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingDoc: JsonObject\n}\n\nexport const promise = async <T>({\n  id,\n  blockData,\n  collection,\n  context,\n  doc,\n  field,\n  fieldIndex,\n  overrideAccess,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const { localization } = req.payload.config\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    let fieldData = siblingDoc?.[field.name]\n    const fieldIsLocalized = field.localized && localization\n\n    // Run field beforeDuplicate hooks\n    if (Array.isArray(field.hooks?.beforeDuplicate)) {\n      if (fieldIsLocalized) {\n        const localeData = await localization.localeCodes.reduce(\n          async (localizedValuesPromise: Promise<JsonObject>, locale) => {\n            const localizedValues = await localizedValuesPromise\n\n            const beforeDuplicateArgs: FieldHookArgs = {\n              blockData,\n              collection,\n              context,\n              data: doc,\n              field,\n              global: undefined,\n              indexPath: indexPathSegments,\n              path: pathSegments,\n              previousSiblingDoc: siblingDoc,\n              previousValue: siblingDoc[field.name]?.[locale],\n              req,\n              schemaPath: schemaPathSegments,\n              siblingData: siblingDoc,\n              siblingDocWithLocales: siblingDoc,\n              value: siblingDoc[field.name]?.[locale],\n            }\n\n            const hookResult = await runBeforeDuplicateHooks(beforeDuplicateArgs)\n\n            if (typeof hookResult !== 'undefined') {\n              return {\n                ...localizedValues,\n                [locale]: hookResult,\n              }\n            }\n\n            return localizedValuesPromise\n          },\n          Promise.resolve({}),\n        )\n\n        siblingDoc[field.name] = localeData\n      } else {\n        const beforeDuplicateArgs: FieldHookArgs = {\n          blockData,\n          collection,\n          context,\n          data: doc,\n          field,\n          global: undefined,\n          indexPath: indexPathSegments,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData: siblingDoc,\n          siblingDocWithLocales: siblingDoc,\n          value: siblingDoc[field.name],\n        }\n\n        const hookResult = await runBeforeDuplicateHooks(beforeDuplicateArgs)\n        if (typeof hookResult !== 'undefined') {\n          siblingDoc[field.name] = hookResult\n        }\n      }\n    }\n\n    // First, for any localized fields, we will loop over locales\n    // and if locale data is present, traverse the sub fields.\n    // There are only a few different fields where this is possible.\n    if (fieldIsLocalized) {\n      if (typeof fieldData !== 'object' || fieldData === null) {\n        siblingDoc[field.name] = {}\n        fieldData = siblingDoc[field.name]\n      }\n\n      const promises = []\n\n      localization.localeCodes.forEach((locale) => {\n        if (fieldData[locale]) {\n          switch (field.type) {\n            case 'array': {\n              const rows = fieldData[locale]\n\n              if (Array.isArray(rows)) {\n                const promises = []\n\n                rows.forEach((row, rowIndex) => {\n                  promises.push(\n                    traverseFields({\n                      id,\n                      blockData,\n                      collection,\n                      context,\n                      doc,\n                      fields: field.fields,\n                      overrideAccess,\n                      parentIndexPath: '',\n                      parentPath: path + '.' + rowIndex,\n                      parentSchemaPath: schemaPath,\n                      req,\n                      siblingDoc: row,\n                    }),\n                  )\n                })\n              }\n\n              break\n            }\n\n            case 'blocks': {\n              const rows = fieldData[locale]\n\n              if (Array.isArray(rows)) {\n                const promises = []\n\n                rows.forEach((row, rowIndex) => {\n                  const blockTypeToMatch = row.blockType\n\n                  const block = field.blocks.find(\n                    (blockType) => blockType.slug === blockTypeToMatch,\n                  )\n\n                  promises.push(\n                    traverseFields({\n                      id,\n                      blockData: row,\n                      collection,\n                      context,\n                      doc,\n                      fields: block.fields,\n                      overrideAccess,\n                      parentIndexPath: '',\n                      parentPath: path + '.' + rowIndex,\n                      parentSchemaPath: schemaPath + '.' + block.slug,\n                      req,\n                      siblingDoc: row,\n                    }),\n                  )\n                })\n              }\n              break\n            }\n\n            case 'group':\n            case 'tab': {\n              promises.push(\n                traverseFields({\n                  id,\n                  blockData,\n                  collection,\n                  context,\n                  doc,\n                  fields: field.fields,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentPath: path,\n                  parentSchemaPath: schemaPath,\n                  req,\n                  siblingDoc: fieldData[locale],\n                }),\n              )\n\n              break\n            }\n          }\n        }\n      })\n\n      await Promise.all(promises)\n    } else {\n      // If the field is not localized, but it affects data,\n      // we need to further traverse its children\n      // so the child fields can run beforeDuplicate hooks\n      switch (field.type) {\n        case 'array': {\n          const rows = siblingDoc[field.name]\n\n          if (Array.isArray(rows)) {\n            const promises = []\n\n            rows.forEach((row, rowIndex) => {\n              promises.push(\n                traverseFields({\n                  id,\n                  blockData,\n                  collection,\n                  context,\n                  doc,\n                  fields: field.fields,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentPath: path + '.' + rowIndex,\n                  parentSchemaPath: schemaPath,\n                  req,\n                  siblingDoc: row,\n                }),\n              )\n            })\n\n            await Promise.all(promises)\n          }\n\n          break\n        }\n\n        case 'blocks': {\n          const rows = siblingDoc[field.name]\n\n          if (Array.isArray(rows)) {\n            const promises = []\n\n            rows.forEach((row, rowIndex) => {\n              const blockTypeToMatch = row.blockType\n              const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n              if (block) {\n                ;(row as JsonObject).blockType = blockTypeToMatch\n\n                promises.push(\n                  traverseFields({\n                    id,\n                    blockData: row,\n                    collection,\n                    context,\n                    doc,\n                    fields: block.fields,\n                    overrideAccess,\n                    parentIndexPath: '',\n                    parentPath: path + '.' + rowIndex,\n                    parentSchemaPath: schemaPath + '.' + block.slug,\n                    req,\n                    siblingDoc: row,\n                  }),\n                )\n              }\n            })\n\n            await Promise.all(promises)\n          }\n\n          break\n        }\n\n        case 'group': {\n          if (typeof siblingDoc[field.name] !== 'object') {\n            siblingDoc[field.name] = {}\n          }\n\n          const groupDoc = siblingDoc[field.name] as JsonObject\n\n          await traverseFields({\n            id,\n            blockData,\n            collection,\n            context,\n            doc,\n            fields: field.fields,\n            overrideAccess,\n            parentIndexPath: '',\n            parentPath: path,\n            parentSchemaPath: schemaPath,\n            req,\n            siblingDoc: groupDoc,\n          })\n\n          break\n        }\n\n        case 'tab': {\n          if (typeof siblingDoc[field.name] !== 'object') {\n            siblingDoc[field.name] = {}\n          }\n\n          const tabDoc = siblingDoc[field.name] as JsonObject\n\n          await traverseFields({\n            id,\n            blockData,\n            collection,\n            context,\n            doc,\n            fields: field.fields,\n            overrideAccess,\n            parentIndexPath: '',\n            parentPath: path,\n            parentSchemaPath: schemaPath,\n            req,\n            siblingDoc: tabDoc,\n          })\n\n          break\n        }\n      }\n    }\n  } else {\n    // Finally, we traverse fields which do not affect data here\n    switch (field.type) {\n      case 'collapsible':\n      case 'row': {\n        await traverseFields({\n          id,\n          blockData,\n          collection,\n          context,\n          doc,\n          fields: field.fields,\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          req,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      // Unnamed Tab\n      // @ts-expect-error `fieldAffectsData` inferred return type doesn't account for TabAsField\n      case 'tab': {\n        await traverseFields({\n          id,\n          blockData,\n          collection,\n          context,\n          doc,\n          // @ts-expect-error `fieldAffectsData` inferred return type doesn't account for TabAsField\n          fields: field.fields,\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          req,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      case 'tabs': {\n        await traverseFields({\n          id,\n          blockData,\n          collection,\n          context,\n          doc,\n          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          req,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n  }\n}\n"],"names":["fieldAffectsData","getFieldPathsModified","getFieldPaths","runBeforeDuplicateHooks","traverseFields","promise","id","blockData","collection","context","doc","field","fieldIndex","overrideAccess","parentIndexPath","parentPath","parentSchemaPath","req","siblingDoc","indexPath","path","schemaPath","index","localization","payload","config","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","fieldData","name","fieldIsLocalized","localized","Array","isArray","hooks","beforeDuplicate","localeData","localeCodes","reduce","localizedValuesPromise","locale","localizedValues","beforeDuplicateArgs","data","global","undefined","previousSiblingDoc","previousValue","siblingData","siblingDocWithLocales","value","hookResult","Promise","resolve","promises","forEach","type","rows","row","rowIndex","push","fields","blockTypeToMatch","blockType","block","blocks","find","slug","all","groupDoc","tabDoc","tabs","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2756, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2762, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeDuplicate/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args<T> = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc: T\n  fields: (Field | TabAsField)[]\n  id?: number | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async <T>({\n  id,\n  blockData,\n  collection,\n  context,\n  doc,\n  fields,\n  overrideAccess,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        id,\n        blockData,\n        collection,\n        context,\n        doc,\n        field,\n        fieldIndex,\n        overrideAccess,\n        parentIndexPath,\n        parentPath,\n        parentSchemaPath,\n        req,\n        siblingDoc,\n      }),\n    )\n  })\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","blockData","collection","context","doc","fields","overrideAccess","parentIndexPath","parentPath","parentSchemaPath","req","siblingDoc","promises","forEach","field","fieldIndex","push","Promise","all"],"mappings":";;;AAKA,SAASA,OAAO,QAAQ,eAAc;;AAoB/B,MAAMC,iBAAiB,OAAU,EACtCC,EAAE,EACFC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,GAAG,EACHC,MAAM,EACNC,cAAc,EACdC,eAAe,EACfC,UAAU,EACVC,gBAAgB,EAChBC,GAAG,EACHC,UAAU,EACF;IACR,MAAMC,WAAW,EAAE;IAEnBP,OAAOQ,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,8YACXlB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAU;YACAC;YACAT;YACAC;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IACA,MAAMM,QAAQC,GAAG,CAACN;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2788, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2794, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeDuplicate/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc?: T\n  id?: number | string\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for running beforeDuplicate hooks\n * against a document including all locale data.\n * It will run each field's beforeDuplicate hook\n * and return the resulting docWithLocales.\n */\nexport const beforeDuplicate = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  doc,\n  overrideAccess,\n  req,\n}: Args<T>): Promise<T> => {\n  await traverseFields({\n    id,\n    collection,\n    context,\n    doc,\n    fields: collection?.fields,\n    overrideAccess,\n    parentIndexPath: '',\n    parentPath: '',\n    parentSchemaPath: '',\n    req,\n    siblingDoc: doc,\n  })\n\n  return doc\n}\n"],"names":["traverseFields","beforeDuplicate","id","collection","context","doc","overrideAccess","req","fields","parentIndexPath","parentPath","parentSchemaPath","siblingDoc"],"mappings":";;;AAIA,SAASA,cAAc,QAAQ,sBAAqB;;AAiB7C,MAAMC,kBAAkB,OAA6B,EAC1DC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,GAAG,EACHC,cAAc,EACdC,GAAG,EACK;IACR,0ZAAMP,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC;QACAG,QAAQL,YAAYK;QACpBF;QACAG,iBAAiB;QACjBC,YAAY;QACZC,kBAAkB;QAClBJ;QACAK,YAAYP;IACd;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2815, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2821, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeChange/cloneDataFromOriginalDoc.ts"],"sourcesContent":["import type { JsonArray, JsonObject } from '../../../types/index.js'\n\nexport const cloneDataFromOriginalDoc = (\n  originalDocData: JsonArray | JsonObject,\n): JsonArray | JsonObject => {\n  if (Array.isArray(originalDocData)) {\n    return originalDocData.map((row) => {\n      if (typeof row === 'object' && row != null) {\n        return {\n          ...row,\n        }\n      }\n\n      return row\n    })\n  }\n\n  if (typeof originalDocData === 'object' && originalDocData !== null) {\n    return { ...originalDocData }\n  }\n\n  return originalDocData\n}\n"],"names":["cloneDataFromOriginalDoc","originalDocData","Array","isArray","map","row"],"mappings":";;;AAEO,MAAMA,2BAA2B,CACtCC;IAEA,IAAIC,MAAMC,OAAO,CAACF,kBAAkB;QAClC,OAAOA,gBAAgBG,GAAG,CAAC,CAACC;YAC1B,IAAI,OAAOA,QAAQ,YAAYA,OAAO,MAAM;gBAC1C,OAAO;oBACL,GAAGA,GAAG;gBACR;YACF;YAEA,OAAOA;QACT;IACF;IAEA,IAAI,OAAOJ,oBAAoB,YAAYA,oBAAoB,MAAM;QACnE,OAAO;YAAE,GAAGA,eAAe;QAAC;IAC9B;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2842, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2848, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeChange/getExistingRowDoc.ts"],"sourcesContent":["/**\n * If there is an incoming row id,\n * and it matches the existing sibling doc id,\n * this is an existing row, so it should be merged.\n * Otherwise, return an empty object.\n */\nimport type { JsonObject } from '../../../types/index.js'\n\nexport const getExistingRowDoc = (incomingRow: JsonObject, existingRows?: unknown): JsonObject => {\n  if (incomingRow.id && Array.isArray(existingRows)) {\n    const matchedExistingRow = existingRows.find((existingRow) => {\n      if (typeof existingRow === 'object' && 'id' in existingRow) {\n        if (existingRow.id === incomingRow.id) {\n          return existingRow\n        }\n      }\n\n      return false\n    })\n\n    if (matchedExistingRow) {\n      return matchedExistingRow\n    }\n  }\n\n  return {}\n}\n"],"names":["getExistingRowDoc","incomingRow","existingRows","id","Array","isArray","matchedExistingRow","find","existingRow"],"mappings":"AAAA;;;;;CAKC,GAGD;;;AAAO,MAAMA,oBAAoB,CAACC,aAAyBC;IACzD,IAAID,YAAYE,EAAE,IAAIC,MAAMC,OAAO,CAACH,eAAe;QACjD,MAAMI,qBAAqBJ,aAAaK,IAAI,CAAC,CAACC;YAC5C,IAAI,OAAOA,gBAAgB,YAAY,QAAQA,aAAa;gBAC1D,IAAIA,YAAYL,EAAE,KAAKF,YAAYE,EAAE,EAAE;oBACrC,OAAOK;gBACT;YACF;YAEA,OAAO;QACT;QAEA,IAAIF,oBAAoB;YACtB,OAAOA;QACT;IACF;IAEA,OAAO,CAAC;AACV,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2872, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2878, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeValidate/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, JsonValue, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName, valueIsValueWithRelation } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { cloneDataFromOriginalDoc } from '../beforeChange/cloneDataFromOriginalDoc.js'\nimport { getExistingRowDoc } from '../beforeChange/getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: T\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n}\n\n// This function is responsible for the following actions, in order:\n// - Sanitize incoming data\n// - Execute field hooks\n// - Execute field access control\n// - Merge original document data into incoming data\n// - Compute default values for undefined fields\n\nexport const promise = async <T>({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  fieldIndex,\n  global,\n  operation,\n  overrideAccess,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    if (field.name === 'id') {\n      if (field.type === 'number' && typeof siblingData[field.name] === 'string') {\n        const value = siblingData[field.name] as string\n\n        siblingData[field.name] = parseFloat(value)\n      }\n\n      if (\n        field.type === 'text' &&\n        typeof siblingData[field.name]?.toString === 'function' &&\n        typeof siblingData[field.name] !== 'string'\n      ) {\n        siblingData[field.name] = siblingData[field.name].toString()\n      }\n    }\n\n    // Sanitize incoming data\n    switch (field.type) {\n      case 'array':\n      case 'blocks': {\n        // Handle cases of arrays being intentionally set to 0\n        if (siblingData[field.name] === '0' || siblingData[field.name] === 0) {\n          siblingData[field.name] = []\n        }\n\n        break\n      }\n\n      case 'checkbox': {\n        if (siblingData[field.name] === 'true') {\n          siblingData[field.name] = true\n        }\n        if (siblingData[field.name] === 'false') {\n          siblingData[field.name] = false\n        }\n        if (siblingData[field.name] === '') {\n          siblingData[field.name] = false\n        }\n\n        break\n      }\n\n      case 'number': {\n        if (typeof siblingData[field.name] === 'string') {\n          const value = siblingData[field.name] as string\n          const trimmed = value.trim()\n          siblingData[field.name] = trimmed.length === 0 ? null : parseFloat(trimmed)\n        }\n\n        break\n      }\n\n      case 'point': {\n        if (Array.isArray(siblingData[field.name])) {\n          siblingData[field.name] = (siblingData[field.name] as string[]).map((coordinate, i) => {\n            if (typeof coordinate === 'string') {\n              const value = siblingData[field.name][i] as string\n              const trimmed = value.trim()\n              return trimmed.length === 0 ? null : parseFloat(trimmed)\n            }\n            return coordinate\n          })\n        }\n\n        break\n      }\n      case 'relationship':\n      case 'upload': {\n        if (\n          siblingData[field.name] === '' ||\n          siblingData[field.name] === 'none' ||\n          siblingData[field.name] === 'null' ||\n          siblingData[field.name] === null\n        ) {\n          if (field.hasMany === true) {\n            siblingData[field.name] = []\n          } else {\n            siblingData[field.name] = null\n          }\n        }\n\n        const value = siblingData[field.name]\n\n        if (Array.isArray(field.relationTo)) {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: { relationTo: string; value: JsonValue }, i) => {\n              const relatedCollection = req.payload.collections?.[relatedDoc.relationTo]?.config\n\n              if (\n                typeof relatedDoc.value === 'object' &&\n                relatedDoc.value &&\n                'id' in relatedDoc.value\n              ) {\n                relatedDoc.value = relatedDoc.value.id\n              }\n\n              if (relatedCollection?.fields) {\n                const relationshipIDField = relatedCollection.fields.find(\n                  (collectionField) =>\n                    fieldAffectsData(collectionField) && collectionField.name === 'id',\n                )\n                if (relationshipIDField?.type === 'number') {\n                  siblingData[field.name][i] = {\n                    ...relatedDoc,\n                    value: parseFloat(relatedDoc.value as string),\n                  }\n                }\n              }\n            })\n          }\n          if (field.hasMany !== true && valueIsValueWithRelation(value)) {\n            const relatedCollection = req.payload.collections?.[value.relationTo]?.config\n\n            if (typeof value.value === 'object' && value.value && 'id' in value.value) {\n              value.value = (value.value as TypeWithID).id\n            }\n\n            if (relatedCollection?.fields) {\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name] = { ...value, value: parseFloat(value.value as string) }\n              }\n            }\n          }\n        } else {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: unknown, i) => {\n              const relatedCollection = Array.isArray(field.relationTo)\n                ? undefined\n                : req.payload.collections?.[field.relationTo]?.config\n\n              if (typeof relatedDoc === 'object' && relatedDoc && 'id' in relatedDoc) {\n                value[i] = relatedDoc.id\n              }\n\n              if (relatedCollection?.fields) {\n                const relationshipIDField = relatedCollection.fields.find(\n                  (collectionField) =>\n                    fieldAffectsData(collectionField) && collectionField.name === 'id',\n                )\n                if (relationshipIDField?.type === 'number') {\n                  siblingData[field.name][i] = parseFloat(relatedDoc as string)\n                }\n              }\n            })\n          }\n          if (field.hasMany !== true && value) {\n            const relatedCollection = req.payload.collections?.[field.relationTo]?.config\n\n            if (typeof value === 'object' && value && 'id' in value) {\n              siblingData[field.name] = value.id\n            }\n\n            if (relatedCollection?.fields) {\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name] = parseFloat(value as string)\n              }\n            }\n          }\n        }\n        break\n      }\n      case 'richText': {\n        if (typeof siblingData[field.name] === 'string') {\n          try {\n            const richTextJSON = JSON.parse(siblingData[field.name] as string)\n            siblingData[field.name] = richTextJSON\n          } catch {\n            // Disregard this data as it is not valid.\n            // Will be reported to user by field validation\n          }\n        }\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeValidate) {\n      await field.hooks.beforeValidate.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          overrideAccess,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n\n    // Execute access control\n    if (field.access && field.access[operation]) {\n      const result = overrideAccess\n        ? true\n        : await field.access[operation]({ id, blockData, data, doc, req, siblingData })\n\n      if (!result) {\n        delete siblingData[field.name]\n      }\n    }\n\n    if (typeof siblingData[field.name] === 'undefined') {\n      // If no incoming data, but existing document data is found, merge it in\n      if (typeof siblingDoc[field.name] !== 'undefined') {\n        siblingData[field.name] = cloneDataFromOriginalDoc(siblingDoc[field.name])\n\n        // Otherwise compute default value\n      } else if (typeof field.defaultValue !== 'undefined') {\n        siblingData[field.name] = await getDefaultValue({\n          defaultValue: field.defaultValue,\n          locale: req.locale,\n          req,\n          user: req.user,\n          value: siblingData[field.name],\n        })\n      }\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              id,\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              overrideAccess,\n              parentIndexPath: '',\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              req,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n          const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n          if (block) {\n            ;(row as JsonObject).blockType = blockTypeToMatch\n\n            promises.push(\n              traverseFields({\n                id,\n                blockData: row,\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                overrideAccess,\n                parentIndexPath: '',\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                req,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') {\n        siblingData[field.name] = {}\n      }\n\n      if (typeof siblingDoc[field.name] !== 'object') {\n        siblingDoc[field.name] = {}\n      }\n\n      const groupData = siblingData[field.name] as Record<string, unknown>\n      const groupDoc = siblingDoc[field.name] as Record<string, unknown>\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: '',\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: groupData as JsonObject,\n        siblingDoc: groupDoc as JsonObject,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeValidate?.length) {\n        await editor.hooks.beforeValidate.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            indexPath: indexPathSegments,\n            operation,\n            originalDoc: doc,\n            overrideAccess,\n            path: pathSegments,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingData[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData\n      let tabSiblingDoc\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as Record<string, unknown>\n        tabSiblingDoc = siblingDoc[field.name] as Record<string, unknown>\n      } else {\n        tabSiblingData = siblingData\n        tabSiblingDoc = siblingDoc\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","valueIsValueWithRelation","getDefaultValue","getFieldPathsModified","getFieldPaths","cloneDataFromOriginalDoc","getExistingRowDoc","traverseFields","promise","id","blockData","collection","context","data","doc","field","fieldIndex","global","operation","overrideAccess","parentIndexPath","parentPath","parentSchemaPath","req","siblingData","siblingDoc","indexPath","path","schemaPath","index","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","name","type","value","parseFloat","toString","trimmed","trim","length","Array","isArray","coordinate","i","hasMany","relationTo","forEach","relatedDoc","relatedCollection","payload","collections","config","fields","relationshipIDField","find","collectionField","undefined","richTextJSON","JSON","parse","hooks","beforeValidate","reduce","priorHook","currentHook","hookedValue","originalDoc","previousSiblingDoc","previousValue","Promise","resolve","access","result","defaultValue","locale","user","rows","promises","row","rowIndex","push","all","rowSiblingDoc","blockTypeToMatch","blockType","block","blocks","slug","groupData","groupDoc","editor","Error","tabSiblingData","tabSiblingDoc","isNamedTab","tabs","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3340, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3346, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeValidate/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args<T> = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: T\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async <T>({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  fields,\n  global,\n  operation,\n  overrideAccess,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        field,\n        fieldIndex,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath,\n        parentPath,\n        parentSchemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n      }),\n    )\n  })\n\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","blockData","collection","context","data","doc","fields","global","operation","overrideAccess","parentIndexPath","parentPath","parentSchemaPath","req","siblingData","siblingDoc","promises","forEach","field","fieldIndex","push","Promise","all"],"mappings":";;;AAMA,SAASA,OAAO,QAAQ,eAAc;;AA8B/B,MAAMC,iBAAiB,OAAU,EACtCC,EAAE,EACFC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,eAAe,EACfC,UAAU,EACVC,gBAAgB,EAChBC,GAAG,EACHC,WAAW,EACXC,UAAU,EACF;IACR,MAAMC,WAAW,EAAE;IAEnBV,OAAOW,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,6YACXtB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAa;YACAC;YACAZ;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,MAAMM,QAAQC,GAAG,CAACN;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3376, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3382, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeValidate/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\n\nimport { type RequestContext } from '../../../index.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  doc?: T\n  duplicate?: boolean\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Sanitize incoming data\n * - Execute field hooks\n * - Execute field access control\n * - Merge original document data into incoming data\n * - Compute default values for undefined fields\n */\nexport const beforeValidate = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  data: incomingData,\n  doc,\n  global,\n  operation,\n  overrideAccess,\n  req,\n}: Args<T>): Promise<T> => {\n  await traverseFields({\n    id,\n    collection,\n    context,\n    data: incomingData,\n    doc,\n    fields: collection?.fields || global?.fields,\n    global,\n    operation,\n    overrideAccess,\n    parentIndexPath: '',\n    parentPath: '',\n    parentSchemaPath: '',\n    req,\n    siblingData: incomingData,\n    siblingDoc: doc,\n  })\n\n  return incomingData\n}\n"],"names":["traverseFields","beforeValidate","id","collection","context","data","incomingData","doc","global","operation","overrideAccess","req","fields","parentIndexPath","parentPath","parentSchemaPath","siblingData","siblingDoc"],"mappings":";;;AAKA,SAASA,cAAc,QAAQ,sBAAqB;;AAuB7C,MAAMC,iBAAiB,OAA6B,EACzDC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,MAAMC,YAAY,EAClBC,GAAG,EACHC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,GAAG,EACK;IACR,yZAAMX,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC,MAAMC;QACNC;QACAK,QAAQT,YAAYS,UAAUJ,QAAQI;QACtCJ;QACAC;QACAC;QACAG,iBAAiB;QACjBC,YAAY;QACZC,kBAAkB;QAClBJ;QACAK,aAAaV;QACbW,YAAYV;IACd;IAEA,OAAOD;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3407, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3413, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeChange/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField, Validate } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { deepMergeWithSourceArrays } from '../../../utilities/deepMerge.js'\nimport { getLabelFromPath } from '../../../utilities/getLabelFromPath.js'\nimport { getTranslatedLabel } from '../../../utilities/getTranslatedLabel.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { getExistingRowDoc } from './getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  docWithLocales: JsonObject\n  errors: ValidationFieldError[]\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void>)[]\n  operation: Operation\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingDocWithLocales?: JsonObject\n  skipValidation: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Run condition\n// - Execute field hooks\n// - Validate data\n// - Transform data for storage\n// - beforeDuplicate hooks (if duplicate)\n// - Unflatten locales\n\nexport const promise = async ({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  field,\n  fieldIndex,\n  global,\n  mergeLocaleActions,\n  operation,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  skipValidation,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const passesCondition = field.admin?.condition\n    ? Boolean(field.admin.condition(data, siblingData, { blockData, user: req.user }))\n    : true\n  let skipValidationFromHere = skipValidation || !passesCondition\n  const { localization } = req.payload.config\n  const defaultLocale = localization ? localization?.defaultLocale : 'en'\n  const operationLocale = req.locale || defaultLocale\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    // skip validation if the field is localized and the incoming data is null\n    if (field.localized && operationLocale !== defaultLocale) {\n      if (['array', 'blocks'].includes(field.type) && siblingData[field.name] === null) {\n        skipValidationFromHere = true\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeChange) {\n      await field.hooks.beforeChange.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          siblingDocWithLocales,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n\n    // Validate\n    if (!skipValidationFromHere && 'validate' in field && field.validate) {\n      const valueToValidate = siblingData[field.name]\n      let jsonError: object\n\n      if (field.type === 'json' && typeof siblingData[field.name] === 'string') {\n        try {\n          JSON.parse(siblingData[field.name] as string)\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      const validateFn: Validate<object, object, object, object> = field.validate as Validate<\n        object,\n        object,\n        object,\n        object\n      >\n      const validationResult = await validateFn(valueToValidate as never, {\n        ...field,\n        id,\n        blockData,\n        collectionSlug: collection?.slug,\n        data: deepMergeWithSourceArrays(doc, data),\n        event: 'submit',\n        // @ts-expect-error\n        jsonError,\n        operation,\n        preferences: { fields: {} },\n        previousValue: siblingDoc[field.name],\n        req,\n        siblingData: deepMergeWithSourceArrays(siblingDoc, siblingData),\n      })\n\n      if (typeof validationResult === 'string') {\n        const label = getTranslatedLabel(field?.label || field?.name, req.i18n)\n        const parentPathSegments = parentPath ? parentPath.split('.') : []\n\n        const fieldLabel =\n          Array.isArray(parentPathSegments) && parentPathSegments.length > 0\n            ? getLabelFromPath(parentPathSegments.concat(label))\n            : label\n\n        errors.push({\n          label: fieldLabel,\n          message: validationResult,\n          path,\n        })\n      }\n    }\n\n    // Push merge locale action if applicable\n    if (localization && field.localized) {\n      mergeLocaleActions.push(async () => {\n        const localeData = await localization.localeCodes.reduce(\n          async (localizedValuesPromise: Promise<JsonObject>, locale) => {\n            const localizedValues = await localizedValuesPromise\n            const fieldValue =\n              locale === req.locale\n                ? siblingData[field.name]\n                : siblingDocWithLocales?.[field.name]?.[locale]\n\n            // const result = await localizedValues\n            // update locale value if it's not undefined\n            if (typeof fieldValue !== 'undefined') {\n              return {\n                ...localizedValues,\n                [locale]: fieldValue,\n              }\n            }\n\n            return localizedValuesPromise\n          },\n          Promise.resolve({}),\n        )\n\n        // If there are locales with data, set the data\n        if (Object.keys(localeData).length > 0) {\n          siblingData[field.name] = localeData\n        }\n      })\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              id,\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              docWithLocales,\n              errors,\n              fields: field.fields,\n              global,\n              mergeLocaleActions,\n              operation,\n              parentIndexPath: '',\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              req,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n              siblingDocWithLocales: getExistingRowDoc(\n                row as JsonObject,\n                siblingDocWithLocales[field.name],\n              ),\n              skipValidation: skipValidationFromHere,\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n\n          const rowSiblingDocWithLocales = getExistingRowDoc(\n            row as JsonObject,\n            siblingDocWithLocales ? siblingDocWithLocales[field.name] : {},\n          )\n\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n          const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                id,\n                blockData: row,\n                collection,\n                context,\n                data,\n                doc,\n                docWithLocales,\n                errors,\n                fields: block.fields,\n                global,\n                mergeLocaleActions,\n                operation,\n                parentIndexPath: '',\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                req,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n                siblingDocWithLocales: rowSiblingDocWithLocales,\n                skipValidation: skipValidationFromHere,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: indexPath,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') {\n        siblingData[field.name] = {}\n      }\n\n      if (typeof siblingDoc[field.name] !== 'object') {\n        siblingDoc[field.name] = {}\n      }\n\n      if (typeof siblingDocWithLocales[field.name] !== 'object') {\n        siblingDocWithLocales[field.name] = {}\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: '',\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: siblingData[field.name] as JsonObject,\n        siblingDoc: siblingDoc[field.name] as JsonObject,\n        siblingDocWithLocales: siblingDocWithLocales[field.name] as JsonObject,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'point': {\n      // Transform point data for storage\n      if (\n        Array.isArray(siblingData[field.name]) &&\n        siblingData[field.name][0] !== null &&\n        siblingData[field.name][1] !== null\n      ) {\n        siblingData[field.name] = {\n          type: 'Point',\n          coordinates: [\n            parseFloat(siblingData[field.name][0]),\n            parseFloat(siblingData[field.name][1]),\n          ],\n        }\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeChange?.length) {\n        await editor.hooks.beforeChange.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            docWithLocales,\n            errors,\n            field,\n            global,\n            indexPath: indexPathSegments,\n            mergeLocaleActions,\n            operation,\n            originalDoc: doc,\n            path: pathSegments,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingDoc[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            siblingDocWithLocales,\n            skipValidation,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabSiblingDocWithLocales = siblingDocWithLocales\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        if (typeof siblingDocWithLocales[field.name] !== 'object') {\n          siblingDocWithLocales[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as JsonObject\n        tabSiblingDoc = siblingDoc[field.name] as JsonObject\n        tabSiblingDocWithLocales = siblingDocWithLocales[field.name] as JsonObject\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n        siblingDocWithLocales: tabSiblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: indexPath,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","deepMergeWithSourceArrays","getLabelFromPath","getTranslatedLabel","fieldAffectsData","tabHasName","getFieldPathsModified","getFieldPaths","getExistingRowDoc","traverseFields","promise","id","blockData","collection","context","data","doc","docWithLocales","errors","field","fieldIndex","global","mergeLocaleActions","operation","parentIndexPath","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingDocWithLocales","skipValidation","indexPath","path","schemaPath","index","passesCondition","admin","condition","Boolean","user","skipValidationFromHere","localization","payload","config","defaultLocale","operationLocale","locale","pathSegments","split","schemaPathSegments","indexPathSegments","filter","map","Number","localized","includes","type","name","hooks","beforeChange","reduce","priorHook","currentHook","hookedValue","originalDoc","previousSiblingDoc","previousValue","value","undefined","Promise","resolve","validate","valueToValidate","jsonError","JSON","parse","e","validateFn","validationResult","collectionSlug","slug","event","preferences","fields","label","i18n","parentPathSegments","fieldLabel","Array","isArray","length","concat","push","message","localeData","localeCodes","localizedValuesPromise","localizedValues","fieldValue","Object","keys","rows","promises","forEach","row","rowIndex","all","rowSiblingDoc","rowSiblingDocWithLocales","blockTypeToMatch","blockType","block","blocks","find","coordinates","parseFloat","editor","Error","tabSiblingData","tabSiblingDoc","tabSiblingDocWithLocales","isNamedTab","tabs","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3822, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3828, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeChange/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: JsonObject\n  /**\n   * The original data with locales (not modified by any hooks)\n   */\n  docWithLocales: JsonObject\n  errors: ValidationFieldError[]\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void>)[]\n  operation: Operation\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n  /**\n   * The original siblingData with locales (not modified by any hooks)\n   */\n  siblingDocWithLocales: JsonObject\n  skipValidation?: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Run condition\n * - Execute field hooks\n * - Validate data\n * - Transform data for storage\n * - Unflatten locales. The input `data` is the normal document for one locale. The output result will become the document with locales.\n */\nexport const traverseFields = async ({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  fields,\n  global,\n  mergeLocaleActions,\n  operation,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  skipValidation,\n}: Args): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        field,\n        fieldIndex,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath,\n        parentPath,\n        parentSchemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation,\n      }),\n    )\n  })\n\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","blockData","collection","context","data","doc","docWithLocales","errors","fields","global","mergeLocaleActions","operation","parentIndexPath","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingDocWithLocales","skipValidation","promises","forEach","field","fieldIndex","push","Promise","all"],"mappings":";;;AAOA,SAASA,OAAO,QAAQ,eAAc;;AAgD/B,MAAMC,iBAAiB,OAAO,EACnCC,EAAE,EACFC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,cAAc,EACdC,MAAM,EACNC,MAAM,EACNC,MAAM,EACNC,kBAAkB,EAClBC,SAAS,EACTC,eAAe,EACfC,UAAU,EACVC,gBAAgB,EAChBC,GAAG,EACHC,WAAW,EACXC,UAAU,EACVC,qBAAqB,EACrBC,cAAc,EACT;IACL,MAAMC,WAAW,EAAE;IAEnBZ,OAAOa,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,2YACX1B,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAe;YACAC;YACAd;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,MAAMM,QAAQC,GAAG,CAACN;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3862, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3868, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeChange/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\n\nimport { ValidationError } from '../../../errors/index.js'\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\nexport type Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  doc: T\n  docWithLocales: JsonObject\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: Operation\n  req: PayloadRequest\n  skipValidation?: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Run condition\n * - Execute field hooks\n * - Validate data\n * - Transform data for storage\n * - Unflatten locales. The input `data` is the normal document for one locale. The output result will become the document with locales.\n */\n\nexport const beforeChange = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  data: incomingData,\n  doc,\n  docWithLocales,\n  global,\n  operation,\n  req,\n  skipValidation,\n}: Args<T>): Promise<T> => {\n  const data = deepCopyObjectSimple(incomingData)\n  const mergeLocaleActions = []\n  const errors: ValidationFieldError[] = []\n\n  await traverseFields({\n    id,\n    collection,\n    context,\n    data,\n    doc,\n    docWithLocales,\n    errors,\n    fields: collection?.fields || global?.fields,\n    global,\n    mergeLocaleActions,\n    operation,\n    parentIndexPath: '',\n    parentPath: '',\n    parentSchemaPath: '',\n    req,\n    siblingData: data,\n    siblingDoc: doc,\n    siblingDocWithLocales: docWithLocales,\n    skipValidation,\n  })\n\n  if (errors.length > 0) {\n    throw new ValidationError(\n      {\n        id,\n        collection: collection?.slug,\n        errors,\n        global: global?.slug,\n      },\n      req.t,\n    )\n  }\n\n  await mergeLocaleActions.reduce(async (priorAction, action) => {\n    await priorAction\n    await action()\n  }, Promise.resolve())\n\n  return data\n}\n"],"names":["ValidationError","deepCopyObjectSimple","traverseFields","beforeChange","id","collection","context","data","incomingData","doc","docWithLocales","global","operation","req","skipValidation","mergeLocaleActions","errors","fields","parentIndexPath","parentPath","parentSchemaPath","siblingData","siblingDoc","siblingDocWithLocales","length","slug","t","reduce","priorAction","action","Promise","resolve"],"mappings":";;;AAOA,SAASC,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;AAFpD,SAASF,eAAe,QAAQ,2BAA0B;;;;AAyBnD,MAAMG,eAAe,OAA6B,EACvDC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,MAAMC,YAAY,EAClBC,GAAG,EACHC,cAAc,EACdC,MAAM,EACNC,SAAS,EACTC,GAAG,EACHC,cAAc,EACN;IACR,MAAMP,kYAAON,uBAAAA,EAAqBO;IAClC,MAAMO,qBAAqB,EAAE;IAC7B,MAAMC,SAAiC,EAAE;IAEzC,uZAAMd,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC;QACAE;QACAC;QACAM;QACAC,QAAQZ,YAAYY,UAAUN,QAAQM;QACtCN;QACAI;QACAH;QACAM,iBAAiB;QACjBC,YAAY;QACZC,kBAAkB;QAClBP;QACAQ,aAAad;QACbe,YAAYb;QACZc,uBAAuBb;QACvBI;IACF;IAEA,IAAIE,OAAOQ,MAAM,GAAG,GAAG;QACrB,MAAM,yXAAIxB,kBAAAA,CACR;YACEI;YACAC,YAAYA,YAAYoB;YACxBT;YACAL,QAAQA,QAAQc;QAClB,GACAZ,IAAIa,CAAC;IAET;IAEA,MAAMX,mBAAmBY,MAAM,CAAC,OAAOC,aAAaC;QAClD,MAAMD;QACN,MAAMC;IACR,GAAGC,QAAQC,OAAO;IAElB,OAAOxB;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3916, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3922, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterChange/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n  previousDoc: JsonObject\n  previousSiblingDoc: JsonObject\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n}\n\n// This function is responsible for the following actions, in order:\n// - Execute field hooks\n\nexport const promise = async ({\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  fieldIndex,\n  global,\n  operation,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (field.hooks?.afterChange) {\n      await field.hooks.afterChange.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          path: pathSegments,\n          previousDoc,\n          previousSiblingDoc,\n          previousValue: previousDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          value: siblingDoc[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingDoc[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              parentIndexPath: '',\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              previousDoc,\n              previousSiblingDoc: previousDoc?.[field.name]?.[rowIndex] || ({} as JsonObject),\n              req,\n              siblingData: siblingData?.[field.name]?.[rowIndex] || {},\n              siblingDoc: row ? { ...row } : {},\n            }),\n          )\n        })\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          const block = field.blocks.find(\n            (blockType) => blockType.slug === (row as JsonObject).blockType,\n          )\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                blockData: siblingData?.[field.name]?.[rowIndex],\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                parentIndexPath: '',\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                previousDoc,\n                previousSiblingDoc: previousDoc?.[field.name]?.[rowIndex] || ({} as JsonObject),\n                req,\n                siblingData: siblingData?.[field.name]?.[rowIndex] || {},\n                siblingDoc: row ? { ...row } : {},\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        parentIndexPath: indexPath,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n\n    case 'group': {\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        parentIndexPath: '',\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: previousDoc[field.name] as JsonObject,\n        req,\n        siblingData: (siblingData?.[field.name] as JsonObject) || {},\n        siblingDoc: siblingDoc[field.name] as JsonObject,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterChange?.length) {\n        await editor.hooks.afterChange.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            indexPath: indexPathSegments,\n            operation,\n            originalDoc: doc,\n            path: pathSegments,\n            previousDoc,\n            previousSiblingDoc,\n            previousValue: previousDoc[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabPreviousSiblingDoc = siblingDoc\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        tabSiblingData = (siblingData[field.name] as JsonObject) ?? {}\n        tabSiblingDoc = (siblingDoc[field.name] as JsonObject) ?? {}\n        tabPreviousSiblingDoc = (previousDoc[field.name] as JsonObject) ?? {}\n      }\n\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: tabPreviousSiblingDoc,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        parentIndexPath: indexPath,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getFieldPathsModified","getFieldPaths","traverseFields","promise","blockData","collection","context","data","doc","field","fieldIndex","global","operation","parentIndexPath","parentPath","parentSchemaPath","previousDoc","previousSiblingDoc","req","siblingData","siblingDoc","indexPath","path","schemaPath","index","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","hooks","afterChange","reduce","priorHook","currentHook","hookedValue","originalDoc","previousValue","name","value","undefined","Promise","resolve","type","rows","Array","isArray","promises","forEach","row","rowIndex","push","fields","all","block","blocks","find","blockType","slug","editor","Error","length","tabSiblingData","tabSiblingDoc","tabPreviousSiblingDoc","isNamedTab","tabs","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4194, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4200, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterChange/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n  previousDoc: JsonObject\n  previousSiblingDoc: JsonObject\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async ({\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  fields,\n  global,\n  operation,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        field,\n        fieldIndex,\n        global,\n        operation,\n        parentIndexPath,\n        parentPath,\n        parentSchemaPath,\n        previousDoc,\n        previousSiblingDoc,\n        req,\n        siblingData,\n        siblingDoc,\n      }),\n    )\n  })\n\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","blockData","collection","context","data","doc","fields","global","operation","parentIndexPath","parentPath","parentSchemaPath","previousDoc","previousSiblingDoc","req","siblingData","siblingDoc","promises","forEach","field","fieldIndex","push","Promise","all"],"mappings":";;;AAMA,SAASA,OAAO,QAAQ,eAAc;;AAwB/B,MAAMC,iBAAiB,OAAO,EACnCC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,eAAe,EACfC,UAAU,EACVC,gBAAgB,EAChBC,WAAW,EACXC,kBAAkB,EAClBC,GAAG,EACHC,WAAW,EACXC,UAAU,EACL;IACL,MAAMC,WAAW,EAAE;IAEnBX,OAAOY,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,0YACXtB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAc;YACAC;YACAb;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,MAAMM,QAAQC,GAAG,CAACN;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4230, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4236, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterChange/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  /**\n   * The data before hooks\n   */\n  data: T\n  /**\n   * The data after hooks\n   */\n  doc: T\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  previousDoc: T\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Execute field hooks\n */\nexport const afterChange = async <T extends JsonObject>({\n  collection,\n  context,\n  data,\n  doc: incomingDoc,\n  global,\n  operation,\n  previousDoc,\n  req,\n}: Args<T>): Promise<T> => {\n  await traverseFields({\n    collection,\n    context,\n    data,\n    doc: incomingDoc,\n    fields: collection?.fields || global?.fields,\n    global,\n    operation,\n    parentIndexPath: '',\n    parentPath: '',\n    parentSchemaPath: '',\n    previousDoc,\n    previousSiblingDoc: previousDoc,\n    req,\n    siblingData: data,\n    siblingDoc: incomingDoc,\n  })\n\n  return incomingDoc\n}\n"],"names":["traverseFields","afterChange","collection","context","data","doc","incomingDoc","global","operation","previousDoc","req","fields","parentIndexPath","parentPath","parentSchemaPath","previousSiblingDoc","siblingData","siblingDoc"],"mappings":";;;AAKA,SAASA,cAAc,QAAQ,sBAAqB;;AAuB7C,MAAMC,cAAc,OAA6B,EACtDC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,KAAKC,WAAW,EAChBC,MAAM,EACNC,SAAS,EACTC,WAAW,EACXC,GAAG,EACK;IACR,sZAAMV,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC,KAAKC;QACLK,QAAQT,YAAYS,UAAUJ,QAAQI;QACtCJ;QACAC;QACAI,iBAAiB;QACjBC,YAAY;QACZC,kBAAkB;QAClBL;QACAM,oBAAoBN;QACpBC;QACAM,aAAaZ;QACba,YAAYX;IACd;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4261, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4267, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/mergeBaseFields.ts"],"sourcesContent":["import type { Field, FieldWithSubFields } from './config/types.js'\n\nimport { deepMergeWithReactComponents } from '../utilities/deepMerge.js'\nimport { fieldAffectsData, fieldHasSubFields } from './config/types.js'\n\nconst mergeBaseFields = (fields: Field[], baseFields: Field[]): Field[] => {\n  const mergedFields = [...(fields || [])]\n\n  baseFields.forEach((baseField) => {\n    let matchedIndex = null\n\n    if (fieldAffectsData(baseField)) {\n      const match = mergedFields.find((field, i) => {\n        if (fieldAffectsData(field) && field.name === baseField.name) {\n          matchedIndex = i\n          return true\n        }\n\n        return false\n      })\n\n      if (match) {\n        const matchCopy: Field = { ...match }\n        mergedFields.splice(matchedIndex, 1)\n\n        const mergedField = deepMergeWithReactComponents<Field>(baseField, matchCopy)\n\n        if (fieldHasSubFields(baseField) && fieldHasSubFields(matchCopy)) {\n          ;(mergedField as FieldWithSubFields).fields = mergeBaseFields(\n            matchCopy.fields,\n            baseField.fields,\n          )\n        }\n\n        mergedFields.push(mergedField)\n      } else {\n        mergedFields.push(baseField)\n      }\n    }\n  })\n\n  return mergedFields\n}\n\nexport default mergeBaseFields\n"],"names":["deepMergeWithReactComponents","fieldAffectsData","fieldHasSubFields","mergeBaseFields","fields","baseFields","mergedFields","forEach","baseField","matchedIndex","match","find","field","i","name","matchCopy","splice","mergedField","push"],"mappings":";;;AAGA,SAASC,gBAAgB,EAAEC,iBAAiB,QAAQ,oBAAmB;AADvE,SAASF,4BAA4B,QAAQ,4BAA2B;;;AAGxE,MAAMG,kBAAkB,CAACC,QAAiBC;IACxC,MAAMC,eAAe;WAAKF,UAAU,EAAE;KAAE;IAExCC,WAAWE,OAAO,CAAC,CAACC;QAClB,IAAIC,eAAe;QAEnB,KAAIR,2YAAAA,EAAiBO,YAAY;YAC/B,MAAME,QAAQJ,aAAaK,IAAI,CAAC,CAACC,OAAOC;gBACtC,KAAIZ,2YAAAA,EAAiBW,UAAUA,MAAME,IAAI,KAAKN,UAAUM,IAAI,EAAE;oBAC5DL,eAAeI;oBACf,OAAO;gBACT;gBAEA,OAAO;YACT;YAEA,IAAIH,OAAO;gBACT,MAAMK,YAAmB;oBAAE,GAAGL,KAAK;gBAAC;gBACpCJ,aAAaU,MAAM,CAACP,cAAc;gBAElC,MAAMQ,oZAAcjB,+BAAAA,EAAoCQ,WAAWO;gBAEnE,6XAAIb,oBAAAA,EAAkBM,uYAAcN,oBAAAA,EAAkBa,YAAY;;oBAC9DE,YAAmCb,MAAM,GAAGD,gBAC5CY,UAAUX,MAAM,EAChBI,UAAUJ,MAAM;gBAEpB;gBAEAE,aAAaY,IAAI,CAACD;YACpB,OAAO;gBACLX,aAAaY,IAAI,CAACV;YACpB;QACF;IACF;IAEA,OAAOF;AACT;uCAEeH,gBAAe","ignoreList":[0]}},
    {"offset": {"line": 4308, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}