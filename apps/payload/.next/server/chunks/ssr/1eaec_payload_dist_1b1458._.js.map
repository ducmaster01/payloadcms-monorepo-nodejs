{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/APIError.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\n// This gets dynamically reassigned during compilation\nexport let APIErrorName = 'APIError'\n\nclass ExtendableError<TData extends object = { [key: string]: unknown }> extends Error {\n  data: TData\n\n  isOperational: boolean\n\n  isPublic: boolean\n\n  status: number\n\n  constructor(message: string, status: number, data: TData, isPublic: boolean) {\n    super(message, {\n      // show data in cause\n      cause: data,\n    })\n    APIErrorName = this.constructor.name\n    this.name = this.constructor.name\n    this.message = message\n    this.status = status\n    this.data = data\n    this.isPublic = isPublic\n    this.isOperational = true // This is required since bluebird 4 doesn't append it anymore.\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\n/**\n * Class representing an API error.\n * @extends ExtendableError\n */\nexport class APIError<\n  TData extends null | object = { [key: string]: unknown } | null,\n> extends ExtendableError<TData> {\n  /**\n   * Creates an API error.\n   * @param {string} message - Error message.\n   * @param {number} status - HTTP status code of error.\n   * @param {object} data - response data to be returned.\n   * @param {boolean} isPublic - Whether the message should be visible to user or not.\n   */\n  constructor(\n    message: string,\n    status: number = httpStatus.INTERNAL_SERVER_ERROR,\n    data: TData = null,\n    isPublic = false,\n  ) {\n    super(message, status, data, isPublic)\n  }\n}\n"],"names":["httpStatus","APIErrorName","ExtendableError","Error","data","isOperational","isPublic","status","constructor","message","cause","name","captureStackTrace","APIError","INTERNAL_SERVER_ERROR"],"mappings":";;;;AAAA,OAAOA,gBAAgB,cAAa;;AAG7B,IAAIC,eAAe,WAAU;AAEpC,MAAMC,wBAA2EC;IAC/EC,KAAW;IAEXC,cAAsB;IAEtBC,SAAiB;IAEjBC,OAAc;IAEdC,YAAYC,OAAe,EAAEF,MAAc,EAAEH,IAAW,EAAEE,QAAiB,CAAE;QAC3E,KAAK,CAACG,SAAS;YACb,qBAAqB;YACrBC,OAAON;QACT;QACAH,eAAe,IAAI,CAACO,WAAW,CAACG,IAAI;QACpC,IAAI,CAACA,IAAI,GAAG,IAAI,CAACH,WAAW,CAACG,IAAI;QACjC,IAAI,CAACF,OAAO,GAAGA;QACf,IAAI,CAACF,MAAM,GAAGA;QACd,IAAI,CAACH,IAAI,GAAGA;QACZ,IAAI,CAACE,QAAQ,GAAGA;QAChB,IAAI,CAACD,aAAa,GAAG,KAAK,+DAA+D;;QACzFF,MAAMS,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAACJ,WAAW;IAChD;AACF;AAMO,MAAMK,iBAEHX;IACR;;;;;;GAMC,GACDM,YACEC,OAAe,EACfF,mNAAiBP,UAAAA,CAAWc,qBAAqB,EACjDV,OAAc,IAAI,EAClBE,WAAW,KAAK,CAChB;QACA,KAAK,CAACG,SAASF,QAAQH,MAAME;IAC/B;AACF","ignoreList":[0]}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/QueryError.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class QueryError extends APIError<{ path: string }[]> {\n  constructor(results: { path: string }[]) {\n    const message = `The following path${results.length === 1 ? '' : 's'} cannot be queried:`\n\n    super(\n      `${message} ${results.map((err) => err.path).join(', ')}`,\n      httpStatus.BAD_REQUEST,\n      results,\n    )\n  }\n}\n"],"names":["httpStatus","APIError","QueryError","constructor","results","message","length","map","err","path","join","BAD_REQUEST"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,+XAAmBD,WAAAA;IAC9BE,YAAYC,OAA2B,CAAE;QACvC,MAAMC,UAAU,CAAC,kBAAkB,EAAED,QAAQE,MAAM,KAAK,IAAI,KAAK,IAAI,mBAAmB,CAAC;QAEzF,KAAK,CACH,GAAGD,QAAQ,CAAC,EAAED,QAAQG,GAAG,CAAC,CAACC,MAAQA,IAAIC,IAAI,EAAEC,IAAI,CAAC,OAAO,4MACzDV,UAAAA,CAAWW,WAAW,EACtBP;IAEJ;AACF","ignoreList":[0]}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/ValidationError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\n// This gets dynamically reassigned during compilation\nexport let ValidationErrorName = 'ValidationError'\n\nexport type ValidationFieldError = {\n  // The error message to display for this field\n  message: string\n  path: string\n}\n\nexport class ValidationError extends APIError<{\n  collection?: string\n  errors: ValidationFieldError[]\n  global?: string\n}> {\n  constructor(\n    results: {\n      collection?: string\n      errors: ValidationFieldError[]\n      global?: string\n      id?: number | string\n    },\n    t?: TFunction,\n  ) {\n    const message = t\n      ? t('error:followingFieldsInvalid', { count: results.errors.length })\n      : results.errors.length === 1\n        ? en.translations.error.followingFieldsInvalid_one\n        : en.translations.error.followingFieldsInvalid_other\n\n    super(\n      `${message} ${results.errors.map((f) => f.path).join(', ')}`,\n      httpStatus.BAD_REQUEST,\n      results,\n    )\n\n    ValidationErrorName = this.constructor.name\n  }\n}\n"],"names":["en","httpStatus","APIError","ValidationErrorName","ValidationError","constructor","results","t","message","count","errors","length","translations","error","followingFieldsInvalid_one","followingFieldsInvalid_other","map","f","path","join","BAD_REQUEST","name"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAGjC,IAAIC,sBAAsB,kBAAiB;AAQ3C,MAAMC,oYAAwBF,WAAAA;IAKnCG,YACEC,OAKC,EACDC,CAAa,CACb;QACA,MAAMC,UAAUD,IACZA,EAAE,gCAAgC;YAAEE,OAAOH,QAAQI,MAAM,CAACC,MAAM;QAAC,KACjEL,QAAQI,MAAM,CAACC,MAAM,KAAK,sPACxBX,KAAAA,CAAGY,YAAY,CAACC,KAAK,CAACC,0BAA0B,qPAChDd,KAAAA,CAAGY,YAAY,CAACC,KAAK,CAACE,4BAA4B;QAExD,KAAK,CACH,GAAGP,QAAQ,CAAC,EAAEF,QAAQI,MAAM,CAACM,GAAG,CAAC,CAACC,IAAMA,EAAEC,IAAI,EAAEC,IAAI,CAAC,OAAO,4MAC5DlB,UAAAA,CAAWmB,WAAW,EACtBd;QAGFH,sBAAsB,IAAI,CAACE,WAAW,CAACgB,IAAI;IAC7C;AACF","ignoreList":[0]}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/InvalidConfiguration.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidConfiguration extends APIError {\n  constructor(message: string) {\n    super(message, httpStatus.INTERNAL_SERVER_ERROR)\n  }\n}\n"],"names":["httpStatus","APIError","InvalidConfiguration","constructor","message","INTERNAL_SERVER_ERROR"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,yYAA6BD,WAAAA;IACxCE,YAAYC,OAAe,CAAE;QAC3B,KAAK,CAACA,mNAASJ,UAAAA,CAAWK,qBAAqB;IACjD;AACF","ignoreList":[0]}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/Forbidden.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class Forbidden extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:notAllowedToPerformAction') : en.translations.error.notAllowedToPerformAction,\n      httpStatus.FORBIDDEN,\n    )\n  }\n}\n"],"names":["en","httpStatus","APIError","Forbidden","constructor","t","translations","error","notAllowedToPerformAction","FORBIDDEN"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,8XAAkBD,WAAAA;IAC7BE,YAAYC,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,uRAAqCL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,yBAAyB,4MAC1FP,UAAAA,CAAWQ,SAAS;IAExB;AACF","ignoreList":[0]}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 135, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/UnathorizedError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class UnauthorizedError extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('error:unauthorized') : en.translations.error.unauthorized, httpStatus.UNAUTHORIZED)\n  }\n}\n"],"names":["en","httpStatus","APIError","UnauthorizedError","constructor","t","translations","error","unauthorized","UNAUTHORIZED"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,sYAA0BD,WAAAA;IACrCE,YAAYC,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,0QAAwBL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,YAAY,4MAAEP,UAAAA,CAAWQ,YAAY;IACjG;AACF","ignoreList":[0]}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/NotFound.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class NotFound extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('general:notFound') : en.translations.general.notFound, httpStatus.NOT_FOUND)\n  }\n}\n"],"names":["en","httpStatus","APIError","NotFound","constructor","t","translations","general","notFound","NOT_FOUND"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,6XAAiBD,WAAAA;IAC5BE,YAAYC,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,wQAAsBL,KAAAA,CAAGM,YAAY,CAACC,OAAO,CAACC,QAAQ,4MAAEP,UAAAA,CAAWQ,SAAS;IAC1F;AACF","ignoreList":[0]}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/MissingFieldType.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { APIError } from './APIError.js'\n\nexport class MissingFieldType extends APIError {\n  constructor(field: Field) {\n    super(\n      `Field${\n        fieldAffectsData(field) ? ` \"${field.name}\"` : ''\n      } is either missing a field type or it does not match an available field type`,\n    )\n  }\n}\n"],"names":["fieldAffectsData","APIError","MissingFieldType","constructor","field","name"],"mappings":";;;AAEA,SAASA,gBAAgB,QAAQ,4BAA2B;AAC5D,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,qYAAyBD,WAAAA;IACpCE,YAAYC,KAAY,CAAE;QACxB,KAAK,CACH,CAAC,KAAK,yXACJJ,mBAAAA,EAAiBI,SAAS,CAAC,EAAE,EAAEA,MAAMC,IAAI,CAAC,CAAC,CAAC,GAAG,GAChD,4EAA4E,CAAC;IAElF;AACF","ignoreList":[0]}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/InvalidFieldName.ts"],"sourcesContent":["import type { FieldAffectingData } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidFieldName extends APIError {\n  constructor(field: FieldAffectingData, fieldName: string) {\n    super(\n      `Field ${field.label} has invalid name '${fieldName}'. Field names can not include periods (.) and must be alphanumeric.`,\n    )\n  }\n}\n"],"names":["APIError","InvalidFieldName","constructor","field","fieldName","label"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,qYAAyBD,WAAAA;IACpCE,YAAYC,KAAyB,EAAEC,SAAiB,CAAE;QACxD,KAAK,CACH,CAAC,MAAM,EAAED,MAAME,KAAK,CAAC,mBAAmB,EAAED,UAAU,oEAAoE,CAAC;IAE7H;AACF","ignoreList":[0]}},
    {"offset": {"line": 203, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/InvalidFieldJoin.ts"],"sourcesContent":["import type { JoinField } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidFieldJoin extends APIError {\n  constructor(field: JoinField) {\n    super(\n      `Invalid join field ${field.name}. The config does not have a field '${field.on}' in collection '${field.collection}'.`,\n    )\n  }\n}\n"],"names":["APIError","InvalidFieldJoin","constructor","field","name","on","collection"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,qYAAyBD,WAAAA;IACpCE,YAAYC,KAAgB,CAAE;QAC5B,KAAK,CACH,CAAC,mBAAmB,EAAEA,MAAMC,IAAI,CAAC,oCAAoC,EAAED,MAAME,EAAE,CAAC,iBAAiB,EAAEF,MAAMG,UAAU,CAAC,EAAE,CAAC;IAE3H;AACF","ignoreList":[0]}},
    {"offset": {"line": 219, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/InvalidFieldRelationship.ts"],"sourcesContent":["import type { RelationshipField, UploadField } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidFieldRelationship extends APIError {\n  constructor(field: RelationshipField | UploadField, relationship: string) {\n    super(`Field ${field.label} has invalid relationship '${relationship}'.`)\n  }\n}\n"],"names":["APIError","InvalidFieldRelationship","constructor","field","relationship","label"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,6YAAiCD,WAAAA;IAC5CE,YAAYC,KAAsC,EAAEC,YAAoB,CAAE;QACxE,KAAK,CAAC,CAAC,MAAM,EAAED,MAAME,KAAK,CAAC,2BAA2B,EAAED,aAAa,EAAE,CAAC;IAC1E;AACF","ignoreList":[0]}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/DuplicateFieldName.ts"],"sourcesContent":["import { APIError } from './APIError.js'\n\nexport class DuplicateFieldName extends APIError {\n  constructor(fieldName: string) {\n    super(\n      `A field with the name '${fieldName}' was found multiple times on the same level. Field names must be unique.`,\n    )\n  }\n}\n"],"names":["APIError","DuplicateFieldName","constructor","fieldName"],"mappings":";;;AAAA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,uYAA2BD,WAAAA;IACtCE,YAAYC,SAAiB,CAAE;QAC7B,KAAK,CACH,CAAC,uBAAuB,EAAEA,UAAU,yEAAyE,CAAC;IAElH;AACF","ignoreList":[0]}},
    {"offset": {"line": 251, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 257, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/MissingEditorProp.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { APIError } from './APIError.js'\n\nexport class MissingEditorProp extends APIError {\n  constructor(field: Field) {\n    super(\n      `RichText field${fieldAffectsData(field) ? ` \"${field.name}\"` : ''} is missing the editor prop. For sub-richText fields, the editor props is required, as it would otherwise create infinite recursion.`,\n    )\n  }\n}\n"],"names":["fieldAffectsData","APIError","MissingEditorProp","constructor","field","name"],"mappings":";;;AAEA,SAASA,gBAAgB,QAAQ,4BAA2B;AAC5D,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,sYAA0BD,WAAAA;IACrCE,YAAYC,KAAY,CAAE;QACxB,KAAK,CACH,CAAC,cAAc,yXAAEJ,mBAAAA,EAAiBI,SAAS,CAAC,EAAE,EAAEA,MAAMC,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,oIAAoI,CAAC;IAE5M;AACF","ignoreList":[0]}},
    {"offset": {"line": 269, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 275, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/TimestampsRequired.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class TimestampsRequired extends APIError {\n  constructor(collection: CollectionConfig) {\n    super(\n      `Timestamps are required in the collection ${collection.slug} because you have opted in to Versions.`,\n    )\n  }\n}\n"],"names":["APIError","TimestampsRequired","constructor","collection","slug"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,uYAA2BD,WAAAA;IACtCE,YAAYC,UAA4B,CAAE;QACxC,KAAK,CACH,CAAC,0CAA0C,EAAEA,WAAWC,IAAI,CAAC,uCAAuC,CAAC;IAEzG;AACF","ignoreList":[0]}},
    {"offset": {"line": 285, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 291, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/ReservedFieldName.ts"],"sourcesContent":["import type { FieldAffectingData } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class ReservedFieldName extends APIError {\n  constructor(field: FieldAffectingData, fieldName: string) {\n    super(`Field ${field.label} has reserved name '${fieldName}'.`)\n  }\n}\n"],"names":["APIError","ReservedFieldName","constructor","field","fieldName","label"],"mappings":";;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,sYAA0BD,WAAAA;IACrCE,YAAYC,KAAyB,EAAEC,SAAiB,CAAE;QACxD,KAAK,CAAC,CAAC,MAAM,EAAED,MAAME,KAAK,CAAC,oBAAoB,EAAED,UAAU,EAAE,CAAC;IAChE;AACF","ignoreList":[0]}},
    {"offset": {"line": 301, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 307, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/DuplicateCollection.ts"],"sourcesContent":["import { APIError } from './APIError.js'\n\nexport class DuplicateCollection extends APIError {\n  constructor(propertyName: string, duplicates: string[]) {\n    super(`Collection ${propertyName} already in use: \"${duplicates.join(', ')}\"`)\n  }\n}\n"],"names":["APIError","DuplicateCollection","constructor","propertyName","duplicates","join"],"mappings":";;;AAAA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,wYAA4BD,WAAAA;IACvCE,YAAYC,YAAoB,EAAEC,UAAoB,CAAE;QACtD,KAAK,CAAC,CAAC,WAAW,EAAED,aAAa,kBAAkB,EAAEC,WAAWC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC/E;AACF","ignoreList":[0]}},
    {"offset": {"line": 317, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/AuthenticationError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class AuthenticationError extends APIError {\n  constructor(t?: TFunction, loginWithUsername?: boolean) {\n    super(\n      t\n        ? `${loginWithUsername ? t('error:usernameOrPasswordIncorrect') : t('error:emailOrPasswordIncorrect')}`\n        : en.translations.error.emailOrPasswordIncorrect,\n      httpStatus.UNAUTHORIZED,\n    )\n  }\n}\n"],"names":["en","httpStatus","APIError","AuthenticationError","constructor","t","loginWithUsername","translations","error","emailOrPasswordIncorrect","UNAUTHORIZED"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,wYAA4BD,WAAAA;IACvCE,YAAYC,CAAa,EAAEC,iBAA2B,CAAE;QACtD,KAAK,CACHD,IACI,GAAGC,oBAAoBD,EAAE,uCAAuCA,EAAE,mCAAmC,qPACrGL,KAAAA,CAAGO,YAAY,CAACC,KAAK,CAACC,wBAAwB,4MAClDR,UAAAA,CAAWS,YAAY;IAE3B;AACF","ignoreList":[0]}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/LockedAuth.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class LockedAuth extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('error:userLocked') : en.translations.error.userLocked, httpStatus.UNAUTHORIZED)\n  }\n}\n"],"names":["en","httpStatus","APIError","LockedAuth","constructor","t","translations","error","userLocked","UNAUTHORIZED"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,+XAAmBD,WAAAA;IAC9BE,YAAYC,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,wQAAsBL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,UAAU,4MAAEP,UAAAA,CAAWQ,YAAY;IAC7F;AACF","ignoreList":[0]}},
    {"offset": {"line": 357, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/FileRetrievalError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class FileRetrievalError extends APIError {\n  constructor(t?: TFunction, message?: string) {\n    let msg = t ? t('error:problemUploadingFile') : 'There was a problem while retrieving the file.'\n\n    if (message) {\n      msg += ` ${message}`\n    }\n    super(msg, httpStatus.INTERNAL_SERVER_ERROR)\n  }\n}\n"],"names":["httpStatus","APIError","FileRetrievalError","constructor","t","message","msg","INTERNAL_SERVER_ERROR"],"mappings":";;;AAEA,OAAOA,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,uYAA2BD,WAAAA;IACtCE,YAAYC,CAAa,EAAEC,OAAgB,CAAE;QAC3C,IAAIC,MAAMF,IAAIA,EAAE,gCAAgC;QAEhD,IAAIC,SAAS;YACXC,OAAO,CAAC,CAAC,EAAED,SAAS;QACtB;QACA,KAAK,CAACC,+MAAKN,UAAAA,CAAWO,qBAAqB;IAC7C;AACF","ignoreList":[0]}},
    {"offset": {"line": 379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 385, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/FileUploadError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class FileUploadError extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:problemUploadingFile') : en.translations.error.problemUploadingFile,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n}\n"],"names":["en","httpStatus","APIError","FileUploadError","constructor","t","translations","error","problemUploadingFile","BAD_REQUEST"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,oYAAwBD,WAAAA;IACnCE,YAAYC,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,kRAAgCL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,oBAAoB,4MAChFP,UAAAA,CAAWQ,WAAW;IAE1B;AACF","ignoreList":[0]}},
    {"offset": {"line": 399, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 405, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/MissingFile.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class MissingFile extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:noFilesUploaded') : en.translations.error.noFilesUploaded,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n}\n"],"names":["en","httpStatus","APIError","MissingFile","constructor","t","translations","error","noFilesUploaded","BAD_REQUEST"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,gYAAoBD,WAAAA;IAC/BE,YAAYC,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,6QAA2BL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,eAAe,4MACtEP,UAAAA,CAAWQ,WAAW;IAE1B;AACF","ignoreList":[0]}},
    {"offset": {"line": 419, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/Locked.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class Locked extends APIError {\n  constructor(message: string) {\n    super(message, httpStatus.LOCKED)\n  }\n}\n"],"names":["httpStatus","APIError","Locked","constructor","message","LOCKED"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,2XAAeD,WAAAA;IAC1BE,YAAYC,OAAe,CAAE;QAC3B,KAAK,CAACA,mNAASJ,UAAAA,CAAWK,MAAM;IAClC;AACF","ignoreList":[0]}},
    {"offset": {"line": 437, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 443, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/errors/ErrorDeletingFile.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport httpStatus from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class ErrorDeletingFile extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:deletingFile') : en.translations.error.deletingFile,\n      httpStatus.INTERNAL_SERVER_ERROR,\n    )\n  }\n}\n"],"names":["en","httpStatus","APIError","ErrorDeletingFile","constructor","t","translations","error","deletingFile","INTERNAL_SERVER_ERROR"],"mappings":";;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;AAC1D,OAAOC,gBAAgB,cAAa;AAEpC,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,sYAA0BD,WAAAA;IACrCE,YAAYC,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,0QAAwBL,KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,YAAY,4MAChEP,UAAAA,CAAWQ,qBAAqB;IAEpC;AACF","ignoreList":[0]}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 463, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/formatFilesize.ts"],"sourcesContent":["export function formatFilesize(bytes: number, decimals = 0): string {\n  if (bytes === 0) {\n    return '0 bytes'\n  }\n\n  const k = 1024\n  const dm = decimals < 0 ? 0 : decimals\n  const sizes = [' bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n\n  const i = Math.floor(Math.log(bytes) / Math.log(k))\n\n  return `${parseFloat((bytes / k ** i).toFixed(dm))}${sizes[i]}`\n}\n"],"names":["formatFilesize","bytes","decimals","k","dm","sizes","i","Math","floor","log","parseFloat","toFixed"],"mappings":";;;AAAO,SAASA,eAAeC,KAAa,EAAEC,WAAW,CAAC;IACxD,IAAID,UAAU,GAAG;QACf,OAAO;IACT;IAEA,MAAME,IAAI;IACV,MAAMC,KAAKF,WAAW,IAAI,IAAIA;IAC9B,MAAMG,QAAQ;QAAC;QAAU;QAAM;QAAM;QAAM;QAAM;QAAM;QAAM;QAAM;KAAK;IAExE,MAAMC,IAAIC,KAAKC,KAAK,CAACD,KAAKE,GAAG,CAACR,SAASM,KAAKE,GAAG,CAACN;IAEhD,OAAO,GAAGO,WAAYT,CAAAA,QAAQE,KAAKG,CAAAA,EAAGK,OAAO,CAACP,OAAOC,KAAK,CAACC,EAAE,EAAE;AACjE","ignoreList":[0]}},
    {"offset": {"line": 486, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 492, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/isImage.ts"],"sourcesContent":["export function isImage(mimeType: string): boolean {\n  return (\n    ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml', 'image/webp', 'image/avif'].indexOf(\n      mimeType,\n    ) > -1\n  )\n}\n"],"names":["isImage","mimeType","indexOf"],"mappings":";;;AAAO,SAASA,QAAQC,QAAgB;IACtC,OACE;QAAC;QAAc;QAAa;QAAa;QAAiB;QAAc;KAAa,CAACC,OAAO,CAC3FD,YACE,CAAC;AAET","ignoreList":[0]}},
    {"offset": {"line": 505, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 511, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/mimeTypeValidator.ts"],"sourcesContent":["import type { Validate } from '../fields/config/types.js'\n\nimport { validateMimeType } from '../utilities/validateMimeType.js'\n\nexport const mimeTypeValidator =\n  (mimeTypes: string[]): Validate =>\n  (val: string, { siblingData }) => {\n    if (!siblingData.filename) {\n      return true\n    }\n\n    if (!val) {\n      return 'Invalid file type'\n    }\n\n    const isValidMimeType = validateMimeType(val, mimeTypes)\n    return isValidMimeType ? true : `Invalid file type: '${val}'`\n  }\n"],"names":["validateMimeType","mimeTypeValidator","mimeTypes","val","siblingData","filename","isValidMimeType"],"mappings":";;;AAEA,SAASA,gBAAgB,QAAQ,mCAAkC;;AAE5D,MAAMC,oBACX,CAACC,YACD,CAACC,KAAa,EAAEC,WAAW,EAAE;QAC3B,IAAI,CAACA,YAAYC,QAAQ,EAAE;YACzB,OAAO;QACT;QAEA,IAAI,CAACF,KAAK;YACR,OAAO;QACT;QAEA,MAAMG,6YAAkBN,mBAAAA,EAAiBG,KAAKD;QAC9C,OAAOI,kBAAkB,OAAO,CAAC,oBAAoB,EAAEH,IAAI,CAAC,CAAC;IAC/D,EAAC","ignoreList":[0]}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 532, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getBaseFields.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Config } from '../config/types.js'\nimport type { Field } from '../fields/config/types.js'\nimport type { UploadConfig } from './types.js'\n\nimport { mimeTypeValidator } from './mimeTypeValidator.js'\n\ntype GenerateURLArgs = {\n  collectionSlug: string\n  config: Config\n  filename?: string\n}\nconst generateURL = ({ collectionSlug, config, filename }: GenerateURLArgs) => {\n  if (filename) {\n    return `${config.serverURL || ''}${config.routes.api || ''}/${collectionSlug}/file/${encodeURIComponent(filename)}`\n  }\n  return undefined\n}\n\ntype Options = {\n  collection: CollectionConfig\n  config: Config\n}\n\nexport const getBaseUploadFields = ({ collection, config }: Options): Field[] => {\n  const uploadOptions: UploadConfig = typeof collection.upload === 'object' ? collection.upload : {}\n\n  const mimeType: Field = {\n    name: 'mimeType',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: 'MIME Type',\n  }\n\n  const thumbnailURL: Field = {\n    name: 'thumbnailURL',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    hooks: {\n      afterRead: [\n        ({ originalDoc }) => {\n          const adminThumbnail =\n            typeof collection.upload !== 'boolean' ? collection.upload?.adminThumbnail : undefined\n\n          if (typeof adminThumbnail === 'function') {\n            return adminThumbnail({ doc: originalDoc })\n          }\n\n          if (\n            typeof adminThumbnail === 'string' &&\n            'sizes' in originalDoc &&\n            originalDoc.sizes?.[adminThumbnail]?.filename\n          ) {\n            return generateURL({\n              collectionSlug: collection.slug,\n              config,\n              filename: originalDoc.sizes?.[adminThumbnail].filename as string,\n            })\n          }\n\n          return null\n        },\n      ],\n    },\n    label: 'Thumbnail URL',\n  }\n\n  const width: Field = {\n    name: 'width',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:width'),\n  }\n\n  const height: Field = {\n    name: 'height',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:height'),\n  }\n\n  const filesize: Field = {\n    name: 'filesize',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:fileSize'),\n  }\n\n  const filename: Field = {\n    name: 'filename',\n    type: 'text',\n    admin: {\n      disableBulkEdit: true,\n      hidden: true,\n      readOnly: true,\n    },\n    index: true,\n    label: ({ t }) => t('upload:fileName'),\n  }\n\n  // Only set unique: true if the collection does not have a compound index\n  if (\n    collection.upload === true ||\n    (typeof collection.upload === 'object' && !collection.upload.filenameCompoundIndex)\n  ) {\n    filename.unique = true\n  }\n\n  const url: Field = {\n    name: 'url',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: 'URL',\n  }\n\n  let uploadFields: Field[] = [\n    {\n      ...url,\n      hooks: {\n        afterRead: [\n          ({ data, value }) => {\n            if (value && !data.filename) {\n              return value\n            }\n\n            return generateURL({\n              collectionSlug: collection.slug,\n              config,\n              filename: data?.filename,\n            })\n          },\n        ],\n      },\n    },\n    thumbnailURL,\n    filename,\n    mimeType,\n    filesize,\n    width,\n    height,\n  ]\n\n  // Add focal point fields if not disabled\n  if (\n    uploadOptions.focalPoint !== false ||\n    uploadOptions.imageSizes ||\n    uploadOptions.resizeOptions\n  ) {\n    uploadFields = uploadFields.concat(\n      ['focalX', 'focalY'].map((name) => {\n        return {\n          name,\n          type: 'number',\n          admin: {\n            hidden: true,\n          },\n        }\n      }),\n    )\n  }\n\n  if (uploadOptions.mimeTypes) {\n    mimeType.validate = mimeTypeValidator(uploadOptions.mimeTypes)\n  }\n\n  if (uploadOptions.imageSizes) {\n    uploadFields = uploadFields.concat([\n      {\n        name: 'sizes',\n        type: 'group',\n        admin: {\n          hidden: true,\n        },\n        fields: uploadOptions.imageSizes.map((size) => ({\n          name: size.name,\n          type: 'group',\n          admin: {\n            hidden: true,\n          },\n          fields: [\n            {\n              ...url,\n              hooks: {\n                afterRead: [\n                  ({ data, value }) => {\n                    if (value && size.height && size.width && !data.filename) {\n                      return value\n                    }\n\n                    const sizeFilename = data?.sizes?.[size.name]?.filename\n\n                    if (sizeFilename) {\n                      return `${config.serverURL}${config.routes.api}/${collection.slug}/file/${sizeFilename}`\n                    }\n\n                    return null\n                  },\n                ],\n              },\n            },\n            width,\n            height,\n            mimeType,\n            filesize,\n            {\n              ...filename,\n              unique: false,\n            },\n          ],\n          label: size.name,\n        })),\n        label: ({ t }) => t('upload:sizes'),\n      },\n    ])\n  }\n  return uploadFields\n}\n"],"names":["mimeTypeValidator","generateURL","collectionSlug","config","filename","serverURL","routes","api","encodeURIComponent","undefined","getBaseUploadFields","collection","uploadOptions","upload","mimeType","name","type","admin","hidden","readOnly","label","thumbnailURL","hooks","afterRead","originalDoc","adminThumbnail","doc","sizes","slug","width","t","height","filesize","disableBulkEdit","index","filenameCompoundIndex","unique","url","uploadFields","data","value","focalPoint","imageSizes","resizeOptions","concat","map","mimeTypes","validate","fields","size","sizeFilename"],"mappings":";;;AAKA,SAASA,iBAAiB,QAAQ,yBAAwB;;AAO1D,MAAMC,cAAc,CAAC,EAAEC,cAAc,EAAEC,MAAM,EAAEC,QAAQ,EAAmB;IACxE,IAAIA,UAAU;QACZ,OAAO,GAAGD,OAAOE,SAAS,IAAI,KAAKF,OAAOG,MAAM,CAACC,GAAG,IAAI,GAAG,CAAC,EAAEL,eAAe,MAAM,EAAEM,mBAAmBJ,WAAW;IACrH;IACA,OAAOK;AACT;AAOO,MAAMC,sBAAsB,CAAC,EAAEC,UAAU,EAAER,MAAM,EAAW;IACjE,MAAMS,gBAA8B,OAAOD,WAAWE,MAAM,KAAK,WAAWF,WAAWE,MAAM,GAAG,CAAC;IAEjG,MAAMC,WAAkB;QACtBC,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,QAAQ;YACRC,UAAU;QACZ;QACAC,OAAO;IACT;IAEA,MAAMC,eAAsB;QAC1BN,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,QAAQ;YACRC,UAAU;QACZ;QACAG,OAAO;YACLC,WAAW;gBACT,CAAC,EAAEC,WAAW,EAAE;oBACd,MAAMC,iBACJ,OAAOd,WAAWE,MAAM,KAAK,YAAYF,WAAWE,MAAM,EAAEY,iBAAiBhB;oBAE/E,IAAI,OAAOgB,mBAAmB,YAAY;wBACxC,OAAOA,eAAe;4BAAEC,KAAKF;wBAAY;oBAC3C;oBAEA,IACE,OAAOC,mBAAmB,YAC1B,WAAWD,eACXA,YAAYG,KAAK,EAAE,CAACF,eAAe,EAAErB,UACrC;wBACA,OAAOH,YAAY;4BACjBC,gBAAgBS,WAAWiB,IAAI;4BAC/BzB;4BACAC,UAAUoB,YAAYG,KAAK,EAAE,CAACF,eAAe,CAACrB;wBAChD;oBACF;oBAEA,OAAO;gBACT;aACD;QACH;QACAgB,OAAO;IACT;IAEA,MAAMS,QAAe;QACnBd,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,QAAQ;YACRC,UAAU;QACZ;QACAC,OAAO,CAAC,EAAEU,CAAC,EAAE,GAAKA,EAAE;IACtB;IAEA,MAAMC,SAAgB;QACpBhB,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,QAAQ;YACRC,UAAU;QACZ;QACAC,OAAO,CAAC,EAAEU,CAAC,EAAE,GAAKA,EAAE;IACtB;IAEA,MAAME,WAAkB;QACtBjB,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,QAAQ;YACRC,UAAU;QACZ;QACAC,OAAO,CAAC,EAAEU,CAAC,EAAE,GAAKA,EAAE;IACtB;IAEA,MAAM1B,WAAkB;QACtBW,MAAM;QACNC,MAAM;QACNC,OAAO;YACLgB,iBAAiB;YACjBf,QAAQ;YACRC,UAAU;QACZ;QACAe,OAAO;QACPd,OAAO,CAAC,EAAEU,CAAC,EAAE,GAAKA,EAAE;IACtB;IAEA,yEAAyE;IACzE,IACEnB,WAAWE,MAAM,KAAK,QACrB,OAAOF,WAAWE,MAAM,KAAK,YAAY,CAACF,WAAWE,MAAM,CAACsB,qBAAqB,EAClF;QACA/B,SAASgC,MAAM,GAAG;IACpB;IAEA,MAAMC,MAAa;QACjBtB,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,QAAQ;YACRC,UAAU;QACZ;QACAC,OAAO;IACT;IAEA,IAAIkB,eAAwB;QAC1B;YACE,GAAGD,GAAG;YACNf,OAAO;gBACLC,WAAW;oBACT,CAAC,EAAEgB,IAAI,EAAEC,KAAK,EAAE;wBACd,IAAIA,SAAS,CAACD,KAAKnC,QAAQ,EAAE;4BAC3B,OAAOoC;wBACT;wBAEA,OAAOvC,YAAY;4BACjBC,gBAAgBS,WAAWiB,IAAI;4BAC/BzB;4BACAC,UAAUmC,MAAMnC;wBAClB;oBACF;iBACD;YACH;QACF;QACAiB;QACAjB;QACAU;QACAkB;QACAH;QACAE;KACD;IAED,yCAAyC;IACzC,IACEnB,cAAc6B,UAAU,KAAK,SAC7B7B,cAAc8B,UAAU,IACxB9B,cAAc+B,aAAa,EAC3B;QACAL,eAAeA,aAAaM,MAAM,CAChC;YAAC;YAAU;SAAS,CAACC,GAAG,CAAC,CAAC9B;YACxB,OAAO;gBACLA;gBACAC,MAAM;gBACNC,OAAO;oBACLC,QAAQ;gBACV;YACF;QACF;IAEJ;IAEA,IAAIN,cAAckC,SAAS,EAAE;QAC3BhC,SAASiC,QAAQ,6XAAG/C,oBAAAA,EAAkBY,cAAckC,SAAS;IAC/D;IAEA,IAAIlC,cAAc8B,UAAU,EAAE;QAC5BJ,eAAeA,aAAaM,MAAM,CAAC;YACjC;gBACE7B,MAAM;gBACNC,MAAM;gBACNC,OAAO;oBACLC,QAAQ;gBACV;gBACA8B,QAAQpC,cAAc8B,UAAU,CAACG,GAAG,CAAC,CAACI,OAAU,CAAA;wBAC9ClC,MAAMkC,KAAKlC,IAAI;wBACfC,MAAM;wBACNC,OAAO;4BACLC,QAAQ;wBACV;wBACA8B,QAAQ;4BACN;gCACE,GAAGX,GAAG;gCACNf,OAAO;oCACLC,WAAW;wCACT,CAAC,EAAEgB,IAAI,EAAEC,KAAK,EAAE;4CACd,IAAIA,SAASS,KAAKlB,MAAM,IAAIkB,KAAKpB,KAAK,IAAI,CAACU,KAAKnC,QAAQ,EAAE;gDACxD,OAAOoC;4CACT;4CAEA,MAAMU,eAAeX,MAAMZ,OAAO,CAACsB,KAAKlC,IAAI,CAAC,EAAEX;4CAE/C,IAAI8C,cAAc;gDAChB,OAAO,GAAG/C,OAAOE,SAAS,GAAGF,OAAOG,MAAM,CAACC,GAAG,CAAC,CAAC,EAAEI,WAAWiB,IAAI,CAAC,MAAM,EAAEsB,cAAc;4CAC1F;4CAEA,OAAO;wCACT;qCACD;gCACH;4BACF;4BACArB;4BACAE;4BACAjB;4BACAkB;4BACA;gCACE,GAAG5B,QAAQ;gCACXgC,QAAQ;4BACV;yBACD;wBACDhB,OAAO6B,KAAKlC,IAAI;oBAClB,CAAA;gBACAK,OAAO,CAAC,EAAEU,CAAC,EAAE,GAAKA,EAAE;YACtB;SACD;IACH;IACA,OAAOQ;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 726, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 732, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getFileByPath.ts"],"sourcesContent":["import { fileTypeFromFile } from 'file-type'\nimport fs from 'fs'\nimport path from 'path'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nconst mimeTypeEstimate = {\n  svg: 'image/svg+xml',\n}\n\nexport const getFileByPath = async (filePath: string): Promise<PayloadRequest['file']> => {\n  if (typeof filePath === 'string') {\n    const data = fs.readFileSync(filePath)\n    const mimetype = fileTypeFromFile(filePath)\n    const { size } = fs.statSync(filePath)\n\n    const name = path.basename(filePath)\n    const ext = path.extname(filePath).slice(1)\n\n    const mime = (await mimetype)?.mime || mimeTypeEstimate[ext]\n\n    return {\n      name,\n      data,\n      mimetype: mime,\n      size,\n    }\n  }\n\n  return undefined\n}\n"],"names":["fileTypeFromFile","fs","path","mimeTypeEstimate","svg","getFileByPath","filePath","data","readFileSync","mimetype","size","statSync","name","basename","ext","extname","slice","mime","undefined"],"mappings":";;;AACA,OAAOC,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;AAFvB,SAASF,gBAAgB,QAAQ,YAAW;;;;AAM5C,MAAMG,mBAAmB;IACvBC,KAAK;AACP;AAEO,MAAMC,gBAAgB,OAAOC;IAClC,IAAI,OAAOA,aAAa,UAAU;QAChC,MAAMC,qGAAON,UAAAA,CAAGO,YAAY,CAACF;QAC7B,MAAMG,+NAAWT,mBAAAA,EAAiBM;QAClC,MAAM,EAAEI,IAAI,EAAE,iGAAGT,UAAAA,CAAGU,QAAQ,CAACL;QAE7B,MAAMM,yGAAOV,UAAAA,CAAKW,QAAQ,CAACP;QAC3B,MAAMQ,wGAAMZ,UAAAA,CAAKa,OAAO,CAACT,UAAUU,KAAK,CAAC;QAEzC,MAAMC,OAAQ,CAAA,MAAMR,QAAO,GAAIQ,QAAQd,gBAAgB,CAACW,IAAI;QAE5D,OAAO;YACLF;YACAL;YACAE,UAAUQ;YACVP;QACF;IACF;IAEA,OAAOQ;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 761, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 767, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getExternalFile.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\nimport type { File, FileData, UploadConfig } from './types.js'\n\nimport { APIError } from '../errors/index.js'\n\ntype Args = {\n  data: FileData\n  req: PayloadRequest\n  uploadConfig: UploadConfig\n}\nexport const getExternalFile = async ({ data, req, uploadConfig }: Args): Promise<File> => {\n  const { filename, url } = data\n\n  if (typeof url === 'string') {\n    let fileURL = url\n    if (!url.startsWith('http')) {\n      const baseUrl = req.headers.get('origin') || `${req.protocol}://${req.headers.get('host')}`\n      fileURL = `${baseUrl}${url}`\n    }\n\n    const headers = uploadConfig.externalFileHeaderFilter\n      ? uploadConfig.externalFileHeaderFilter(Object.fromEntries(new Headers(req.headers)))\n      : { cookie: req.headers?.get('cookie') }\n\n    const res = await fetch(fileURL, {\n      credentials: 'include',\n      headers,\n      method: 'GET',\n    })\n\n    if (!res.ok) {\n      throw new APIError(`Failed to fetch file from ${fileURL}`, res.status)\n    }\n\n    const data = await res.arrayBuffer()\n\n    return {\n      name: filename,\n      data: Buffer.from(data),\n      mimetype: res.headers.get('content-type') || undefined,\n      size: Number(res.headers.get('content-length')) || 0,\n    }\n  }\n\n  throw new APIError('Invalid file url', 400)\n}\n"],"names":["APIError","getExternalFile","data","req","uploadConfig","filename","url","fileURL","startsWith","baseUrl","headers","get","protocol","externalFileHeaderFilter","Object","fromEntries","Headers","cookie","res","fetch","credentials","method","ok","status","arrayBuffer","name","Buffer","from","mimetype","undefined","size","Number"],"mappings":";;;AAGA,SAASA,QAAQ,QAAQ,qBAAoB;;AAOtC,MAAMC,kBAAkB,OAAO,EAAEC,IAAI,EAAEC,GAAG,EAAEC,YAAY,EAAQ;IACrE,MAAM,EAAEC,QAAQ,EAAEC,GAAG,EAAE,GAAGJ;IAE1B,IAAI,OAAOI,QAAQ,UAAU;QAC3B,IAAIC,UAAUD;QACd,IAAI,CAACA,IAAIE,UAAU,CAAC,SAAS;YAC3B,MAAMC,UAAUN,IAAIO,OAAO,CAACC,GAAG,CAAC,aAAa,GAAGR,IAAIS,QAAQ,CAAC,GAAG,EAAET,IAAIO,OAAO,CAACC,GAAG,CAAC,SAAS;YAC3FJ,UAAU,GAAGE,UAAUH,KAAK;QAC9B;QAEA,MAAMI,UAAUN,aAAaS,wBAAwB,GACjDT,aAAaS,wBAAwB,CAACC,OAAOC,WAAW,CAAC,IAAIC,QAAQb,IAAIO,OAAO,MAChF;YAAEO,QAAQd,IAAIO,OAAO,EAAEC,IAAI;QAAU;QAEzC,MAAMO,MAAM,MAAMC,MAAMZ,SAAS;YAC/Ba,aAAa;YACbV;YACAW,QAAQ;QACV;QAEA,IAAI,CAACH,IAAII,EAAE,EAAE;YACX,MAAM,gXAAItB,WAAAA,CAAS,CAAC,0BAA0B,EAAEO,SAAS,EAAEW,IAAIK,MAAM;QACvE;QAEA,MAAMrB,OAAO,MAAMgB,IAAIM,WAAW;QAElC,OAAO;YACLC,MAAMpB;YACNH,MAAMwB,OAAOC,IAAI,CAACzB;YAClB0B,UAAUV,IAAIR,OAAO,CAACC,GAAG,CAAC,mBAAmBkB;YAC7CC,MAAMC,OAAOb,IAAIR,OAAO,CAACC,GAAG,CAAC,sBAAsB;QACrD;IACF;IAEA,MAAM,gXAAIX,WAAAA,CAAS,oBAAoB;AACzC,EAAC","ignoreList":[0]}},
    {"offset": {"line": 801, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 807, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/canResizeImage.ts"],"sourcesContent":["export function canResizeImage(mimeType: string): boolean {\n  return ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/tiff'].indexOf(mimeType) > -1\n}\n"],"names":["canResizeImage","mimeType","indexOf"],"mappings":";;;AAAO,SAASA,eAAeC,QAAgB;IAC7C,OAAO;QAAC;QAAc;QAAa;QAAa;QAAc;KAAa,CAACC,OAAO,CAACD,YAAY,CAAC;AACnG","ignoreList":[0]}},
    {"offset": {"line": 819, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 825, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/tempFile.ts"],"sourcesContent":["import { promises as fsPromises } from 'fs'\nimport os from 'node:os'\nimport path from 'node:path'\nimport { v4 as uuid } from 'uuid'\n\nasync function runTask(temporaryPath: string, callback) {\n  try {\n    return await callback(temporaryPath)\n  } finally {\n    await fsPromises.rm(temporaryPath, { force: true, maxRetries: 2, recursive: true })\n  }\n}\n\ntype Options = {\n  extension?: string\n  name?: string\n}\n\nexport const temporaryFileTask = async (callback, options: Options = {}) => {\n  const filePath = await temporaryFile(options)\n  return runTask(filePath, callback)\n}\n\nasync function temporaryFile(options: Options) {\n  if (options.name) {\n    if (options.extension !== undefined && options.extension !== null) {\n      throw new Error('The `name` and `extension` options are mutually exclusive')\n    }\n\n    return path.join(await temporaryDirectory(), options.name)\n  }\n\n  return (\n    (await getPath()) +\n    (options.extension === undefined || options.extension === null\n      ? ''\n      : '.' + options.extension.replace(/^\\./, ''))\n  )\n}\n\nasync function temporaryDirectory({ prefix = '' } = {}) {\n  const directory = await getPath(prefix)\n  await fsPromises.mkdir(directory)\n  return directory\n}\n\nasync function getPath(prefix = ''): Promise<string> {\n  const temporaryDirectory = await fsPromises.realpath(os.tmpdir())\n  return path.join(temporaryDirectory, prefix + uuid())\n}\n"],"names":["promises","fsPromises","os","path","v4","uuid","runTask","temporaryPath","callback","rm","force","maxRetries","recursive","temporaryFileTask","options","filePath","temporaryFile","name","extension","undefined","Error","join","temporaryDirectory","getPath","replace","prefix","directory","mkdir","realpath","tmpdir"],"mappings":";;;AAAA,SAASA,YAAYC,UAAU,QAAQ,KAAI;AAC3C,OAAOC,QAAQ,UAAS;AACxB,OAAOC,UAAU,YAAW;AAC5B,SAASC,MAAMC,IAAI,QAAQ,OAAM;;;;;AAEjC,eAAeC,QAAQC,aAAqB,EAAEC,QAAQ;IACpD,IAAI;QACF,OAAO,MAAMA,SAASD;IACxB,SAAU;QACR,oGAAMN,WAAAA,CAAWQ,EAAE,CAACF,eAAe;YAAEG,OAAO;YAAMC,YAAY;YAAGC,WAAW;QAAK;IACnF;AACF;AAOO,MAAMC,oBAAoB,OAAOL,UAAUM,UAAmB,CAAC,CAAC;IACrE,MAAMC,WAAW,MAAMC,cAAcF;IACrC,OAAOR,QAAQS,UAAUP;AAC3B,EAAC;AAED,eAAeQ,cAAcF,OAAgB;IAC3C,IAAIA,QAAQG,IAAI,EAAE;QAChB,IAAIH,QAAQI,SAAS,KAAKC,aAAaL,QAAQI,SAAS,KAAK,MAAM;YACjE,MAAM,IAAIE,MAAM;QAClB;QAEA,yHAAOjB,UAAAA,CAAKkB,IAAI,CAAC,MAAMC,sBAAsBR,QAAQG,IAAI;IAC3D;IAEA,OACG,MAAMM,YACNT,CAAAA,QAAQI,SAAS,KAAKC,aAAaL,QAAQI,SAAS,KAAK,OACtD,KACA,MAAMJ,QAAQI,SAAS,CAACM,OAAO,CAAC,OAAO,GAAE;AAEjD;AAEA,eAAeF,mBAAmB,EAAEG,SAAS,EAAE,EAAE,GAAG,CAAC,CAAC;IACpD,MAAMC,YAAY,MAAMH,QAAQE;IAChC,oGAAMxB,WAAAA,CAAW0B,KAAK,CAACD;IACvB,OAAOA;AACT;AAEA,eAAeH,QAAQE,SAAS,EAAE;IAChC,MAAMH,qBAAqB,oGAAMrB,WAAAA,CAAW2B,QAAQ,+GAAC1B,UAAAA,CAAG2B,MAAM;IAC9D,yHAAO1B,UAAAA,CAAKkB,IAAI,CAACC,oBAAoBG,kPAASpB,KAAAA;AAChD","ignoreList":[0]}},
    {"offset": {"line": 869, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 875, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getImageSize.ts"],"sourcesContent":["import fs from 'fs'\nimport sizeOfImport from 'image-size'\nimport { promisify } from 'util'\n\nimport type { PayloadRequest } from '../types/index.js'\nimport type { ProbedImageSize } from './types.js'\n\nimport { temporaryFileTask } from './tempFile.js'\n\nconst { imageSize } = sizeOfImport\nconst imageSizePromise = promisify(imageSize)\n\nexport async function getImageSize(file: PayloadRequest['file']): Promise<ProbedImageSize> {\n  if (file.tempFilePath) {\n    return imageSizePromise(file.tempFilePath)\n  }\n\n  // Tiff file do not support buffers or streams, so we must write to file first\n  // then retrieve dimensions. https://github.com/image-size/image-size/issues/103\n  if (file.mimetype === 'image/tiff') {\n    const dimensions = await temporaryFileTask(\n      async (filepath: string) => {\n        fs.writeFileSync(filepath, file.data)\n        return imageSizePromise(filepath)\n      },\n      { extension: 'tiff' },\n    )\n    return dimensions\n  }\n\n  return imageSize(file.data)\n}\n"],"names":["fs","sizeOfImport","promisify","temporaryFileTask","imageSize","imageSizePromise","getImageSize","file","tempFilePath","mimetype","dimensions","filepath","writeFileSync","data","extension"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,kBAAkB,aAAY;AACrC,SAASC,SAAS,QAAQ,OAAM;AAKhC,SAASC,iBAAiB,QAAQ,gBAAe;;;;;AAEjD,MAAM,EAAEC,SAAS,EAAE,4MAAGH,UAAAA;AACtB,MAAMI,yHAAmBH,YAAAA,EAAUE;AAE5B,eAAeE,aAAaC,IAA4B;IAC7D,IAAIA,KAAKC,YAAY,EAAE;QACrB,OAAOH,iBAAiBE,KAAKC,YAAY;IAC3C;IAEA,8EAA8E;IAC9E,gFAAgF;IAChF,IAAID,KAAKE,QAAQ,KAAK,cAAc;QAClC,MAAMC,aAAa,uXAAMP,oBAAAA,EACvB,OAAOQ;0GACLX,UAAAA,CAAGY,aAAa,CAACD,UAAUJ,KAAKM,IAAI;YACpC,OAAOR,iBAAiBM;QAC1B,GACA;YAAEG,WAAW;QAAO;QAEtB,OAAOJ;IACT;IAEA,OAAON,UAAUG,KAAKM,IAAI;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 911, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/optionallyAppendMetadata.ts"],"sourcesContent":["import type { Sharp, Metadata as SharpMetadata } from 'sharp'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nexport type WithMetadata =\n  | ((options: { metadata: SharpMetadata; req: PayloadRequest }) => Promise<boolean>)\n  | boolean\n\nexport async function optionallyAppendMetadata({\n  req,\n  sharpFile,\n  withMetadata,\n}: {\n  req: PayloadRequest\n  sharpFile: Sharp\n  withMetadata: WithMetadata\n}): Promise<Sharp> {\n  const metadata = await sharpFile.metadata()\n\n  if (withMetadata === true) {\n    return sharpFile.withMetadata()\n  } else if (typeof withMetadata === 'function') {\n    const useMetadata = await withMetadata({ metadata, req })\n\n    if (useMetadata) {\n      return sharpFile.withMetadata()\n    }\n  }\n\n  return sharpFile\n}\n"],"names":["optionallyAppendMetadata","req","sharpFile","withMetadata","metadata","useMetadata"],"mappings":";;;AAQO,eAAeA,yBAAyB,EAC7CC,GAAG,EACHC,SAAS,EACTC,YAAY,EAKb;IACC,MAAMC,WAAW,MAAMF,UAAUE,QAAQ;IAEzC,IAAID,iBAAiB,MAAM;QACzB,OAAOD,UAAUC,YAAY;IAC/B,OAAO,IAAI,OAAOA,iBAAiB,YAAY;QAC7C,MAAME,cAAc,MAAMF,aAAa;YAAEC;YAAUH;QAAI;QAEvD,IAAII,aAAa;YACf,OAAOH,UAAUC,YAAY;QAC/B;IACF;IAEA,OAAOD;AACT","ignoreList":[0]}},
    {"offset": {"line": 929, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 935, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/docWithFilenameExists.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\ntype Args = {\n  collectionSlug: string\n  filename: string\n  path: string\n  req: PayloadRequest\n}\n\nconst docWithFilenameExists = async ({ collectionSlug, filename, req }: Args): Promise<boolean> => {\n  const doc = await req.payload.db.findOne({\n    collection: collectionSlug,\n    req,\n    where: {\n      filename: {\n        equals: filename,\n      },\n    },\n  })\n  if (doc) {\n    return true\n  }\n\n  return false\n}\n\nexport default docWithFilenameExists\n"],"names":["docWithFilenameExists","collectionSlug","filename","req","doc","payload","db","findOne","collection","where","equals"],"mappings":";;;AASA,MAAMA,wBAAwB,OAAO,EAAEC,cAAc,EAAEC,QAAQ,EAAEC,GAAG,EAAQ;IAC1E,MAAMC,MAAM,MAAMD,IAAIE,OAAO,CAACC,EAAE,CAACC,OAAO,CAAC;QACvCC,YAAYP;QACZE;QACAM,OAAO;YACLP,UAAU;gBACRQ,QAAQR;YACV;QACF;IACF;IACA,IAAIE,KAAK;QACP,OAAO;IACT;IAEA,OAAO;AACT;uCAEeJ,sBAAqB","ignoreList":[0]}},
    {"offset": {"line": 955, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 961, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fileExists.ts"],"sourcesContent":["import fs from 'fs'\n\nconst fileExists = async (filename: string): Promise<boolean> => {\n  try {\n    await fs.promises.stat(filename)\n\n    return true\n  } catch (err) {\n    return false\n  }\n}\n\nexport default fileExists\n"],"names":["fs","fileExists","filename","promises","stat","err"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;;AAEnB,MAAMC,aAAa,OAAOC;IACxB,IAAI;QACF,oGAAMF,UAAAA,CAAGG,QAAQ,CAACC,IAAI,CAACF;QAEvB,OAAO;IACT,EAAE,OAAOG,KAAK;QACZ,OAAO;IACT;AACF;uCAEeJ,WAAU","ignoreList":[0]}},
    {"offset": {"line": 976, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 982, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getSafeFilename.ts"],"sourcesContent":["import sanitize from 'sanitize-filename'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nimport docWithFilenameExists from './docWithFilenameExists.js'\nimport fileExists from './fileExists.js'\n\nconst incrementName = (name: string) => {\n  const extension = name.split('.').pop()\n  const baseFilename = sanitize(name.substring(0, name.lastIndexOf('.')) || name)\n  let incrementedName = baseFilename\n  const regex = /(.*)-(\\d+)$/\n  const found = baseFilename.match(regex)\n  if (found === null) {\n    incrementedName += '-1'\n  } else {\n    const matchedName = found[1]\n    const matchedNumber = found[2]\n    const incremented = Number(matchedNumber) + 1\n    incrementedName = `${matchedName}-${incremented}`\n  }\n  return `${incrementedName}.${extension}`\n}\n\ntype Args = {\n  collectionSlug: string\n  desiredFilename: string\n  req: PayloadRequest\n  staticPath: string\n}\n\nexport async function getSafeFileName({\n  collectionSlug,\n  desiredFilename,\n  req,\n  staticPath,\n}: Args): Promise<string> {\n  let modifiedFilename = desiredFilename\n\n  while (\n    (await docWithFilenameExists({\n      collectionSlug,\n      filename: modifiedFilename,\n      path: staticPath,\n      req,\n    })) ||\n    (await fileExists(`${staticPath}/${modifiedFilename}`))\n  ) {\n    modifiedFilename = incrementName(modifiedFilename)\n  }\n  return modifiedFilename\n}\n"],"names":["sanitize","docWithFilenameExists","fileExists","incrementName","name","extension","split","pop","baseFilename","substring","lastIndexOf","incrementedName","regex","found","match","matchedName","matchedNumber","incremented","Number","getSafeFileName","collectionSlug","desiredFilename","req","staticPath","modifiedFilename","filename","path"],"mappings":";;;AAAA,OAAOA,cAAc,oBAAmB;AAIxC,OAAOC,2BAA2B,6BAA4B;AAC9D,OAAOC,gBAAgB,kBAAiB;;;;AAExC,MAAMC,gBAAgB,CAACC;IACrB,MAAMC,YAAYD,KAAKE,KAAK,CAAC,KAAKC,GAAG;IACrC,MAAMC,kOAAeR,UAAAA,EAASI,KAAKK,SAAS,CAAC,GAAGL,KAAKM,WAAW,CAAC,SAASN;IAC1E,IAAIO,kBAAkBH;IACtB,MAAMI,QAAQ;IACd,MAAMC,QAAQL,aAAaM,KAAK,CAACF;IACjC,IAAIC,UAAU,MAAM;QAClBF,mBAAmB;IACrB,OAAO;QACL,MAAMI,cAAcF,KAAK,CAAC,EAAE;QAC5B,MAAMG,gBAAgBH,KAAK,CAAC,EAAE;QAC9B,MAAMI,cAAcC,OAAOF,iBAAiB;QAC5CL,kBAAkB,GAAGI,YAAY,CAAC,EAAEE,aAAa;IACnD;IACA,OAAO,GAAGN,gBAAgB,CAAC,EAAEN,WAAW;AAC1C;AASO,eAAec,gBAAgB,EACpCC,cAAc,EACdC,eAAe,EACfC,GAAG,EACHC,UAAU,EACL;IACL,IAAIC,mBAAmBH;IAEvB,MACG,oYAAMpB,UAAAA,EAAsB;QAC3BmB;QACAK,UAAUD;QACVE,MAAMH;QACND;IACF,MACC,yXAAMpB,UAAAA,EAAW,GAAGqB,WAAW,CAAC,EAAEC,kBAAkB,EACrD;QACAA,mBAAmBrB,cAAcqB;IACnC;IACA,OAAOA;AACT","ignoreList":[0]}},
    {"offset": {"line": 1019, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1025, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/cropImage.ts"],"sourcesContent":["import type { SharpOptions } from 'sharp'\n\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { WithMetadata } from './optionallyAppendMetadata.js'\nimport type { UploadEdits } from './types.js'\n\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\nexport const percentToPixel = (value, dimension) => {\n  return Math.floor((parseFloat(value) / 100) * dimension)\n}\n\ntype CropImageArgs = {\n  cropData: UploadEdits['crop']\n  dimensions: { height: number; width: number }\n  file: PayloadRequest['file']\n  heightInPixels: number\n  req?: PayloadRequest\n  sharp: SanitizedConfig['sharp']\n  widthInPixels: number\n  withMetadata?: WithMetadata\n}\nexport async function cropImage({\n  cropData,\n  dimensions,\n  file,\n  heightInPixels,\n  req,\n  sharp,\n  widthInPixels,\n  withMetadata,\n}: CropImageArgs) {\n  try {\n    const { x, y } = cropData\n\n    const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n\n    const sharpOptions: SharpOptions = {}\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    const formattedCropData = {\n      height: Number(heightInPixels),\n      left: percentToPixel(x, dimensions.width),\n      top: percentToPixel(y, dimensions.height),\n      width: Number(widthInPixels),\n    }\n\n    let cropped = sharp(file.tempFilePath || file.data, sharpOptions).extract(formattedCropData)\n\n    cropped = await optionallyAppendMetadata({\n      req,\n      sharpFile: cropped,\n      withMetadata,\n    })\n\n    return await cropped.toBuffer({\n      resolveWithObject: true,\n    })\n  } catch (error) {\n    console.error(`Error cropping image:`, error)\n    throw error\n  }\n}\n"],"names":["optionallyAppendMetadata","percentToPixel","value","dimension","Math","floor","parseFloat","cropImage","cropData","dimensions","file","heightInPixels","req","sharp","widthInPixels","withMetadata","x","y","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","formattedCropData","height","Number","left","width","top","cropped","tempFilePath","data","extract","sharpFile","toBuffer","resolveWithObject","error","console"],"mappings":";;;;AAOA,SAASA,wBAAwB,QAAQ,gCAA+B;;AAEjE,MAAMC,iBAAiB,CAACC,OAAOC;IACpC,OAAOC,KAAKC,KAAK,CAAEC,WAAWJ,SAAS,MAAOC;AAChD,EAAC;AAYM,eAAeI,UAAU,EAC9BC,QAAQ,EACRC,UAAU,EACVC,IAAI,EACJC,cAAc,EACdC,GAAG,EACHC,KAAK,EACLC,aAAa,EACbC,YAAY,EACE;IACd,IAAI;QACF,MAAM,EAAEC,CAAC,EAAEC,CAAC,EAAE,GAAGT;QAEjB,MAAMU,qBAAqB;YAAC;YAAc;YAAa;SAAa,CAACC,QAAQ,CAACT,KAAKU,QAAQ;QAE3F,MAAMC,eAA6B,CAAC;QAEpC,IAAIH,oBAAoB;YACtBG,aAAaC,QAAQ,GAAG;QAC1B;QAEA,MAAMC,oBAAoB;YACxBC,QAAQC,OAAOd;YACfe,MAAMzB,eAAee,GAAGP,WAAWkB,KAAK;YACxCC,KAAK3B,eAAegB,GAAGR,WAAWe,MAAM;YACxCG,OAAOF,OAAOX;QAChB;QAEA,IAAIe,UAAUhB,MAAMH,KAAKoB,YAAY,IAAIpB,KAAKqB,IAAI,EAAEV,cAAcW,OAAO,CAACT;QAE1EM,UAAU,uYAAM7B,2BAAAA,EAAyB;YACvCY;YACAqB,WAAWJ;YACXd;QACF;QAEA,OAAO,MAAMc,QAAQK,QAAQ,CAAC;YAC5BC,mBAAmB;QACrB;IACF,EAAE,OAAOC,OAAO;QACdC,QAAQD,KAAK,CAAC,CAAC,qBAAqB,CAAC,EAAEA;QACvC,MAAMA;IACR;AACF","ignoreList":[0]}},
    {"offset": {"line": 1066, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1072, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/imageResizer.ts"],"sourcesContent":["import type { Sharp, Metadata as SharpMetadata, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs'\nimport sanitize from 'sanitize-filename'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SharpDependency } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { WithMetadata } from './optionallyAppendMetadata.js'\nimport type {\n  FileSize,\n  FileSizes,\n  FileToSave,\n  ImageSize,\n  ProbedImageSize,\n  UploadEdits,\n} from './types.js'\n\nimport { isNumber } from '../utilities/isNumber.js'\nimport fileExists from './fileExists.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\ntype ResizeArgs = {\n  config: SanitizedCollectionConfig\n  dimensions: ProbedImageSize\n  file: PayloadRequest['file']\n  mimeType: string\n  req: PayloadRequest\n  savedFilename: string\n  sharp?: SharpDependency\n  staticPath: string\n  uploadEdits?: UploadEdits\n  withMetadata?: WithMetadata\n}\n\n/** Result from resizing and transforming the requested image sizes */\ntype ImageSizesResult = {\n  focalPoint?: UploadEdits['focalPoint']\n  sizeData: FileSizes\n  sizesToSave: FileToSave[]\n}\n\ntype SanitizedImageData = {\n  ext: string\n  name: string\n}\n\n/**\n * Sanitize the image name and extract the extension from the source image\n *\n * @param sourceImage - the source image\n * @returns the sanitized name and extension\n */\nconst getSanitizedImageData = (sourceImage: string): SanitizedImageData => {\n  const extension = sourceImage.split('.').pop()\n  const name = sanitize(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage)\n  return { name, ext: extension }\n}\n\n/**\n * Create a new image name based on the output image name, the dimensions and\n * the extension.\n *\n * Ignore the fact that duplicate names could happen if the there is one\n * size with `width AND height` and one with only `height OR width`. Because\n * space is expensive, we will reuse the same image for both sizes.\n *\n * @param outputImageName - the sanitized image name\n * @param bufferInfo - the buffer info\n * @param extension - the extension to use\n * @returns the new image name that is not taken\n */\ntype CreateImageNameArgs = {\n  extension: string\n  height: number\n  outputImageName: string\n  width: number\n}\nconst createImageName = ({\n  extension,\n  height,\n  outputImageName,\n  width,\n}: CreateImageNameArgs): string => {\n  return `${outputImageName}-${width}x${height}.${extension}`\n}\n\ntype CreateResultArgs = {\n  filename?: FileSize['filename']\n  filesize?: FileSize['filesize']\n  height?: FileSize['height']\n  mimeType?: FileSize['mimeType']\n  name: string\n  sizesToSave?: FileToSave[]\n  width?: FileSize['width']\n}\n\n/**\n * Create the result object for the image resize operation based on the\n * provided parameters. If the name is not provided, an empty result object\n * is returned.\n *\n * @param name - the name of the image\n * @param filename - the filename of the image\n * @param width - the width of the image\n * @param height - the height of the image\n * @param filesize - the filesize of the image\n * @param mimeType - the mime type of the image\n * @param sizesToSave - the sizes to save\n * @returns the result object\n */\nconst createResult = ({\n  name,\n  filename = null,\n  filesize = null,\n  height = null,\n  mimeType = null,\n  sizesToSave = [],\n  width = null,\n}: CreateResultArgs): ImageSizesResult => {\n  return {\n    sizeData: {\n      [name]: {\n        filename,\n        filesize,\n        height,\n        mimeType,\n        width,\n      },\n    },\n    sizesToSave,\n  }\n}\n\n/**\n * Determine whether or not to resize the image.\n * - resize using image config\n * - resize using image config with focal adjustments\n * - do not resize at all\n *\n * `imageResizeConfig.withoutEnlargement`:\n * - undefined [default]: uploading images with smaller width AND height than the image size will return null\n * - false: always enlarge images to the image size\n * - true: if the image is smaller than the image size, return the original image\n *\n * `imageResizeConfig.withoutReduction`:\n * - false [default]: always enlarge images to the image size\n * - true: if the image is smaller than the image size, return the original image\n *\n * @return 'omit' | 'resize' | 'resizeWithFocalPoint'\n */\nconst getImageResizeAction = ({\n  dimensions: originalImage,\n  hasFocalPoint,\n  imageResizeConfig,\n}: {\n  dimensions: ProbedImageSize\n  hasFocalPoint?: boolean\n  imageResizeConfig: ImageSize\n}): 'omit' | 'resize' | 'resizeWithFocalPoint' => {\n  const {\n    fit,\n    height: targetHeight,\n    width: targetWidth,\n    withoutEnlargement,\n    withoutReduction,\n  } = imageResizeConfig\n\n  // prevent upscaling by default when x and y are both smaller than target image size\n  if (targetHeight && targetWidth) {\n    const originalImageIsSmallerXAndY =\n      originalImage.width < targetWidth && originalImage.height < targetHeight\n    if (withoutEnlargement === undefined && originalImageIsSmallerXAndY) {\n      return 'omit' // prevent image size from being enlarged\n    }\n  }\n\n  const originalImageIsSmallerXOrY =\n    originalImage.width < targetWidth || originalImage.height < targetHeight\n  if (fit === 'contain' || fit === 'inside') {\n    return 'resize'\n  }\n  if (!isNumber(targetHeight) && !isNumber(targetWidth)) {\n    return 'resize'\n  }\n\n  const targetAspectRatio = targetWidth / targetHeight\n  const originalAspectRatio = originalImage.width / originalImage.height\n  if (originalAspectRatio === targetAspectRatio) {\n    return 'resize'\n  }\n\n  if (withoutEnlargement && originalImageIsSmallerXOrY) {\n    return 'resize'\n  }\n  if (withoutReduction && !originalImageIsSmallerXOrY) {\n    return 'resize'\n  }\n\n  return hasFocalPoint ? 'resizeWithFocalPoint' : 'resize'\n}\n\n/**\n * Sanitize the resize config. If the resize config has the `withoutReduction`\n * property set to true, the `fit` and `position` properties will be set to `contain`\n * and `top left` respectively.\n *\n * @param resizeConfig - the resize config\n * @returns a sanitized resize config\n */\nconst sanitizeResizeConfig = (resizeConfig: ImageSize): ImageSize => {\n  if (resizeConfig.withoutReduction) {\n    return {\n      ...resizeConfig,\n      // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595\n      fit: resizeConfig?.fit || 'contain',\n      position: resizeConfig?.position || 'left top',\n    }\n  }\n  return resizeConfig\n}\n\n/**\n * Used to extract height from images, animated or not.\n *\n * @param sharpMetadata - the sharp metadata\n * @returns the height of the image\n */\nfunction extractHeightFromImage(sharpMetadata: SharpMetadata): number {\n  if (sharpMetadata?.pages) {\n    return sharpMetadata.height / sharpMetadata.pages\n  }\n  return sharpMetadata.height\n}\n\n/**\n * For the provided image sizes, handle the resizing and the transforms\n * (format, trim, etc.) of each requested image size and return the result object.\n * This only handles the image sizes. The transforms of the original image\n * are handled in {@link ./generateFileData.ts}.\n *\n * The image will be resized according to the provided\n * resize config. If no image sizes are requested, the resolved data will be empty.\n * For every image that does not need to be resized, a result object with `null`\n * parameters will be returned.\n *\n * @param resizeConfig - the resize config\n * @returns the result of the resize operation(s)\n */\nexport async function resizeAndTransformImageSizes({\n  config,\n  dimensions,\n  file,\n  mimeType,\n  req,\n  savedFilename,\n  sharp,\n  staticPath,\n  uploadEdits,\n  withMetadata,\n}: ResizeArgs): Promise<ImageSizesResult> {\n  const { focalPoint: focalPointEnabled = true, imageSizes } = config.upload\n\n  // Focal point adjustments\n  const incomingFocalPoint = uploadEdits.focalPoint\n    ? {\n        x: isNumber(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,\n        y: isNumber(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50,\n      }\n    : undefined\n\n  const defaultResult: ImageSizesResult = {\n    ...(focalPointEnabled && incomingFocalPoint && { focalPoint: incomingFocalPoint }),\n    sizeData: {},\n    sizesToSave: [],\n  }\n\n  if (!imageSizes || !sharp) {\n    return defaultResult\n  }\n\n  // Determine if the file is animated\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const sharpOptions: SharpOptions = {}\n\n  if (fileIsAnimatedType) {\n    sharpOptions.animated = true\n  }\n\n  const sharpBase: Sharp | undefined = sharp(file.tempFilePath || file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n  const originalImageMeta = await sharpBase.metadata()\n\n  let adjustedDimensions = { ...dimensions }\n\n  // Images with an exif orientation of 5, 6, 7, or 8 are auto-rotated by sharp\n  // Need to adjust the dimensions to match the original image\n  if ([5, 6, 7, 8].includes(originalImageMeta.orientation)) {\n    adjustedDimensions = {\n      ...dimensions,\n      height: dimensions.width,\n      width: dimensions.height,\n    }\n  }\n\n  const resizeImageMeta = {\n    height: extractHeightFromImage(originalImageMeta),\n    width: originalImageMeta.width,\n  }\n\n  const results: ImageSizesResult[] = await Promise.all(\n    imageSizes.map(async (imageResizeConfig): Promise<ImageSizesResult> => {\n      imageResizeConfig = sanitizeResizeConfig(imageResizeConfig)\n\n      const resizeAction = getImageResizeAction({\n        dimensions,\n        hasFocalPoint: Boolean(incomingFocalPoint),\n        imageResizeConfig,\n      })\n      if (resizeAction === 'omit') {\n        return createResult({ name: imageResizeConfig.name })\n      }\n\n      const imageToResize = sharpBase.clone()\n      let resized = imageToResize\n\n      if (resizeAction === 'resizeWithFocalPoint') {\n        let { height: resizeHeight, width: resizeWidth } = imageResizeConfig\n\n        const originalAspectRatio = adjustedDimensions.width / adjustedDimensions.height\n\n        // Calculate resizeWidth based on original aspect ratio if it's undefined\n        if (resizeHeight && !resizeWidth) {\n          resizeWidth = Math.round(resizeHeight * originalAspectRatio)\n        }\n\n        // Calculate resizeHeight based on original aspect ratio if it's undefined\n        if (resizeWidth && !resizeHeight) {\n          resizeHeight = Math.round(resizeWidth / originalAspectRatio)\n        }\n\n        if (!resizeHeight) {\n          resizeHeight = resizeImageMeta.height\n        }\n        if (!resizeWidth) {\n          resizeWidth = resizeImageMeta.width\n        }\n\n        const resizeAspectRatio = resizeWidth / resizeHeight\n        const prioritizeHeight = resizeAspectRatio < originalAspectRatio\n        // Scales the image before extracting from it\n        resized = imageToResize.resize({\n          height: prioritizeHeight ? resizeHeight : undefined,\n          width: prioritizeHeight ? undefined : resizeWidth,\n        })\n\n        const metadataAppendedFile = await optionallyAppendMetadata({\n          req,\n          sharpFile: resized,\n          withMetadata,\n        })\n\n        // Must read from buffer, resized.metadata will return the original image metadata\n        const { info } = await metadataAppendedFile.toBuffer({ resolveWithObject: true })\n\n        resizeImageMeta.height = extractHeightFromImage({\n          ...originalImageMeta,\n          height: info.height,\n        })\n        resizeImageMeta.width = info.width\n\n        const halfResizeX = resizeWidth / 2\n        const xFocalCenter = resizeImageMeta.width * (incomingFocalPoint.x / 100)\n        const calculatedRightPixelBound = xFocalCenter + halfResizeX\n        let leftBound = xFocalCenter - halfResizeX\n\n        // if the right bound is greater than the image width, adjust the left bound\n        // keeping focus on the right\n        if (calculatedRightPixelBound > resizeImageMeta.width) {\n          leftBound = resizeImageMeta.width - resizeWidth\n        }\n\n        // if the left bound is less than 0, adjust the left bound to 0\n        // keeping the focus on the left\n        if (leftBound < 0) {\n          leftBound = 0\n        }\n\n        const halfResizeY = resizeHeight / 2\n        const yFocalCenter = resizeImageMeta.height * (incomingFocalPoint.y / 100)\n        const calculatedBottomPixelBound = yFocalCenter + halfResizeY\n        let topBound = yFocalCenter - halfResizeY\n\n        // if the bottom bound is greater than the image height, adjust the top bound\n        // keeping the image as far right as possible\n        if (calculatedBottomPixelBound > resizeImageMeta.height) {\n          topBound = resizeImageMeta.height - resizeHeight\n        }\n\n        // if the top bound is less than 0, adjust the top bound to 0\n        // keeping the image focus near the top\n        if (topBound < 0) {\n          topBound = 0\n        }\n\n        resized = resized.extract({\n          height: resizeHeight,\n          left: Math.floor(leftBound),\n          top: Math.floor(topBound),\n          width: resizeWidth,\n        })\n      } else {\n        resized = imageToResize.resize(imageResizeConfig)\n      }\n\n      if (imageResizeConfig.formatOptions) {\n        resized = resized.toFormat(\n          imageResizeConfig.formatOptions.format,\n          imageResizeConfig.formatOptions.options,\n        )\n      }\n\n      if (imageResizeConfig.trimOptions) {\n        resized = resized.trim(imageResizeConfig.trimOptions)\n      }\n\n      const metadataAppendedFile = await optionallyAppendMetadata({\n        req,\n        sharpFile: resized,\n        withMetadata,\n      })\n\n      const { data: bufferData, info: bufferInfo } = await metadataAppendedFile.toBuffer({\n        resolveWithObject: true,\n      })\n\n      const sanitizedImage = getSanitizedImageData(savedFilename)\n\n      if (req.payloadUploadSizes) {\n        req.payloadUploadSizes[imageResizeConfig.name] = bufferData\n      }\n\n      const mimeInfo = await fileTypeFromBuffer(bufferData)\n\n      const imageNameWithDimensions = imageResizeConfig.generateImageName\n        ? imageResizeConfig.generateImageName({\n            extension: mimeInfo?.ext || sanitizedImage.ext,\n            height: extractHeightFromImage({\n              ...originalImageMeta,\n              height: bufferInfo.height,\n            }),\n            originalName: sanitizedImage.name,\n            sizeName: imageResizeConfig.name,\n            width: bufferInfo.width,\n          })\n        : createImageName({\n            extension: mimeInfo?.ext || sanitizedImage.ext,\n            height: extractHeightFromImage({\n              ...originalImageMeta,\n              height: bufferInfo.height,\n            }),\n            outputImageName: sanitizedImage.name,\n            width: bufferInfo.width,\n          })\n\n      const imagePath = `${staticPath}/${imageNameWithDimensions}`\n\n      if (await fileExists(imagePath)) {\n        try {\n          fs.unlinkSync(imagePath)\n        } catch {\n          // Ignore unlink errors\n        }\n      }\n\n      const { height, size, width } = bufferInfo\n      return createResult({\n        name: imageResizeConfig.name,\n        filename: imageNameWithDimensions,\n        filesize: size,\n        height:\n          fileIsAnimatedType && originalImageMeta.pages ? height / originalImageMeta.pages : height,\n        mimeType: mimeInfo?.mime || mimeType,\n        sizesToSave: [{ buffer: bufferData, path: imagePath }],\n        width,\n      })\n    }),\n  )\n\n  return results.reduce(\n    (acc, result) => {\n      Object.assign(acc.sizeData, result.sizeData)\n      acc.sizesToSave.push(...result.sizesToSave)\n      return acc\n    },\n    { ...defaultResult },\n  )\n}\n"],"names":["fileTypeFromBuffer","fs","sanitize","isNumber","fileExists","optionallyAppendMetadata","getSanitizedImageData","sourceImage","extension","split","pop","name","substring","lastIndexOf","ext","createImageName","height","outputImageName","width","createResult","filename","filesize","mimeType","sizesToSave","sizeData","getImageResizeAction","dimensions","originalImage","hasFocalPoint","imageResizeConfig","fit","targetHeight","targetWidth","withoutEnlargement","withoutReduction","originalImageIsSmallerXAndY","undefined","originalImageIsSmallerXOrY","targetAspectRatio","originalAspectRatio","sanitizeResizeConfig","resizeConfig","position","extractHeightFromImage","sharpMetadata","pages","resizeAndTransformImageSizes","config","file","req","savedFilename","sharp","staticPath","uploadEdits","withMetadata","focalPoint","focalPointEnabled","imageSizes","upload","incomingFocalPoint","x","Math","round","y","defaultResult","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","sharpBase","tempFilePath","data","rotate","originalImageMeta","metadata","adjustedDimensions","orientation","resizeImageMeta","results","Promise","all","map","resizeAction","Boolean","imageToResize","clone","resized","resizeHeight","resizeWidth","resizeAspectRatio","prioritizeHeight","resize","metadataAppendedFile","sharpFile","info","toBuffer","resolveWithObject","halfResizeX","xFocalCenter","calculatedRightPixelBound","leftBound","halfResizeY","yFocalCenter","calculatedBottomPixelBound","topBound","extract","left","floor","top","formatOptions","toFormat","format","options","trimOptions","trim","bufferData","bufferInfo","sanitizedImage","payloadUploadSizes","mimeInfo","imageNameWithDimensions","generateImageName","originalName","sizeName","imagePath","unlinkSync","size","mime","buffer","path","reduce","acc","result","Object","assign","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1414, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1420, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/generateFileData.ts"],"sourcesContent":["import type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs'\nimport { mkdirSync } from 'node:fs'\nimport sanitize from 'sanitize-filename'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'\n\nimport { FileRetrievalError, FileUploadError, MissingFile } from '../errors/index.js'\nimport { canResizeImage } from './canResizeImage.js'\nimport { cropImage } from './cropImage.js'\nimport { getExternalFile } from './getExternalFile.js'\nimport { getFileByPath } from './getFileByPath.js'\nimport { getImageSize } from './getImageSize.js'\nimport { getSafeFileName } from './getSafeFilename.js'\nimport { resizeAndTransformImageSizes } from './imageResizer.js'\nimport { isImage } from './isImage.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\ntype Args<T> = {\n  collection: Collection\n  config: SanitizedConfig\n  data: T\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc?: T\n  overwriteExistingFiles?: boolean\n  req: PayloadRequest\n  throwOnMissingFile?: boolean\n}\n\ntype Result<T> = Promise<{\n  data: T\n  files: FileToSave[]\n}>\n\nexport const generateFileData = async <T>({\n  collection: { config: collectionConfig },\n  data,\n  isDuplicating,\n  operation,\n  originalDoc,\n  overwriteExistingFiles,\n  req,\n  throwOnMissingFile,\n}: Args<T>): Result<T> => {\n  if (!collectionConfig.upload) {\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  const { sharp } = req.payload.config\n\n  let file = req.file\n\n  const uploadEdits = parseUploadEditsFromReqOrIncomingData({\n    data,\n    isDuplicating,\n    operation,\n    originalDoc,\n    req,\n  })\n\n  const {\n    disableLocalStorage,\n    focalPoint: focalPointEnabled = true,\n    formatOptions,\n    imageSizes,\n    resizeOptions,\n    staticDir,\n    trimOptions,\n    withMetadata,\n  } = collectionConfig.upload\n\n  const staticPath = staticDir\n\n  const incomingFileData = isDuplicating ? originalDoc : data\n\n  if (!file && uploadEdits && incomingFileData) {\n    const { filename, url } = incomingFileData as FileData\n\n    try {\n      if (url && url.startsWith('/') && !disableLocalStorage) {\n        const filePath = `${staticPath}/${filename}`\n        const response = await getFileByPath(filePath)\n        file = response\n        overwriteExistingFiles = true\n      } else if (filename && url) {\n        file = await getExternalFile({\n          data: incomingFileData as FileData,\n          req,\n          uploadConfig: collectionConfig.upload,\n        })\n        overwriteExistingFiles = true\n      }\n    } catch (err: unknown) {\n      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)\n    }\n  }\n\n  if (isDuplicating) {\n    overwriteExistingFiles = false\n  }\n\n  if (!file) {\n    if (throwOnMissingFile) {\n      throw new MissingFile(req.t)\n    }\n\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  if (!disableLocalStorage) {\n    mkdirSync(staticPath, { recursive: true })\n  }\n\n  let newData = data\n  const filesToSave: FileToSave[] = []\n  const fileData: Partial<FileData> = {}\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const cropData =\n    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined\n\n  try {\n    const fileSupportsResize = canResizeImage(file.mimetype)\n    let fsSafeName: string\n    let sharpFile: Sharp | undefined\n    let dimensions: ProbedImageSize | undefined\n    let fileBuffer: { data: Buffer; info: OutputInfo }\n    let ext\n    let mime: string\n    const fileHasAdjustments =\n      fileSupportsResize &&\n      Boolean(resizeOptions || formatOptions || imageSizes || trimOptions || file.tempFilePath)\n\n    const sharpOptions: SharpOptions = {}\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {\n      if (file.tempFilePath) {\n        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      } else {\n        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      }\n\n      if (fileHasAdjustments) {\n        if (resizeOptions) {\n          sharpFile = sharpFile.resize(resizeOptions)\n        }\n        if (formatOptions) {\n          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)\n        }\n        if (trimOptions) {\n          sharpFile = sharpFile.trim(trimOptions)\n        }\n      }\n    }\n\n    if (fileSupportsResize || isImage(file.mimetype)) {\n      dimensions = await getImageSize(file)\n      fileData.width = dimensions.width\n      fileData.height = dimensions.height\n    }\n\n    if (sharpFile) {\n      const metadata = await sharpFile.metadata()\n      sharpFile = await optionallyAppendMetadata({\n        req,\n        sharpFile,\n        withMetadata,\n      })\n      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })\n      ;({ ext, mime } = await fileTypeFromBuffer(fileBuffer.data)) // This is getting an incorrect gif height back.\n      fileData.width = fileBuffer.info.width\n      fileData.height = fileBuffer.info.height\n      fileData.filesize = fileBuffer.info.size\n\n      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages\n      if (metadata.pages) {\n        fileData.height = fileBuffer.info.height / metadata.pages\n        fileData.filesize = fileBuffer.data.length\n      }\n    } else {\n      mime = file.mimetype\n      fileData.filesize = file.size\n\n      if (file.name.includes('.')) {\n        ext = file.name.split('.').pop().split('?')[0]\n      } else {\n        ext = ''\n      }\n    }\n\n    // Adjust SVG mime type. fromBuffer modifies it.\n    if (mime === 'application/xml' && ext === 'svg') {\n      mime = 'image/svg+xml'\n    }\n    fileData.mimeType = mime\n\n    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)\n    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`\n\n    if (!overwriteExistingFiles) {\n      fsSafeName = await getSafeFileName({\n        collectionSlug: collectionConfig.slug,\n        desiredFilename: fsSafeName,\n        req,\n        staticPath,\n      })\n    }\n\n    fileData.filename = fsSafeName\n    let fileForResize = file\n\n    if (cropData && sharp) {\n      const { data: croppedImage, info } = await cropImage({\n        cropData,\n        dimensions,\n        file,\n        heightInPixels: uploadEdits.heightInPixels,\n        req,\n        sharp,\n        widthInPixels: uploadEdits.widthInPixels,\n        withMetadata,\n      })\n\n      // Apply resize after cropping to ensure it conforms to resizeOptions\n      if (resizeOptions) {\n        const resizedAfterCrop = await sharp(croppedImage)\n          .resize({\n            fit: resizeOptions?.fit || 'cover',\n            height: resizeOptions?.height,\n            position: resizeOptions?.position || 'center',\n            width: resizeOptions?.width,\n          })\n          .toBuffer({ resolveWithObject: true })\n\n        filesToSave.push({\n          buffer: resizedAfterCrop.data,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...fileForResize,\n          data: resizedAfterCrop.data,\n          size: resizedAfterCrop.info.size,\n        }\n\n        fileData.width = resizedAfterCrop.info.width\n        fileData.height = resizedAfterCrop.info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile.metadata()\n          fileData.height = metadata.pages\n            ? resizedAfterCrop.info.height / metadata.pages\n            : resizedAfterCrop.info.height\n        }\n        fileData.filesize = resizedAfterCrop.info.size\n      } else {\n        // If resizeOptions is not present, just save the cropped image\n        filesToSave.push({\n          buffer: croppedImage,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...file,\n          data: croppedImage,\n          size: info.size,\n        }\n\n        fileData.width = info.width\n        fileData.height = info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile.metadata()\n          fileData.height = metadata.pages ? info.height / metadata.pages : info.height\n        }\n        fileData.filesize = info.size\n      }\n\n      if (file.tempFilePath) {\n        await fs.promises.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path\n      } else {\n        req.file = fileForResize\n      }\n    } else {\n      filesToSave.push({\n        buffer: fileBuffer?.data || file.data,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      // If using temp files and the image is being resized, write the file to the temp path\n      if (fileBuffer?.data || file.data.length > 0) {\n        if (file.tempFilePath) {\n          await fs.promises.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path\n        } else {\n          // Assign the _possibly modified_ file to the request object\n          req.file = {\n            ...file,\n            data: fileBuffer?.data || file.data,\n            size: fileBuffer?.info.size,\n          }\n        }\n      }\n    }\n\n    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {\n      req.payloadUploadSizes = {}\n      const { focalPoint, sizeData, sizesToSave } = await resizeAndTransformImageSizes({\n        config: collectionConfig,\n        dimensions: !cropData\n          ? dimensions\n          : {\n              ...dimensions,\n              height: fileData.height,\n              width: fileData.width,\n            },\n        file: fileForResize,\n        mimeType: fileData.mimeType,\n        req,\n        savedFilename: fsSafeName || file.name,\n        sharp,\n        staticPath,\n        uploadEdits,\n        withMetadata,\n      })\n\n      fileData.sizes = sizeData\n      fileData.focalX = focalPoint?.x\n      fileData.focalY = focalPoint?.y\n      filesToSave.push(...sizesToSave)\n    }\n  } catch (err) {\n    req.payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n\n  newData = {\n    ...newData,\n    ...fileData,\n  }\n\n  return {\n    data: newData,\n    files: filesToSave,\n  }\n}\n\n/**\n * Parse upload edits from req or incoming data\n */\nfunction parseUploadEditsFromReqOrIncomingData(args: {\n  data: unknown\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc: unknown\n  req: PayloadRequest\n}): UploadEdits {\n  const { data, isDuplicating, operation, originalDoc, req } = args\n\n  // Get intended focal point change from query string or incoming data\n  const uploadEdits =\n    req.query?.uploadEdits && typeof req.query.uploadEdits === 'object'\n      ? (req.query.uploadEdits as UploadEdits)\n      : {}\n\n  if (uploadEdits.focalPoint) {\n    return uploadEdits\n  }\n\n  const incomingData = data as FileData\n  const origDoc = originalDoc as FileData\n\n  if (origDoc && 'focalX' in origDoc && 'focalY' in origDoc) {\n    // If no change in focal point, return undefined.\n    // This prevents a refocal operation triggered from admin, because it always sends the focal point.\n    if (incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {\n      return undefined\n    }\n\n    if (isDuplicating) {\n      uploadEdits.focalPoint = {\n        x: incomingData?.focalX || origDoc.focalX,\n        y: incomingData?.focalY || origDoc.focalX,\n      }\n    }\n  }\n\n  if (incomingData?.focalX && incomingData?.focalY) {\n    uploadEdits.focalPoint = {\n      x: incomingData.focalX,\n      y: incomingData.focalY,\n    }\n    return uploadEdits\n  }\n\n  // If no focal point is set, default to center\n  if (operation === 'create') {\n    uploadEdits.focalPoint = {\n      x: 50,\n      y: 50,\n    }\n  }\n\n  return uploadEdits\n}\n"],"names":["fileTypeFromBuffer","fs","mkdirSync","sanitize","FileRetrievalError","FileUploadError","MissingFile","canResizeImage","cropImage","getExternalFile","getFileByPath","getImageSize","getSafeFileName","resizeAndTransformImageSizes","isImage","optionallyAppendMetadata","generateFileData","collection","config","collectionConfig","data","isDuplicating","operation","originalDoc","overwriteExistingFiles","req","throwOnMissingFile","upload","files","sharp","payload","file","uploadEdits","parseUploadEditsFromReqOrIncomingData","disableLocalStorage","focalPoint","focalPointEnabled","formatOptions","imageSizes","resizeOptions","staticDir","trimOptions","withMetadata","staticPath","incomingFileData","filename","url","startsWith","filePath","response","uploadConfig","err","t","Error","message","undefined","recursive","newData","filesToSave","fileData","fileIsAnimatedType","includes","mimetype","cropData","crop","fileSupportsResize","fsSafeName","sharpFile","dimensions","fileBuffer","ext","mime","fileHasAdjustments","Boolean","tempFilePath","sharpOptions","animated","rotate","resize","toFormat","format","options","trim","width","height","metadata","toBuffer","resolveWithObject","info","filesize","size","pages","length","name","split","pop","mimeType","baseFilename","substring","lastIndexOf","collectionSlug","slug","desiredFilename","fileForResize","croppedImage","heightInPixels","widthInPixels","resizedAfterCrop","fit","position","push","buffer","path","promises","writeFile","Array","isArray","payloadUploadSizes","sizeData","sizesToSave","savedFilename","sizes","focalX","x","focalY","y","logger","error","args","query","incomingData","origDoc"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1760, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1766, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/saveBufferToFile.ts"],"sourcesContent":["import fs from 'fs'\nimport { Readable } from 'stream'\n\n/**\n * Save buffer data to a file.\n * @param {Buffer} buffer - buffer to save to a file.\n * @param {string} filePath - path to a file.\n */\nconst saveBufferToFile = async (buffer: Buffer, filePath: string): Promise<void> => {\n  // Setup readable stream from buffer.\n  let streamData = buffer\n  const readStream = new Readable()\n  readStream._read = () => {\n    readStream.push(streamData)\n    streamData = null\n  }\n  // Setup file system writable stream.\n  return fs.writeFileSync(filePath, buffer)\n}\n\nexport default saveBufferToFile\n"],"names":["fs","Readable","saveBufferToFile","buffer","filePath","streamData","readStream","_read","push","writeFileSync"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,QAAQ,QAAQ,SAAQ;;;AAEjC;;;;CAIC,GACD,MAAMC,mBAAmB,OAAOC,QAAgBC;IAC9C,qCAAqC;IACrC,IAAIC,aAAaF;IACjB,MAAMG,aAAa,0GAAIL,WAAAA;IACvBK,WAAWC,KAAK,GAAG;QACjBD,WAAWE,IAAI,CAACH;QAChBA,aAAa;IACf;IACA,qCAAqC;IACrC,qGAAOL,UAAAA,CAAGS,aAAa,CAACL,UAAUD;AACpC;uCAEeD,iBAAgB","ignoreList":[0]}},
    {"offset": {"line": 1790, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1796, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/uploadFiles.ts"],"sourcesContent":["import type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileToSave } from './types.js'\n\nimport { FileUploadError } from '../errors/index.js'\nimport saveBufferToFile from './saveBufferToFile.js'\n\nexport const uploadFiles = async (\n  payload: Payload,\n  files: FileToSave[],\n  req: PayloadRequest,\n): Promise<void> => {\n  try {\n    await Promise.all(\n      files.map(async ({ buffer, path }) => {\n        await saveBufferToFile(buffer, path)\n      }),\n    )\n  } catch (err) {\n    payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n}\n"],"names":["FileUploadError","saveBufferToFile","uploadFiles","payload","files","req","Promise","all","map","buffer","path","err","logger","error","t"],"mappings":";;;AAKA,OAAOC,sBAAsB,wBAAuB;AADpD,SAASD,eAAe,QAAQ,qBAAoB;;;AAG7C,MAAME,cAAc,OACzBC,SACAC,OACAC;IAEA,IAAI;QACF,MAAMC,QAAQC,GAAG,CACfH,MAAMI,GAAG,CAAC,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAE;YAC/B,+XAAMT,UAAAA,EAAiBQ,QAAQC;QACjC;IAEJ,EAAE,OAAOC,KAAK;QACZR,QAAQS,MAAM,CAACC,KAAK,CAACF;QACrB,MAAM,uXAAIX,kBAAAA,CAAgBK,IAAIS,CAAC;IACjC;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1813, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1819, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/unlinkTempFiles.ts"],"sourcesContent":["import fs from 'fs'\nimport { promisify } from 'util'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { mapAsync } from '../utilities/mapAsync.js'\n\nconst unlinkFile = promisify(fs.unlink)\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  req: PayloadRequest\n}\n/**\n * Cleanup temp files after operation lifecycle\n */\nexport const unlinkTempFiles: (args: Args) => Promise<void> = async ({\n  collectionConfig,\n  config,\n  req,\n}) => {\n  if (config.upload?.useTempFiles && collectionConfig.upload) {\n    const { file } = req\n    const fileArray = [{ file }]\n    await mapAsync(fileArray, async ({ file }) => {\n      // Still need this check because this will not be populated if using local API\n      if (file?.tempFilePath) {\n        await unlinkFile(file.tempFilePath)\n      }\n    })\n  }\n}\n"],"names":["fs","promisify","mapAsync","unlinkFile","unlink","unlinkTempFiles","collectionConfig","config","req","upload","useTempFiles","file","fileArray","tempFilePath"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,SAAS,QAAQ,OAAM;AAMhC,SAASC,QAAQ,QAAQ,2BAA0B;;;;AAEnD,MAAMC,mHAAaF,YAAAA,gGAAUD,UAAAA,CAAGI,MAAM;AAU/B,MAAMC,kBAAiD,OAAO,EACnEC,gBAAgB,EAChBC,MAAM,EACNC,GAAG,EACJ;IACC,IAAID,OAAOE,MAAM,EAAEC,gBAAgBJ,iBAAiBG,MAAM,EAAE;QAC1D,MAAM,EAAEE,IAAI,EAAE,GAAGH;QACjB,MAAMI,YAAY;YAAC;gBAAED;YAAK;SAAE;QAC5B,yXAAMT,WAAAA,EAASU,WAAW,OAAO,EAAED,IAAI,EAAE;YACvC,8EAA8E;YAC9E,IAAIA,MAAME,cAAc;gBACtB,MAAMV,WAAWQ,KAAKE,YAAY;YACpC;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1845, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1851, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/deleteAssociatedFiles.ts"],"sourcesContent":["import fs from 'fs'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave } from './types.js'\n\nimport { ErrorDeletingFile } from '../errors/index.js'\nimport fileExists from './fileExists.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  doc: Record<string, unknown>\n  files?: FileToSave[]\n  overrideDelete: boolean\n  req: PayloadRequest\n}\n\nexport const deleteAssociatedFiles: (args: Args) => Promise<void> = async ({\n  collectionConfig,\n  doc,\n  files = [],\n  overrideDelete,\n  req,\n}) => {\n  if (!collectionConfig.upload) {\n    return\n  }\n  if (overrideDelete || files.length > 0) {\n    const { staticDir: staticPath } = collectionConfig.upload\n\n    const fileToDelete = `${staticPath}/${doc.filename as string}`\n\n    try {\n      if (await fileExists(fileToDelete)) {\n        fs.unlinkSync(fileToDelete)\n      }\n    } catch (err) {\n      throw new ErrorDeletingFile(req.t)\n    }\n\n    if (doc.sizes) {\n      const sizes: FileData[] = Object.values(doc.sizes)\n      // Since forEach will not wait until unlink is finished it could\n      // happen that two operations will try to delete the same file.\n      // To avoid this it is recommended to use \"sync\" instead\n\n      for (const size of sizes) {\n        const sizeToDelete = `${staticPath}/${size.filename}`\n        try {\n          if (await fileExists(sizeToDelete)) {\n            fs.unlinkSync(sizeToDelete)\n          }\n        } catch (err) {\n          throw new ErrorDeletingFile(req.t)\n        }\n      }\n    }\n  }\n}\n"],"names":["fs","ErrorDeletingFile","fileExists","deleteAssociatedFiles","collectionConfig","doc","files","overrideDelete","req","upload","length","staticDir","staticPath","fileToDelete","filename","unlinkSync","err","t","sizes","Object","values","size","sizeToDelete"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AAQnB,OAAOE,gBAAgB,kBAAiB;AADxC,SAASD,iBAAiB,QAAQ,qBAAoB;;;;AAY/C,MAAME,wBAAuD,OAAO,EACzEC,gBAAgB,EAChBC,GAAG,EACHC,QAAQ,EAAE,EACVC,cAAc,EACdC,GAAG,EACJ;IACC,IAAI,CAACJ,iBAAiBK,MAAM,EAAE;QAC5B;IACF;IACA,IAAIF,kBAAkBD,MAAMI,MAAM,GAAG,GAAG;QACtC,MAAM,EAAEC,WAAWC,UAAU,EAAE,GAAGR,iBAAiBK,MAAM;QAEzD,MAAMI,eAAe,GAAGD,WAAW,CAAC,EAAEP,IAAIS,QAAQ,EAAY;QAE9D,IAAI;YACF,IAAI,yXAAMZ,UAAAA,EAAWW,eAAe;gBAClCb,wGAAAA,CAAGe,UAAU,CAACF;YAChB;QACF,EAAE,OAAOG,KAAK;YACZ,MAAM,yXAAIf,oBAAAA,CAAkBO,IAAIS,CAAC;QACnC;QAEA,IAAIZ,IAAIa,KAAK,EAAE;YACb,MAAMA,QAAoBC,OAAOC,MAAM,CAACf,IAAIa,KAAK;YACjD,gEAAgE;YAChE,+DAA+D;YAC/D,wDAAwD;YAExD,KAAK,MAAMG,QAAQH,MAAO;gBACxB,MAAMI,eAAe,GAAGV,WAAW,CAAC,EAAES,KAAKP,QAAQ,EAAE;gBACrD,IAAI;oBACF,IAAI,OAAMZ,4XAAAA,EAAWoB,eAAe;sHAClCtB,UAAAA,CAAGe,UAAU,CAACO;oBAChB;gBACF,EAAE,OAAON,KAAK;oBACZ,MAAM,yXAAIf,oBAAAA,CAAkBO,IAAIS,CAAC;gBACnC;YACF;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1892, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1898, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/bin/generateImportMap/parsePayloadComponent.ts"],"sourcesContent":["import type { PayloadComponent } from '../../config/types.js'\n\nexport function parsePayloadComponent(PayloadComponent: PayloadComponent): {\n  exportName: string\n  path: string\n} {\n  if (!PayloadComponent) {\n    return null\n  }\n\n  const pathAndMaybeExport =\n    typeof PayloadComponent === 'string' ? PayloadComponent : PayloadComponent.path\n\n  let path = ''\n  let exportName = 'default'\n\n  if (pathAndMaybeExport?.includes('#')) {\n    ;[path, exportName] = pathAndMaybeExport.split('#')\n  } else {\n    path = pathAndMaybeExport\n  }\n\n  if (typeof PayloadComponent === 'object' && PayloadComponent.exportName) {\n    exportName = PayloadComponent.exportName\n  }\n\n  return { exportName, path }\n}\n"],"names":["parsePayloadComponent","PayloadComponent","pathAndMaybeExport","path","exportName","includes","split"],"mappings":";;;AAEO,SAASA,sBAAsBC,gBAAkC;IAItE,IAAI,CAACA,kBAAkB;QACrB,OAAO;IACT;IAEA,MAAMC,qBACJ,OAAOD,qBAAqB,WAAWA,mBAAmBA,iBAAiBE,IAAI;IAEjF,IAAIA,OAAO;IACX,IAAIC,aAAa;IAEjB,IAAIF,oBAAoBG,SAAS,MAAM;;QACpC,CAACF,MAAMC,WAAW,GAAGF,mBAAmBI,KAAK,CAAC;IACjD,OAAO;QACLH,OAAOD;IACT;IAEA,IAAI,OAAOD,qBAAqB,YAAYA,iBAAiBG,UAAU,EAAE;QACvEA,aAAaH,iBAAiBG,UAAU;IAC1C;IAEA,OAAO;QAAEA;QAAYD;IAAK;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 1922, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1928, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/bin/generateImportMap/getFromImportMap.ts"],"sourcesContent":["import type { PayloadComponent } from '../../config/types.js'\nimport type { ImportMap } from './index.js'\n\nimport { parsePayloadComponent } from './parsePayloadComponent.js'\n\nexport const getFromImportMap = <TOutput>(args: {\n  importMap: ImportMap\n  PayloadComponent: PayloadComponent\n  schemaPath?: string\n  silent?: boolean\n}): TOutput => {\n  const { importMap, PayloadComponent, schemaPath, silent } = args\n\n  const { exportName, path } = parsePayloadComponent(PayloadComponent)\n\n  const key = path + '#' + exportName\n\n  const importMapEntry = importMap[key]\n\n  if (!importMapEntry && !silent) {\n    // eslint-disable-next-line no-console\n    console.error(\n      `getFromImportMap: PayloadComponent not found in importMap`,\n      {\n        key,\n        PayloadComponent,\n        schemaPath,\n      },\n      'You may need to run the `payload generate:importmap` command to generate the importMap ahead of runtime.',\n    )\n  }\n\n  return importMapEntry\n}\n"],"names":["parsePayloadComponent","getFromImportMap","args","importMap","PayloadComponent","schemaPath","silent","exportName","path","key","importMapEntry","console","error"],"mappings":";;;AAGA,SAASA,qBAAqB,QAAQ,6BAA4B;;AAE3D,MAAMC,mBAAmB,CAAUC;IAMxC,MAAM,EAAEC,SAAS,EAAEC,gBAAgB,EAAEC,UAAU,EAAEC,MAAM,EAAE,GAAGJ;IAE5D,MAAM,EAAEK,UAAU,EAAEC,IAAI,EAAE,kZAAGR,wBAAAA,EAAsBI;IAEnD,MAAMK,MAAMD,OAAO,MAAMD;IAEzB,MAAMG,iBAAiBP,SAAS,CAACM,IAAI;IAErC,IAAI,CAACC,kBAAkB,CAACJ,QAAQ;QAC9B,sCAAsC;QACtCK,QAAQC,KAAK,CACX,CAAC,yDAAyD,CAAC,EAC3D;YACEH;YACAL;YACAC;QACF,GACA;IAEJ;IAEA,OAAOK;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1948, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1954, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/bin/generateImportMap/iterateFields.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-expressions */\nimport type { PayloadComponent, SanitizedConfig } from '../../config/types.js'\nimport type { Block, Field, Tab } from '../../fields/config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nfunction hasKey<T, K extends string>(\n  obj: null | T | undefined,\n  key: K,\n): obj is { [P in K]: PayloadComponent | PayloadComponent[] } & T {\n  return obj != null && Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nconst defaultUIFieldComponentKeys: Array<'Cell' | 'Description' | 'Field' | 'Filter'> = [\n  'Cell',\n  'Description',\n  'Field',\n  'Filter',\n]\nexport function genImportMapIterateFields({\n  addToImportMap,\n  baseDir,\n  config,\n  fields,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  config: SanitizedConfig\n  fields: Block[] | Field[] | Tab[]\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  for (const field of fields) {\n    if ('fields' in field) {\n      genImportMapIterateFields({\n        addToImportMap,\n        baseDir,\n        config,\n        fields: field.fields,\n        importMap,\n        imports,\n      })\n    } else if (field.type === 'blocks') {\n      genImportMapIterateFields({\n        addToImportMap,\n        baseDir,\n        config,\n        fields: field.blocks,\n        importMap,\n        imports,\n      })\n    } else if (field.type === 'tabs') {\n      genImportMapIterateFields({\n        addToImportMap,\n        baseDir,\n        config,\n        fields: field.tabs,\n        importMap,\n        imports,\n      })\n    } else if (field.type === 'richText') {\n      if (\n        field?.editor &&\n        typeof field.editor === 'object' &&\n        field.editor.generateImportMap &&\n        typeof field.editor.generateImportMap === 'function'\n      ) {\n        field.editor.generateImportMap({\n          addToImportMap,\n          baseDir,\n          config,\n          importMap,\n          imports,\n        })\n      }\n    } else if (field.type === 'ui') {\n      if (field?.admin?.components) {\n        // Render any extra, untyped components\n        for (const key in field.admin.components) {\n          if (key in defaultUIFieldComponentKeys) {\n            continue\n          }\n          addToImportMap(field.admin.components[key])\n        }\n      }\n    }\n\n    hasKey(field?.admin, 'jsx') && addToImportMap(field.admin.jsx) // For Blocks\n\n    hasKey(field?.admin?.components, 'Label') && addToImportMap(field.admin.components.Label)\n\n    hasKey(field?.admin?.components, 'Block') && addToImportMap(field.admin.components.Block)\n\n    hasKey(field?.admin?.components, 'Cell') && addToImportMap(field?.admin?.components?.Cell)\n\n    hasKey(field?.admin?.components, 'Description') &&\n      addToImportMap(field?.admin?.components?.Description)\n\n    hasKey(field?.admin?.components, 'Field') && addToImportMap(field?.admin?.components?.Field)\n    hasKey(field?.admin?.components, 'Filter') && addToImportMap(field?.admin?.components?.Filter)\n\n    hasKey(field?.admin?.components, 'Error') && addToImportMap(field?.admin?.components?.Error)\n\n    hasKey(field?.admin?.components, 'afterInput') &&\n      addToImportMap(field?.admin?.components?.afterInput)\n\n    hasKey(field?.admin?.components, 'beforeInput') &&\n      addToImportMap(field?.admin?.components?.beforeInput)\n\n    hasKey(field?.admin?.components, 'RowLabel') &&\n      addToImportMap(field?.admin?.components?.RowLabel)\n  }\n}\n"],"names":["hasKey","obj","key","Object","prototype","hasOwnProperty","call","defaultUIFieldComponentKeys","genImportMapIterateFields","addToImportMap","baseDir","config","fields","importMap","imports","field","type","blocks","tabs","editor","generateImportMap","admin","components","jsx","Label","Block","Cell","Description","Field","Filter","Error","afterInput","beforeInput","RowLabel"],"mappings":"AAAA,2DAA2D;;;AAK3D,SAASA,OACPC,GAAyB,EACzBC,GAAM;IAEN,OAAOD,OAAO,QAAQE,OAAOC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACL,KAAKC;AAClE;AAEA,MAAMK,8BAAkF;IACtF;IACA;IACA;IACA;CACD;AACM,SAASC,0BAA0B,EACxCC,cAAc,EACdC,OAAO,EACPC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,OAAO,EAQR;IACC,KAAK,MAAMC,SAASH,OAAQ;QAC1B,IAAI,YAAYG,OAAO;YACrBP,0BAA0B;gBACxBC;gBACAC;gBACAC;gBACAC,QAAQG,MAAMH,MAAM;gBACpBC;gBACAC;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,UAAU;YAClCR,0BAA0B;gBACxBC;gBACAC;gBACAC;gBACAC,QAAQG,MAAME,MAAM;gBACpBJ;gBACAC;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,QAAQ;YAChCR,0BAA0B;gBACxBC;gBACAC;gBACAC;gBACAC,QAAQG,MAAMG,IAAI;gBAClBL;gBACAC;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,YAAY;YACpC,IACED,OAAOI,UACP,OAAOJ,MAAMI,MAAM,KAAK,YACxBJ,MAAMI,MAAM,CAACC,iBAAiB,IAC9B,OAAOL,MAAMI,MAAM,CAACC,iBAAiB,KAAK,YAC1C;gBACAL,MAAMI,MAAM,CAACC,iBAAiB,CAAC;oBAC7BX;oBACAC;oBACAC;oBACAE;oBACAC;gBACF;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,MAAM;YAC9B,IAAID,OAAOM,OAAOC,YAAY;gBAC5B,uCAAuC;gBACvC,IAAK,MAAMpB,OAAOa,MAAMM,KAAK,CAACC,UAAU,CAAE;oBACxC,IAAIpB,OAAOK,6BAA6B;wBACtC;oBACF;oBACAE,eAAeM,MAAMM,KAAK,CAACC,UAAU,CAACpB,IAAI;gBAC5C;YACF;QACF;QAEAF,OAAOe,OAAOM,OAAO,UAAUZ,eAAeM,MAAMM,KAAK,CAACE,GAAG,EAAE,aAAa;;QAE5EvB,OAAOe,OAAOM,OAAOC,YAAY,YAAYb,eAAeM,MAAMM,KAAK,CAACC,UAAU,CAACE,KAAK;QAExFxB,OAAOe,OAAOM,OAAOC,YAAY,YAAYb,eAAeM,MAAMM,KAAK,CAACC,UAAU,CAACG,KAAK;QAExFzB,OAAOe,OAAOM,OAAOC,YAAY,WAAWb,eAAeM,OAAOM,OAAOC,YAAYI;QAErF1B,OAAOe,OAAOM,OAAOC,YAAY,kBAC/Bb,eAAeM,OAAOM,OAAOC,YAAYK;QAE3C3B,OAAOe,OAAOM,OAAOC,YAAY,YAAYb,eAAeM,OAAOM,OAAOC,YAAYM;QACtF5B,OAAOe,OAAOM,OAAOC,YAAY,aAAab,eAAeM,OAAOM,OAAOC,YAAYO;QAEvF7B,OAAOe,OAAOM,OAAOC,YAAY,YAAYb,eAAeM,OAAOM,OAAOC,YAAYQ;QAEtF9B,OAAOe,OAAOM,OAAOC,YAAY,iBAC/Bb,eAAeM,OAAOM,OAAOC,YAAYS;QAE3C/B,OAAOe,OAAOM,OAAOC,YAAY,kBAC/Bb,eAAeM,OAAOM,OAAOC,YAAYU;QAE3ChC,OAAOe,OAAOM,OAAOC,YAAY,eAC/Bb,eAAeM,OAAOM,OAAOC,YAAYW;IAC7C;AACF","ignoreList":[0]}},
    {"offset": {"line": 2030, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2036, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/bin/generateImportMap/iterateCollections.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { SanitizedConfig } from '../../config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nimport { genImportMapIterateFields } from './iterateFields.js'\n\nexport function iterateCollections({\n  addToImportMap,\n  baseDir,\n  collections,\n  config,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  collections: SanitizedCollectionConfig[]\n  config: SanitizedConfig\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  for (const collection of collections) {\n    genImportMapIterateFields({\n      addToImportMap,\n      baseDir,\n      config,\n      fields: collection.fields,\n      importMap,\n      imports,\n    })\n\n    addToImportMap(collection.admin?.components?.afterList)\n    addToImportMap(collection.admin?.components?.afterListTable)\n    addToImportMap(collection.admin?.components?.beforeList)\n    addToImportMap(collection.admin?.components?.beforeListTable)\n    addToImportMap(collection.admin?.components?.Description)\n\n    addToImportMap(collection.admin?.components?.edit?.PreviewButton)\n    addToImportMap(collection.admin?.components?.edit?.PublishButton)\n    addToImportMap(collection.admin?.components?.edit?.SaveButton)\n    addToImportMap(collection.admin?.components?.edit?.SaveDraftButton)\n    addToImportMap(collection.admin?.components?.edit?.Upload)\n\n    if (collection.admin?.components?.views?.edit) {\n      for (const editViewConfig of Object.values(collection.admin?.components?.views?.edit)) {\n        if ('Component' in editViewConfig) {\n          addToImportMap(editViewConfig?.Component)\n        }\n\n        if ('actions' in editViewConfig) {\n          addToImportMap(editViewConfig?.actions)\n        }\n\n        if ('tab' in editViewConfig) {\n          addToImportMap(editViewConfig?.tab?.Component)\n          addToImportMap(editViewConfig?.tab?.Pill)\n        }\n      }\n    }\n\n    addToImportMap(collection.admin?.components?.views?.list?.Component)\n    addToImportMap(collection.admin?.components?.views?.list?.actions)\n  }\n}\n"],"names":["genImportMapIterateFields","iterateCollections","addToImportMap","baseDir","collections","config","importMap","imports","collection","fields","admin","components","afterList","afterListTable","beforeList","beforeListTable","Description","edit","PreviewButton","PublishButton","SaveButton","SaveDraftButton","Upload","views","editViewConfig","Object","values","Component","actions","tab","Pill","list"],"mappings":";;;AAIA,SAASA,yBAAyB,QAAQ,qBAAoB;;AAEvD,SAASC,mBAAmB,EACjCC,cAAc,EACdC,OAAO,EACPC,WAAW,EACXC,MAAM,EACNC,SAAS,EACTC,OAAO,EAQR;IACC,KAAK,MAAMC,cAAcJ,YAAa;YACpCJ,+ZAAAA,EAA0B;YACxBE;YACAC;YACAE;YACAI,QAAQD,WAAWC,MAAM;YACzBH;YACAC;QACF;QAEAL,eAAeM,WAAWE,KAAK,EAAEC,YAAYC;QAC7CV,eAAeM,WAAWE,KAAK,EAAEC,YAAYE;QAC7CX,eAAeM,WAAWE,KAAK,EAAEC,YAAYG;QAC7CZ,eAAeM,WAAWE,KAAK,EAAEC,YAAYI;QAC7Cb,eAAeM,WAAWE,KAAK,EAAEC,YAAYK;QAE7Cd,eAAeM,WAAWE,KAAK,EAAEC,YAAYM,MAAMC;QACnDhB,eAAeM,WAAWE,KAAK,EAAEC,YAAYM,MAAME;QACnDjB,eAAeM,WAAWE,KAAK,EAAEC,YAAYM,MAAMG;QACnDlB,eAAeM,WAAWE,KAAK,EAAEC,YAAYM,MAAMI;QACnDnB,eAAeM,WAAWE,KAAK,EAAEC,YAAYM,MAAMK;QAEnD,IAAId,WAAWE,KAAK,EAAEC,YAAYY,OAAON,MAAM;YAC7C,KAAK,MAAMO,kBAAkBC,OAAOC,MAAM,CAAClB,WAAWE,KAAK,EAAEC,YAAYY,OAAON,MAAO;gBACrF,IAAI,eAAeO,gBAAgB;oBACjCtB,eAAesB,gBAAgBG;gBACjC;gBAEA,IAAI,aAAaH,gBAAgB;oBAC/BtB,eAAesB,gBAAgBI;gBACjC;gBAEA,IAAI,SAASJ,gBAAgB;oBAC3BtB,eAAesB,gBAAgBK,KAAKF;oBACpCzB,eAAesB,gBAAgBK,KAAKC;gBACtC;YACF;QACF;QAEA5B,eAAeM,WAAWE,KAAK,EAAEC,YAAYY,OAAOQ,MAAMJ;QAC1DzB,eAAeM,WAAWE,KAAK,EAAEC,YAAYY,OAAOQ,MAAMH;IAC5D;AACF","ignoreList":[0]}},
    {"offset": {"line": 2079, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2085, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/bin/generateImportMap/iterateGlobals.ts"],"sourcesContent":["import type { SanitizedConfig } from '../../config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nimport { genImportMapIterateFields } from './iterateFields.js'\n\nexport function iterateGlobals({\n  addToImportMap,\n  baseDir,\n  config,\n  globals,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  config: SanitizedConfig\n  globals: SanitizedGlobalConfig[]\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  for (const global of globals) {\n    genImportMapIterateFields({\n      addToImportMap,\n      baseDir,\n      config,\n      fields: global.fields,\n      importMap,\n      imports,\n    })\n\n    addToImportMap(global.admin?.components?.elements?.Description)\n    addToImportMap(global.admin?.components?.elements?.PreviewButton)\n    addToImportMap(global.admin?.components?.elements?.PublishButton)\n    addToImportMap(global.admin?.components?.elements?.SaveButton)\n    addToImportMap(global.admin?.components?.elements?.SaveDraftButton)\n\n    if (global.admin?.components?.views?.edit) {\n      for (const editViewConfig of Object.values(global.admin?.components?.views?.edit)) {\n        if ('Component' in editViewConfig) {\n          addToImportMap(editViewConfig?.Component)\n        }\n\n        if ('actions' in editViewConfig) {\n          addToImportMap(editViewConfig?.actions)\n        }\n\n        if ('tab' in editViewConfig) {\n          addToImportMap(editViewConfig?.tab?.Component)\n          addToImportMap(editViewConfig?.tab?.Pill)\n        }\n      }\n    }\n  }\n}\n"],"names":["genImportMapIterateFields","iterateGlobals","addToImportMap","baseDir","config","globals","importMap","imports","global","fields","admin","components","elements","Description","PreviewButton","PublishButton","SaveButton","SaveDraftButton","views","edit","editViewConfig","Object","values","Component","actions","tab","Pill"],"mappings":";;;AAIA,SAASA,yBAAyB,QAAQ,qBAAoB;;AAEvD,SAASC,eAAe,EAC7BC,cAAc,EACdC,OAAO,EACPC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,OAAO,EAQR;IACC,KAAK,MAAMC,UAAUH,QAAS;YAC5BL,+ZAAAA,EAA0B;YACxBE;YACAC;YACAC;YACAK,QAAQD,OAAOC,MAAM;YACrBH;YACAC;QACF;QAEAL,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUC;QACnDX,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUE;QACnDZ,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUG;QACnDb,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUI;QACnDd,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUK;QAEnD,IAAIT,OAAOE,KAAK,EAAEC,YAAYO,OAAOC,MAAM;YACzC,KAAK,MAAMC,kBAAkBC,OAAOC,MAAM,CAACd,OAAOE,KAAK,EAAEC,YAAYO,OAAOC,MAAO;gBACjF,IAAI,eAAeC,gBAAgB;oBACjClB,eAAekB,gBAAgBG;gBACjC;gBAEA,IAAI,aAAaH,gBAAgB;oBAC/BlB,eAAekB,gBAAgBI;gBACjC;gBAEA,IAAI,SAASJ,gBAAgB;oBAC3BlB,eAAekB,gBAAgBK,KAAKF;oBACpCrB,eAAekB,gBAAgBK,KAAKC;gBACtC;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2121, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2127, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/bin/generateImportMap/iterateConfig.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-expressions */\nimport type { AdminViewConfig } from '../../admin/views/types.js'\nimport type { SanitizedConfig } from '../../config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nimport { iterateCollections } from './iterateCollections.js'\nimport { iterateGlobals } from './iterateGlobals.js'\n\nexport function iterateConfig({\n  addToImportMap,\n  baseDir,\n  config,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  config: SanitizedConfig\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  iterateCollections({\n    addToImportMap,\n    baseDir,\n    collections: config.collections,\n    config,\n    importMap,\n    imports,\n  })\n\n  iterateGlobals({\n    addToImportMap,\n    baseDir,\n    config,\n    globals: config.globals,\n    importMap,\n    imports,\n  })\n\n  if (typeof config.admin?.avatar === 'object') {\n    addToImportMap(config.admin?.avatar?.Component)\n  }\n\n  addToImportMap(config.admin?.components?.Nav)\n  addToImportMap(config.admin?.components?.header)\n  addToImportMap(config.admin?.components?.logout?.Button)\n  addToImportMap(config.admin?.components?.graphics?.Icon)\n  addToImportMap(config.admin?.components?.graphics?.Logo)\n\n  addToImportMap(config.admin?.components?.actions)\n  addToImportMap(config.admin?.components?.afterDashboard)\n  addToImportMap(config.admin?.components?.afterLogin)\n  addToImportMap(config.admin?.components?.afterNavLinks)\n  addToImportMap(config.admin?.components?.beforeDashboard)\n  addToImportMap(config.admin?.components?.beforeLogin)\n  addToImportMap(config.admin?.components?.beforeNavLinks)\n\n  addToImportMap(config.admin?.components?.providers)\n\n  if (config.admin?.components?.views) {\n    if (Object.keys(config.admin?.components?.views)?.length) {\n      for (const key in config.admin?.components?.views) {\n        const adminViewConfig: AdminViewConfig = config.admin?.components?.views[key]\n        addToImportMap(adminViewConfig?.Component)\n      }\n    }\n  }\n\n  if (config?.admin?.importMap?.generators?.length) {\n    for (const generator of config.admin.importMap.generators) {\n      generator({\n        addToImportMap,\n        baseDir,\n        config,\n        importMap,\n        imports,\n      })\n    }\n  }\n\n  if (config?.admin?.dependencies) {\n    for (const key in config.admin.dependencies) {\n      const dependency = config.admin.dependencies[key]\n      addToImportMap(dependency.path)\n    }\n  }\n\n  /*\n  if (\n    config?.editor &&\n    typeof config.editor === 'object' &&\n    config.editor.generateImportMap &&\n    typeof config.editor.generateImportMap === 'function'\n  ) {\n    config.editor.generateImportMap({\n      addToImportMap,\n      baseDir,\n      componentMap,\n      config,\n      importMap,\n    })\n  }*/ // No need to do that here since in the sanitized editor config, this root editor is already added to the field editor - and we already process that in iterateFields\n}\n"],"names":["iterateCollections","iterateGlobals","iterateConfig","addToImportMap","baseDir","config","importMap","imports","collections","globals","admin","avatar","Component","components","Nav","header","logout","Button","graphics","Icon","Logo","actions","afterDashboard","afterLogin","afterNavLinks","beforeDashboard","beforeLogin","beforeNavLinks","providers","views","Object","keys","length","key","adminViewConfig","generators","generator","dependencies","dependency","path"],"mappings":"AAAA,2DAA2D;;;AAK3D,SAASA,kBAAkB,QAAQ,0BAAyB;AAC5D,SAASC,cAAc,QAAQ,sBAAqB;;;AAE7C,SAASC,cAAc,EAC5BC,cAAc,EACdC,OAAO,EACPC,MAAM,EACNC,SAAS,EACTC,OAAO,EAOR;gZACCP,qBAAAA,EAAmB;QACjBG;QACAC;QACAI,aAAaH,OAAOG,WAAW;QAC/BH;QACAC;QACAC;IACF;4YAEAN,iBAAAA,EAAe;QACbE;QACAC;QACAC;QACAI,SAASJ,OAAOI,OAAO;QACvBH;QACAC;IACF;IAEA,IAAI,OAAOF,OAAOK,KAAK,EAAEC,WAAW,UAAU;QAC5CR,eAAeE,OAAOK,KAAK,EAAEC,QAAQC;IACvC;IAEAT,eAAeE,OAAOK,KAAK,EAAEG,YAAYC;IACzCX,eAAeE,OAAOK,KAAK,EAAEG,YAAYE;IACzCZ,eAAeE,OAAOK,KAAK,EAAEG,YAAYG,QAAQC;IACjDd,eAAeE,OAAOK,KAAK,EAAEG,YAAYK,UAAUC;IACnDhB,eAAeE,OAAOK,KAAK,EAAEG,YAAYK,UAAUE;IAEnDjB,eAAeE,OAAOK,KAAK,EAAEG,YAAYQ;IACzClB,eAAeE,OAAOK,KAAK,EAAEG,YAAYS;IACzCnB,eAAeE,OAAOK,KAAK,EAAEG,YAAYU;IACzCpB,eAAeE,OAAOK,KAAK,EAAEG,YAAYW;IACzCrB,eAAeE,OAAOK,KAAK,EAAEG,YAAYY;IACzCtB,eAAeE,OAAOK,KAAK,EAAEG,YAAYa;IACzCvB,eAAeE,OAAOK,KAAK,EAAEG,YAAYc;IAEzCxB,eAAeE,OAAOK,KAAK,EAAEG,YAAYe;IAEzC,IAAIvB,OAAOK,KAAK,EAAEG,YAAYgB,OAAO;QACnC,IAAIC,OAAOC,IAAI,CAAC1B,OAAOK,KAAK,EAAEG,YAAYgB,QAAQG,QAAQ;YACxD,IAAK,MAAMC,OAAO5B,OAAOK,KAAK,EAAEG,YAAYgB,MAAO;gBACjD,MAAMK,kBAAmC7B,OAAOK,KAAK,EAAEG,YAAYgB,KAAK,CAACI,IAAI;gBAC7E9B,eAAe+B,iBAAiBtB;YAClC;QACF;IACF;IAEA,IAAIP,QAAQK,OAAOJ,WAAW6B,YAAYH,QAAQ;QAChD,KAAK,MAAMI,aAAa/B,OAAOK,KAAK,CAACJ,SAAS,CAAC6B,UAAU,CAAE;YACzDC,UAAU;gBACRjC;gBACAC;gBACAC;gBACAC;gBACAC;YACF;QACF;IACF;IAEA,IAAIF,QAAQK,OAAO2B,cAAc;QAC/B,IAAK,MAAMJ,OAAO5B,OAAOK,KAAK,CAAC2B,YAAY,CAAE;YAC3C,MAAMC,aAAajC,OAAOK,KAAK,CAAC2B,YAAY,CAACJ,IAAI;YACjD9B,eAAemC,WAAWC,IAAI;QAChC;IACF;AAEA;;;;;;;;;;;;;;GAcC,GAAG,qKAAqK;AAC3K","ignoreList":[0]}},
    {"offset": {"line": 2208, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2214, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/bin/generateImportMap/index.ts"],"sourcesContent":["import crypto from 'crypto'\nimport fs from 'fs'\nimport process from 'node:process'\nimport path from 'path'\n\nimport type { PayloadComponent, SanitizedConfig } from '../../config/types.js'\n\nimport { iterateConfig } from './iterateConfig.js'\nimport { parsePayloadComponent } from './parsePayloadComponent.js'\n\ntype ImportIdentifier = string\ntype ImportSpecifier = string\ntype ImportPath = string\ntype UserImportPath = string\n\n/**\n * Import Map before being written to the file. Only contains all paths\n */\nexport type InternalImportMap = {\n  [path: UserImportPath]: ImportIdentifier\n}\n\n/**\n * Imports of the import map.\n */\nexport type Imports = {\n  [identifier: ImportIdentifier]: {\n    path: ImportPath\n    specifier: ImportSpecifier\n  }\n}\n\n/**\n * Import Map after being imported from the actual import map. Contains all the actual imported components\n */\nexport type ImportMap = {\n  [path: UserImportPath]: any\n}\n\nexport function addPayloadComponentToImportMap({\n  baseDir,\n  importMap,\n  imports,\n  payloadComponent,\n}: {\n  baseDir: string\n  importMap: InternalImportMap\n  imports: Imports\n  payloadComponent: PayloadComponent\n}) {\n  if (!payloadComponent) {\n    return\n  }\n  const { exportName, path: componentPath } = parsePayloadComponent(payloadComponent)\n\n  if (importMap[componentPath + '#' + exportName]) {\n    return\n  }\n\n  const importIdentifier =\n    exportName + '_' + crypto.createHash('md5').update(componentPath).digest('hex')\n\n  // e.g. if baseDir is /test/fields and componentPath is /components/Field.tsx\n  // then path needs to be /test/fields/components/Field.tsx NOT /users/username/project/test/fields/components/Field.tsx\n  // so we need to append baseDir to componentPath\n\n  if (componentPath.startsWith('.') || componentPath.startsWith('/')) {\n    const normalizedBaseDir = baseDir.replace(/\\\\/g, '/')\n\n    const finalPath = normalizedBaseDir.startsWith('/../')\n      ? `${normalizedBaseDir}${componentPath.slice(1)}`\n      : path.posix.join(normalizedBaseDir, componentPath.slice(1))\n\n    imports[importIdentifier] = {\n      path:\n        componentPath.startsWith('.') || componentPath.startsWith('/') ? finalPath : componentPath,\n      specifier: exportName,\n    }\n  } else {\n    imports[importIdentifier] = {\n      path: componentPath,\n      specifier: exportName,\n    }\n  }\n  importMap[componentPath + '#' + exportName] = importIdentifier\n}\n\nexport type AddToImportMap = (payloadComponent: PayloadComponent | PayloadComponent[]) => void\n\nexport async function generateImportMap(\n  config: SanitizedConfig,\n  options?: { force?: boolean; log: boolean },\n): Promise<void> {\n  const shouldLog = options?.log ?? true\n\n  if (shouldLog) {\n    console.log('Generating import map')\n  }\n\n  const importMap: InternalImportMap = {}\n  const imports: Imports = {}\n\n  const rootDir = process.env.ROOT_DIR ?? process.cwd()\n\n  // get componentsBaseDir.\n  // E.g.:\n  // config.admin.importMap.baseDir = /test/fields/\n  // rootDir: /\n  // componentsBaseDir = /test/fields/\n\n  // or\n\n  // E.g.:\n  // config.admin.importMap.baseDir = /test/fields/\n  // rootDir: /test\n  // componentsBaseDir = /fields/\n\n  // or\n  // config.admin.importMap.baseDir = /\n  // rootDir: /\n  // componentsBaseDir = /\n\n  // E.g.:\n  // config.admin.importMap.baseDir = /test/fields/\n  // rootDir: /test/fields/prod\n  // componentsBaseDir = ../\n\n  // Check if rootDir is a subdirectory of baseDir\n  const baseDir = config.admin.importMap.baseDir\n  const isSubdirectory = path.relative(baseDir, rootDir).startsWith('..')\n\n  let componentsBaseDir\n\n  if (isSubdirectory) {\n    // Get the relative path from rootDir to baseDir\n    componentsBaseDir = path.relative(rootDir, baseDir)\n  } else {\n    // If rootDir is not a subdirectory, just return baseDir relative to rootDir\n    componentsBaseDir = `/${path.relative(rootDir, baseDir)}`\n  }\n\n  // Ensure result has a trailing slash\n  if (!componentsBaseDir.endsWith('/')) {\n    componentsBaseDir += '/'\n  }\n\n  const addToImportMap: AddToImportMap = (payloadComponent) => {\n    if (!payloadComponent) {\n      return\n    }\n\n    if (typeof payloadComponent !== 'object' && typeof payloadComponent !== 'string') {\n      console.error(payloadComponent)\n      throw new Error('addToImportMap > Payload component must be an object or a string')\n    }\n\n    if (Array.isArray(payloadComponent)) {\n      for (const component of payloadComponent) {\n        addPayloadComponentToImportMap({\n          baseDir: componentsBaseDir,\n          importMap,\n          imports,\n          payloadComponent: component,\n        })\n      }\n    } else {\n      addPayloadComponentToImportMap({\n        baseDir: componentsBaseDir,\n        importMap,\n        imports,\n        payloadComponent,\n      })\n    }\n  }\n\n  iterateConfig({\n    addToImportMap,\n    baseDir: config.admin.importMap.baseDir,\n    config,\n    importMap,\n    imports,\n  })\n\n  await writeImportMap({\n    componentMap: importMap,\n    config,\n    fileName: 'importMap.js',\n    force: options?.force,\n    importMap: imports,\n    log: shouldLog,\n    rootDir,\n  })\n}\n\nexport async function writeImportMap({\n  componentMap,\n  config,\n  fileName,\n  force,\n  importMap,\n  log,\n  rootDir,\n}: {\n  componentMap: InternalImportMap\n  config: SanitizedConfig\n  fileName: string\n  force?: boolean\n  importMap: Imports\n  log?: boolean\n  rootDir: string\n}) {\n  let importMapFolderPath = ''\n  if (fs.existsSync(path.resolve(rootDir, `app/(payload)${config.routes.admin}/`))) {\n    importMapFolderPath = path.resolve(rootDir, `app/(payload)${config.routes.admin}/`)\n  } else if (fs.existsSync(path.resolve(rootDir, `src/app/(payload)${config.routes.admin}/`))) {\n    importMapFolderPath = path.resolve(rootDir, `src/app/(payload)${config.routes.admin}/`)\n  } else {\n    throw new Error(\n      `Could not find the payload admin directory. Looked in ${path.resolve(rootDir, `app/(payload)${config.routes.admin}/`)} and ${path.resolve(rootDir, `src/app/(payload)${config.routes.admin}/`)}`,\n    )\n  }\n\n  const imports: string[] = []\n  for (const [identifier, { path, specifier }] of Object.entries(importMap)) {\n    imports.push(`import { ${specifier} as ${identifier} } from '${path}'`)\n  }\n\n  const mapKeys: string[] = []\n  for (const [userPath, identifier] of Object.entries(componentMap)) {\n    mapKeys.push(`  \"${userPath}\": ${identifier}`)\n  }\n\n  const importMapOutputFile = `${imports.join('\\n')}\n\nexport const importMap = {\n${mapKeys.join(',\\n')}\n}\n`\n\n  const importMapFilePath = path.resolve(importMapFolderPath, fileName)\n\n  if (!force) {\n    // Read current import map and check in the IMPORTS if there are any new imports. If not, don't write the file.\n    const currentImportMap = await fs.promises.readFile(importMapFilePath, 'utf-8')\n\n    if (currentImportMap?.trim() === importMapOutputFile?.trim()) {\n      if (log) {\n        console.log('No new imports found, skipping writing import map')\n      }\n      return\n    }\n  }\n\n  if (log) {\n    console.log('Writing import map to', importMapFilePath)\n  }\n\n  await fs.promises.writeFile(importMapFilePath, importMapOutputFile)\n}\n"],"names":["crypto","fs","process","path","iterateConfig","parsePayloadComponent","addPayloadComponentToImportMap","baseDir","importMap","imports","payloadComponent","exportName","componentPath","importIdentifier","createHash","update","digest","startsWith","normalizedBaseDir","replace","finalPath","slice","posix","join","specifier","generateImportMap","config","options","shouldLog","log","console","rootDir","env","ROOT_DIR","cwd","admin","isSubdirectory","relative","componentsBaseDir","endsWith","addToImportMap","error","Error","Array","isArray","component","writeImportMap","componentMap","fileName","force","importMapFolderPath","existsSync","resolve","routes","identifier","Object","entries","push","mapKeys","userPath","importMapOutputFile","importMapFilePath","currentImportMap","promises","readFile","trim","writeFile"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2381, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2387, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/config/types.ts"],"sourcesContent":["import type {\n  DefaultTranslationKeys,\n  DefaultTranslationsObject,\n  I18nClient,\n  I18nOptions,\n  TFunction,\n} from '@payloadcms/translations'\nimport type { BusboyConfig } from 'busboy'\nimport type GraphQL from 'graphql'\nimport type { GraphQLFormattedError } from 'graphql'\nimport type { JSONSchema4 } from 'json-schema'\nimport type { DestinationStream, Level, pino } from 'pino'\nimport type React from 'react'\nimport type { default as sharp } from 'sharp'\nimport type { DeepRequired } from 'ts-essentials'\n\nimport type { RichTextAdapterProvider } from '../admin/RichText.js'\nimport type { DocumentTabConfig, RichTextAdapter } from '../admin/types.js'\nimport type {\n  AdminViewConfig,\n  ServerSideEditViewProps,\n  VisibleEntities,\n} from '../admin/views/types.js'\nimport type { SanitizedPermissions } from '../auth/index.js'\nimport type {\n  AddToImportMap,\n  ImportMap,\n  Imports,\n  InternalImportMap,\n} from '../bin/generateImportMap/index.js'\nimport type {\n  Collection,\n  CollectionConfig,\n  SanitizedCollectionConfig,\n} from '../collections/config/types.js'\nimport type { DatabaseAdapterResult } from '../database/types.js'\nimport type { EmailAdapter, SendEmailOptions } from '../email/types.js'\nimport type { ErrorName } from '../errors/types.js'\nimport type { GlobalConfig, Globals, SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { JobsConfig, Payload, RequestContext, TypedUser } from '../index.js'\nimport type { PayloadRequest, Where } from '../types/index.js'\nimport type { PayloadLogger } from '../utilities/logger.js'\n\n/**\n * The string path pointing to the React component. If one of the generics is `never`, you effectively mark it as a server-only or client-only component.\n *\n * If it is `false` an empty component will be rendered.\n */\nexport type PayloadComponent<\n  TComponentServerProps extends never | object = Record<string, any>,\n  TComponentClientProps extends never | object = Record<string, any>,\n> = false | RawPayloadComponent<TComponentServerProps, TComponentClientProps> | string\n\n// We need the actual object as its own type, otherwise the infers for the PayloadClientReactComponent / PayloadServerReactComponent will not work due to the string union.\n// We also NEED to actually use those generics for this to work, thus they are part of the props.\nexport type RawPayloadComponent<\n  TComponentServerProps extends never | object = Record<string, any>,\n  TComponentClientProps extends never | object = Record<string, any>,\n> = {\n  clientProps?: object | TComponentClientProps\n  exportName?: string\n  path: string\n  serverProps?: object | TComponentServerProps\n}\n\nexport type PayloadComponentProps<TPayloadComponent> =\n  TPayloadComponent extends RawPayloadComponent<\n    infer TComponentServerProps,\n    infer TComponentClientProps\n  >\n    ? TComponentClientProps | TComponentServerProps\n    : never\n\nexport type PayloadClientComponentProps<TPayloadComponent> =\n  TPayloadComponent extends RawPayloadComponent<infer _, infer TComponentClientProps>\n    ? TComponentClientProps\n    : never\n\nexport type PayloadServerComponentProps<TPayloadComponent> =\n  TPayloadComponent extends RawPayloadComponent<infer TComponentServerProps, infer _>\n    ? TComponentServerProps\n    : never\n\nexport type PayloadReactComponent<TPayloadComponent> = React.FC<\n  PayloadComponentProps<TPayloadComponent>\n>\n\n// This also ensures that if never is passed to TComponentClientProps, this entire type will be never.\n// => TypeScript will now ensure that users cannot even define the typed Server Components if the PayloadComponent is marked as\n// Client-Only (marked as Client-Only = TComponentServerProps is never)\nexport type PayloadClientReactComponent<TPayloadComponent> =\n  TPayloadComponent extends RawPayloadComponent<infer _, infer TComponentClientProps>\n    ? TComponentClientProps extends never\n      ? never\n      : React.FC<TComponentClientProps>\n    : never\n\nexport type PayloadServerReactComponent<TPayloadComponent> =\n  TPayloadComponent extends RawPayloadComponent<infer TComponentServerProps, infer _>\n    ? TComponentServerProps extends never\n      ? never\n      : React.FC<TComponentServerProps>\n    : never\n\nexport type ResolvedComponent<\n  TComponentServerProps extends never | object,\n  TComponentClientProps extends never | object,\n> = {\n  clientProps?: TComponentClientProps\n  Component: React.FC<TComponentClientProps | TComponentServerProps>\n  serverProps?: TComponentServerProps\n}\n\nexport type BinScriptConfig = {\n  key: string\n  scriptPath: string\n}\n\nexport type BinScript = (config: SanitizedConfig) => Promise<void> | void\n\ntype Prettify<T> = {\n  [K in keyof T]: T[K]\n} & NonNullable<unknown>\n\nexport type Plugin = (config: Config) => Config | Promise<Config>\n\nexport type LivePreviewConfig = {\n  /**\n   Device breakpoints to use for the `iframe` of the Live Preview window.\n   Options are displayed in the Live Preview toolbar.\n   The `responsive` breakpoint is included by default.\n   */\n  breakpoints?: {\n    height: number | string\n    label: string\n    name: string\n    width: number | string\n  }[]\n  /**\n   The URL of the frontend application. This will be rendered within an `iframe` as its `src`.\n   Payload will send a `window.postMessage()` to this URL with the document data in real-time.\n   The frontend application is responsible for receiving the message and updating the UI accordingly.\n   Use the `useLivePreview` hook to get started in React applications.\n   */\n  url?:\n    | ((args: {\n        collectionConfig?: SanitizedCollectionConfig\n        data: Record<string, any>\n        globalConfig?: SanitizedGlobalConfig\n        locale: Locale\n        /**\n         * @deprecated\n         * Use `req.payload` instead. This will be removed in the next major version.\n         */\n        payload: Payload\n        req: PayloadRequest\n      }) => Promise<string> | string)\n    | string\n}\n\nexport type OGImageConfig = {\n  alt?: string\n  height?: number | string\n  type?: string\n  url: string\n  width?: number | string\n}\n\nexport type OpenGraphConfig = {\n  description?: string\n  images?: OGImageConfig | OGImageConfig[]\n  siteName?: string\n  title?: string\n}\n\nexport type IconConfig = {\n  color?: string\n  /**\n   * @see https://developer.mozilla.org/docs/Web/API/HTMLImageElement/fetchPriority\n   */\n  fetchPriority?: 'auto' | 'high' | 'low'\n  media?: string\n  /** defaults to rel=\"icon\" */\n  rel?: string\n  sizes?: string\n  type?: string\n  /**\n   * URL of the icon to use. You can use a relative path from the public folder (see https://nextjs.org/docs/app/building-your-application/optimizing/static-assets) or an absolute URL.\n   */\n  url: string\n}\n\nexport type MetaConfig = {\n  /**\n   * When `static`, a pre-made image will be used for all pages.\n   * When `dynamic`, a unique image will be generated for each page based on page content and given overrides.\n   * When `off`, no Open Graph images will be generated and the `/api/og` endpoint will be disabled. You can still provide custom images using the `openGraph.images` property.\n   * @default 'dynamic'\n   */\n  defaultOGImageType?: 'dynamic' | 'off' | 'static'\n  /**\n   * Overrides the auto-generated <meta name=\"description\"> of admin pages\n   * @example `\"This is my custom CMS built with Payload.\"`\n   */\n  description?: string\n  /**\n   * Icons to be rendered by devices and browsers.\n   *\n   * For example browser tabs, phone home screens, and search engine results.\n   */\n  icons?: IconConfig[]\n  /**\n   * Overrides the auto-generated <meta name=\"keywords\"> of admin pages\n   * @example `\"CMS, Payload, Custom\"`\n   */\n  keywords?: string\n  /**\n   * Metadata to be rendered as `og` meta tags in the head of the Admin Panel.\n   *\n   * For example when sharing the Admin Panel on social media or through messaging services.\n   */\n  openGraph?: OpenGraphConfig\n  /**\n   * Overrides the auto-generated <title> of admin pages\n   * @example `\"My Admin Panel\"`\n   */\n  title?: string\n  /**\n   * String to append to the auto-generated <title> of admin pages\n   * @example `\" - Custom CMS\"`\n   */\n  titleSuffix?: string\n}\n\nexport type ServerOnlyLivePreviewProperties = keyof Pick<LivePreviewConfig, 'url'>\n\ntype GeneratePreviewURLOptions = {\n  locale: string\n  req: PayloadRequest\n  token: null | string\n}\n\nexport type GeneratePreviewURL = (\n  doc: Record<string, unknown>,\n  options: GeneratePreviewURLOptions,\n) => null | Promise<null | string> | string\n\nexport type GraphQLInfo = {\n  collections: {\n    [slug: string]: Collection\n  }\n  globals: Globals\n  Mutation: {\n    fields: Record<string, any>\n    name: string\n  }\n  Query: {\n    fields: Record<string, any>\n    name: string\n  }\n  types: {\n    arrayTypes: Record<string, GraphQL.GraphQLType>\n    blockInputTypes: Record<string, GraphQL.GraphQLInputObjectType>\n    blockTypes: Record<string, GraphQL.GraphQLObjectType>\n    fallbackLocaleInputType?: GraphQL.GraphQLEnumType | GraphQL.GraphQLScalarType\n    groupTypes: Record<string, GraphQL.GraphQLObjectType>\n    localeInputType?: GraphQL.GraphQLEnumType | GraphQL.GraphQLScalarType\n    tabTypes: Record<string, GraphQL.GraphQLObjectType>\n  }\n}\nexport type GraphQLExtension = (\n  graphQL: typeof GraphQL,\n  context: {\n    config: SanitizedConfig\n  } & GraphQLInfo,\n) => Record<string, unknown>\n\nexport type InitOptions = {\n  /**\n   * Sometimes, with the local API, you might need to pass a config file directly, for example, serverless on Vercel\n   * The passed config should match the config file, and if it doesn't, there could be mismatches between the admin UI\n   * and the backend functionality\n   */\n  config: Promise<SanitizedConfig> | SanitizedConfig\n  /**\n   * Disable connect to the database on init\n   */\n  disableDBConnect?: boolean\n\n  /**\n   * Disable running of the `onInit` function\n   */\n  disableOnInit?: boolean\n\n  importMap?: ImportMap\n\n  /**\n   * A function that is called immediately following startup that receives the Payload instance as it's only argument.\n   */\n  onInit?: (payload: Payload) => Promise<void> | void\n}\n\n/**\n * This result is calculated on the server\n * and then sent to the client allowing the dashboard to show accessible data and actions.\n *\n * If the result is `true`, the user has access.\n * If the result is an object, it is interpreted as a MongoDB query.\n *\n * @example `{ createdBy: { equals: id } }`\n *\n * @example `{ tenant: { in: tenantIds } }`\n *\n * @see https://payloadcms.com/docs/access-control/overview\n */\nexport type AccessResult = boolean | Where\n\nexport type AccessArgs<TData = any> = {\n  /**\n   * The relevant resource that is being accessed.\n   *\n   * `data` is null when a list is requested\n   */\n  data?: TData\n  /** ID of the resource being accessed */\n  id?: number | string\n  /** If true, the request is for a static file */\n  isReadingStaticFile?: boolean\n  /** The original request that requires an access check */\n  req: PayloadRequest\n}\n\n/**\n * Access function runs on the server\n * and is sent to the client allowing the dashboard to show accessible data and actions.\n *\n * @see https://payloadcms.com/docs/access-control/overview\n */\nexport type Access<TData = any> = (args: AccessArgs<TData>) => AccessResult | Promise<AccessResult>\n\n/** Web Request/Response model, but the req has more payload specific properties added to it. */\nexport type PayloadHandler = (req: PayloadRequest) => Promise<Response> | Response\n\n/**\n * Docs: https://payloadcms.com/docs/rest-api/overview#custom-endpoints\n */\nexport type Endpoint = {\n  /** Extension point to add your custom data. */\n  custom?: Record<string, any>\n\n  /**\n   * Middleware that will be called when the path/method matches\n   *\n   * Compatible with Web Request/Response Model\n   */\n  handler: PayloadHandler\n  /** HTTP method (or \"all\") */\n  method: 'connect' | 'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put'\n  /**\n   * Pattern that should match the path of the incoming request\n   *\n   * Compatible with the Express router\n   */\n  path: string\n  /**\n   * Please add \"root\" routes under the /api folder in the Payload Project.\n   * https://nextjs.org/docs/app/api-reference/file-conventions/route\n   *\n   * @deprecated in 3.0\n   */\n  root?: never\n}\n\nexport type EditViewComponent = PayloadComponent<ServerSideEditViewProps>\n\nexport type EditViewConfig = {\n  meta?: MetaConfig\n} & (\n  | {\n      actions?: CustomComponent[]\n    }\n  | {\n      Component: EditViewComponent\n      path?: string\n    }\n  | {\n      path?: string\n      /**\n       * Add a new Edit View to the admin panel\n       * i.e. you can render a custom view that has no tab, if desired\n       * Or override a specific properties of an existing one\n       * i.e. you can customize the `Default` view tab label, if desired\n       */\n      tab?: DocumentTabConfig\n    }\n)\n\ntype ClientProps = {\n  readonly [key: string]: unknown\n}\n\nexport type ServerProps = {\n  readonly i18n: I18nClient\n  readonly locale?: Locale\n  readonly params?: { [key: string]: string | string[] | undefined }\n  readonly payload: Payload\n  readonly permissions?: SanitizedPermissions\n  readonly searchParams?: { [key: string]: string | string[] | undefined }\n  readonly user?: TypedUser\n  readonly visibleEntities?: VisibleEntities\n} & ClientProps\n\nexport const serverProps: (keyof ServerProps)[] = [\n  'payload',\n  'i18n',\n  'locale',\n  'params',\n  'permissions',\n  'searchParams',\n  'permissions',\n]\n\nexport type CustomComponent<TAdditionalProps extends object = Record<string, any>> =\n  PayloadComponent<ServerProps & TAdditionalProps, TAdditionalProps>\n\nexport type Locale = {\n  /**\n   * value of supported locale\n   * @example \"en\"\n   */\n  code: string\n  /**\n   * Code of another locale to use when reading documents with fallback, if not specified defaultLocale is used\n   */\n  fallbackLocale?: string\n  /**\n   * label of supported locale\n   * @example \"English\"\n   */\n  label: Record<string, string> | string\n  /**\n   * if true, defaults textAligmnent on text fields to RTL\n   */\n  rtl?: boolean\n}\n\nexport type BaseLocalizationConfig = {\n  /**\n   * Locale for users that have not expressed their preference for a specific locale\n   * @example `\"en\"`\n   */\n  defaultLocale: string\n  /** Set to `true` to let missing values in localised fields fall back to the values in `defaultLocale`\n   *\n   * If false, then no requests will fallback unless a fallbackLocale is specified in the request.\n   * @default true\n   */\n  fallback?: boolean\n}\n\nexport type LocalizationConfigWithNoLabels = Prettify<\n  {\n    /**\n     * List of supported locales\n     * @example `[\"en\", \"es\", \"fr\", \"nl\", \"de\", \"jp\"]`\n     */\n    locales: string[]\n  } & BaseLocalizationConfig\n>\n\nexport type LocalizationConfigWithLabels = Prettify<\n  {\n    /**\n     * List of supported locales with labels\n     * @example {\n     *  label: 'English',\n     *  value: 'en',\n     *  rtl: false\n     * }\n     */\n    locales: Locale[]\n  } & BaseLocalizationConfig\n>\n\nexport type SanitizedLocalizationConfig = Prettify<\n  {\n    /**\n     * List of supported locales\n     * @example `[\"en\", \"es\", \"fr\", \"nl\", \"de\", \"jp\"]`\n     */\n    localeCodes: string[]\n  } & LocalizationConfigWithLabels\n>\n\n/**\n * @see https://payloadcms.com/docs/configuration/localization#localization\n */\nexport type LocalizationConfig = Prettify<\n  LocalizationConfigWithLabels | LocalizationConfigWithNoLabels\n>\n\nexport type LabelFunction<TTranslationKeys = DefaultTranslationKeys> = ({\n  t,\n}: {\n  t: TFunction<TTranslationKeys>\n}) => string\n\nexport type StaticLabel = Record<string, string> | string\n\nexport type SharpDependency = (\n  input?:\n    | ArrayBuffer\n    | Buffer\n    | Float32Array\n    | Float64Array\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | string\n    | Uint8Array\n    | Uint8ClampedArray\n    | Uint16Array\n    | Uint32Array,\n  options?: sharp.SharpOptions,\n) => sharp.Sharp\n\nexport type CORSConfig = {\n  headers?: string[]\n  origins: '*' | string[]\n}\n\nexport type AdminFunction = {\n  args?: object\n  path: string\n  type: 'function'\n}\n\nexport type AdminComponent = {\n  clientProps?: object\n  path: string\n  serverProps?: object\n  type: 'component'\n}\n\nexport interface AdminDependencies {\n  [key: string]: AdminComponent | AdminFunction\n}\n\nexport type FetchAPIFileUploadOptions = {\n  /**\n   * Returns a HTTP 413 when the file is bigger than the size limit if `true`.\n   * Otherwise, it will add a `truncated = true` to the resulting file structure.\n   * @default false\n   */\n  abortOnLimit?: boolean | undefined\n  /**\n   * Automatically creates the directory path specified in `.mv(filePathName)`\n   * @default false\n   */\n  createParentPath?: boolean | undefined\n  /**\n   * Turn on/off upload process logging. Can be useful for troubleshooting.\n   * @default false\n   */\n  debug?: boolean | undefined\n  /**\n   * User defined limit handler which will be invoked if the file is bigger than configured limits.\n   * @default false\n   */\n  limitHandler?: ((args: { request: Request; size: number }) => void) | boolean | undefined\n  /**\n   * By default, `req.body` and `req.files` are flattened like this:\n   * `{'name': 'John', 'hobbies[0]': 'Cinema', 'hobbies[1]': 'Bike'}\n   *\n   * When this option is enabled they are parsed in order to be nested like this:\n   * `{'name': 'John', 'hobbies': ['Cinema', 'Bike']}`\n   * @default false\n   */\n  parseNested?: boolean | undefined\n  /**\n   * Preserves filename extension when using `safeFileNames` option.\n   * If set to `true`, will default to an extension length of `3`.\n   * If set to `number`, this will be the max allowable extension length.\n   * If an extension is smaller than the extension length, it remains untouched. If the extension is longer,\n   * it is shifted.\n   * @default false\n   *\n   * @example\n   * // true\n   * app.use(fileUpload({ safeFileNames: true, preserveExtension: true }));\n   * // myFileName.ext --> myFileName.ext\n   *\n   * @example\n   * // max extension length 2, extension shifted\n   * app.use(fileUpload({ safeFileNames: true, preserveExtension: 2 }));\n   * // myFileName.ext --> myFileNamee.xt\n   */\n  preserveExtension?: boolean | number | undefined\n  /**\n   * Response which will be send to client if file size limit exceeded when `abortOnLimit` set to `true`.\n   * @default 'File size limit has been reached'\n   */\n  responseOnLimit?: string | undefined\n  /**\n   * Strips characters from the upload's filename.\n   * You can use custom regex to determine what to strip.\n   * If set to `true`, non-alphanumeric characters _except_ dashes and underscores will be stripped.\n   * This option is off by default.\n   * @default false\n   *\n   * @example\n   * // strip slashes from file names\n   * app.use(fileUpload({ safeFileNames: /\\\\/g }))\n   *\n   * @example\n   * app.use(fileUpload({ safeFileNames: true }))\n   */\n  safeFileNames?: boolean | RegExp | undefined\n  /**\n   * Path to store temporary files.\n   * Used along with the `useTempFiles` option. By default this module uses `'tmp'` folder\n   * in the current working directory.\n   * You can use trailing slash, but it is not necessary.\n   * @default './tmp'\n   */\n  tempFileDir?: string | undefined\n  /**\n   * This defines how long to wait for data before aborting. Set to `0` if you want to turn off timeout checks.\n   * @default 60_000\n   */\n  uploadTimeout?: number | undefined\n  /**\n   * Applies uri decoding to file names if set `true`.\n   * @default false\n   */\n  uriDecodeFileNames?: boolean | undefined\n  /**\n   * By default this module uploads files into RAM.\n   * Setting this option to `true` turns on using temporary files instead of utilising RAM.\n   * This avoids memory overflow issues when uploading large files or in case of uploading\n   * lots of files at same time.\n   * @default false\n   */\n  useTempFiles?: boolean | undefined\n} & Partial<BusboyConfig>\n\nexport type ErrorResult = { data?: any; errors: unknown[]; stack?: string }\n\nexport type AfterErrorResult = {\n  graphqlResult?: GraphQLFormattedError\n  response?: Partial<ErrorResult> & Record<string, unknown>\n  status?: number\n} | void\n\nexport type AfterErrorHookArgs = {\n  /** The Collection that the hook is operating on. This will be undefined if the hook is executed from a non-collection endpoint or GraphQL. */\n  collection?: SanitizedCollectionConfig\n  /** \tCustom context passed between hooks */\n  context: RequestContext\n  /** The error that occurred. */\n  error: Error\n  /** The GraphQL result object, available if the hook is executed within a GraphQL context. */\n  graphqlResult?: GraphQLFormattedError\n  /** The Request object containing the currently authenticated user. */\n  req: PayloadRequest\n  /** The formatted error result object, available if the hook is executed from a REST context. */\n  result?: ErrorResult\n}\n\nexport type AfterErrorHook = (\n  args: AfterErrorHookArgs,\n) => AfterErrorResult | Promise<AfterErrorResult>\n\n/**\n * This is the central configuration\n *\n * @see https://payloadcms.com/docs/configuration/overview\n */\nexport type Config = {\n  /** Configure admin dashboard */\n  admin?: {\n    /** Automatically log in as a user */\n    autoLogin?:\n      | {\n          /**\n           * The email address of the user to login as\n           */\n          email?: string\n          /** The password of the user to login as. This is only needed if `prefillOnly` is set to true */\n          password?: string\n          /**\n           * If set to true, the login credentials will be prefilled but the user will still need to click the login button.\n           *\n           * @default false\n           */\n          prefillOnly?: boolean\n          /** The username of the user to login as */\n          username?: string\n        }\n      | false\n\n    /** Set account profile picture. Options: gravatar, default or a custom React component. */\n    avatar?:\n      | 'default'\n      | 'gravatar'\n      | {\n          Component: PayloadComponent\n        }\n    /**\n     * Add extra and/or replace built-in components with custom components\n     *\n     * @see https://payloadcms.com/docs/admin/components\n     */\n    components?: {\n      /**\n       * Add custom components to the top right of the Admin Panel\n       */\n      actions?: CustomComponent[]\n      /**\n       * Add custom components after the collection overview\n       */\n      afterDashboard?: CustomComponent[]\n      /**\n       * Add custom components after the email/password field\n       */\n      afterLogin?: CustomComponent[]\n      /**\n       * Add custom components after the navigation links\n       */\n      afterNavLinks?: CustomComponent[]\n      /**\n       * Add custom components before the collection overview\n       */\n      beforeDashboard?: CustomComponent[]\n      /**\n       * Add custom components before the email/password field\n       */\n      beforeLogin?: CustomComponent[]\n      /**\n       * Add custom components before the navigation links\n       */\n      beforeNavLinks?: CustomComponent[]\n      /** Replace graphical components */\n      graphics?: {\n        /** Replace the icon in the navigation */\n        Icon?: CustomComponent\n        /** Replace the logo on the login page */\n        Logo?: CustomComponent\n      }\n      /**\n       * Add custom header to top of page globally\n       */\n      header?: CustomComponent[]\n      /** Replace logout related components */\n      logout?: {\n        /** Replace the logout button  */\n        Button?: CustomComponent\n      }\n      /**\n       * Replace the navigation with a custom component\n       */\n      Nav?: CustomComponent\n      /**\n       * Wrap the admin dashboard in custom context providers\n       */\n      providers?: PayloadComponent<{ children?: React.ReactNode }, { children?: React.ReactNode }>[]\n      /**\n       * Replace or modify top-level admin routes, or add new ones:\n       * + `Account` - `/admin/account`\n       * + `Dashboard` - `/admin`\n       * + `:path` - `/admin/:path`\n       */\n      views?: {\n        /** Add custom admin views */\n        [key: string]: AdminViewConfig\n        /** Replace the account screen */\n        account?: AdminViewConfig\n        /** Replace the admin homepage */\n        dashboard?: AdminViewConfig\n      }\n    }\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n    /** Global date format that will be used for all dates in the Admin panel. Any valid date-fns format pattern can be used. */\n    dateFormat?: string\n    /**\n     * Each entry in this map generates an entry in the importMap,\n     * as well as an entry in the componentMap if the type of the\n     * dependency is 'component'\n     */\n    dependencies?: AdminDependencies\n    /** If set to true, the entire Admin panel will be disabled. */\n    disable?: boolean\n    importMap?: {\n      /**\n       * Automatically generate component map during development\n       * @default true\n       */\n      autoGenerate?: boolean\n\n      /** The base directory for component paths starting with /.\n       *\n       * By default, this is process.cwd()\n       **/\n      baseDir?: string\n      /**\n       * You can use generators to add custom components to the component import map.\n       * This allows you to import custom components in the admin panel.\n       */\n      generators?: Array<\n        (props: {\n          addToImportMap: AddToImportMap\n          baseDir: string\n          config: SanitizedConfig\n          importMap: InternalImportMap\n          imports: Imports\n        }) => void\n      >\n    }\n    livePreview?: {\n      collections?: string[]\n      globals?: string[]\n    } & LivePreviewConfig\n    /** Base meta data to use for the Admin Panel. Included properties are titleSuffix, ogImage, and favicon. */\n    meta?: MetaConfig\n    routes?: {\n      /** The route for the account page. */\n      account?: string\n      /** The route for the create first user page. */\n      createFirstUser?: string\n      /** The route for the forgot password page. */\n      forgot?: string\n      /** The route the user will be redirected to after being inactive for too long. */\n      inactivity?: string\n      /** The route for the login page. */\n      login?: string\n      /** The route for the logout page. */\n      logout?: string\n      /** The route for the reset password page. */\n      reset?: string\n      /** The route for the unauthorized page. */\n      unauthorized?: string\n    }\n    /**\n     * Suppresses React hydration mismatch warnings during the hydration of the root <html> tag.\n     * Useful in scenarios where the server-rendered HTML might intentionally differ from the client-rendered DOM.\n     * @default false\n     */\n    suppressHydrationWarning?: boolean\n    /**\n     * Restrict the Admin Panel theme to use only one of your choice\n     *\n     * @default 'all' // The theme can be configured by users\n     */\n    theme?: 'all' | 'dark' | 'light'\n    /** The slug of a Collection that you want to be used to log in to the Admin dashboard. */\n    user?: string\n  }\n  /** Custom Payload bin scripts can be injected via the config. */\n  bin?: BinScriptConfig[]\n  /**\n   * Manage the datamodel of your application\n   *\n   * @see https://payloadcms.com/docs/configuration/collections#collection-configs\n   */\n  collections?: CollectionConfig[]\n  /**\n   * Compatibility flags for prior Payload versions\n   */\n  compatibility?: {\n    /**\n     * By default, Payload will remove the `localized: true` property\n     * from fields if a parent field is localized. Set this property\n     * to `true` only if you have an existing Payload database from pre-3.0\n     * that you would like to maintain without migrating. This is only\n     * relevant for MongoDB databases.\n     */\n    allowLocalizedWithinLocalized: true\n  }\n  /**\n   * Prefix a string to all cookies that Payload sets.\n   *\n   * @default \"payload\"\n   */\n  cookiePrefix?: string\n  /** Either a whitelist array of URLS to allow CORS requests from, or a wildcard string ('*') to accept incoming requests from any domain. */\n  cors?: '*' | CORSConfig | string[]\n  /** A whitelist array of URLs to allow Payload cookies to be accepted from as a form of CSRF protection. */\n  csrf?: string[]\n\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n\n  /** Pass in a database adapter for use on this project. */\n  db: DatabaseAdapterResult\n  /** Enable to expose more detailed error information. */\n  debug?: boolean\n  /**\n   * If a user does not specify `depth` while requesting a resource, this depth will be used.\n   *\n   * @see https://payloadcms.com/docs/getting-started/concepts#depth\n   *\n   * @default 2\n   */\n  defaultDepth?: number\n  /**\n   * The maximum allowed depth to be permitted application-wide. This setting helps prevent against malicious queries.\n   *\n   * @default 40000\n   */\n  defaultMaxTextLength?: number\n  /** Default richtext editor to use for richText fields */\n  editor?: RichTextAdapterProvider<any, any, any>\n  /**\n   * Email Adapter\n   *\n   * @see https://payloadcms.com/docs/email/overview\n   */\n  email?: EmailAdapter | Promise<EmailAdapter>\n  /** Custom REST endpoints */\n  endpoints?: Endpoint[]\n  /**\n   * @see https://payloadcms.com/docs/configuration/globals#global-configs\n   */\n  globals?: GlobalConfig[]\n  /**\n   * Manage the GraphQL API\n   *\n   * You can add your own GraphQL queries and mutations to Payload, making use of all the types that Payload has defined for you.\n   *\n   * @see https://payloadcms.com/docs/graphql/overview\n   */\n  graphQL?: {\n    disable?: boolean\n    disablePlaygroundInProduction?: boolean\n    maxComplexity?: number\n    /**\n     * Function that returns an object containing keys to custom GraphQL mutations\n     *\n     * @see https://payloadcms.com/docs/graphql/extending\n     */\n    mutations?: GraphQLExtension\n    /**\n     * Function that returns an object containing keys to custom GraphQL queries\n     *\n     * @see https://payloadcms.com/docs/graphql/extending\n     */\n    queries?: GraphQLExtension\n    /**\n     * Filepath to write the generated schema to\n     */\n    schemaOutputFile?: string\n    /**\n     * Function that returns an array of validation rules to apply to the GraphQL schema\n     *\n     * @see https://payloadcms.com/docs/graphql/overview#custom-validation-rules\n     */\n    validationRules?: (args: GraphQL.ExecutionArgs) => GraphQL.ValidationRule[]\n  }\n  /**\n   * Tap into Payload-wide hooks.\n   *\n   * @see https://payloadcms.com/docs/hooks/overview\n   */\n  hooks?: {\n    afterError?: AfterErrorHook[]\n  }\n  /** i18n config settings */\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  i18n?: I18nOptions<{} | DefaultTranslationsObject> // loosen the type here to allow for custom translations\n  /** Automatically index all sortable top-level fields in the database to improve sort performance and add database compatibility for Azure Cosmos and similar. */\n  indexSortableFields?: boolean\n  /**\n   * @experimental There may be frequent breaking changes to this API\n   */\n  jobs?: JobsConfig\n  /**\n   * Translate your content to different languages/locales.\n   *\n   * @default false // disable localization\n   */\n  localization?: false | LocalizationConfig\n\n  /**\n   * Logger options, logger options with a destination stream, or an instantiated logger instance.\n   *\n   * See Pino Docs for options: https://getpino.io/#/docs/api?id=options\n   *\n   * ```ts\n   * // Logger options only\n   * logger: {\n   *   level: 'info',\n   * }\n   *\n   * // Logger options with destination stream\n   * logger: {\n   *  options: {\n   *   level: 'info',\n   *  },\n   *  destination: process.stdout\n   * },\n   *\n   * // Logger instance\n   * logger: pino({ name: 'my-logger' })\n   *\n   * ```\n   */\n  logger?: 'sync' | { destination?: DestinationStream; options: pino.LoggerOptions } | PayloadLogger\n\n  /**\n   * Override the log level of errors for Payload's error handler or disable logging with `false`.\n   * Levels can be any of the following: 'trace', 'debug', 'info', 'warn', 'error', 'fatal' or false.\n   *\n   * Default levels:\n   * {\n  `*   APIError: 'error',\n  `*   AuthenticationError: 'error',\n  `*   ErrorDeletingFile: 'error',\n  `*   FileRetrievalError: 'error',\n  `*   FileUploadError: 'error',\n  `*   Forbidden: 'info',\n  `*   Locked: 'info',\n  `*   LockedAuth: 'error',\n  `*   MissingFile: 'info',\n  `*   NotFound: 'info',\n  `*   QueryError: 'error',\n  `*   ValidationError: 'info',\n   * }\n   */\n  loggingLevels?: Partial<Record<ErrorName, false | Level>>\n\n  /**\n   * The maximum allowed depth to be permitted application-wide. This setting helps prevent against malicious queries.\n   *\n   * @see https://payloadcms.com/docs/getting-started/concepts#depth\n   *\n   * @default 10\n   */\n  maxDepth?: number\n  /** A function that is called immediately following startup that receives the Payload instance as its only argument. */\n  onInit?: (payload: Payload) => Promise<void> | void\n  /**\n   * An array of Payload plugins.\n   *\n   * @see https://payloadcms.com/docs/plugins/overview\n   */\n  plugins?: Plugin[]\n  /** Control the routing structure that Payload binds itself to. */\n  routes?: {\n    /** The route for the admin panel.\n     * @example \"/my-admin\"\n     * @default \"/admin\"\n     */\n    admin?: string\n    /** @default \"/api\"  */\n    api?: string\n    /** @default \"/graphql\"  */\n    graphQL?: string\n    /** @default \"/graphql-playground\" */\n    graphQLPlayground?: string\n  }\n  /** Secure string that Payload will use for any encryption workflows */\n  secret: string\n  /**\n   * Define the absolute URL of your app including the protocol, for example `https://example.org`.\n   * No paths allowed, only protocol, domain and (optionally) port.\n   *\n   * @see https://payloadcms.com/docs/configuration/overview#options\n   */\n  serverURL?: string\n  /**\n   * Pass in a local copy of Sharp if you'd like to use it.\n   *\n   */\n  sharp?: SharpDependency\n  /** Send anonymous telemetry data about general usage. */\n  telemetry?: boolean\n  /** Control how typescript interfaces are generated from your collections. */\n  typescript?: {\n    /**\n     * Automatically generate types during development\n     * @default true\n     */\n    autoGenerate?: boolean\n\n    /** Disable declare block in generated types file */\n    declare?:\n      | {\n          /**\n           * @internal internal use only to allow for multiple declarations within a monorepo and suppress the \"Duplicate identifier GeneratedTypes\" error\n           *\n           * Adds a @ts-ignore flag above the GeneratedTypes interface declaration\n           *\n           * @default false\n           */\n          ignoreTSError?: boolean\n        }\n      | false\n\n    /** Filename to write the generated types to */\n    outputFile?: string\n\n    /**\n     * Allows you to modify the base JSON schema that is generated during generate:types. This JSON schema will be used\n     * to generate the TypeScript interfaces.\n     */\n    schema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  }\n  /**\n   * Customize the handling of incoming file uploads for collections that have uploads enabled.\n   */\n  upload?: FetchAPIFileUploadOptions\n}\n\nexport type SanitizedConfig = {\n  collections: SanitizedCollectionConfig[]\n  /** Default richtext editor to use for richText fields */\n  editor?: RichTextAdapter<any, any, any>\n  endpoints: Endpoint[]\n  globals: SanitizedGlobalConfig[]\n  i18n: Required<I18nOptions>\n  jobs: JobsConfig // Redefine here, as the DeepRequired<Config> can break its type\n  localization: false | SanitizedLocalizationConfig\n  paths: {\n    config: string\n    configDir: string\n    rawConfig: string\n  }\n  upload: {\n    /**\n     * Deduped list of adapters used in the project\n     */\n    adapters: string[]\n  } & FetchAPIFileUploadOptions\n} & Omit<\n  // TODO: DeepRequired breaks certain, advanced TypeScript types / certain type information is lost. We should remove it when possible.\n  // E.g. in packages/ui/src/graphics/Account/index.tsx in getComponent, if avatar.Component is casted to what it's supposed to be,\n  // the result type is different\n  DeepRequired<Config>,\n  'collections' | 'editor' | 'endpoint' | 'globals' | 'i18n' | 'localization' | 'upload'\n>\n\nexport type EditConfig = EditConfigWithoutRoot | EditConfigWithRoot\n\nexport type EditConfigWithRoot = {\n  api?: never\n  default?: never\n  livePreview?: never\n  /**\n   * Replace or modify _all_ nested document views and routes, including the document header, controls, and tabs. This cannot be used in conjunction with other nested views.\n   * + `root` - `/admin/collections/:collection/:id/**\\/*`\n   */\n  root: Partial<EditViewConfig>\n  version?: never\n  versions?: never\n}\n\nexport type EditConfigWithoutRoot = {\n  [key: string]: EditViewConfig\n  /**\n   * Replace or modify individual nested routes, or add new ones:\n   * + `default` - `/admin/collections/:collection/:id`\n   * + `api` - `/admin/collections/:collection/:id/api`\n   * + `livePreview` - `/admin/collections/:collection/:id/preview`\n   * + `references` - `/admin/collections/:collection/:id/references`\n   * + `relationships` - `/admin/collections/:collection/:id/relationships`\n   * + `versions` - `/admin/collections/:collection/:id/versions`\n   * + `version` - `/admin/collections/:collection/:id/versions/:version`\n   * + `customView` - `/admin/collections/:collection/:id/:path`\n   *\n   * To override the entire Edit View including all nested views, use the `root` key.\n   */\n  api?: Partial<EditViewConfig>\n  default?: Partial<EditViewConfig>\n  livePreview?: Partial<EditViewConfig>\n  root?: never\n  version?: Partial<EditViewConfig>\n  versions?: Partial<EditViewConfig>\n}\n\nexport type EntityDescriptionComponent = CustomComponent\n\nexport type EntityDescriptionFunction = ({ t }: { t: TFunction }) => string\n\nexport type EntityDescription = EntityDescriptionFunction | Record<string, string> | string\n\nexport type { EmailAdapter, SendEmailOptions }\n"],"names":["serverProps"],"mappings":";;;AA4ZO,MAAMA,cAAqC;IAChD;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2399, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2405, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/config/defaults.ts"],"sourcesContent":["import type { JobsConfig } from '../queues/config/types/index.js'\nimport type { Config } from './types.js'\n\nimport defaultAccess from '../auth/defaultAccess.js'\n\nexport const defaults: Omit<Config, 'db' | 'editor' | 'secret'> = {\n  admin: {\n    avatar: 'gravatar',\n    components: {},\n    custom: {},\n    dateFormat: 'MMMM do yyyy, h:mm a',\n    dependencies: {},\n    disable: false,\n    importMap: {\n      baseDir: `${typeof process?.cwd === 'function' ? process.cwd() : ''}`,\n    },\n    meta: {\n      defaultOGImageType: 'dynamic',\n      titleSuffix: '- Payload',\n    },\n    routes: {\n      account: '/account',\n      createFirstUser: '/create-first-user',\n      forgot: '/forgot',\n      inactivity: '/logout-inactivity',\n      login: '/login',\n      logout: '/logout',\n      reset: '/reset',\n      unauthorized: '/unauthorized',\n    },\n    theme: 'all',\n  },\n  bin: [],\n  collections: [],\n  cookiePrefix: 'payload',\n  cors: [],\n  csrf: [],\n  custom: {},\n  defaultDepth: 2,\n  defaultMaxTextLength: 40000,\n  endpoints: [],\n  globals: [],\n  graphQL: {\n    disablePlaygroundInProduction: true,\n    maxComplexity: 1000,\n    schemaOutputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/schema.graphql`,\n  },\n  hooks: {},\n  i18n: {},\n  jobs: {\n    access: {\n      run: defaultAccess,\n    },\n    deleteJobOnComplete: true,\n    depth: 0,\n  } as JobsConfig,\n  localization: false,\n  maxDepth: 10,\n  routes: {\n    admin: '/admin',\n    api: '/api',\n    graphQL: '/graphql',\n    graphQLPlayground: '/graphql-playground',\n  },\n  serverURL: '',\n  telemetry: true,\n  typescript: {\n    autoGenerate: true,\n    outputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/payload-types.ts`,\n  },\n  upload: {},\n}\n"],"names":["defaultAccess","defaults","admin","avatar","components","custom","dateFormat","dependencies","disable","importMap","baseDir","process","cwd","meta","defaultOGImageType","titleSuffix","routes","account","createFirstUser","forgot","inactivity","login","logout","reset","unauthorized","theme","bin","collections","cookiePrefix","cors","csrf","defaultDepth","defaultMaxTextLength","endpoints","globals","graphQL","disablePlaygroundInProduction","maxComplexity","schemaOutputFile","hooks","i18n","jobs","access","run","deleteJobOnComplete","depth","localization","maxDepth","api","graphQLPlayground","serverURL","telemetry","typescript","autoGenerate","outputFile","upload"],"mappings":";;;AAGA,OAAOA,mBAAmB,2BAA0B;;AAE7C,MAAMC,WAAqD;IAChEC,OAAO;QACLC,QAAQ;QACRC,YAAY,CAAC;QACbC,QAAQ,CAAC;QACTC,YAAY;QACZC,cAAc,CAAC;QACfC,SAAS;QACTC,WAAW;YACTC,SAAS,GAAG,OAAOC,SAASC,QAAQ,aAAaD,QAAQC,GAAG,KAAK,IAAI;QACvE;QACAC,MAAM;YACJC,oBAAoB;YACpBC,aAAa;QACf;QACAC,QAAQ;YACNC,SAAS;YACTC,iBAAiB;YACjBC,QAAQ;YACRC,YAAY;YACZC,OAAO;YACPC,QAAQ;YACRC,OAAO;YACPC,cAAc;QAChB;QACAC,OAAO;IACT;IACAC,KAAK,EAAE;IACPC,aAAa,EAAE;IACfC,cAAc;IACdC,MAAM,EAAE;IACRC,MAAM,EAAE;IACRzB,QAAQ,CAAC;IACT0B,cAAc;IACdC,sBAAsB;IACtBC,WAAW,EAAE;IACbC,SAAS,EAAE;IACXC,SAAS;QACPC,+BAA+B;QAC/BC,eAAe;QACfC,kBAAkB,GAAG,OAAO3B,SAASC,QAAQ,aAAaD,QAAQC,GAAG,KAAK,GAAG,eAAe,CAAC;IAC/F;IACA2B,OAAO,CAAC;IACRC,MAAM,CAAC;IACPC,MAAM;QACJC,QAAQ;YACNC,oXAAK3C,UAAAA;QACP;QACA4C,qBAAqB;QACrBC,OAAO;IACT;IACAC,cAAc;IACdC,UAAU;IACV/B,QAAQ;QACNd,OAAO;QACP8C,KAAK;QACLb,SAAS;QACTc,mBAAmB;IACrB;IACAC,WAAW;IACXC,WAAW;IACXC,YAAY;QACVC,cAAc;QACdC,YAAY,GAAG,OAAO3C,SAASC,QAAQ,aAAaD,QAAQC,GAAG,KAAK,GAAG,iBAAiB,CAAC;IAC3F;IACA2C,QAAQ,CAAC;AACX,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2477, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2483, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/config/sanitize.ts"],"sourcesContent":["import type { AcceptedLanguages } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { deepMergeSimple } from '@payloadcms/translations/utilities'\n\nimport type {\n  Config,\n  LocalizationConfigWithLabels,\n  LocalizationConfigWithNoLabels,\n  SanitizedConfig,\n} from './types.js'\n\nimport { defaultUserCollection } from '../auth/defaultUser.js'\nimport { sanitizeCollection } from '../collections/config/sanitize.js'\nimport { migrationsCollection } from '../database/migrations/migrationsCollection.js'\nimport { InvalidConfiguration } from '../errors/index.js'\nimport { sanitizeGlobals } from '../globals/config/sanitize.js'\nimport { getLockedDocumentsCollection } from '../lockedDocuments/lockedDocumentsCollection.js'\nimport getPreferencesCollection from '../preferences/preferencesCollection.js'\nimport { getDefaultJobsCollection } from '../queues/config/jobsCollection.js'\nimport checkDuplicateCollections from '../utilities/checkDuplicateCollections.js'\nimport { defaults } from './defaults.js'\n\nconst sanitizeAdminConfig = (configToSanitize: Config): Partial<SanitizedConfig> => {\n  const sanitizedConfig = { ...configToSanitize }\n\n  // default logging level will be 'error' if not provided\n  sanitizedConfig.loggingLevels = {\n    Forbidden: 'info',\n    Locked: 'info',\n    MissingFile: 'info',\n    NotFound: 'info',\n    ValidationError: 'info',\n    ...(sanitizedConfig.loggingLevels || {}),\n  }\n\n  // add default user collection if none provided\n  if (!sanitizedConfig?.admin?.user) {\n    const firstCollectionWithAuth = sanitizedConfig.collections.find(({ auth }) => Boolean(auth))\n    if (firstCollectionWithAuth) {\n      sanitizedConfig.admin.user = firstCollectionWithAuth.slug\n    } else {\n      sanitizedConfig.admin.user = defaultUserCollection.slug\n      sanitizedConfig.collections.push(defaultUserCollection)\n    }\n  }\n\n  const userCollection = sanitizedConfig.collections.find(\n    ({ slug }) => slug === sanitizedConfig.admin.user,\n  )\n  if (!userCollection || !userCollection.auth) {\n    throw new InvalidConfiguration(\n      `${sanitizedConfig.admin.user} is not a valid admin user collection`,\n    )\n  }\n\n  return sanitizedConfig as unknown as Partial<SanitizedConfig>\n}\n\nexport const sanitizeConfig = async (incomingConfig: Config): Promise<SanitizedConfig> => {\n  const configWithDefaults = {\n    ...defaults,\n    ...incomingConfig,\n    admin: {\n      ...defaults.admin,\n      ...incomingConfig?.admin,\n      meta: {\n        ...defaults.admin.meta,\n        ...incomingConfig?.admin?.meta,\n      },\n      routes: {\n        ...defaults.admin.routes,\n        ...incomingConfig?.admin?.routes,\n      },\n    },\n    graphQL: {\n      ...defaults.graphQL,\n      ...incomingConfig?.graphQL,\n    },\n    jobs: {\n      ...defaults.jobs,\n      ...incomingConfig?.jobs,\n      access: {\n        ...defaults.jobs.access,\n        ...incomingConfig?.jobs?.access,\n      },\n      tasks: incomingConfig?.jobs?.tasks || [],\n      workflows: incomingConfig?.jobs?.workflows || [],\n    },\n    routes: {\n      ...defaults.routes,\n      ...incomingConfig?.routes,\n    },\n    typescript: {\n      ...defaults.typescript,\n      ...incomingConfig?.typescript,\n    },\n  }\n\n  if (!configWithDefaults?.serverURL) {\n    configWithDefaults.serverURL = ''\n  }\n\n  if (process.env.NEXT_BASE_PATH) {\n    if (!incomingConfig?.routes?.api) {\n      // check for incomingConfig, as configWithDefaults will always have a default value for routes.api\n      configWithDefaults.routes.api = process.env.NEXT_BASE_PATH + '/api'\n    }\n  }\n\n  const config: Partial<SanitizedConfig> = sanitizeAdminConfig(configWithDefaults)\n\n  if (config.localization && config.localization.locales?.length > 0) {\n    // clone localization config so to not break everything\n    const firstLocale = config.localization.locales[0]\n    if (typeof firstLocale === 'string') {\n      config.localization.localeCodes = [\n        ...(config.localization as unknown as LocalizationConfigWithNoLabels).locales,\n      ]\n\n      // is string[], so convert to Locale[]\n      config.localization.locales = (\n        config.localization as unknown as LocalizationConfigWithNoLabels\n      ).locales.map((locale) => ({\n        code: locale,\n        label: locale,\n        rtl: false,\n        toString: () => locale,\n      }))\n    } else {\n      // is Locale[], so convert to string[] for localeCodes\n      config.localization.localeCodes = config.localization.locales.reduce((locales, locale) => {\n        locales.push(locale.code)\n        return locales\n      }, [] as string[])\n\n      config.localization.locales = (\n        config.localization as LocalizationConfigWithLabels\n      ).locales.map((locale) => ({\n        ...locale,\n        toString: () => locale.code,\n      }))\n    }\n\n    // Default fallback to true if not provided\n    config.localization.fallback = config.localization?.fallback ?? true\n  }\n\n  const i18nConfig: SanitizedConfig['i18n'] = {\n    fallbackLanguage: 'en',\n    supportedLanguages: {\n      en,\n    },\n    translations: {},\n  }\n\n  if (incomingConfig?.i18n) {\n    i18nConfig.supportedLanguages =\n      incomingConfig.i18n?.supportedLanguages || i18nConfig.supportedLanguages\n\n    const supportedLangKeys = <AcceptedLanguages[]>Object.keys(i18nConfig.supportedLanguages)\n    const fallbackLang = incomingConfig.i18n?.fallbackLanguage || i18nConfig.fallbackLanguage\n\n    i18nConfig.fallbackLanguage = supportedLangKeys.includes(fallbackLang)\n      ? fallbackLang\n      : supportedLangKeys[0]\n    i18nConfig.translations =\n      (incomingConfig.i18n?.translations as SanitizedConfig['i18n']['translations']) ||\n      i18nConfig.translations\n  }\n\n  config.i18n = i18nConfig\n\n  // Need to add default jobs collection before locked documents collections\n  if (\n    (Array.isArray(configWithDefaults.jobs?.tasks) && configWithDefaults.jobs?.tasks?.length) ||\n    (Array.isArray(configWithDefaults.jobs?.workflows) &&\n      configWithDefaults.jobs?.workflows?.length)\n  ) {\n    let defaultJobsCollection = getDefaultJobsCollection(config as unknown as Config)\n\n    if (typeof configWithDefaults.jobs.jobsCollectionOverrides === 'function') {\n      defaultJobsCollection = configWithDefaults.jobs.jobsCollectionOverrides({\n        defaultJobsCollection,\n      })\n    }\n\n    configWithDefaults.collections.push(defaultJobsCollection)\n  }\n\n  configWithDefaults.collections.push(getLockedDocumentsCollection(config as unknown as Config))\n  configWithDefaults.collections.push(getPreferencesCollection(config as unknown as Config))\n  configWithDefaults.collections.push(migrationsCollection)\n\n  const richTextSanitizationPromises: Array<(config: SanitizedConfig) => Promise<void>> = []\n  for (let i = 0; i < config.collections.length; i++) {\n    config.collections[i] = await sanitizeCollection(\n      config as unknown as Config,\n      config.collections[i],\n      richTextSanitizationPromises,\n    )\n  }\n\n  checkDuplicateCollections(config.collections)\n\n  if (config.globals.length > 0) {\n    config.globals = await sanitizeGlobals(\n      config as unknown as Config,\n      richTextSanitizationPromises,\n    )\n  }\n\n  if (config.serverURL !== '') {\n    config.csrf.push(config.serverURL)\n  }\n\n  // Get deduped list of upload adapters\n  if (!config.upload) {\n    config.upload = { adapters: [] }\n  }\n  config.upload.adapters = Array.from(\n    new Set(config.collections.map((c) => c.upload?.adapter).filter(Boolean)),\n  )\n\n  // Pass through the email config as is so adapters don't break\n  if (incomingConfig.email) {\n    config.email = incomingConfig.email\n  }\n\n  /*\n    Execute richText sanitization\n   */\n  if (typeof incomingConfig.editor === 'function') {\n    config.editor = await incomingConfig.editor({\n      config: config as SanitizedConfig,\n      isRoot: true,\n      parentIsLocalized: false,\n    })\n    if (config.editor.i18n && Object.keys(config.editor.i18n).length >= 0) {\n      config.i18n.translations = deepMergeSimple(config.i18n.translations, config.editor.i18n)\n    }\n  }\n\n  const promises: Promise<void>[] = []\n  for (const sanitizeFunction of richTextSanitizationPromises) {\n    promises.push(sanitizeFunction(config as SanitizedConfig))\n  }\n  await Promise.all(promises)\n\n  return config as SanitizedConfig\n}\n"],"names":["en","deepMergeSimple","defaultUserCollection","sanitizeCollection","migrationsCollection","InvalidConfiguration","sanitizeGlobals","getLockedDocumentsCollection","getPreferencesCollection","getDefaultJobsCollection","checkDuplicateCollections","defaults","sanitizeAdminConfig","configToSanitize","sanitizedConfig","loggingLevels","Forbidden","Locked","MissingFile","NotFound","ValidationError","admin","user","firstCollectionWithAuth","collections","find","auth","Boolean","slug","push","userCollection","sanitizeConfig","incomingConfig","configWithDefaults","meta","routes","graphQL","jobs","access","tasks","workflows","typescript","serverURL","process","env","NEXT_BASE_PATH","api","config","localization","locales","length","firstLocale","localeCodes","map","locale","code","label","rtl","toString","reduce","fallback","i18nConfig","fallbackLanguage","supportedLanguages","translations","i18n","supportedLangKeys","Object","keys","fallbackLang","includes","Array","isArray","defaultJobsCollection","jobsCollectionOverrides","richTextSanitizationPromises","i","globals","csrf","upload","adapters","from","Set","c","adapter","filter","email","editor","isRoot","parentIsLocalized","promises","sanitizeFunction","Promise","all"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2686, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2692, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/config/build.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from './types.js'\n\nimport { sanitizeConfig } from './sanitize.js'\n\n/**\n * @description Builds and validates Payload configuration\n * @param config Payload Config\n * @returns Built and sanitized Payload Config\n */\nexport async function buildConfig(config: Config): Promise<SanitizedConfig> {\n  if (Array.isArray(config.plugins)) {\n    const configAfterPlugins = await config.plugins.reduce(async (acc, plugin) => {\n      const configAfterPlugin = await acc\n      return plugin(configAfterPlugin)\n    }, Promise.resolve(config))\n\n    return await sanitizeConfig(configAfterPlugins)\n  }\n\n  return await sanitizeConfig(config)\n}\n"],"names":["sanitizeConfig","buildConfig","config","Array","isArray","plugins","configAfterPlugins","reduce","acc","plugin","configAfterPlugin","Promise","resolve"],"mappings":";;;AAEA,SAASA,cAAc,QAAQ,gBAAe;;AAOvC,eAAeC,YAAYC,MAAc;IAC9C,IAAIC,MAAMC,OAAO,CAACF,OAAOG,OAAO,GAAG;QACjC,MAAMC,qBAAqB,MAAMJ,OAAOG,OAAO,CAACE,MAAM,CAAC,OAAOC,KAAKC;YACjE,MAAMC,oBAAoB,MAAMF;YAChC,OAAOC,OAAOC;QAChB,GAAGC,QAAQC,OAAO,CAACV;QAEnB,OAAO,sXAAMF,iBAAAA,EAAeM;IAC9B;IAEA,OAAO,sXAAMN,iBAAAA,EAAeE;AAC9B","ignoreList":[0]}},
    {"offset": {"line": 2707, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2713, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/config/client.ts"],"sourcesContent":["import type { I18nClient } from '@payloadcms/translations'\nimport type { DeepPartial } from 'ts-essentials'\n\nimport type { ImportMap } from '../bin/generateImportMap/index.js'\nimport type {\n  LivePreviewConfig,\n  SanitizedConfig,\n  ServerOnlyLivePreviewProperties,\n} from './types.js'\n\nimport {\n  type ClientCollectionConfig,\n  createClientCollectionConfigs,\n} from '../collections/config/client.js'\nimport { type ClientGlobalConfig, createClientGlobalConfigs } from '../globals/config/client.js'\n\nexport type ServerOnlyRootProperties = keyof Pick<\n  SanitizedConfig,\n  | 'bin'\n  | 'cors'\n  | 'csrf'\n  | 'custom'\n  | 'db'\n  | 'editor'\n  | 'email'\n  | 'endpoints'\n  | 'graphQL'\n  | 'hooks'\n  | 'jobs'\n  | 'logger'\n  | 'onInit'\n  | 'plugins'\n  | 'secret'\n  | 'sharp'\n  | 'typescript'\n>\n\nexport type ServerOnlyRootAdminProperties = keyof Pick<SanitizedConfig['admin'], 'components'>\n\nexport type ClientConfig = {\n  admin: {\n    livePreview?: Omit<LivePreviewConfig, ServerOnlyLivePreviewProperties>\n  } & Omit<SanitizedConfig['admin'], 'components' | 'dependencies' | 'livePreview'>\n  collections: ClientCollectionConfig[]\n  custom?: Record<string, any>\n  globals: ClientGlobalConfig[]\n  i18n?: Omit<SanitizedConfig['i18n'], 'supportedLanguages'>\n} & Omit<SanitizedConfig, 'admin' | 'collections' | 'globals' | 'i18n' | ServerOnlyRootProperties>\n\nexport const serverOnlyAdminConfigProperties: readonly Partial<ServerOnlyRootAdminProperties>[] = []\n\nexport const serverOnlyConfigProperties: readonly Partial<ServerOnlyRootProperties>[] = [\n  'endpoints',\n  'db',\n  'editor',\n  'plugins',\n  'sharp',\n  'onInit',\n  'secret',\n  'hooks',\n  'bin',\n  'typescript',\n  'cors',\n  'csrf',\n  'email',\n  'custom',\n  'graphQL',\n  'jobs',\n  'logger',\n  // `admin`, `onInit`, `localization`, `collections`, and `globals` are all handled separately\n]\n\nexport const createClientConfig = ({\n  config,\n  i18n,\n  importMap,\n}: {\n  config: SanitizedConfig\n  i18n: I18nClient\n  importMap: ImportMap\n}): ClientConfig => {\n  const clientConfig = {} as DeepPartial<ClientConfig>\n\n  for (const key in config) {\n    if (serverOnlyConfigProperties.includes(key as any)) {\n      continue\n    }\n    switch (key) {\n      case 'admin':\n        clientConfig.admin = {\n          autoLogin: config.admin.autoLogin,\n          avatar: config.admin.avatar,\n          custom: config.admin.custom,\n          dateFormat: config.admin.dateFormat,\n          disable: config.admin.disable,\n          importMap: config.admin.importMap,\n          meta: config.admin.meta,\n          routes: config.admin.routes,\n          theme: config.admin.theme,\n          user: config.admin.user,\n        }\n        if (config.admin.livePreview) {\n          clientConfig.admin.livePreview = {}\n\n          if (config.admin.livePreview.breakpoints) {\n            clientConfig.admin.livePreview.breakpoints = config.admin.livePreview.breakpoints\n          }\n        }\n        break\n      case 'collections':\n        ;(clientConfig.collections as ClientCollectionConfig[]) = createClientCollectionConfigs({\n          collections: config.collections,\n          defaultIDType: config.db.defaultIDType,\n          i18n,\n          importMap,\n        })\n        break\n      case 'globals':\n        ;(clientConfig.globals as ClientGlobalConfig[]) = createClientGlobalConfigs({\n          defaultIDType: config.db.defaultIDType,\n          globals: config.globals,\n          i18n,\n          importMap,\n        })\n        break\n      case 'i18n':\n        clientConfig.i18n = {\n          fallbackLanguage: config.i18n.fallbackLanguage,\n          translations: config.i18n.translations,\n        }\n        break\n      case 'localization':\n        if (typeof config.localization === 'object' && config.localization) {\n          clientConfig.localization = {}\n          if (config.localization.defaultLocale) {\n            clientConfig.localization.defaultLocale = config.localization.defaultLocale\n          }\n          if (config.localization.fallback) {\n            clientConfig.localization.fallback = config.localization.fallback\n          }\n          if (config.localization.localeCodes) {\n            clientConfig.localization.localeCodes = config.localization.localeCodes\n          }\n          if (config.localization.locales) {\n            clientConfig.localization.locales = []\n            for (const locale of config.localization.locales) {\n              if (locale) {\n                const clientLocale: Partial<(typeof config.localization.locales)[0]> = {}\n                if (locale.code) {\n                  clientLocale.code = locale.code\n                }\n                if (locale.fallbackLocale) {\n                  clientLocale.fallbackLocale = locale.fallbackLocale\n                }\n                if (locale.label) {\n                  clientLocale.label = locale.label\n                }\n                if (locale.rtl) {\n                  clientLocale.rtl = locale.rtl\n                }\n                clientConfig.localization.locales.push(clientLocale)\n              }\n            }\n          }\n        }\n        break\n      default:\n        clientConfig[key] = config[key]\n    }\n  }\n  return clientConfig as ClientConfig\n}\n"],"names":["createClientCollectionConfigs","createClientGlobalConfigs","serverOnlyAdminConfigProperties","serverOnlyConfigProperties","createClientConfig","config","i18n","importMap","clientConfig","key","includes","admin","autoLogin","avatar","custom","dateFormat","disable","meta","routes","theme","user","livePreview","breakpoints","collections","defaultIDType","db","globals","fallbackLanguage","translations","localization","defaultLocale","fallback","localeCodes","locales","locale","clientLocale","code","fallbackLocale","label","rtl","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2834, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2840, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/types/constants.ts"],"sourcesContent":["export const validOperators = [\n  'equals',\n  'contains',\n  'not_equals',\n  'in',\n  'all',\n  'not_in',\n  'exists',\n  'greater_than',\n  'greater_than_equal',\n  'less_than',\n  'less_than_equal',\n  'like',\n  'within',\n  'intersects',\n  'near',\n] as const\n"],"names":["validOperators"],"mappings":";;;AAAO,MAAMA,iBAAiB;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAAS","ignoreList":[0]}},
    {"offset": {"line": 2860, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2866, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/types/index.ts"],"sourcesContent":["import type { I18n, TFunction } from '@payloadcms/translations'\nimport type DataLoader from 'dataloader'\nimport type { URL } from 'url'\n\nimport type {\n  DataFromCollectionSlug,\n  TypeWithID,\n  TypeWithTimestamps,\n} from '../collections/config/types.js'\nimport type payload from '../index.js'\nimport type {\n  CollectionSlug,\n  DataFromGlobalSlug,\n  GlobalSlug,\n  RequestContext,\n  TypedCollectionJoins,\n  TypedCollectionSelect,\n  TypedLocale,\n  TypedUser,\n} from '../index.js'\nimport type { validOperators } from './constants.js'\nexport type { Payload as Payload } from '../index.js'\n\nexport type CustomPayloadRequestProperties = {\n  context: RequestContext\n  /** The locale that should be used for a field when it is not translated to the requested locale */\n  fallbackLocale?: string\n  i18n: I18n\n  /**\n   * The requested locale if specified\n   * Only available for localized collections\n   */\n  locale?: TypedLocale\n  /**\n   * The payload object\n   */\n  payload: typeof payload\n  /**\n   * The context in which the request is being made\n   */\n  payloadAPI: 'GraphQL' | 'local' | 'REST'\n  /** Optimized document loader */\n  payloadDataLoader?: DataLoader<string, TypeWithID>\n  /** Resized versions of the image that was uploaded during this request */\n  payloadUploadSizes?: Record<string, Buffer>\n  /** Query params on the request */\n  query: Record<string, unknown>\n  /** Any response headers that are required to be set when a response is sent */\n  responseHeaders?: Headers\n  /** The route parameters\n   * @example\n   * /:collection/:id -> /posts/123\n   * { collection: 'posts', id: '123' }\n   */\n  routeParams?: Record<string, unknown>\n  /** Translate function - duplicate of i18n.t */\n  t: TFunction\n  /**\n   * Identifier for the database transaction for interactions in a single, all-or-nothing operation.\n   * Can also be used to ensure consistency when multiple operations try to create a transaction concurrently on the same request.\n   */\n  transactionID?: number | Promise<number | string> | string\n  /**\n   * Used to ensure consistency when multiple operations try to create a transaction concurrently on the same request\n   * @deprecated This is not used anywhere, instead `transactionID` is used for the above. Will be removed in next major version.\n   */\n  transactionIDPromise?: Promise<void>\n  /** The signed-in user */\n  user: null | TypedUser\n} & Pick<\n  URL,\n  'hash' | 'host' | 'href' | 'origin' | 'pathname' | 'port' | 'protocol' | 'search' | 'searchParams'\n>\ntype PayloadRequestData = {\n  /**\n   * Data from the request body\n   *\n   * Within Payload operations, i.e. hooks, data will be there\n   * BUT in custom endpoints it will not be, you will need to\n   * use either:\n   *  1. `const data = await req.json()`\n   *\n   *  2. import { addDataAndFileToRequest } from '@payloadcms/next/utilities'\n   *    `await addDataAndFileToRequest(req)`\n   * */\n  data?: JsonObject\n  /** The file on the request, same rules apply as the `data` property */\n  file?: {\n    data: Buffer\n    mimetype: string\n    name: string\n    size: number\n    tempFilePath?: string\n  }\n}\nexport type PayloadRequest = CustomPayloadRequestProperties &\n  Partial<Request> &\n  PayloadRequestData &\n  Required<Pick<Request, 'headers'>>\n\nexport type Operator = (typeof validOperators)[number]\n\n// Makes it so things like passing new Date() will error\nexport type JsonValue = JsonArray | JsonObject | unknown //Date | JsonArray | JsonObject | boolean | null | number | string // TODO: Evaluate proper, strong type for this\n\nexport type JsonArray = Array<JsonValue>\n\nexport interface JsonObject {\n  [key: string]: any\n}\n\nexport type WhereField = {\n  // any json-serializable value\n  [key in Operator]?: JsonValue\n}\n\nexport type Where = {\n  [key: string]: Where[] | WhereField\n  and?: Where[]\n  or?: Where[]\n}\n\nexport type Sort = Array<string> | string\n\ntype SerializableValue = boolean | number | object | string\nexport type DefaultValue =\n  | ((args: {\n      locale?: TypedLocale\n      req: PayloadRequest\n      user: PayloadRequest['user']\n    }) => SerializableValue)\n  | SerializableValue\n\n/**\n * Applies pagination for join fields for including collection relationships\n */\nexport type JoinQuery<TSlug extends CollectionSlug = string> =\n  TypedCollectionJoins[TSlug] extends Record<string, string>\n    ?\n        | false\n        | Partial<{\n            [K in keyof TypedCollectionJoins[TSlug]]:\n              | {\n                  limit?: number\n                  sort?: string\n                  where?: Where\n                }\n              | false\n          }>\n    : never\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Document = any\n\nexport type Operation = 'create' | 'delete' | 'read' | 'update'\nexport type VersionOperations = 'readVersions'\nexport type AuthOperations = 'unlock'\nexport type AllOperations = AuthOperations | Operation | VersionOperations\n\nexport function docHasTimestamps(doc: any): doc is TypeWithTimestamps {\n  return doc?.createdAt && doc?.updatedAt\n}\n\nexport type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N // This is a commonly used trick to detect 'any'\nexport type IsAny<T> = IfAny<T, true, false>\nexport type ReplaceAny<T, DefaultType> = IsAny<T> extends true ? DefaultType : T\n\nexport type SelectIncludeType = {\n  [k: string]: SelectIncludeType | true\n}\n\nexport type SelectExcludeType = {\n  [k: string]: false | SelectExcludeType\n}\n\nexport type SelectMode = 'exclude' | 'include'\n\nexport type SelectType = SelectExcludeType | SelectIncludeType\n\nexport type ApplyDisableErrors<T, DisableErrors = false> = false extends DisableErrors\n  ? T\n  : null | T\n\nexport type TransformDataWithSelect<\n  Data extends Record<string, any>,\n  Select extends SelectType,\n> = Select extends never\n  ? Data\n  : string extends keyof Select\n    ? Data\n    : // START Handle types when they aren't generated\n      // For example in any package in this repository outside of tests / plugins\n      // This stil gives us autocomplete when using include select mode, i.e select: {title :true} returns type {title: any, id: string | number}\n      string extends keyof Omit<Data, 'id'>\n      ? Select extends SelectIncludeType\n        ? {\n            [K in Data extends TypeWithID ? 'id' | keyof Select : keyof Select]: K extends 'id'\n              ? number | string\n              : unknown\n          }\n        : Data\n      : // END Handle types when they aren't generated\n        // Handle include mode\n        Select extends SelectIncludeType\n        ? {\n            [K in keyof Data as K extends keyof Select\n              ? Select[K] extends object | true\n                ? K\n                : never\n              : // select 'id' always\n                K extends 'id'\n                ? K\n                : never]: Data[K]\n          }\n        : // Handle exclude mode\n          {\n            [K in keyof Data as K extends keyof Select\n              ? Select[K] extends object | undefined\n                ? K\n                : never\n              : K]: Data[K]\n          }\n\nexport type TransformCollectionWithSelect<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectType,\n> = TSelect extends SelectType\n  ? TransformDataWithSelect<DataFromCollectionSlug<TSlug>, TSelect>\n  : DataFromCollectionSlug<TSlug>\n\nexport type TransformGlobalWithSelect<\n  TSlug extends GlobalSlug,\n  TSelect extends SelectType,\n> = TSelect extends SelectType\n  ? TransformDataWithSelect<DataFromGlobalSlug<TSlug>, TSelect>\n  : DataFromGlobalSlug<TSlug>\n\nexport type PopulateType = Partial<TypedCollectionSelect>\n"],"names":["docHasTimestamps","doc","createdAt","updatedAt"],"mappings":";;;AA+JO,SAASA,iBAAiBC,GAAQ;IACvC,OAAOA,KAAKC,aAAaD,KAAKE;AAChC","ignoreList":[0]}},
    {"offset": {"line": 2872, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2878, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/defaults.ts"],"sourcesContent":["export const versionDefaults = {\n  autosaveInterval: 2000,\n}\n"],"names":["versionDefaults","autosaveInterval"],"mappings":";;;AAAO,MAAMA,kBAAkB;IAC7BC,kBAAkB;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2884, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2890, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/baseFields.ts"],"sourcesContent":["import type { CheckboxField, Field } from '../fields/config/types.js'\n\nexport const statuses = [\n  {\n    label: ({ t }) => t('version:draft'),\n    value: 'draft',\n  },\n  {\n    label: ({ t }) => t('version:published'),\n    value: 'published',\n  },\n]\n\nconst baseVersionFields: Field[] = [\n  {\n    name: '_status',\n    type: 'select',\n    admin: {\n      components: {\n        Field: false,\n      },\n      disableBulkEdit: true,\n    },\n    defaultValue: 'draft',\n    index: true,\n    label: ({ t }) => t('version:status'),\n    options: statuses,\n  },\n]\n\n// When publishing a specific locale,\n// we need to create a new draft which acts as a\n// \"snapshot\" to retain all existing draft data.\n// This field will be used to exclude any snapshot versions\n// from the admin Versions list\nexport const versionSnapshotField: CheckboxField = {\n  name: 'snapshot',\n  type: 'checkbox',\n  admin: {\n    disableBulkEdit: true,\n    disabled: true,\n  },\n  index: true,\n}\n\nexport default baseVersionFields\n"],"names":["statuses","label","t","value","baseVersionFields","name","type","admin","components","Field","disableBulkEdit","defaultValue","index","options","versionSnapshotField","disabled"],"mappings":";;;;;AAEO,MAAMA,WAAW;IACtB;QACEC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACpBC,OAAO;IACT;IACA;QACEF,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACpBC,OAAO;IACT;CACD,CAAA;AAED,MAAMC,oBAA6B;IACjC;QACEC,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,YAAY;gBACVC,OAAO;YACT;YACAC,iBAAiB;QACnB;QACAC,cAAc;QACdC,OAAO;QACPX,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACpBW,SAASb;IACX;CACD;AAOM,MAAMc,uBAAsC;IACjDT,MAAM;IACNC,MAAM;IACNC,OAAO;QACLG,iBAAiB;QACjBK,UAAU;IACZ;IACAH,OAAO;AACT,EAAC;uCAEcR,kBAAiB","ignoreList":[0]}},
    {"offset": {"line": 2932, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2938, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/buildGlobalFields.ts"],"sourcesContent":["import type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FlattenedField } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { versionSnapshotField } from './baseFields.js'\n\nexport const buildVersionGlobalFields = <T extends boolean = false>(\n  config: SanitizedConfig,\n  global: SanitizedGlobalConfig,\n  flatten?: T,\n): true extends T ? FlattenedField[] : Field[] => {\n  const fields: FlattenedField[] = [\n    {\n      name: 'version',\n      type: 'group',\n      fields: global.fields,\n      ...(flatten && {\n        flattenedFields: global.flattenedFields,\n      }),\n    },\n    {\n      name: 'createdAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n    {\n      name: 'updatedAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n  ]\n\n  if (global?.versions?.drafts) {\n    if (config.localization) {\n      fields.push(versionSnapshotField)\n\n      fields.push({\n        name: 'publishedLocale',\n        type: 'select',\n        admin: {\n          disableBulkEdit: true,\n          disabled: true,\n        },\n        index: true,\n        options: config.localization.locales.map((locale) => {\n          if (typeof locale === 'string') {\n            return locale\n          }\n\n          return locale.code\n        }),\n      })\n    }\n\n    fields.push({\n      name: 'latest',\n      type: 'checkbox',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    })\n\n    if (global?.versions?.drafts?.autosave) {\n      fields.push({\n        name: 'autosave',\n        type: 'checkbox',\n        index: true,\n      })\n    }\n  }\n\n  return fields as true extends T ? FlattenedField[] : Field[]\n}\n"],"names":["versionSnapshotField","buildVersionGlobalFields","config","global","flatten","fields","name","type","flattenedFields","admin","disabled","index","versions","drafts","localization","push","disableBulkEdit","options","locales","map","locale","code","autosave"],"mappings":";;;AAIA,SAASA,oBAAoB,QAAQ,kBAAiB;;AAE/C,MAAMC,2BAA2B,CACtCC,QACAC,QACAC;IAEA,MAAMC,SAA2B;QAC/B;YACEC,MAAM;YACNC,MAAM;YACNF,QAAQF,OAAOE,MAAM;YACrB,GAAID,WAAW;gBACbI,iBAAiBL,OAAOK,eAAe;YACzC,CAAC;QACH;QACA;YACEF,MAAM;YACNC,MAAM;YACNE,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;QACA;YACEL,MAAM;YACNC,MAAM;YACNE,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;KACD;IAED,IAAIR,QAAQS,UAAUC,QAAQ;QAC5B,IAAIX,OAAOY,YAAY,EAAE;YACvBT,OAAOU,IAAI,iXAACf,uBAAAA;YAEZK,OAAOU,IAAI,CAAC;gBACVT,MAAM;gBACNC,MAAM;gBACNE,OAAO;oBACLO,iBAAiB;oBACjBN,UAAU;gBACZ;gBACAC,OAAO;gBACPM,SAASf,OAAOY,YAAY,CAACI,OAAO,CAACC,GAAG,CAAC,CAACC;oBACxC,IAAI,OAAOA,WAAW,UAAU;wBAC9B,OAAOA;oBACT;oBAEA,OAAOA,OAAOC,IAAI;gBACpB;YACF;QACF;QAEAhB,OAAOU,IAAI,CAAC;YACVT,MAAM;YACNC,MAAM;YACNE,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;QAEA,IAAIR,QAAQS,UAAUC,QAAQS,UAAU;YACtCjB,OAAOU,IAAI,CAAC;gBACVT,MAAM;gBACNC,MAAM;gBACNI,OAAO;YACT;QACF;IACF;IAEA,OAAON;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3007, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3013, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/buildCollectionFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FlattenedField } from '../fields/config/types.js'\n\nimport { versionSnapshotField } from './baseFields.js'\n\nexport const buildVersionCollectionFields = <T extends boolean = false>(\n  config: SanitizedConfig,\n  collection: SanitizedCollectionConfig,\n  flatten?: T,\n): true extends T ? FlattenedField[] : Field[] => {\n  const fields: FlattenedField[] = [\n    {\n      name: 'parent',\n      type: 'relationship',\n      index: true,\n      relationTo: collection.slug,\n    },\n    {\n      name: 'version',\n      type: 'group',\n      fields: collection.fields.filter((field) => !('name' in field) || field.name !== 'id'),\n      ...(flatten && {\n        flattenedFields: collection.flattenedFields.filter((each) => each.name !== 'id'),\n      }),\n    },\n    {\n      name: 'createdAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n    {\n      name: 'updatedAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n  ]\n\n  if (collection?.versions?.drafts) {\n    if (config.localization) {\n      fields.push(versionSnapshotField)\n\n      fields.push({\n        name: 'publishedLocale',\n        type: 'select',\n        admin: {\n          disableBulkEdit: true,\n          disabled: true,\n        },\n        index: true,\n        options: config.localization.locales.map((locale) => {\n          if (typeof locale === 'string') {\n            return locale\n          }\n\n          return locale.code\n        }),\n      })\n    }\n\n    fields.push({\n      name: 'latest',\n      type: 'checkbox',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    })\n\n    if (collection?.versions?.drafts?.autosave) {\n      fields.push({\n        name: 'autosave',\n        type: 'checkbox',\n        index: true,\n      })\n    }\n  }\n\n  return fields as true extends T ? FlattenedField[] : Field[]\n}\n"],"names":["versionSnapshotField","buildVersionCollectionFields","config","collection","flatten","fields","name","type","index","relationTo","slug","filter","field","flattenedFields","each","admin","disabled","versions","drafts","localization","push","disableBulkEdit","options","locales","map","locale","code","autosave"],"mappings":";;;AAIA,SAASA,oBAAoB,QAAQ,kBAAiB;;AAE/C,MAAMC,+BAA+B,CAC1CC,QACAC,YACAC;IAEA,MAAMC,SAA2B;QAC/B;YACEC,MAAM;YACNC,MAAM;YACNC,OAAO;YACPC,YAAYN,WAAWO,IAAI;QAC7B;QACA;YACEJ,MAAM;YACNC,MAAM;YACNF,QAAQF,WAAWE,MAAM,CAACM,MAAM,CAAC,CAACC,QAAU,CAAE,CAAA,UAAUA,KAAI,KAAMA,MAAMN,IAAI,KAAK;YACjF,GAAIF,WAAW;gBACbS,iBAAiBV,WAAWU,eAAe,CAACF,MAAM,CAAC,CAACG,OAASA,KAAKR,IAAI,KAAK;YAC7E,CAAC;QACH;QACA;YACEA,MAAM;YACNC,MAAM;YACNQ,OAAO;gBACLC,UAAU;YACZ;YACAR,OAAO;QACT;QACA;YACEF,MAAM;YACNC,MAAM;YACNQ,OAAO;gBACLC,UAAU;YACZ;YACAR,OAAO;QACT;KACD;IAED,IAAIL,YAAYc,UAAUC,QAAQ;QAChC,IAAIhB,OAAOiB,YAAY,EAAE;YACvBd,OAAOe,IAAI,iXAACpB,uBAAAA;YAEZK,OAAOe,IAAI,CAAC;gBACVd,MAAM;gBACNC,MAAM;gBACNQ,OAAO;oBACLM,iBAAiB;oBACjBL,UAAU;gBACZ;gBACAR,OAAO;gBACPc,SAASpB,OAAOiB,YAAY,CAACI,OAAO,CAACC,GAAG,CAAC,CAACC;oBACxC,IAAI,OAAOA,WAAW,UAAU;wBAC9B,OAAOA;oBACT;oBAEA,OAAOA,OAAOC,IAAI;gBACpB;YACF;QACF;QAEArB,OAAOe,IAAI,CAAC;YACVd,MAAM;YACNC,MAAM;YACNQ,OAAO;gBACLC,UAAU;YACZ;YACAR,OAAO;QACT;QAEA,IAAIL,YAAYc,UAAUC,QAAQS,UAAU;YAC1CtB,OAAOe,IAAI,CAAC;gBACVd,MAAM;gBACNC,MAAM;gBACNC,OAAO;YACT;QACF;IACF;IAEA,OAAOH;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3088, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3094, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/drafts/appendVersionToQueryKey.ts"],"sourcesContent":["import type { Where } from '../../types/index.js'\n\nexport const appendVersionToQueryKey = (query: Where = {}): Where => {\n  return Object.entries(query).reduce((res, [key, val]) => {\n    if (['AND', 'and', 'OR', 'or'].includes(key) && Array.isArray(val)) {\n      return {\n        ...res,\n        [key.toLowerCase()]: val.map((subQuery) => appendVersionToQueryKey(subQuery)),\n      }\n    }\n\n    if (key !== 'id') {\n      return {\n        ...res,\n        [`version.${key}`]: val,\n      }\n    }\n\n    return {\n      ...res,\n      parent: val,\n    }\n  }, {})\n}\n"],"names":["appendVersionToQueryKey","query","Object","entries","reduce","res","key","val","includes","Array","isArray","toLowerCase","map","subQuery","parent"],"mappings":";;;AAEO,MAAMA,0BAA0B,CAACC,QAAe,CAAC,CAAC;IACvD,OAAOC,OAAOC,OAAO,CAACF,OAAOG,MAAM,CAAC,CAACC,KAAK,CAACC,KAAKC,IAAI;QAClD,IAAI;YAAC;YAAO;YAAO;YAAM;SAAK,CAACC,QAAQ,CAACF,QAAQG,MAAMC,OAAO,CAACH,MAAM;YAClE,OAAO;gBACL,GAAGF,GAAG;gBACN,CAACC,IAAIK,WAAW,GAAG,EAAEJ,IAAIK,GAAG,CAAC,CAACC,WAAab,wBAAwBa;YACrE;QACF;QAEA,IAAIP,QAAQ,MAAM;YAChB,OAAO;gBACL,GAAGD,GAAG;gBACN,CAAC,CAAC,QAAQ,EAAEC,KAAK,CAAC,EAAEC;YACtB;QACF;QAEA,OAAO;YACL,GAAGF,GAAG;YACNS,QAAQP;QACV;IACF,GAAG,CAAC;AACN,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3122, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3128, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/getLatestCollectionVersion.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { FindOneArgs } from '../database/types.js'\nimport type { Payload, PayloadRequest } from '../types/index.js'\nimport type { TypeWithVersion } from './types.js'\n\nimport { combineQueries } from '../database/combineQueries.js'\nimport { appendVersionToQueryKey } from './drafts/appendVersionToQueryKey.js'\n\ntype Args = {\n  config: SanitizedCollectionConfig\n  id: number | string\n  payload: Payload\n  published?: boolean\n  query: FindOneArgs\n  req?: PayloadRequest\n}\n\nexport const getLatestCollectionVersion = async <T extends TypeWithID = any>({\n  id,\n  config,\n  payload,\n  published,\n  query,\n  req,\n}: Args): Promise<T> => {\n  let latestVersion: TypeWithVersion<T>\n\n  const whereQuery = published\n    ? { and: [{ parent: { equals: id } }, { 'version._status': { equals: 'published' } }] }\n    : { and: [{ parent: { equals: id } }, { latest: { equals: true } }] }\n\n  if (config.versions?.drafts) {\n    const { docs } = await payload.db.findVersions<T>({\n      collection: config.slug,\n      limit: 1,\n      pagination: false,\n      req,\n      sort: '-updatedAt',\n      where: combineQueries(appendVersionToQueryKey(query.where), whereQuery),\n    })\n    ;[latestVersion] = docs\n  }\n\n  if (!latestVersion) {\n    if (!published) {\n      const doc = await payload.db.findOne<T>({ ...query, req })\n\n      return doc\n    }\n\n    return undefined\n  }\n\n  latestVersion.version.id = id\n\n  return latestVersion.version\n}\n"],"names":["combineQueries","appendVersionToQueryKey","getLatestCollectionVersion","id","config","payload","published","query","req","latestVersion","whereQuery","and","parent","equals","latest","versions","drafts","docs","db","findVersions","collection","slug","limit","pagination","sort","where","doc","findOne","undefined","version"],"mappings":";;;AAKA,SAASA,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,uBAAuB,QAAQ,sCAAqC;;;AAWtE,MAAMC,6BAA6B,OAAmC,EAC3EC,EAAE,EACFC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,KAAK,EACLC,GAAG,EACE;IACL,IAAIC;IAEJ,MAAMC,aAAaJ,YACf;QAAEK,KAAK;YAAC;gBAAEC,QAAQ;oBAAEC,QAAQV;gBAAG;YAAE;YAAG;gBAAE,mBAAmB;oBAAEU,QAAQ;gBAAY;YAAE;SAAE;IAAC,IACpF;QAAEF,KAAK;YAAC;gBAAEC,QAAQ;oBAAEC,QAAQV;gBAAG;YAAE;YAAG;gBAAEW,QAAQ;oBAAED,QAAQ;gBAAK;YAAE;SAAE;IAAC;IAEtE,IAAIT,OAAOW,QAAQ,EAAEC,QAAQ;QAC3B,MAAM,EAAEC,IAAI,EAAE,GAAG,MAAMZ,QAAQa,EAAE,CAACC,YAAY,CAAI;YAChDC,YAAYhB,OAAOiB,IAAI;YACvBC,OAAO;YACPC,YAAY;YACZf;YACAgB,MAAM;YACNC,+XAAOzB,iBAAAA,6YAAeC,0BAAAA,EAAwBM,MAAMkB,KAAK,GAAGf;QAC9D;QACC,CAACD,cAAc,GAAGQ;IACrB;IAEA,IAAI,CAACR,eAAe;QAClB,IAAI,CAACH,WAAW;YACd,MAAMoB,MAAM,MAAMrB,QAAQa,EAAE,CAACS,OAAO,CAAI;gBAAE,GAAGpB,KAAK;gBAAEC;YAAI;YAExD,OAAOkB;QACT;QAEA,OAAOE;IACT;IAEAnB,cAAcoB,OAAO,CAAC1B,EAAE,GAAGA;IAE3B,OAAOM,cAAcoB,OAAO;AAC9B,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3188, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3194, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/drafts/getQueryDraftsSelect.ts"],"sourcesContent":["import type { SelectType } from '../../types/index.js'\n\nimport { getSelectMode } from '../../utilities/getSelectMode.js'\n\nexport const getQueryDraftsSelect = ({\n  select,\n}: {\n  select?: SelectType\n}): SelectType | undefined => {\n  if (!select) {\n    return\n  }\n\n  const mode = getSelectMode(select)\n\n  if (mode === 'include') {\n    return {\n      parent: true,\n      version: select,\n    } as SelectType\n  }\n\n  return {\n    version: select,\n  } as SelectType\n}\n"],"names":["getSelectMode","getQueryDraftsSelect","select","mode","parent","version"],"mappings":";;;AAEA,SAASA,aAAa,QAAQ,mCAAkC;;AAEzD,MAAMC,uBAAuB,CAAC,EACnCC,MAAM,EAGP;IACC,IAAI,CAACA,QAAQ;QACX;IACF;IAEA,MAAMC,OAAOH,wYAAAA,EAAcE;IAE3B,IAAIC,SAAS,WAAW;QACtB,OAAO;YACLC,QAAQ;YACRC,SAASH;QACX;IACF;IAEA,OAAO;QACLG,SAASH;IACX;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3214, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3220, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/enforceMaxVersions.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Payload, PayloadRequest, Where } from '../types/index.js'\n\ntype Args = {\n  collection?: SanitizedCollectionConfig\n  global?: SanitizedGlobalConfig\n  id?: number | string\n  max: number\n  payload: Payload\n  req?: PayloadRequest\n}\n\nexport const enforceMaxVersions = async ({\n  id,\n  collection,\n  global,\n  max,\n  payload,\n  req,\n}: Args): Promise<void> => {\n  const entityType = collection ? 'collection' : 'global'\n  const slug = collection ? collection.slug : global?.slug\n\n  try {\n    const where: Where = {}\n    let oldestAllowedDoc\n\n    if (collection) {\n      where.parent = {\n        equals: id,\n      }\n\n      const query = await payload.db.findVersions({\n        collection: collection.slug,\n        limit: 1,\n        pagination: false,\n        req,\n        skip: max,\n        sort: '-updatedAt',\n        where,\n      })\n\n      ;[oldestAllowedDoc] = query.docs\n    } else if (global) {\n      const query = await payload.db.findGlobalVersions({\n        global: global.slug,\n        limit: 1,\n        pagination: false,\n        req,\n        skip: max,\n        sort: '-updatedAt',\n        where,\n      })\n\n      ;[oldestAllowedDoc] = query.docs\n    }\n\n    if (oldestAllowedDoc?.updatedAt) {\n      const deleteQuery: Where = {\n        updatedAt: {\n          less_than_equal: oldestAllowedDoc.updatedAt,\n        },\n      }\n\n      if (collection) {\n        deleteQuery.parent = {\n          equals: id,\n        }\n      }\n\n      await payload.db.deleteVersions({\n        collection: slug,\n        req,\n        where: deleteQuery,\n      })\n    }\n  } catch (err) {\n    payload.logger.error(\n      `There was an error cleaning up old versions for the ${entityType} ${slug}`,\n    )\n  }\n}\n"],"names":["enforceMaxVersions","id","collection","global","max","payload","req","entityType","slug","where","oldestAllowedDoc","parent","equals","query","db","findVersions","limit","pagination","skip","sort","docs","findGlobalVersions","updatedAt","deleteQuery","less_than_equal","deleteVersions","err","logger","error"],"mappings":";;;AAaO,MAAMA,qBAAqB,OAAO,EACvCC,EAAE,EACFC,UAAU,EACVC,MAAM,EACNC,GAAG,EACHC,OAAO,EACPC,GAAG,EACE;IACL,MAAMC,aAAaL,aAAa,eAAe;IAC/C,MAAMM,OAAON,aAAaA,WAAWM,IAAI,GAAGL,QAAQK;IAEpD,IAAI;QACF,MAAMC,QAAe,CAAC;QACtB,IAAIC;QAEJ,IAAIR,YAAY;YACdO,MAAME,MAAM,GAAG;gBACbC,QAAQX;YACV;YAEA,MAAMY,QAAQ,MAAMR,QAAQS,EAAE,CAACC,YAAY,CAAC;gBAC1Cb,YAAYA,WAAWM,IAAI;gBAC3BQ,OAAO;gBACPC,YAAY;gBACZX;gBACAY,MAAMd;gBACNe,MAAM;gBACNV;YACF;YAEC,CAACC,iBAAiB,GAAGG,MAAMO,IAAI;QAClC,OAAO,IAAIjB,QAAQ;YACjB,MAAMU,QAAQ,MAAMR,QAAQS,EAAE,CAACO,kBAAkB,CAAC;gBAChDlB,QAAQA,OAAOK,IAAI;gBACnBQ,OAAO;gBACPC,YAAY;gBACZX;gBACAY,MAAMd;gBACNe,MAAM;gBACNV;YACF;YAEC,CAACC,iBAAiB,GAAGG,MAAMO,IAAI;QAClC;QAEA,IAAIV,kBAAkBY,WAAW;YAC/B,MAAMC,cAAqB;gBACzBD,WAAW;oBACTE,iBAAiBd,iBAAiBY,SAAS;gBAC7C;YACF;YAEA,IAAIpB,YAAY;gBACdqB,YAAYZ,MAAM,GAAG;oBACnBC,QAAQX;gBACV;YACF;YAEA,MAAMI,QAAQS,EAAE,CAACW,cAAc,CAAC;gBAC9BvB,YAAYM;gBACZF;gBACAG,OAAOc;YACT;QACF;IACF,EAAE,OAAOG,KAAK;QACZrB,QAAQsB,MAAM,CAACC,KAAK,CAClB,CAAC,oDAAoD,EAAErB,WAAW,CAAC,EAAEC,MAAM;IAE/E;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3276, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3282, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/saveVersion.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Payload } from '../index.js'\nimport type { PayloadRequest, SelectType } from '../types/index.js'\n\nimport { deepCopyObjectSimple } from '../index.js'\nimport sanitizeInternalFields from '../utilities/sanitizeInternalFields.js'\nimport { getQueryDraftsSelect } from './drafts/getQueryDraftsSelect.js'\nimport { enforceMaxVersions } from './enforceMaxVersions.js'\n\ntype Args = {\n  autosave?: boolean\n  collection?: SanitizedCollectionConfig\n  docWithLocales: any\n  draft?: boolean\n  global?: SanitizedGlobalConfig\n  id?: number | string\n  payload: Payload\n  publishSpecificLocale?: string\n  req?: PayloadRequest\n  select?: SelectType\n  snapshot?: any\n}\n\nexport const saveVersion = async ({\n  id,\n  autosave,\n  collection,\n  docWithLocales: doc,\n  draft,\n  global,\n  payload,\n  publishSpecificLocale,\n  req,\n  select,\n  snapshot,\n}: Args): Promise<TypeWithID> => {\n  let result\n  let createNewVersion = true\n  const now = new Date().toISOString()\n  const versionData = deepCopyObjectSimple(doc)\n  if (draft) {\n    versionData._status = 'draft'\n  }\n  if (versionData._id) {\n    delete versionData._id\n  }\n\n  try {\n    if (autosave) {\n      let docs\n      const findVersionArgs = {\n        limit: 1,\n        pagination: false,\n        req,\n        sort: '-updatedAt',\n      }\n\n      if (collection) {\n        ;({ docs } = await payload.db.findVersions({\n          ...findVersionArgs,\n          collection: collection.slug,\n          limit: 1,\n          pagination: false,\n          req,\n          where: {\n            parent: {\n              equals: id,\n            },\n          },\n        }))\n      } else {\n        ;({ docs } = await payload.db.findGlobalVersions({\n          ...findVersionArgs,\n          global: global.slug,\n          limit: 1,\n          pagination: false,\n          req,\n        }))\n      }\n      const [latestVersion] = docs\n\n      // overwrite the latest version if it's set to autosave\n      if (latestVersion?.autosave === true) {\n        createNewVersion = false\n\n        const data: Record<string, unknown> = {\n          createdAt: new Date(latestVersion.createdAt).toISOString(),\n          latest: true,\n          parent: id,\n          updatedAt: now,\n          version: {\n            ...versionData,\n          },\n        }\n\n        const updateVersionArgs = {\n          id: latestVersion.id,\n          req,\n          versionData: data as TypeWithID,\n        }\n\n        if (collection) {\n          result = await payload.db.updateVersion({\n            ...updateVersionArgs,\n            collection: collection.slug,\n            req,\n          })\n        } else {\n          result = await payload.db.updateGlobalVersion({\n            ...updateVersionArgs,\n            global: global.slug,\n            req,\n          })\n        }\n      }\n    }\n\n    if (createNewVersion) {\n      const createVersionArgs = {\n        autosave: Boolean(autosave),\n        collectionSlug: undefined,\n        createdAt: now,\n        globalSlug: undefined,\n        parent: collection ? id : undefined,\n        publishedLocale: publishSpecificLocale || undefined,\n        req,\n        select: getQueryDraftsSelect({ select }),\n        updatedAt: now,\n        versionData,\n      }\n\n      if (collection) {\n        createVersionArgs.collectionSlug = collection.slug\n        result = await payload.db.createVersion(createVersionArgs)\n      }\n\n      if (global) {\n        createVersionArgs.globalSlug = global.slug\n        result = await payload.db.createGlobalVersion(createVersionArgs)\n      }\n\n      if (publishSpecificLocale && snapshot) {\n        const snapshotData = deepCopyObjectSimple(snapshot)\n        if (snapshotData._id) {\n          delete snapshotData._id\n        }\n\n        snapshotData._status = 'draft'\n\n        const snapshotDate = new Date().toISOString()\n\n        const updatedArgs = {\n          ...createVersionArgs,\n          createdAt: snapshotDate,\n          snapshot: true,\n          updatedAt: snapshotDate,\n          versionData: snapshotData,\n        } as any\n\n        if (collection) {\n          await payload.db.createVersion(updatedArgs)\n        }\n        if (global) {\n          await payload.db.createGlobalVersion(updatedArgs)\n        }\n      }\n    }\n  } catch (err) {\n    let errorMessage: string | undefined\n\n    if (collection) {\n      errorMessage = `There was an error while saving a version for the ${typeof collection.labels.singular === 'string' ? collection.labels.singular : collection.slug} with ID ${id}.`\n    }\n    if (global) {\n      errorMessage = `There was an error while saving a version for the global ${typeof global.label === 'string' ? global.label : global.slug}.`\n    }\n    payload.logger.error({ err, msg: errorMessage })\n    return\n  }\n\n  const max = collection ? collection.versions.maxPerDoc : global.versions.max\n\n  if (createNewVersion && max > 0) {\n    await enforceMaxVersions({\n      id,\n      collection,\n      global,\n      max,\n      payload,\n      req,\n    })\n  }\n\n  let createdVersion = result.version\n\n  createdVersion = sanitizeInternalFields(createdVersion)\n  createdVersion.id = result.parent\n\n  return createdVersion\n}\n"],"names":["deepCopyObjectSimple","sanitizeInternalFields","getQueryDraftsSelect","enforceMaxVersions","saveVersion","id","autosave","collection","docWithLocales","doc","draft","global","payload","publishSpecificLocale","req","select","snapshot","result","createNewVersion","now","Date","toISOString","versionData","_status","_id","docs","findVersionArgs","limit","pagination","sort","db","findVersions","slug","where","parent","equals","findGlobalVersions","latestVersion","data","createdAt","latest","updatedAt","version","updateVersionArgs","updateVersion","updateGlobalVersion","createVersionArgs","Boolean","collectionSlug","undefined","globalSlug","publishedLocale","createVersion","createGlobalVersion","snapshotData","snapshotDate","updatedArgs","err","errorMessage","labels","singular","label","logger","error","msg","max","versions","maxPerDoc","createdVersion"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3445, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3451, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/deleteCollectionVersions.ts"],"sourcesContent":["import type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\ntype Args = {\n  id?: number | string\n  payload: Payload\n  req?: PayloadRequest\n  slug: string\n}\n\nexport const deleteCollectionVersions = async ({ id, slug, payload, req }: Args): Promise<void> => {\n  try {\n    await payload.db.deleteVersions({\n      collection: slug,\n      req,\n      where: {\n        parent: {\n          equals: id,\n        },\n      },\n    })\n  } catch (err) {\n    payload.logger.error(\n      `There was an error removing versions for the deleted ${slug} document with ID ${id}.`,\n    )\n  }\n}\n"],"names":["deleteCollectionVersions","id","slug","payload","req","db","deleteVersions","collection","where","parent","equals","err","logger","error"],"mappings":";;;AAUO,MAAMA,2BAA2B,OAAO,EAAEC,EAAE,EAAEC,IAAI,EAAEC,OAAO,EAAEC,GAAG,EAAQ;IAC7E,IAAI;QACF,MAAMD,QAAQE,EAAE,CAACC,cAAc,CAAC;YAC9BC,YAAYL;YACZE;YACAI,OAAO;gBACLC,QAAQ;oBACNC,QAAQT;gBACV;YACF;QACF;IACF,EAAE,OAAOU,KAAK;QACZR,QAAQS,MAAM,CAACC,KAAK,CAClB,CAAC,qDAAqD,EAAEX,KAAK,kBAAkB,EAAED,GAAG,CAAC,CAAC;IAE1F;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3469, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3475, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/drafts/getQueryDraftsSort.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { Sort } from '../../types/index.js'\n\n/**\n * Takes the incoming sort argument and prefixes it with `versions.` and preserves any `-` prefixes for descending order\n * @param sort\n */\nexport const getQueryDraftsSort = ({\n  collectionConfig,\n  sort,\n}: {\n  collectionConfig: SanitizedCollectionConfig\n  sort?: Sort\n}): Sort => {\n  if (!sort) {\n    if (collectionConfig.defaultSort) {\n      sort = collectionConfig.defaultSort\n    } else {\n      sort = '-createdAt'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  return sort.map((field: string) => {\n    let orderBy: string\n    let direction = ''\n    if (field[0] === '-') {\n      orderBy = field.substring(1)\n      direction = '-'\n    } else {\n      orderBy = field\n    }\n\n    if (orderBy === 'id') {\n      return `${direction}parent`\n    }\n\n    return `${direction}version.${orderBy}`\n  })\n}\n"],"names":["getQueryDraftsSort","collectionConfig","sort","defaultSort","map","field","orderBy","direction","substring"],"mappings":"AAGA;;;CAGC,GACD;;;AAAO,MAAMA,qBAAqB,CAAC,EACjCC,gBAAgB,EAChBC,IAAI,EAIL;IACC,IAAI,CAACA,MAAM;QACT,IAAID,iBAAiBE,WAAW,EAAE;YAChCD,OAAOD,iBAAiBE,WAAW;QACrC,OAAO;YACLD,OAAO;QACT;IACF;IAEA,IAAI,OAAOA,SAAS,UAAU;QAC5BA,OAAO;YAACA;SAAK;IACf;IAEA,OAAOA,KAAKE,GAAG,CAAC,CAACC;QACf,IAAIC;QACJ,IAAIC,YAAY;QAChB,IAAIF,KAAK,CAAC,EAAE,KAAK,KAAK;YACpBC,UAAUD,MAAMG,SAAS,CAAC;YAC1BD,YAAY;QACd,OAAO;YACLD,UAAUD;QACZ;QAEA,IAAIC,YAAY,MAAM;YACpB,OAAO,GAAGC,UAAU,MAAM,CAAC;QAC7B;QAEA,OAAO,GAAGA,UAAU,QAAQ,EAAED,SAAS;IACzC;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3509, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3515, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/drafts/replaceWithDraftIfAvailable.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'\nimport type { AccessResult } from '../../config/types.js'\nimport type { FindGlobalVersionsArgs, FindVersionsArgs } from '../../database/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { PayloadRequest, SelectType, Where } from '../../types/index.js'\n\nimport { hasWhereAccessResult } from '../../auth/index.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { docHasTimestamps } from '../../types/index.js'\nimport { deepCopyObjectSimple } from '../../utilities/deepCopyObject.js'\nimport sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'\nimport { appendVersionToQueryKey } from './appendVersionToQueryKey.js'\nimport { getQueryDraftsSelect } from './getQueryDraftsSelect.js'\n\ntype Arguments<T> = {\n  accessResult: AccessResult\n  doc: T\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n  entityType: 'collection' | 'global'\n  overrideAccess: boolean\n  req: PayloadRequest\n  select?: SelectType\n}\n\nconst replaceWithDraftIfAvailable = async <T extends TypeWithID>({\n  accessResult,\n  doc,\n  entity,\n  entityType,\n  req,\n  select,\n}: Arguments<T>): Promise<T> => {\n  const { locale } = req\n\n  const queryToBuild: Where = {\n    and: [\n      {\n        'version._status': {\n          equals: 'draft',\n        },\n      },\n    ],\n  }\n\n  if (entityType === 'collection') {\n    queryToBuild.and.push({\n      parent: {\n        equals: doc.id,\n      },\n    })\n  }\n\n  if (docHasTimestamps(doc)) {\n    queryToBuild.and.push({\n      or: [\n        {\n          updatedAt: {\n            greater_than: doc.updatedAt,\n          },\n        },\n        {\n          latest: {\n            equals: true,\n          },\n        },\n      ],\n    })\n  }\n\n  let versionAccessResult\n\n  if (hasWhereAccessResult(accessResult)) {\n    versionAccessResult = appendVersionToQueryKey(accessResult)\n  }\n\n  const findVersionsArgs: FindGlobalVersionsArgs & FindVersionsArgs = {\n    collection: entity.slug,\n    global: entity.slug,\n    limit: 1,\n    locale,\n    pagination: false,\n    req,\n    select: getQueryDraftsSelect({ select }),\n    sort: '-updatedAt',\n    where: combineQueries(queryToBuild, versionAccessResult),\n  }\n\n  let versionDocs\n  if (entityType === 'global') {\n    versionDocs = (await req.payload.db.findGlobalVersions<T>(findVersionsArgs)).docs\n  } else {\n    versionDocs = (await req.payload.db.findVersions<T>(findVersionsArgs)).docs\n  }\n\n  let draft = versionDocs[0]\n\n  if (!draft) {\n    return doc\n  }\n\n  draft = deepCopyObjectSimple(draft)\n  draft = sanitizeInternalFields(draft)\n\n  // Patch globalType onto version doc\n  if (entityType === 'global' && 'globalType' in doc) {\n    draft.version.globalType = doc.globalType\n  }\n\n  // handle when .version wasn't selected due to projection\n  if (!draft.version) {\n    draft.version = {}\n  }\n\n  // Disregard all other draft content at this point,\n  // Only interested in the version itself.\n  // Operations will handle firing hooks, etc.\n\n  draft.version.id = doc.id\n\n  return draft.version\n}\n\nexport default replaceWithDraftIfAvailable\n"],"names":["hasWhereAccessResult","combineQueries","docHasTimestamps","deepCopyObjectSimple","sanitizeInternalFields","appendVersionToQueryKey","getQueryDraftsSelect","replaceWithDraftIfAvailable","accessResult","doc","entity","entityType","req","select","locale","queryToBuild","and","equals","push","parent","id","or","updatedAt","greater_than","latest","versionAccessResult","findVersionsArgs","collection","slug","global","limit","pagination","sort","where","versionDocs","payload","db","findGlobalVersions","docs","findVersions","draft","version","globalType"],"mappings":";;;AAQA,SAASE,gBAAgB,QAAQ,uBAAsB;AAFvD,SAASF,oBAAoB,QAAQ,sBAAqB;AAK1D,SAASK,uBAAuB,QAAQ,+BAA8B;AACtE,SAASC,oBAAoB,QAAQ,4BAA2B;AALhE,SAASL,cAAc,QAAQ,mCAAkC;AAEjE,SAASE,oBAAoB,QAAQ,oCAAmC;AACxE,OAAOC,4BAA4B,4CAA2C;;;;;;;;AAc9E,MAAMG,8BAA8B,OAA6B,EAC/DC,YAAY,EACZC,GAAG,EACHC,MAAM,EACNC,UAAU,EACVC,GAAG,EACHC,MAAM,EACO;IACb,MAAM,EAAEC,MAAM,EAAE,GAAGF;IAEnB,MAAMG,eAAsB;QAC1BC,KAAK;YACH;gBACE,mBAAmB;oBACjBC,QAAQ;gBACV;YACF;SACD;IACH;IAEA,IAAIN,eAAe,cAAc;QAC/BI,aAAaC,GAAG,CAACE,IAAI,CAAC;YACpBC,QAAQ;gBACNF,QAAQR,IAAIW,EAAE;YAChB;QACF;IACF;IAEA,QAAIlB,2XAAAA,EAAiBO,MAAM;QACzBM,aAAaC,GAAG,CAACE,IAAI,CAAC;YACpBG,IAAI;gBACF;oBACEC,WAAW;wBACTC,cAAcd,IAAIa,SAAS;oBAC7B;gBACF;gBACA;oBACEE,QAAQ;wBACNP,QAAQ;oBACV;gBACF;aACD;QACH;IACF;IAEA,IAAIQ;IAEJ,QAAIzB,8XAAAA,EAAqBQ,eAAe;QACtCiB,iaAAsBpB,0BAAAA,EAAwBG;IAChD;IAEA,MAAMkB,mBAA8D;QAClEC,YAAYjB,OAAOkB,IAAI;QACvBC,QAAQnB,OAAOkB,IAAI;QACnBE,OAAO;QACPhB;QACAiB,YAAY;QACZnB;QACAC,gZAAQP,uBAAAA,EAAqB;YAAEO;QAAO;QACtCmB,MAAM;QACNC,QAAOhC,wYAAAA,EAAec,cAAcU;IACtC;IAEA,IAAIS;IACJ,IAAIvB,eAAe,UAAU;QAC3BuB,cAAe,CAAA,MAAMtB,IAAIuB,OAAO,CAACC,EAAE,CAACC,kBAAkB,CAAIX,iBAAgB,EAAGY,IAAI;IACnF,OAAO;QACLJ,cAAe,CAAA,MAAMtB,IAAIuB,OAAO,CAACC,EAAE,CAACG,YAAY,CAAIb,iBAAgB,EAAGY,IAAI;IAC7E;IAEA,IAAIE,QAAQN,WAAW,CAAC,EAAE;IAE1B,IAAI,CAACM,OAAO;QACV,OAAO/B;IACT;IAEA+B,iYAAQrC,uBAAAA,EAAqBqC;IAC7BA,SAAQpC,0YAAAA,EAAuBoC;IAE/B,oCAAoC;IACpC,IAAI7B,eAAe,YAAY,gBAAgBF,KAAK;QAClD+B,MAAMC,OAAO,CAACC,UAAU,GAAGjC,IAAIiC,UAAU;IAC3C;IAEA,yDAAyD;IACzD,IAAI,CAACF,MAAMC,OAAO,EAAE;QAClBD,MAAMC,OAAO,GAAG,CAAC;IACnB;IAEA,mDAAmD;IACnD,yCAAyC;IACzC,4CAA4C;IAE5CD,MAAMC,OAAO,CAACrB,EAAE,GAAGX,IAAIW,EAAE;IAEzB,OAAOoB,MAAMC,OAAO;AACtB;uCAEelC,4BAA2B","ignoreList":[0]}},
    {"offset": {"line": 3611, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3617, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/getLatestGlobalVersion.ts"],"sourcesContent":["import type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Document, Payload, PayloadRequest, Where } from '../types/index.js'\n\nimport { docHasTimestamps } from '../types/index.js'\n\ntype Args = {\n  config: SanitizedGlobalConfig\n  locale?: string\n  payload: Payload\n  published?: boolean\n  req?: PayloadRequest\n  slug: string\n  where: Where\n}\n\nexport const getLatestGlobalVersion = async ({\n  slug,\n  config,\n  locale,\n  payload,\n  published,\n  req,\n  where,\n}: Args): Promise<{ global: Document; globalExists: boolean }> => {\n  let latestVersion\n\n  const whereQuery = published\n    ? { 'version._status': { equals: 'published' } }\n    : { latest: { equals: true } }\n\n  if (config.versions?.drafts) {\n    latestVersion = (\n      await payload.db.findGlobalVersions({\n        global: slug,\n        limit: 1,\n        locale,\n        pagination: false,\n        req,\n        where: whereQuery,\n      })\n    ).docs[0]\n  }\n\n  const global = await payload.db.findGlobal({\n    slug,\n    locale,\n    req,\n    where,\n  })\n  const globalExists = Boolean(global)\n\n  if (!latestVersion) {\n    return {\n      global,\n      globalExists,\n    }\n  }\n\n  if (!latestVersion.version.createdAt) {\n    latestVersion.version.createdAt = latestVersion.createdAt\n  }\n\n  if (!latestVersion.version.updatedAt) {\n    latestVersion.version.updatedAt = latestVersion.updatedAt\n  }\n\n  return {\n    global: latestVersion.version,\n    globalExists,\n  }\n}\n"],"names":["getLatestGlobalVersion","slug","config","locale","payload","published","req","where","latestVersion","whereQuery","equals","latest","versions","drafts","db","findGlobalVersions","global","limit","pagination","docs","findGlobal","globalExists","Boolean","version","createdAt","updatedAt"],"mappings":";;;AAeO,MAAMA,yBAAyB,OAAO,EAC3CC,IAAI,EACJC,MAAM,EACNC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,GAAG,EACHC,KAAK,EACA;IACL,IAAIC;IAEJ,MAAMC,aAAaJ,YACf;QAAE,mBAAmB;YAAEK,QAAQ;QAAY;IAAE,IAC7C;QAAEC,QAAQ;YAAED,QAAQ;QAAK;IAAE;IAE/B,IAAIR,OAAOU,QAAQ,EAAEC,QAAQ;QAC3BL,gBACE,CAAA,MAAMJ,QAAQU,EAAE,CAACC,kBAAkB,CAAC;YAClCC,QAAQf;YACRgB,OAAO;YACPd;YACAe,YAAY;YACZZ;YACAC,OAAOE;QACT,EAAC,EACDU,IAAI,CAAC,EAAE;IACX;IAEA,MAAMH,SAAS,MAAMZ,QAAQU,EAAE,CAACM,UAAU,CAAC;QACzCnB;QACAE;QACAG;QACAC;IACF;IACA,MAAMc,eAAeC,QAAQN;IAE7B,IAAI,CAACR,eAAe;QAClB,OAAO;YACLQ;YACAK;QACF;IACF;IAEA,IAAI,CAACb,cAAce,OAAO,CAACC,SAAS,EAAE;QACpChB,cAAce,OAAO,CAACC,SAAS,GAAGhB,cAAcgB,SAAS;IAC3D;IAEA,IAAI,CAAChB,cAAce,OAAO,CAACE,SAAS,EAAE;QACpCjB,cAAce,OAAO,CAACE,SAAS,GAAGjB,cAAciB,SAAS;IAC3D;IAEA,OAAO;QACLT,QAAQR,cAAce,OAAO;QAC7BF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3665, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3671, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/versions/payloadPackageList.ts"],"sourcesContent":["export const PAYLOAD_PACKAGE_LIST = [\n  'payload',\n  '@payloadcms/bundler-vite',\n  '@payloadcms/bundler-webpack',\n  '@payloadcms/db-mongodb',\n  '@payloadcms/db-postgres',\n  '@payloadcms/email-nodemailer',\n  '@payloadcms/email-resend',\n  '@payloadcms/graphql',\n  '@payloadcms/live-preview-react',\n  '@payloadcms/live-preview',\n  '@payloadcms/next/utilities',\n  '@payloadcms/plugin-cloud-storage',\n  '@payloadcms/payload-cloud',\n  '@payloadcms/plugin-form-builder',\n  '@payloadcms/plugin-nested-docs',\n  '@payloadcms/plugin-redirects',\n  '@payloadcms/plugin-search',\n  '@payloadcms/plugin-seo',\n  '@payloadcms/plugin-stripe',\n  '@payloadcms/plugin-zapier',\n  '@payloadcms/richtext-lexical',\n  '@payloadcms/richtext-slate',\n  '@payloadcms/storage-azure',\n  '@payloadcms/storage-gcs',\n  '@payloadcms/storage-s3',\n  '@payloadcms/storage-uploadthing',\n  '@payloadcms/storage-vercel-blob',\n  '@payloadcms/translations',\n  '@payloadcms/ui/shared',\n]\n"],"names":["PAYLOAD_PACKAGE_LIST"],"mappings":";;;AAAO,MAAMA,uBAAuB;IAClC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3705, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3711, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/exports/shared.ts"],"sourcesContent":["export {\n  generateCookie,\n  generateExpiredPayloadCookie,\n  generatePayloadCookie,\n  getCookieExpiration,\n  parseCookies,\n} from '../auth/cookies.js'\nexport { getLoginOptions } from '../auth/getLoginOptions.js'\nexport { getFromImportMap } from '../bin/generateImportMap/getFromImportMap.js'\nexport { parsePayloadComponent } from '../bin/generateImportMap/parsePayloadComponent.js'\nexport { defaults as collectionDefaults } from '../collections/config/defaults.js'\n\nexport { serverProps } from '../config/types.js'\n\nexport {\n  fieldAffectsData,\n  fieldHasMaxDepth,\n  fieldHasSubFields,\n  fieldIsArrayType,\n  fieldIsBlockType,\n  fieldIsGroupType,\n  fieldIsHiddenOrDisabled,\n  fieldIsID,\n  fieldIsLocalized,\n  fieldIsPresentationalOnly,\n  fieldIsSidebar,\n  fieldIsVirtual,\n  fieldSupportsMany,\n  optionIsObject,\n  optionIsValue,\n  optionsAreObjects,\n  tabHasName,\n  valueIsValueWithRelation,\n} from '../fields/config/types.js'\n\nexport { getFieldPaths } from '../fields/getFieldPaths.js'\n\nexport * from '../fields/validations.js'\n\nexport { validOperators } from '../types/constants.js'\n\nexport { formatFilesize } from '../uploads/formatFilesize.js'\n\nexport { isImage } from '../uploads/isImage.js'\n\nexport {\n  deepCopyObject,\n  deepCopyObjectComplex,\n  deepCopyObjectSimple,\n  deepCopyObjectSimpleWithoutReactComponents,\n} from '../utilities/deepCopyObject.js'\nexport {\n  deepMerge,\n  deepMergeWithCombinedArrays,\n  deepMergeWithReactComponents,\n  deepMergeWithSourceArrays,\n} from '../utilities/deepMerge.js'\n\nexport { fieldSchemaToJSON } from '../utilities/fieldSchemaToJSON.js'\nexport { flattenAllFields } from '../utilities/flattenAllFields.js'\nexport { default as flattenTopLevelFields } from '../utilities/flattenTopLevelFields.js'\n\nexport { getDataByPath } from '../utilities/getDataByPath.js'\nexport { getSelectMode } from '../utilities/getSelectMode.js'\nexport { getSiblingData } from '../utilities/getSiblingData.js'\n\nexport { getUniqueListBy } from '../utilities/getUniqueListBy.js'\n\nexport { isNumber } from '../utilities/isNumber.js'\n\nexport { isPlainObject } from '../utilities/isPlainObject.js'\n\nexport {\n  isReactClientComponent,\n  isReactComponentOrFunction,\n  isReactServerComponentOrFunction,\n} from '../utilities/isReactComponent.js'\n\nexport { reduceFieldsToValues } from '../utilities/reduceFieldsToValues.js'\n\nexport { setsAreEqual } from '../utilities/setsAreEqual.js'\n\nexport { default as toKebabCase } from '../utilities/toKebabCase.js'\n\nexport { unflatten } from '../utilities/unflatten.js'\n\nexport { validateMimeType } from '../utilities/validateMimeType.js'\nexport { wait } from '../utilities/wait.js'\nexport { default as wordBoundariesRegex } from '../utilities/wordBoundariesRegex.js'\nexport { versionDefaults } from '../versions/defaults.js'\nexport { deepMergeSimple } from '@payloadcms/translations/utilities'\n"],"names":["generateCookie","generateExpiredPayloadCookie","generatePayloadCookie","getCookieExpiration","parseCookies","getLoginOptions","getFromImportMap","parsePayloadComponent","defaults","collectionDefaults","serverProps","fieldAffectsData","fieldHasMaxDepth","fieldHasSubFields","fieldIsArrayType","fieldIsBlockType","fieldIsGroupType","fieldIsHiddenOrDisabled","fieldIsID","fieldIsLocalized","fieldIsPresentationalOnly","fieldIsSidebar","fieldIsVirtual","fieldSupportsMany","optionIsObject","optionIsValue","optionsAreObjects","tabHasName","valueIsValueWithRelation","getFieldPaths","validOperators","formatFilesize","isImage","deepCopyObject","deepCopyObjectComplex","deepCopyObjectSimple","deepCopyObjectSimpleWithoutReactComponents","deepMerge","deepMergeWithCombinedArrays","deepMergeWithReactComponents","deepMergeWithSourceArrays","fieldSchemaToJSON","flattenAllFields","default","flattenTopLevelFields","getDataByPath","getSelectMode","getSiblingData","getUniqueListBy","isNumber","isPlainObject","isReactClientComponent","isReactComponentOrFunction","isReactServerComponentOrFunction","reduceFieldsToValues","setsAreEqual","toKebabCase","unflatten","validateMimeType","wait","wordBoundariesRegex","versionDefaults","deepMergeSimple"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 3746, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3876, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/readMigrationFiles.ts"],"sourcesContent":["import fs from 'fs'\nimport { pathToFileURL } from 'node:url'\nimport path from 'path'\n\nimport type { Payload } from '../../index.js'\nimport type { Migration } from '../types.js'\n\n/**\n * Read the migration files from disk\n */\nexport const readMigrationFiles = async ({\n  payload,\n}: {\n  payload: Payload\n}): Promise<Migration[]> => {\n  if (!fs.existsSync(payload.db.migrationDir)) {\n    payload.logger.error({\n      msg: `No migration directory found at ${payload.db.migrationDir}`,\n    })\n    return []\n  }\n\n  payload.logger.info({\n    msg: `Reading migration files from ${payload.db.migrationDir}`,\n  })\n\n  const files = fs\n    .readdirSync(payload.db.migrationDir)\n    .sort()\n    .filter((f) => {\n      return (f.endsWith('.ts') || f.endsWith('.js')) && !f.includes('index.')\n    })\n    .map((file) => {\n      return path.resolve(payload.db.migrationDir, file)\n    })\n\n  return Promise.all(\n    files.map(async (filePath) => {\n      // eval used to circumvent errors bundling\n      let migration =\n        typeof require === 'function'\n          ? await eval(`require('${filePath.replaceAll('\\\\', '/')}')`)\n          : await eval(`import('${pathToFileURL(filePath).href}')`)\n      if ('default' in migration) {\n        migration = migration.default\n      }\n\n      const result: Migration = {\n        name: path.basename(filePath).split('.')?.[0],\n        down: migration.down,\n        up: migration.up,\n      }\n\n      return result\n    }),\n  )\n}\n"],"names":["fs","pathToFileURL","path","readMigrationFiles","payload","existsSync","db","migrationDir","logger","error","msg","info","files","readdirSync","sort","filter","f","endsWith","includes","map","file","resolve","Promise","all","filePath","migration","require","eval","replaceAll","href","default","result","name","basename","split","down","up"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,aAAa,QAAQ,WAAU;AACxC,OAAOC,UAAU,OAAM;;;;AAQhB,MAAMC,qBAAqB,OAAO,EACvCC,OAAO,EAGR;IACC,IAAI,+FAACJ,UAAAA,CAAGK,UAAU,CAACD,QAAQE,EAAE,CAACC,YAAY,GAAG;QAC3CH,QAAQI,MAAM,CAACC,KAAK,CAAC;YACnBC,KAAK,CAAC,gCAAgC,EAAEN,QAAQE,EAAE,CAACC,YAAY,EAAE;QACnE;QACA,OAAO,EAAE;IACX;IAEAH,QAAQI,MAAM,CAACG,IAAI,CAAC;QAClBD,KAAK,CAAC,6BAA6B,EAAEN,QAAQE,EAAE,CAACC,YAAY,EAAE;IAChE;IAEA,MAAMK,sGAAQZ,UAAAA,CACXa,WAAW,CAACT,QAAQE,EAAE,CAACC,YAAY,EACnCO,IAAI,GACJC,MAAM,CAAC,CAACC;QACP,OAAQA,CAAAA,EAAEC,QAAQ,CAAC,UAAUD,EAAEC,QAAQ,CAAC,MAAK,KAAM,CAACD,EAAEE,QAAQ,CAAC;IACjE,GACCC,GAAG,CAAC,CAACC;QACJ,yGAAOlB,UAAAA,CAAKmB,OAAO,CAACjB,QAAQE,EAAE,CAACC,YAAY,EAAEa;IAC/C;IAEF,OAAOE,QAAQC,GAAG,CAChBX,MAAMO,GAAG,CAAC,OAAOK;QACf,0CAA0C;QAC1C,IAAIC,YACF,OAAOC,YAAY,oBACf,MAAMC,KAAK,CAAC,SAAS,EAAEH,SAASI,UAAU,CAAC,MAAM,KAAK,EAAE,CAAC,IACzD,MAAMD,KAAK,CAAC,QAAQ,EAAE1B,cAAcuB,UAAUK,IAAI,CAAC,EAAE,CAAC;QAC5D,IAAI,aAAaJ,WAAW;YAC1BA,YAAYA,UAAUK,OAAO;QAC/B;QAEA,MAAMC,SAAoB;YACxBC,wGAAM9B,UAAAA,CAAK+B,QAAQ,CAACT,UAAUU,KAAK,CAAC,MAAM,CAAC,EAAE;YAC7CC,MAAMV,UAAUU,IAAI;YACpBC,IAAIX,UAAUW,EAAE;QAClB;QAEA,OAAOL;IACT;AAEJ,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3914, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3920, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/getMigrations.ts"],"sourcesContent":["import type { Payload } from '../../index.js'\nimport type { MigrationData } from '../types.js'\n\n/**\n * Gets all existing migrations from the database, excluding the dev migration\n */\nexport async function getMigrations({\n  payload,\n}: {\n  payload: Payload\n}): Promise<{ existingMigrations: MigrationData[]; latestBatch: number }> {\n  const migrationQuery = await payload.find({\n    collection: 'payload-migrations',\n    limit: 0,\n    sort: ['-batch', '-name'],\n    where: {\n      batch: {\n        not_equals: -1,\n      },\n    },\n  })\n\n  const existingMigrations = migrationQuery.docs as unknown as MigrationData[]\n\n  // Get the highest batch number from existing migrations\n  const latestBatch = Number(existingMigrations?.[0]?.batch) || 0\n\n  return {\n    existingMigrations,\n    latestBatch,\n  }\n}\n"],"names":["getMigrations","payload","migrationQuery","find","collection","limit","sort","where","batch","not_equals","existingMigrations","docs","latestBatch","Number"],"mappings":"AAGA;;CAEC,GACD;;;AAAO,eAAeA,cAAc,EAClCC,OAAO,EAGR;IACC,MAAMC,iBAAiB,MAAMD,QAAQE,IAAI,CAAC;QACxCC,YAAY;QACZC,OAAO;QACPC,MAAM;YAAC;YAAU;SAAQ;QACzBC,OAAO;YACLC,OAAO;gBACLC,YAAY,CAAC;YACf;QACF;IACF;IAEA,MAAMC,qBAAqBR,eAAeS,IAAI;IAE9C,wDAAwD;IACxD,MAAMC,cAAcC,OAAOH,oBAAoB,CAAC,EAAE,EAAEF,UAAU;IAE9D,OAAO;QACLE;QACAE;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3947, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3953, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/combineQueries.ts"],"sourcesContent":["import type { Where } from '../types/index.js'\n\nimport { hasWhereAccessResult } from '../auth/index.js'\n\nexport const combineQueries = (where: Where, access: boolean | Where): Where => {\n  if (!where && !access) {\n    return {}\n  }\n\n  const result: Where = {\n    and: [],\n  }\n\n  if (where) {\n    result.and.push(where)\n  }\n  if (hasWhereAccessResult(access)) {\n    result.and.push(access)\n  }\n\n  return result\n}\n"],"names":["hasWhereAccessResult","combineQueries","where","access","result","and","push"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,mBAAkB;;AAEhD,MAAMC,iBAAiB,CAACC,OAAcC;IAC3C,IAAI,CAACD,SAAS,CAACC,QAAQ;QACrB,OAAO,CAAC;IACV;IAEA,MAAMC,SAAgB;QACpBC,KAAK,EAAE;IACT;IAEA,IAAIH,OAAO;QACTE,OAAOC,GAAG,CAACC,IAAI,CAACJ;IAClB;IACA,+WAAIF,uBAAAA,EAAqBG,SAAS;QAChCC,OAAOC,GAAG,CAACC,IAAI,CAACH;IAClB;IAEA,OAAOC;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3973, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3979, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/getPredefinedMigration.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport { pathToFileURL } from 'url'\n\nimport type { Payload } from '../../index.js'\nimport type { MigrationTemplateArgs } from '../types.js'\n\n/**\n * Get predefined migration 'up', 'down' and 'imports'\n */\nexport const getPredefinedMigration = async ({\n  dirname,\n  file,\n  migrationName: migrationNameArg,\n  payload,\n}: {\n  dirname: string\n  file?: string\n  migrationName?: string\n  payload: Payload\n}): Promise<MigrationTemplateArgs> => {\n  // Check for predefined migration.\n  // Either passed in via --file or prefixed with '@payloadcms/db-mongodb/' for example\n  const importPath = file ?? migrationNameArg\n\n  if (importPath?.startsWith('@payloadcms/db-')) {\n    // removes the package name from the migrationName.\n    const migrationName = importPath.split('/').slice(2).join('/')\n    let cleanPath = path.join(dirname, `./predefinedMigrations/${migrationName}`)\n    if (fs.existsSync(`${cleanPath}.mjs`)) {\n      cleanPath = `${cleanPath}.mjs`\n    } else if (fs.existsSync(`${cleanPath}.js`)) {\n      cleanPath = `${cleanPath}.js`\n    } else {\n      payload.logger.error({\n        msg: `Canned migration ${migrationName} not found.`,\n      })\n      process.exit(1)\n    }\n    cleanPath = cleanPath.replaceAll('\\\\', '/')\n    const moduleURL = pathToFileURL(cleanPath)\n    try {\n      const { downSQL, imports, upSQL } = await eval(`import('${moduleURL.href}')`)\n      return {\n        downSQL,\n        imports,\n        upSQL,\n      }\n    } catch (err) {\n      payload.logger.error({\n        err,\n        msg: `Error loading predefined migration ${migrationName}`,\n      })\n      process.exit(1)\n    }\n  } else if (importPath) {\n    try {\n      const { downSQL, imports, upSQL } = await eval(`import('${importPath}')`)\n      return {\n        downSQL,\n        imports,\n        upSQL,\n      }\n    } catch (_err) {\n      if (importPath?.includes('/')) {\n        // We can assume that the intent was to import a file, thus we throw an error.\n        throw new Error(`Error importing migration file from ${importPath}`)\n      }\n      // Silently fail. If the migration cannot be imported, it will be created as a blank migration and the import path will be used as the migration name.\n      return {}\n    }\n  }\n  return {}\n}\n"],"names":["fs","path","pathToFileURL","getPredefinedMigration","dirname","file","migrationName","migrationNameArg","payload","importPath","startsWith","split","slice","join","cleanPath","existsSync","logger","error","msg","process","exit","replaceAll","moduleURL","downSQL","imports","upSQL","eval","href","err","_err","includes","Error"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;AACvB,SAASC,aAAa,QAAQ,MAAK;;;;AAQ5B,MAAMC,yBAAyB,OAAO,EAC3CC,OAAO,EACPC,IAAI,EACJC,eAAeC,gBAAgB,EAC/BC,OAAO,EAMR;IACC,kCAAkC;IAClC,qFAAqF;IACrF,MAAMC,aAAaJ,QAAQE;IAE3B,IAAIE,YAAYC,WAAW,oBAAoB;QAC7C,mDAAmD;QACnD,MAAMJ,gBAAgBG,WAAWE,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAGC,IAAI,CAAC;QAC1D,IAAIC,8GAAYb,UAAAA,CAAKY,IAAI,CAACT,SAAS,CAAC,uBAAuB,EAAEE,eAAe;QAC5E,IAAIN,wGAAAA,CAAGe,UAAU,CAAC,GAAGD,UAAU,IAAI,CAAC,GAAG;YACrCA,YAAY,GAAGA,UAAU,IAAI,CAAC;QAChC,OAAO,IAAId,wGAAAA,CAAGe,UAAU,CAAC,GAAGD,UAAU,GAAG,CAAC,GAAG;YAC3CA,YAAY,GAAGA,UAAU,GAAG,CAAC;QAC/B,OAAO;YACLN,QAAQQ,MAAM,CAACC,KAAK,CAAC;gBACnBC,KAAK,CAAC,iBAAiB,EAAEZ,cAAc,WAAW,CAAC;YACrD;YACAa,QAAQC,IAAI,CAAC;QACf;QACAN,YAAYA,UAAUO,UAAU,CAAC,MAAM;QACvC,MAAMC,gHAAYpB,gBAAAA,EAAcY;QAChC,IAAI;YACF,MAAM,EAAES,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAE,GAAG,MAAMC,KAAK,CAAC,QAAQ,EAAEJ,UAAUK,IAAI,CAAC,EAAE,CAAC;YAC5E,OAAO;gBACLJ;gBACAC;gBACAC;YACF;QACF,EAAE,OAAOG,KAAK;YACZpB,QAAQQ,MAAM,CAACC,KAAK,CAAC;gBACnBW;gBACAV,KAAK,CAAC,mCAAmC,EAAEZ,eAAe;YAC5D;YACAa,QAAQC,IAAI,CAAC;QACf;IACF,OAAO,IAAIX,YAAY;QACrB,IAAI;YACF,MAAM,EAAEc,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAE,GAAG,MAAMC,KAAK,CAAC,QAAQ,EAAEjB,WAAW,EAAE,CAAC;YACxE,OAAO;gBACLc;gBACAC;gBACAC;YACF;QACF,EAAE,OAAOI,MAAM;YACb,IAAIpB,YAAYqB,SAAS,MAAM;gBAC7B,8EAA8E;gBAC9E,MAAM,IAAIC,MAAM,CAAC,oCAAoC,EAAEtB,YAAY;YACrE;YACA,sJAAsJ;YACtJ,OAAO,CAAC;QACV;IACF;IACA,OAAO,CAAC;AACV,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4041, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4047, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/writeMigrationIndex.ts"],"sourcesContent":["import fs from 'fs'\nimport { getTsconfig } from 'get-tsconfig'\nimport path from 'path'\n\n// Function to get all migration files (TS or JS) excluding 'index'\nconst getMigrationFiles = (dir: string) => {\n  return fs\n    .readdirSync(dir)\n    .filter(\n      (file) =>\n        (file.endsWith('.ts') || file.endsWith('.js')) &&\n        file !== 'index.ts' &&\n        file !== 'index.js',\n    )\n    .sort()\n}\n\n// Function to generate the index.ts content\nconst generateIndexContent = (files: string[]) => {\n  const tsconfig = getTsconfig()\n  const importExt = tsconfig?.config?.compilerOptions?.moduleResolution === 'NodeNext' ? '.js' : ''\n\n  let imports = ''\n  let exportsArray = 'export const migrations = [\\n'\n\n  files.forEach((file, index) => {\n    const fileNameWithoutExt = file.replace(/\\.[^/.]+$/, '')\n    imports += `import * as migration_${fileNameWithoutExt} from './${fileNameWithoutExt}${importExt}';\\n`\n    exportsArray += `  {\n    up: migration_${fileNameWithoutExt}.up,\n    down: migration_${fileNameWithoutExt}.down,\n    name: '${fileNameWithoutExt}'${index !== files.length - 1 ? ',' : ''}\\n  },\\n`\n  })\n\n  exportsArray += '];\\n'\n  return imports + '\\n' + exportsArray\n}\n\n// Main function to create the index.ts file\nexport const writeMigrationIndex = (args: { migrationsDir: string }) => {\n  const migrationFiles = getMigrationFiles(args.migrationsDir)\n  const indexContent = generateIndexContent(migrationFiles)\n\n  fs.writeFileSync(path.join(args.migrationsDir, 'index.ts'), indexContent)\n}\n"],"names":["fs","getTsconfig","path","getMigrationFiles","dir","readdirSync","filter","file","endsWith","sort","generateIndexContent","files","tsconfig","importExt","config","compilerOptions","moduleResolution","imports","exportsArray","forEach","index","fileNameWithoutExt","replace","length","writeMigrationIndex","args","migrationFiles","migrationsDir","indexContent","writeFileSync","join"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,WAAW,QAAQ,eAAc;AAC1C,OAAOC,UAAU,OAAM;;;;AAEvB,mEAAmE;AACnE,MAAMC,oBAAoB,CAACC;IACzB,qGAAOJ,UAAAA,CACJK,WAAW,CAACD,KACZE,MAAM,CACL,CAACC,OACEA,CAAAA,KAAKC,QAAQ,CAAC,UAAUD,KAAKC,QAAQ,CAAC,MAAK,KAC5CD,SAAS,cACTA,SAAS,YAEZE,IAAI;AACT;AAEA,4CAA4C;AAC5C,MAAMC,uBAAuB,CAACC;IAC5B,MAAMC,WAAWX,gOAAAA;IACjB,MAAMY,YAAYD,UAAUE,QAAQC,iBAAiBC,qBAAqB,aAAa,QAAQ;IAE/F,IAAIC,UAAU;IACd,IAAIC,eAAe;IAEnBP,MAAMQ,OAAO,CAAC,CAACZ,MAAMa;QACnB,MAAMC,qBAAqBd,KAAKe,OAAO,CAAC,aAAa;QACrDL,WAAW,CAAC,sBAAsB,EAAEI,mBAAmB,SAAS,EAAEA,qBAAqBR,UAAU,IAAI,CAAC;QACtGK,gBAAgB,CAAC;kBACH,EAAEG,mBAAmB;oBACnB,EAAEA,mBAAmB;WAC9B,EAAEA,mBAAmB,CAAC,EAAED,UAAUT,MAAMY,MAAM,GAAG,IAAI,MAAM,GAAG,QAAQ,CAAC;IAChF;IAEAL,gBAAgB;IAChB,OAAOD,UAAU,OAAOC;AAC1B;AAGO,MAAMM,sBAAsB,CAACC;IAClC,MAAMC,iBAAiBvB,kBAAkBsB,KAAKE,aAAa;IAC3D,MAAMC,eAAelB,qBAAqBgB;kGAE1C1B,UAAAA,CAAG6B,aAAa,mGAAC3B,UAAAA,CAAK4B,IAAI,CAACL,KAAKE,aAAa,EAAE,aAAaC;AAC9D,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4082, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4088, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/migrationTemplate.ts"],"sourcesContent":["export const migrationTemplate = `\nimport {\n  MigrateUpArgs,\n  MigrateDownArgs,\n} from \"@payloadcms/db-mongodb\";\n\nexport async function up({ payload, req }: MigrateUpArgs): Promise<void> {\n  // Migration code\n};\n\nexport async function down({ payload, req }: MigrateDownArgs): Promise<void> {\n  // Migration code\n};\n`\n"],"names":["migrationTemplate"],"mappings":";;;AAAO,MAAMA,oBAAoB,CAAC;;;;;;;;;;;;;AAalC,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 4105, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4111, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/createMigration.ts"],"sourcesContent":["import fs from 'fs'\n\nimport type { CreateMigration } from '../types.js'\n\nimport { writeMigrationIndex } from '../../index.js'\nimport { migrationTemplate } from './migrationTemplate.js'\n\nexport const createMigration: CreateMigration = function createMigration({\n  migrationName,\n  payload,\n}) {\n  const dir = payload.db.migrationDir\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir)\n  }\n\n  const [yyymmdd, hhmmss] = new Date().toISOString().split('T')\n  const formattedDate = yyymmdd.replace(/\\D/g, '')\n  const formattedTime = hhmmss.split('.')[0].replace(/\\D/g, '')\n\n  const timestamp = `${formattedDate}_${formattedTime}`\n\n  const formattedName = migrationName.replace(/\\W/g, '_')\n  const fileName = `${timestamp}_${formattedName}.ts`\n  const filePath = `${dir}/${fileName}`\n  fs.writeFileSync(filePath, migrationTemplate)\n\n  writeMigrationIndex({ migrationsDir: payload.db.migrationDir })\n\n  payload.logger.info({ msg: `Migration created at ${filePath}` })\n}\n"],"names":["fs","writeMigrationIndex","migrationTemplate","createMigration","migrationName","payload","dir","db","migrationDir","existsSync","mkdirSync","yyymmdd","hhmmss","Date","toISOString","split","formattedDate","replace","formattedTime","timestamp","formattedName","fileName","filePath","writeFileSync","migrationsDir","logger","info","msg"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AAKnB,SAASE,iBAAiB,QAAQ,yBAAwB;AAD1D,SAASD,mBAAmB,QAAQ,iBAAgB;;;;AAG7C,MAAME,kBAAmC,SAASA,gBAAgB,EACvEC,aAAa,EACbC,OAAO,EACR;IACC,MAAMC,MAAMD,QAAQE,EAAE,CAACC,YAAY;IACnC,IAAI,+FAACR,UAAAA,CAAGS,UAAU,CAACH,MAAM;sGACvBN,UAAAA,CAAGU,SAAS,CAACJ;IACf;IAEA,MAAM,CAACK,SAASC,OAAO,GAAG,IAAIC,OAAOC,WAAW,GAAGC,KAAK,CAAC;IACzD,MAAMC,gBAAgBL,QAAQM,OAAO,CAAC,OAAO;IAC7C,MAAMC,gBAAgBN,OAAOG,KAAK,CAAC,IAAI,CAAC,EAAE,CAACE,OAAO,CAAC,OAAO;IAE1D,MAAME,YAAY,GAAGH,cAAc,CAAC,EAAEE,eAAe;IAErD,MAAME,gBAAgBhB,cAAca,OAAO,CAAC,OAAO;IACnD,MAAMI,WAAW,GAAGF,UAAU,CAAC,EAAEC,cAAc,GAAG,CAAC;IACnD,MAAME,WAAW,GAAGhB,IAAI,CAAC,EAAEe,UAAU;kGACrCrB,UAAAA,CAAGuB,aAAa,CAACD,+YAAUpB,oBAAAA;+YAE3BD,sBAAAA,EAAoB;QAAEuB,eAAenB,QAAQE,EAAE,CAACC,YAAY;IAAC;IAE7DH,QAAQoB,MAAM,CAACC,IAAI,CAAC;QAAEC,KAAK,CAAC,qBAAqB,EAAEL,UAAU;IAAC;AAChE,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4140, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4146, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/migrate.ts"],"sourcesContent":["import type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { createLocalReq } from '../../utilities/createLocalReq.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport const migrate: BaseDatabaseAdapter['migrate'] = async function migrate(\n  this: BaseDatabaseAdapter,\n  args,\n): Promise<void> {\n  const { payload } = this\n  const migrationFiles = args?.migrations || (await readMigrationFiles({ payload }))\n  const { existingMigrations, latestBatch } = await getMigrations({ payload })\n\n  const newBatch = latestBatch + 1\n\n  // Execute 'up' function for each migration sequentially\n  for (const migration of migrationFiles) {\n    const existingMigration = existingMigrations.find(\n      (existing) => existing.name === migration.name,\n    )\n\n    // Run migration if not found in database\n    if (existingMigration) {\n      continue\n    }\n\n    const start = Date.now()\n    const req = await createLocalReq({}, payload)\n\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n\n    try {\n      await initTransaction(req)\n      const session = payload.db.sessions?.[await req.transactionID]\n      await migration.up({ payload, req, session })\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          batch: newBatch,\n        },\n        req,\n      })\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({ err, msg: `Error running migration ${migration.name}` })\n      throw err\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrate","args","payload","migrationFiles","migrations","existingMigrations","latestBatch","newBatch","migration","existingMigration","find","existing","name","start","Date","now","req","logger","info","msg","session","db","sessions","transactionID","up","create","collection","data","batch","err","error"],"mappings":";;;AAOA,SAASK,kBAAkB,QAAQ,0BAAyB;AAD5D,SAASD,aAAa,QAAQ,qBAAoB;AAHlD,SAASH,cAAc,QAAQ,oCAAmC;AAClE,SAASC,eAAe,QAAQ,qCAAoC;AAFpE,SAASF,iBAAiB,QAAQ,uCAAsC;AAGxE,SAASG,eAAe,QAAQ,qCAAoC;;;;;;;AAI7D,MAAMG,UAA0C,eAAeA,QAEpEC,IAAI;IAEJ,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiBF,MAAMG,cAAe,UAAML,2ZAAAA,EAAmB;QAAEG;IAAQ;IAC/E,MAAM,EAAEG,kBAAkB,EAAEC,WAAW,EAAE,GAAG,UAAMR,iZAAAA,EAAc;QAAEI;IAAQ;IAE1E,MAAMK,WAAWD,cAAc;IAE/B,wDAAwD;IACxD,KAAK,MAAME,aAAaL,eAAgB;QACtC,MAAMM,oBAAoBJ,mBAAmBK,IAAI,CAC/C,CAACC,WAAaA,SAASC,IAAI,KAAKJ,UAAUI,IAAI;QAGhD,yCAAyC;QACzC,IAAIH,mBAAmB;YACrB;QACF;QAEA,MAAMI,QAAQC,KAAKC,GAAG;QACtB,MAAMC,MAAM,+XAAMrB,iBAAAA,EAAe,CAAC,GAAGO;QAErCA,QAAQe,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK,CAAC,WAAW,EAAEX,UAAUI,IAAI,EAAE;QAAC;QAE1D,IAAI;YACF,gYAAMhB,kBAAAA,EAAgBoB;YACtB,MAAMI,UAAUlB,QAAQmB,EAAE,CAACC,QAAQ,EAAE,CAAC,MAAMN,IAAIO,aAAa,CAAC;YAC9D,MAAMf,UAAUgB,EAAE,CAAC;gBAAEtB;gBAASc;gBAAKI;YAAQ;YAC3ClB,QAAQe,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,WAAW,EAAEX,UAAUI,IAAI,CAAC,EAAE,EAAEE,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YAAC;YACpF,MAAMX,QAAQuB,MAAM,CAAC;gBACnBC,YAAY;gBACZC,MAAM;oBACJf,MAAMJ,UAAUI,IAAI;oBACpBgB,OAAOrB;gBACT;gBACAS;YACF;YACA,kYAAMtB,oBAAAA,EAAkBsB;QAC1B,EAAE,OAAOa,KAAc;YACrB,gYAAMhC,kBAAAA,EAAgBmB;YACtBd,QAAQe,MAAM,CAACa,KAAK,CAAC;gBAAED;gBAAKV,KAAK,CAAC,wBAAwB,EAAEX,UAAUI,IAAI,EAAE;YAAC;YAC7E,MAAMiB;QACR;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4212, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4218, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/migrateDown.ts"],"sourcesContent":["import type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { createLocalReq } from '../../utilities/createLocalReq.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport async function migrateDown(this: BaseDatabaseAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const latestBatchMigrations = existingMigrations.filter(({ batch }) => batch === latestBatch)\n\n  for (const migration of latestBatchMigrations) {\n    const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n    if (!migrationFile) {\n      throw new Error(`Migration ${migration.name} not found locally.`)\n    }\n\n    const start = Date.now()\n    const req = await createLocalReq({}, payload)\n\n    try {\n      payload.logger.info({ msg: `Migrating down: ${migrationFile.name}` })\n      await initTransaction(req)\n      const session = payload.db.sessions?.[await req.transactionID]\n      await migrationFile.down({ payload, req, session })\n      payload.logger.info({\n        msg: `Migrated down:  ${migrationFile.name} (${Date.now() - start}ms)`,\n      })\n      // Waiting for implementation here\n      await payload.delete({\n        id: migration.id,\n        collection: 'payload-migrations',\n        req,\n      })\n\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: `Error running migration ${migrationFile.name}`,\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrateDown","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","latestBatchMigrations","filter","batch","migration","migrationFile","find","m","name","Error","start","Date","now","req","session","db","sessions","transactionID","down","delete","id","collection","err","error","process","exit"],"mappings":";;;AAOA,SAASK,kBAAkB,QAAQ,0BAAyB;AAD5D,SAASD,aAAa,QAAQ,qBAAoB;AAHlD,SAASH,cAAc,QAAQ,oCAAmC;AAClE,SAASC,eAAe,QAAQ,qCAAoC;AAFpE,SAASF,iBAAiB,QAAQ,uCAAsC;AAGxE,SAASG,eAAe,QAAQ,qCAAoC;;;;;;;AAI7D,eAAeG;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,gZAAMH,qBAAAA,EAAmB;QAAEE;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAEC,WAAW,EAAE,GAAG,2YAAMN,gBAAAA,EAAc;QAC9DG;IACF;IAEA,IAAI,CAACE,oBAAoBE,QAAQ;QAC/BJ,QAAQK,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA6B;QACxD;IACF;IAEAP,QAAQK,MAAM,CAACC,IAAI,CAAC;QAClBC,KAAK,CAAC,mBAAmB,EAAEJ,YAAY,eAAe,EAAED,mBAAmBE,MAAM,CAAC,cAAc,CAAC;IACnG;IAEA,MAAMI,wBAAwBN,mBAAmBO,MAAM,CAAC,CAAC,EAAEC,KAAK,EAAE,GAAKA,UAAUP;IAEjF,KAAK,MAAMQ,aAAaH,sBAAuB;QAC7C,MAAMI,gBAAgBX,eAAeY,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAC1E,IAAI,CAACH,eAAe;YAClB,MAAM,IAAII,MAAM,CAAC,UAAU,EAAEL,UAAUI,IAAI,CAAC,mBAAmB,CAAC;QAClE;QAEA,MAAME,QAAQC,KAAKC,GAAG;QACtB,MAAMC,MAAM,+XAAM1B,iBAAAA,EAAe,CAAC,GAAGM;QAErC,IAAI;YACFA,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,EAAE;YAAC;YACnE,gYAAMpB,kBAAAA,EAAgByB;YACtB,MAAMC,UAAUrB,QAAQsB,EAAE,CAACC,QAAQ,EAAE,CAAC,MAAMH,IAAII,aAAa,CAAC;YAC9D,MAAMZ,cAAca,IAAI,CAAC;gBAAEzB;gBAASoB;gBAAKC;YAAQ;YACjDrB,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAClBC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,CAAC,EAAE,EAAEG,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YACxE;YACA,kCAAkC;YAClC,MAAMjB,QAAQ0B,MAAM,CAAC;gBACnBC,IAAIhB,UAAUgB,EAAE;gBAChBC,YAAY;gBACZR;YACF;YAEA,kYAAM3B,oBAAAA,EAAkB2B;QAC1B,EAAE,OAAOS,KAAc;YACrB,gYAAMjC,kBAAAA,EAAgBwB;YACtBpB,QAAQK,MAAM,CAACyB,KAAK,CAAC;gBACnBD;gBACAtB,KAAK,CAAC,wBAAwB,EAAEK,cAAcG,IAAI,EAAE;YACtD;YACAgB,QAAQC,IAAI,CAAC;QACf;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 4289, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4295, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/migrateRefresh.ts"],"sourcesContent":["import type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { createLocalReq } from '../../utilities/createLocalReq.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\n/**\n * Run all migration down functions before running up\n */\nexport async function migrateRefresh(this: BaseDatabaseAdapter) {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations } = await getMigrations({\n    payload,\n  })\n\n  const req = await createLocalReq({}, payload)\n\n  if (existingMigrations?.length) {\n    payload.logger.info({\n      msg: `Rolling back all ${existingMigrations.length} migration(s).`,\n    })\n    // Reverse order of migrations to rollback\n    existingMigrations.reverse()\n\n    for (const migration of existingMigrations) {\n      try {\n        const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n        if (!migrationFile) {\n          throw new Error(`Migration ${migration.name} not found locally.`)\n        }\n\n        payload.logger.info({ msg: `Migrating down: ${migration.name}` })\n        const start = Date.now()\n        await initTransaction(req)\n        const session = payload.db.sessions?.[await req.transactionID]\n        await migrationFile.down({ payload, req, session })\n        payload.logger.info({\n          msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)`,\n        })\n        await payload.delete({\n          collection: 'payload-migrations',\n          req,\n          where: {\n            name: {\n              equals: migration.name,\n            },\n          },\n        })\n      } catch (err: unknown) {\n        await killTransaction(req)\n        let msg = `Error running migration ${migration.name}. Rolling back.`\n        if (err instanceof Error) {\n          msg += ` ${err.message}`\n        }\n        payload.logger.error({\n          err,\n          msg,\n        })\n        process.exit(1)\n      }\n    }\n  } else {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n  }\n\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      await migration.up({ payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          executed: true,\n        },\n        req,\n      })\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      let msg = `Error running migration ${migration.name}. Rolling back.`\n      if (err instanceof Error) {\n        msg += ` ${err.message}`\n      }\n      payload.logger.error({\n        err,\n        msg,\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrateRefresh","payload","migrationFiles","existingMigrations","req","length","logger","info","msg","reverse","migration","migrationFile","find","m","name","Error","start","Date","now","session","db","sessions","transactionID","down","delete","collection","where","equals","err","message","error","process","exit","up","create","data","executed"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4410, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4416, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/migrateReset.ts"],"sourcesContent":["import type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { createLocalReq } from '../../utilities/createLocalReq.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport async function migrateReset(this: BaseDatabaseAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations } = await getMigrations({ payload })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to reset.' })\n    return\n  }\n\n  const req = await createLocalReq({}, payload)\n\n  // Rollback all migrations in order\n  for (const migration of migrationFiles) {\n    // Create or update migration in database\n    const existingMigration = existingMigrations.find(\n      (existing) => existing.name === migration.name,\n    )\n    if (existingMigration) {\n      payload.logger.info({ msg: `Migrating down: ${migration.name}` })\n      try {\n        const start = Date.now()\n        await initTransaction(req)\n        const session = payload.db.sessions?.[await req.transactionID]\n        await migration.down({ payload, req, session })\n        await payload.delete({\n          collection: 'payload-migrations',\n          req,\n          where: {\n            id: {\n              equals: existingMigration.id,\n            },\n          },\n        })\n        await commitTransaction(req)\n        payload.logger.info({ msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)` })\n      } catch (err: unknown) {\n        await killTransaction(req)\n        payload.logger.error({ err, msg: `Error running migration ${migration.name}` })\n        throw err\n      }\n    }\n  }\n\n  // Delete dev migration\n  try {\n    await payload.delete({\n      collection: 'payload-migrations',\n      where: {\n        batch: {\n          equals: -1,\n        },\n      },\n    })\n  } catch (err: unknown) {\n    payload.logger.error({ err, msg: 'Error deleting dev migration' })\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrateReset","payload","migrationFiles","existingMigrations","length","logger","info","msg","req","migration","existingMigration","find","existing","name","start","Date","now","session","db","sessions","transactionID","down","delete","collection","where","id","equals","err","error","batch"],"mappings":";;;AAOA,SAASK,kBAAkB,QAAQ,0BAAyB;AAD5D,SAASD,aAAa,QAAQ,qBAAoB;AAHlD,SAASH,cAAc,QAAQ,oCAAmC;AAClE,SAASC,eAAe,QAAQ,qCAAoC;AAFpE,SAASF,iBAAiB,QAAQ,uCAAsC;AAGxE,SAASG,eAAe,QAAQ,qCAAoC;;;;;;;AAI7D,eAAeG;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,gZAAMH,qBAAAA,EAAmB;QAAEE;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAE,GAAG,2YAAML,gBAAAA,EAAc;QAAEG;IAAQ;IAE7D,IAAI,CAACE,oBAAoBC,QAAQ;QAC/BH,QAAQI,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA0B;QACrD;IACF;IAEA,MAAMC,MAAM,MAAMb,0YAAAA,EAAe,CAAC,GAAGM;IAErC,mCAAmC;IACnC,KAAK,MAAMQ,aAAaP,eAAgB;QACtC,yCAAyC;QACzC,MAAMQ,oBAAoBP,mBAAmBQ,IAAI,CAC/C,CAACC,WAAaA,SAASC,IAAI,KAAKJ,UAAUI,IAAI;QAEhD,IAAIH,mBAAmB;YACrBT,QAAQI,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEE,UAAUI,IAAI,EAAE;YAAC;YAC/D,IAAI;gBACF,MAAMC,QAAQC,KAAKC,GAAG;gBACtB,OAAMpB,2YAAAA,EAAgBY;gBACtB,MAAMS,UAAUhB,QAAQiB,EAAE,CAACC,QAAQ,EAAE,CAAC,MAAMX,IAAIY,aAAa,CAAC;gBAC9D,MAAMX,UAAUY,IAAI,CAAC;oBAAEpB;oBAASO;oBAAKS;gBAAQ;gBAC7C,MAAMhB,QAAQqB,MAAM,CAAC;oBACnBC,YAAY;oBACZf;oBACAgB,OAAO;wBACLC,IAAI;4BACFC,QAAQhB,kBAAkBe,EAAE;wBAC9B;oBACF;gBACF;gBACA,UAAM/B,4YAAAA,EAAkBc;gBACxBP,QAAQI,MAAM,CAACC,IAAI,CAAC;oBAAEC,KAAK,CAAC,gBAAgB,EAAEE,UAAUI,IAAI,CAAC,EAAE,EAAEE,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;gBAAC;YAC3F,EAAE,OAAOa,KAAc;gBACrB,gYAAM9B,kBAAAA,EAAgBW;gBACtBP,QAAQI,MAAM,CAACuB,KAAK,CAAC;oBAAED;oBAAKpB,KAAK,CAAC,wBAAwB,EAAEE,UAAUI,IAAI,EAAE;gBAAC;gBAC7E,MAAMc;YACR;QACF;IACF;IAEA,uBAAuB;IACvB,IAAI;QACF,MAAM1B,QAAQqB,MAAM,CAAC;YACnBC,YAAY;YACZC,OAAO;gBACLK,OAAO;oBACLH,QAAQ,CAAC;gBACX;YACF;QACF;IACF,EAAE,OAAOC,KAAc;QACrB1B,QAAQI,MAAM,CAACuB,KAAK,CAAC;YAAED;YAAKpB,KAAK;QAA+B;IAClE;AACF","ignoreList":[0]}},
    {"offset": {"line": 4503, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4509, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/migrateStatus.ts"],"sourcesContent":["import { Table } from 'console-table-printer'\n\nimport type { BaseDatabaseAdapter } from '../types.js'\n\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport async function migrateStatus(this: BaseDatabaseAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  payload.logger.debug({\n    msg: `Found ${migrationFiles.length} migration files.`,\n  })\n\n  const { existingMigrations } = await getMigrations({ payload })\n\n  if (!migrationFiles.length) {\n    payload.logger.info({ msg: 'No migrations found.' })\n    return\n  }\n\n  // Compare migration files to existing migrations\n  const statuses = migrationFiles.map((migration) => {\n    const existingMigration = existingMigrations.find((m) => m.name === migration.name)\n    return {\n      Name: migration.name,\n\n      Batch: existingMigration?.batch,\n      Ran: existingMigration ? 'Yes' : 'No',\n    }\n  })\n\n  const p = new Table()\n\n  statuses.forEach((s) => {\n    p.addRow(s, {\n      color: s.Ran === 'Yes' ? 'green' : 'red',\n    })\n  })\n  p.printTable()\n}\n"],"names":["Table","getMigrations","readMigrationFiles","migrateStatus","payload","migrationFiles","logger","debug","msg","length","existingMigrations","info","statuses","map","migration","existingMigration","find","m","name","Name","Batch","batch","Ran","p","forEach","s","addRow","color","printTable"],"mappings":";;;AAAA,SAASA,KAAK,QAAQ,wBAAuB;AAK7C,SAASE,kBAAkB,QAAQ,0BAAyB;AAD5D,SAASD,aAAa,QAAQ,qBAAoB;;;;AAG3C,eAAeE;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,gZAAMH,qBAAAA,EAAmB;QAAEE;IAAQ;IAE1DA,QAAQE,MAAM,CAACC,KAAK,CAAC;QACnBC,KAAK,CAAC,MAAM,EAAEH,eAAeI,MAAM,CAAC,iBAAiB,CAAC;IACxD;IAEA,MAAM,EAAEC,kBAAkB,EAAE,GAAG,2YAAMT,gBAAAA,EAAc;QAAEG;IAAQ;IAE7D,IAAI,CAACC,eAAeI,MAAM,EAAE;QAC1BL,QAAQE,MAAM,CAACK,IAAI,CAAC;YAAEH,KAAK;QAAuB;QAClD;IACF;IAEA,iDAAiD;IACjD,MAAMI,WAAWP,eAAeQ,GAAG,CAAC,CAACC;QACnC,MAAMC,oBAAoBL,mBAAmBM,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAClF,OAAO;YACLC,MAAML,UAAUI,IAAI;YAEpBE,OAAOL,mBAAmBM;YAC1BC,KAAKP,oBAAoB,QAAQ;QACnC;IACF;IAEA,MAAMQ,IAAI,0OAAIvB,QAAAA;IAEdY,SAASY,OAAO,CAAC,CAACC;QAChBF,EAAEG,MAAM,CAACD,GAAG;YACVE,OAAOF,EAAEH,GAAG,KAAK,QAAQ,UAAU;QACrC;IACF;IACAC,EAAEK,UAAU;AACd","ignoreList":[0]}},
    {"offset": {"line": 4552, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4558, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/createDatabaseAdapter.ts"],"sourcesContent":["import type { MarkOptional } from 'ts-essentials'\n\nimport type {\n  BaseDatabaseAdapter,\n  BeginTransaction,\n  CommitTransaction,\n  RollbackTransaction,\n} from './types.js'\n\nimport { createMigration } from './migrations/createMigration.js'\nimport { migrate } from './migrations/migrate.js'\nimport { migrateDown } from './migrations/migrateDown.js'\nimport { migrateRefresh } from './migrations/migrateRefresh.js'\nimport { migrateReset } from './migrations/migrateReset.js'\nimport { migrateStatus } from './migrations/migrateStatus.js'\n\nconst beginTransaction: BeginTransaction = async () => null\nconst rollbackTransaction: RollbackTransaction = async () => null\nconst commitTransaction: CommitTransaction = async () => null\n\nexport function createDatabaseAdapter<T extends BaseDatabaseAdapter>(\n  args: MarkOptional<\n    T,\n    | 'createMigration'\n    | 'migrate'\n    | 'migrateDown'\n    | 'migrateFresh'\n    | 'migrateRefresh'\n    | 'migrateReset'\n    | 'migrateStatus'\n    | 'migrationDir'\n  >,\n): T {\n  return {\n    // Default 'null' transaction functions\n    beginTransaction,\n    commitTransaction,\n    createMigration,\n    migrate,\n    migrateDown,\n    migrateFresh: async ({ forceAcceptWarning = null }) => null,\n    migrateRefresh,\n    migrateReset,\n    migrateStatus,\n    rollbackTransaction,\n\n    ...args,\n\n    // Ensure migrationDir is set\n    migrationDir: args.migrationDir || 'migrations',\n  } as T\n}\n"],"names":["createMigration","migrate","migrateDown","migrateRefresh","migrateReset","migrateStatus","beginTransaction","rollbackTransaction","commitTransaction","createDatabaseAdapter","args","migrateFresh","forceAcceptWarning","migrationDir"],"mappings":";;;AASA,SAASA,eAAe,QAAQ,kCAAiC;AACjE,SAASC,OAAO,QAAQ,0BAAyB;AACjD,SAASC,WAAW,QAAQ,8BAA6B;AACzD,SAASC,cAAc,QAAQ,iCAAgC;AAC/D,SAASC,YAAY,QAAQ,+BAA8B;AAC3D,SAASC,aAAa,QAAQ,gCAA+B;;;;;;;AAE7D,MAAMC,mBAAqC,UAAY;AACvD,MAAMC,sBAA2C,UAAY;AAC7D,MAAMC,oBAAuC,UAAY;AAElD,SAASC,sBACdC,IAUC;IAED,OAAO;QACL,uCAAuC;QACvCJ;QACAE;4ZACAR,kBAAAA;4YACAC,UAAAA;oZACAC,cAAAA;QACAS,cAAc,OAAO,EAAEC,qBAAqB,IAAI,EAAE,GAAK;0ZACvDT,iBAAAA;sZACAC,eAAAA;wZACAC,gBAAAA;QACAE;QAEA,GAAGG,IAAI;QAEP,6BAA6B;QAC7BG,cAAcH,KAAKG,YAAY,IAAI;IACrC;AACF","ignoreList":[0]}},
    {"offset": {"line": 4594, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4600, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/defaultBeginTransaction.ts"],"sourcesContent":["import type { BeginTransaction } from './types.js'\n\n/**\n * Default implementation of `beginTransaction` that returns a resolved promise of null\n */\nexport function defaultBeginTransaction(): BeginTransaction {\n  const promiseSingleton: Promise<null> = Promise.resolve(null)\n  return () => promiseSingleton\n}\n"],"names":["defaultBeginTransaction","promiseSingleton","Promise","resolve"],"mappings":"AAEA;;CAEC,GACD;;;AAAO,SAASA;IACd,MAAMC,mBAAkCC,QAAQC,OAAO,CAAC;IACxD,OAAO,IAAMF;AACf","ignoreList":[0]}},
    {"offset": {"line": 4609, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4615, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/migrations/migrationsCollection.ts"],"sourcesContent":["import type { CollectionConfig } from '../../collections/config/types.js'\n\nexport const migrationsCollection: CollectionConfig = {\n  slug: 'payload-migrations',\n  admin: {\n    hidden: true,\n  },\n  endpoints: false,\n  fields: [\n    {\n      name: 'name',\n      type: 'text',\n    },\n    {\n      name: 'batch',\n      type: 'number',\n      // NOTE: This value is -1 if it is a \"dev push\"\n    },\n  ],\n  graphQL: false,\n  lockDocuments: false,\n}\n"],"names":["migrationsCollection","slug","admin","hidden","endpoints","fields","name","type","graphQL","lockDocuments"],"mappings":";;;AAEO,MAAMA,uBAAyC;IACpDC,MAAM;IACNC,OAAO;QACLC,QAAQ;IACV;IACAC,WAAW;IACXC,QAAQ;QACN;YACEC,MAAM;YACNC,MAAM;QACR;QACA;YACED,MAAM;YACNC,MAAM;QAER;KACD;IACDC,SAAS;IACTC,eAAe;AACjB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4637, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4643, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/getLocalizedPaths.ts"],"sourcesContent":["import type { Field, FlattenedField } from '../fields/config/types.js'\nimport type { Payload } from '../index.js'\nimport type { PathToQuery } from './queryValidation/types.js'\n\nexport function getLocalizedPaths({\n  collectionSlug,\n  fields,\n  globalSlug,\n  incomingPath,\n  locale,\n  overrideAccess = false,\n  payload,\n}: {\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  incomingPath: string\n  locale?: string\n  overrideAccess?: boolean\n  payload: Payload\n}): PathToQuery[] {\n  const pathSegments = incomingPath.split('.')\n  const localizationConfig = payload.config.localization\n\n  let paths: PathToQuery[] = [\n    {\n      collectionSlug,\n      complete: false,\n      field: undefined,\n      fields,\n      globalSlug,\n      invalid: false,\n      path: '',\n    },\n  ]\n\n  for (let i = 0; i < pathSegments.length; i += 1) {\n    const segment = pathSegments[i]\n\n    const lastIncompletePath = paths.find(({ complete }) => !complete)\n\n    if (lastIncompletePath) {\n      const { path } = lastIncompletePath\n      let currentPath = path ? `${path}.${segment}` : segment\n\n      let fieldsToSearch: FlattenedField[]\n\n      if (lastIncompletePath?.field && 'flattenedFields' in lastIncompletePath.field) {\n        fieldsToSearch = lastIncompletePath.field.flattenedFields\n      } else {\n        fieldsToSearch = lastIncompletePath.fields\n      }\n\n      const matchedField = fieldsToSearch.find((field) => field.name === segment)\n      lastIncompletePath.field = matchedField\n\n      if (currentPath === 'globalType' && globalSlug) {\n        lastIncompletePath.path = currentPath\n        lastIncompletePath.complete = true\n        lastIncompletePath.field = {\n          name: 'globalType',\n          type: 'text',\n        }\n\n        return paths\n      }\n\n      if (!matchedField && currentPath === 'id' && i === pathSegments.length - 1) {\n        lastIncompletePath.path = currentPath\n        const idField: Field = {\n          name: 'id',\n          type: payload.db.defaultIDType as 'text',\n        }\n        lastIncompletePath.field = idField\n        lastIncompletePath.complete = true\n        return paths\n      }\n\n      if (matchedField) {\n        if ('hidden' in matchedField && matchedField.hidden && !overrideAccess) {\n          lastIncompletePath.invalid = true\n        }\n\n        const nextSegment = pathSegments[i + 1]\n        const nextSegmentIsLocale =\n          localizationConfig && localizationConfig.localeCodes.includes(nextSegment)\n\n        if (nextSegmentIsLocale) {\n          // Skip the next iteration, because it's a locale\n          i += 1\n          currentPath = `${currentPath}.${nextSegment}`\n        } else if (localizationConfig && 'localized' in matchedField && matchedField.localized) {\n          currentPath = `${currentPath}.${locale}`\n        }\n\n        switch (matchedField.type) {\n          case 'blocks':\n          case 'json':\n          case 'richText': {\n            const upcomingSegments = pathSegments.slice(i + 1).join('.')\n            lastIncompletePath.complete = true\n            lastIncompletePath.path = upcomingSegments\n              ? `${currentPath}.${upcomingSegments}`\n              : currentPath\n            return paths\n          }\n\n          case 'relationship':\n          case 'upload': {\n            // If this is a polymorphic relation,\n            // We only support querying directly (no nested querying)\n            if (typeof matchedField.relationTo !== 'string') {\n              const lastSegmentIsValid =\n                ['relationTo', 'value'].includes(pathSegments[pathSegments.length - 1]) ||\n                pathSegments.length === 1 ||\n                (pathSegments.length === 2 && pathSegments[0] === 'version')\n\n              lastIncompletePath.path = pathSegments.join('.')\n\n              if (lastSegmentIsValid) {\n                lastIncompletePath.complete = true\n              } else {\n                lastIncompletePath.invalid = true\n                return paths\n              }\n            } else {\n              lastIncompletePath.complete = true\n              lastIncompletePath.path = currentPath\n\n              const nestedPathToQuery = pathSegments\n                .slice(nextSegmentIsLocale ? i + 2 : i + 1)\n                .join('.')\n\n              if (nestedPathToQuery) {\n                const relatedCollection = payload.collections[matchedField.relationTo].config\n\n                const remainingPaths = getLocalizedPaths({\n                  collectionSlug: relatedCollection.slug,\n                  fields: relatedCollection.flattenedFields,\n                  globalSlug,\n                  incomingPath: nestedPathToQuery,\n                  locale,\n                  payload,\n                })\n\n                paths = [...paths, ...remainingPaths]\n              }\n\n              return paths\n            }\n\n            break\n          }\n\n          default: {\n            if (i + 1 === pathSegments.length) {\n              lastIncompletePath.complete = true\n            }\n            lastIncompletePath.path = currentPath\n          }\n        }\n      } else {\n        lastIncompletePath.invalid = true\n        lastIncompletePath.path = currentPath\n        return paths\n      }\n    }\n  }\n\n  return paths\n}\n"],"names":["getLocalizedPaths","collectionSlug","fields","globalSlug","incomingPath","locale","overrideAccess","payload","pathSegments","split","localizationConfig","config","localization","paths","complete","field","undefined","invalid","path","i","length","segment","lastIncompletePath","find","currentPath","fieldsToSearch","flattenedFields","matchedField","name","type","idField","db","defaultIDType","hidden","nextSegment","nextSegmentIsLocale","localeCodes","includes","localized","upcomingSegments","slice","join","relationTo","lastSegmentIsValid","nestedPathToQuery","relatedCollection","collections","remainingPaths","slug"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4773, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4779, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/queryValidation/validateSearchParams.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { FlattenedField } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { EntityPolicies, PathToQuery } from './types.js'\n\nimport { fieldAffectsData, fieldIsVirtual } from '../../fields/config/types.js'\nimport { getEntityPolicies } from '../../utilities/getEntityPolicies.js'\nimport isolateObjectProperty from '../../utilities/isolateObjectProperty.js'\nimport { getLocalizedPaths } from '../getLocalizedPaths.js'\nimport { validateQueryPaths } from './validateQueryPaths.js'\n\ntype Args = {\n  collectionConfig?: SanitizedCollectionConfig\n  errors: { path: string }[]\n  fields: FlattenedField[]\n  globalConfig?: SanitizedGlobalConfig\n  operator: string\n  overrideAccess: boolean\n  path: string\n  policies: EntityPolicies\n  req: PayloadRequest\n  val: unknown\n  versionFields?: FlattenedField[]\n}\n\n/**\n * Validate the Payload key / value / operator\n */\nexport async function validateSearchParam({\n  collectionConfig,\n  errors,\n  fields,\n  globalConfig,\n  operator,\n  overrideAccess,\n  path: incomingPath,\n  policies,\n  req,\n  val,\n  versionFields,\n}: Args): Promise<void> {\n  // Replace GraphQL nested field double underscore formatting\n  let sanitizedPath\n  if (incomingPath === '_id') {\n    sanitizedPath = 'id'\n  } else {\n    sanitizedPath = incomingPath.replace(/__/g, '.')\n  }\n  let paths: PathToQuery[] = []\n  const { slug } = collectionConfig || globalConfig\n\n  if (globalConfig && !policies.globals[slug]) {\n    policies.globals[slug] = await getEntityPolicies({\n      type: 'global',\n      entity: globalConfig,\n      operations: ['read'],\n      req,\n    })\n  }\n\n  if (sanitizedPath !== 'id') {\n    paths = getLocalizedPaths({\n      collectionSlug: collectionConfig?.slug,\n      fields,\n      globalSlug: globalConfig?.slug,\n      incomingPath: sanitizedPath,\n      locale: req.locale,\n      overrideAccess,\n      payload: req.payload,\n    })\n  }\n  const promises = []\n\n  // Sanitize relation.otherRelation.id to relation.otherRelation\n  if (paths.at(-1)?.path === 'id') {\n    const previousField = paths.at(-2)?.field\n    if (\n      previousField &&\n      (previousField.type === 'relationship' || previousField.type === 'upload') &&\n      typeof previousField.relationTo === 'string'\n    ) {\n      paths.pop()\n    }\n  }\n\n  promises.push(\n    ...paths.map(async ({ collectionSlug, field, invalid, path }, i) => {\n      if (invalid) {\n        errors.push({ path })\n        return\n      }\n\n      if (fieldIsVirtual(field)) {\n        errors.push({ path })\n      }\n\n      if (!overrideAccess && fieldAffectsData(field)) {\n        if (collectionSlug) {\n          if (!policies.collections[collectionSlug]) {\n            policies.collections[collectionSlug] = await getEntityPolicies({\n              type: 'collection',\n              entity: req.payload.collections[collectionSlug].config,\n              operations: ['read'],\n              req: isolateObjectProperty(req, 'transactionID'),\n            })\n          }\n\n          if (\n            ['hash', 'salt'].includes(incomingPath) &&\n            collectionConfig.auth &&\n            !collectionConfig.auth?.disableLocalStrategy\n          ) {\n            errors.push({ path: incomingPath })\n          }\n        }\n        let fieldPath = path\n        // remove locale from end of path\n        if (path.endsWith(`.${req.locale}`)) {\n          fieldPath = path.slice(0, -(req.locale.length + 1))\n        }\n        // remove \".value\" from ends of polymorphic relationship paths\n        if (\n          (field.type === 'relationship' || field.type === 'upload') &&\n          Array.isArray(field.relationTo)\n        ) {\n          fieldPath = fieldPath.replace('.value', '')\n        }\n\n        const entityType: 'collections' | 'globals' = globalConfig ? 'globals' : 'collections'\n        const entitySlug = collectionSlug || globalConfig.slug\n        const segments = fieldPath.split('.')\n\n        let fieldAccess\n        if (versionFields) {\n          fieldAccess = policies[entityType][entitySlug]\n          if (segments[0] === 'parent' || segments[0] === 'version') {\n            segments.shift()\n          }\n        } else {\n          fieldAccess = policies[entityType][entitySlug].fields\n        }\n\n        segments.forEach((segment) => {\n          if (fieldAccess[segment]) {\n            if ('fields' in fieldAccess[segment]) {\n              fieldAccess = fieldAccess[segment].fields\n            } else if ('blocks' in fieldAccess[segment]) {\n              fieldAccess = fieldAccess[segment]\n            } else {\n              fieldAccess = fieldAccess[segment]\n            }\n          }\n        })\n\n        if (!fieldAccess?.read?.permission) {\n          errors.push({ path: fieldPath })\n        }\n      }\n\n      if (i > 1) {\n        // Remove top collection and reverse array\n        // to work backwards from top\n        const pathsToQuery = paths.slice(1).reverse()\n\n        pathsToQuery.forEach(\n          ({ collectionSlug: pathCollectionSlug, path: subPath }, pathToQueryIndex) => {\n            // On the \"deepest\" collection,\n            // validate query of the relationship\n            if (pathToQueryIndex === 0) {\n              promises.push(\n                validateQueryPaths({\n                  collectionConfig: req.payload.collections[pathCollectionSlug].config,\n                  errors,\n                  globalConfig: undefined,\n                  overrideAccess,\n                  policies,\n                  req,\n                  where: {\n                    [subPath]: {\n                      [operator]: val,\n                    },\n                  },\n                }),\n              )\n            }\n          },\n        )\n      }\n    }),\n  )\n  await Promise.all(promises)\n}\n"],"names":["fieldAffectsData","fieldIsVirtual","getEntityPolicies","isolateObjectProperty","getLocalizedPaths","validateQueryPaths","validateSearchParam","collectionConfig","errors","fields","globalConfig","operator","overrideAccess","path","incomingPath","policies","req","val","versionFields","sanitizedPath","replace","paths","slug","globals","type","entity","operations","collectionSlug","globalSlug","locale","payload","promises","at","previousField","field","relationTo","pop","push","map","invalid","i","collections","config","includes","auth","disableLocalStrategy","fieldPath","endsWith","slice","length","Array","isArray","entityType","entitySlug","segments","split","fieldAccess","shift","forEach","segment","read","permission","pathsToQuery","reverse","pathCollectionSlug","subPath","pathToQueryIndex","undefined","where","Promise","all"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4929, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4935, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/queryValidation/validateQueryPaths.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { FlattenedField } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { Operator, PayloadRequest, Where, WhereField } from '../../types/index.js'\nimport type { EntityPolicies } from './types.js'\n\nimport { QueryError } from '../../errors/QueryError.js'\nimport { validOperators } from '../../types/constants.js'\nimport { validateSearchParam } from './validateSearchParams.js'\n\ntype Args = {\n  errors?: { path: string }[]\n  overrideAccess: boolean\n  policies?: EntityPolicies\n  req: PayloadRequest\n  versionFields?: FlattenedField[]\n  where: Where\n} & (\n  | {\n      collectionConfig: SanitizedCollectionConfig\n      globalConfig?: never | undefined\n    }\n  | {\n      collectionConfig?: never | undefined\n      globalConfig: SanitizedGlobalConfig\n    }\n)\n\nconst flattenWhere = (query: Where): WhereField[] =>\n  Object.entries(query).reduce((flattenedConstraints, [key, val]) => {\n    if ((key === 'and' || key === 'or') && Array.isArray(val)) {\n      const subWhereConstraints: Where[] = val.reduce((acc, subVal) => {\n        const subWhere = flattenWhere(subVal)\n        return [...acc, ...subWhere]\n      }, [])\n      return [...flattenedConstraints, ...subWhereConstraints]\n    }\n\n    return [...flattenedConstraints, { [key]: val }]\n  }, [])\n\nexport async function validateQueryPaths({\n  collectionConfig,\n  errors = [],\n  globalConfig,\n  overrideAccess,\n  policies = {\n    collections: {},\n    globals: {},\n  },\n  req,\n  versionFields,\n  where,\n}: Args): Promise<void> {\n  const fields = versionFields || (globalConfig || collectionConfig).flattenedFields\n\n  if (typeof where === 'object') {\n    const whereFields = flattenWhere(where)\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    const promises = []\n    void whereFields.map((constraint) => {\n      void Object.keys(constraint).map((path) => {\n        void Object.entries(constraint[path]).map(([operator, val]) => {\n          if (validOperators.includes(operator as Operator)) {\n            promises.push(\n              validateSearchParam({\n                collectionConfig,\n                errors,\n                fields,\n                globalConfig,\n                operator,\n                overrideAccess,\n                path,\n                policies,\n                req,\n                val,\n                versionFields,\n              }),\n            )\n          }\n        })\n      })\n    })\n    await Promise.all(promises)\n    if (errors.length > 0) {\n      throw new QueryError(errors)\n    }\n  }\n}\n"],"names":["QueryError","validOperators","validateSearchParam","flattenWhere","query","Object","entries","reduce","flattenedConstraints","key","val","Array","isArray","subWhereConstraints","acc","subVal","subWhere","validateQueryPaths","collectionConfig","errors","globalConfig","overrideAccess","policies","collections","globals","req","versionFields","where","fields","flattenedFields","whereFields","promises","map","constraint","keys","path","operator","includes","push","Promise","all","length"],"mappings":";;;AAOA,SAASC,cAAc,QAAQ,2BAA0B;AACzD,SAASC,mBAAmB,QAAQ,4BAA2B;AAF/D,SAASF,UAAU,QAAQ,6BAA4B;;;;AAsBvD,MAAMG,eAAe,CAACC,QACpBC,OAAOC,OAAO,CAACF,OAAOG,MAAM,CAAC,CAACC,sBAAsB,CAACC,KAAKC,IAAI;QAC5D,IAAKD,CAAAA,QAAQ,SAASA,QAAQ,IAAG,KAAME,MAAMC,OAAO,CAACF,MAAM;YACzD,MAAMG,sBAA+BH,IAAIH,MAAM,CAAC,CAACO,KAAKC;gBACpD,MAAMC,WAAWb,aAAaY;gBAC9B,OAAO;uBAAID;uBAAQE;iBAAS;YAC9B,GAAG,EAAE;YACL,OAAO;mBAAIR;mBAAyBK;aAAoB;QAC1D;QAEA,OAAO;eAAIL;YAAsB;gBAAE,CAACC,IAAI,EAAEC;YAAI;SAAE;IAClD,GAAG,EAAE;AAEA,eAAeO,mBAAmB,EACvCC,gBAAgB,EAChBC,SAAS,EAAE,EACXC,YAAY,EACZC,cAAc,EACdC,WAAW;IACTC,aAAa,CAAC;IACdC,SAAS,CAAC;AACZ,CAAC,EACDC,GAAG,EACHC,aAAa,EACbC,KAAK,EACA;IACL,MAAMC,SAASF,iBAAkBN,CAAAA,gBAAgBF,gBAAe,EAAGW,eAAe;IAElF,IAAI,OAAOF,UAAU,UAAU;QAC7B,MAAMG,cAAc3B,aAAawB;QACjC,uEAAuE;QACvE,MAAMI,WAAW,EAAE;QACnB,KAAKD,YAAYE,GAAG,CAAC,CAACC;YACpB,KAAK5B,OAAO6B,IAAI,CAACD,YAAYD,GAAG,CAAC,CAACG;gBAChC,KAAK9B,OAAOC,OAAO,CAAC2B,UAAU,CAACE,KAAK,EAAEH,GAAG,CAAC,CAAC,CAACI,UAAU1B,IAAI;oBACxD,gXAAIT,iBAAAA,CAAeoC,QAAQ,CAACD,WAAuB;wBACjDL,SAASO,IAAI,EACXpC,saAAAA,EAAoB;4BAClBgB;4BACAC;4BACAS;4BACAR;4BACAgB;4BACAf;4BACAc;4BACAb;4BACAG;4BACAf;4BACAgB;wBACF;oBAEJ;gBACF;YACF;QACF;QACA,MAAMa,QAAQC,GAAG,CAACT;QAClB,IAAIZ,OAAOsB,MAAM,GAAG,GAAG;YACrB,MAAM,kXAAIzC,aAAAA,CAAWmB;QACvB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 5001, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5007, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/database/sanitizeJoinQuery.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { JoinQuery, PayloadRequest } from '../types/index.js'\n\nimport executeAccess from '../auth/executeAccess.js'\nimport { QueryError } from '../errors/QueryError.js'\nimport { deepCopyObjectSimple } from '../utilities/deepCopyObject.js'\nimport { combineQueries } from './combineQueries.js'\nimport { validateQueryPaths } from './queryValidation/validateQueryPaths.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  joins?: JoinQuery\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\n/**\n * * Validates `where` for each join\n * * Combines the access result for joined collection\n * * Combines the default join's `where`\n */\nexport const sanitizeJoinQuery = async ({\n  collectionConfig,\n  joins: joinsQuery,\n  overrideAccess,\n  req,\n}: Args) => {\n  if (joinsQuery === false) {\n    return false\n  }\n\n  if (!joinsQuery) {\n    joinsQuery = {}\n  }\n\n  const errors: { path: string }[] = []\n  const promises: Promise<void>[] = []\n\n  for (const collectionSlug in collectionConfig.joins) {\n    for (const { field, joinPath } of collectionConfig.joins[collectionSlug]) {\n      if (joinsQuery[joinPath] === false) {\n        continue\n      }\n\n      const joinCollectionConfig = req.payload.collections[collectionSlug].config\n\n      const accessResult = !overrideAccess\n        ? await executeAccess({ disableErrors: true, req }, joinCollectionConfig.access.read)\n        : true\n\n      if (accessResult === false) {\n        joinsQuery[joinPath] = false\n        continue\n      }\n\n      if (!joinsQuery[joinPath]) {\n        joinsQuery[joinPath] = {}\n      }\n\n      const joinQuery = joinsQuery[joinPath]\n\n      if (!joinQuery.where) {\n        joinQuery.where = {}\n      }\n\n      if (field.where) {\n        joinQuery.where = combineQueries(joinQuery.where, field.where)\n      }\n\n      promises.push(\n        validateQueryPaths({\n          collectionConfig: joinCollectionConfig,\n          errors,\n          overrideAccess,\n          req,\n          // incoming where input, but we shouldn't validate generated from the access control.\n          where: deepCopyObjectSimple(joinQuery.where),\n        }),\n      )\n\n      if (typeof accessResult === 'object') {\n        joinQuery.where = combineQueries(joinQuery.where, accessResult)\n      }\n    }\n  }\n\n  await Promise.all(promises)\n\n  if (errors.length > 0) {\n    throw new QueryError(errors)\n  }\n\n  return joinsQuery\n}\n"],"names":["executeAccess","QueryError","deepCopyObjectSimple","combineQueries","validateQueryPaths","sanitizeJoinQuery","collectionConfig","joins","joinsQuery","overrideAccess","req","errors","promises","collectionSlug","field","joinPath","joinCollectionConfig","payload","collections","config","accessResult","disableErrors","access","read","joinQuery","where","push","Promise","all","length"],"mappings":";;;AAGA,OAAOA,mBAAmB,2BAA0B;AAGpD,SAASG,cAAc,QAAQ,sBAAqB;AACpD,SAASC,kBAAkB,QAAQ,0CAAyC;AAF5E,SAASF,oBAAoB,QAAQ,iCAAgC;AADrE,SAASD,UAAU,QAAQ,0BAAyB;;;;;;AAiB7C,MAAMI,oBAAoB,OAAO,EACtCC,gBAAgB,EAChBC,OAAOC,UAAU,EACjBC,cAAc,EACdC,GAAG,EACE;IACL,IAAIF,eAAe,OAAO;QACxB,OAAO;IACT;IAEA,IAAI,CAACA,YAAY;QACfA,aAAa,CAAC;IAChB;IAEA,MAAMG,SAA6B,EAAE;IACrC,MAAMC,WAA4B,EAAE;IAEpC,IAAK,MAAMC,kBAAkBP,iBAAiBC,KAAK,CAAE;QACnD,KAAK,MAAM,EAAEO,KAAK,EAAEC,QAAQ,EAAE,IAAIT,iBAAiBC,KAAK,CAACM,eAAe,CAAE;YACxE,IAAIL,UAAU,CAACO,SAAS,KAAK,OAAO;gBAClC;YACF;YAEA,MAAMC,uBAAuBN,IAAIO,OAAO,CAACC,WAAW,CAACL,eAAe,CAACM,MAAM;YAE3E,MAAMC,eAAe,CAACX,iBAClB,yXAAMT,UAAAA,EAAc;gBAAEqB,eAAe;gBAAMX;YAAI,GAAGM,qBAAqBM,MAAM,CAACC,IAAI,IAClF;YAEJ,IAAIH,iBAAiB,OAAO;gBAC1BZ,UAAU,CAACO,SAAS,GAAG;gBACvB;YACF;YAEA,IAAI,CAACP,UAAU,CAACO,SAAS,EAAE;gBACzBP,UAAU,CAACO,SAAS,GAAG,CAAC;YAC1B;YAEA,MAAMS,YAAYhB,UAAU,CAACO,SAAS;YAEtC,IAAI,CAACS,UAAUC,KAAK,EAAE;gBACpBD,UAAUC,KAAK,GAAG,CAAC;YACrB;YAEA,IAAIX,MAAMW,KAAK,EAAE;gBACfD,UAAUC,KAAK,2XAAGtB,iBAAAA,EAAeqB,UAAUC,KAAK,EAAEX,MAAMW,KAAK;YAC/D;YAEAb,SAASc,IAAI,gZACXtB,qBAAAA,EAAmB;gBACjBE,kBAAkBU;gBAClBL;gBACAF;gBACAC;gBACA,qFAAqF;gBACrFe,QAAOvB,+YAAAA,EAAqBsB,UAAUC,KAAK;YAC7C;YAGF,IAAI,OAAOL,iBAAiB,UAAU;gBACpCI,UAAUC,KAAK,2XAAGtB,iBAAAA,EAAeqB,UAAUC,KAAK,EAAEL;YACpD;QACF;IACF;IAEA,MAAMO,QAAQC,GAAG,CAAChB;IAElB,IAAID,OAAOkB,MAAM,GAAG,GAAG;QACrB,MAAM,kXAAI5B,aAAAA,CAAWU;IACvB;IAEA,OAAOH;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 5072, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5078, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/translations/getLocalI18n.ts"],"sourcesContent":["import type { AcceptedLanguages } from '@payloadcms/translations'\n\nimport { initI18n } from '@payloadcms/translations'\n\nimport type { SanitizedConfig } from '../config/types.js'\n\nexport const getLocalI18n = async ({\n  config,\n  language,\n}: {\n  config: SanitizedConfig\n  language: AcceptedLanguages\n}) =>\n  initI18n({\n    config: config.i18n,\n    context: 'api',\n    language,\n  })\n"],"names":["initI18n","getLocalI18n","config","language","i18n","context"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,2BAA0B;;AAI5C,MAAMC,eAAe,OAAO,EACjCC,MAAM,EACNC,QAAQ,EAIT,2PACCH,WAAAA,EAAS;QACPE,QAAQA,OAAOE,IAAI;QACnBC,SAAS;QACTF;IACF,GAAE","ignoreList":[0]}},
    {"offset": {"line": 5089, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5095, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/operations/runJobs/runJob/getUpdateJobFunction.ts"],"sourcesContent":["import type { PayloadRequest } from '../../../../types/index.js'\nimport type { BaseJob } from '../../../config/types/workflowTypes.js'\n\nexport type UpdateJobFunction = (jobData: Partial<BaseJob>) => Promise<BaseJob>\n\nexport function getUpdateJobFunction(job: BaseJob, req: PayloadRequest): UpdateJobFunction {\n  return async (jobData) => {\n    const updatedJob = (await req.payload.update({\n      id: job.id,\n      collection: 'payload-jobs',\n      data: jobData,\n      depth: 0,\n      disableTransaction: true,\n    })) as BaseJob\n\n    // Update job object like this to modify the original object - that way, incoming changes (e.g. taskStatus field that will be re-generated through the hook) will be reflected in the calling function\n    for (const key in updatedJob) {\n      job[key] = updatedJob[key]\n    }\n\n    return updatedJob\n  }\n}\n"],"names":["getUpdateJobFunction","job","req","jobData","updatedJob","payload","update","id","collection","data","depth","disableTransaction","key"],"mappings":";;;AAKO,SAASA,qBAAqBC,GAAY,EAAEC,GAAmB;IACpE,OAAO,OAAOC;QACZ,MAAMC,aAAc,MAAMF,IAAIG,OAAO,CAACC,MAAM,CAAC;YAC3CC,IAAIN,IAAIM,EAAE;YACVC,YAAY;YACZC,MAAMN;YACNO,OAAO;YACPC,oBAAoB;QACtB;QAEA,sMAAsM;QACtM,IAAK,MAAMC,OAAOR,WAAY;YAC5BH,GAAG,CAACW,IAAI,GAAGR,UAAU,CAACQ,IAAI;QAC5B;QAEA,OAAOR;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5114, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5120, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/operations/runJobs/runJob/importHandlerPath.ts"],"sourcesContent":["import { pathToFileURL } from 'url'\n\nexport async function importHandlerPath<T>(path: string): Promise<T> {\n  let runner: T\n  const [runnerPath, runnerImportName] = path.split('#')\n\n  let runnerModule\n  try {\n    // We need to check for `require` for compatibility with outdated frameworks that do not\n    // properly support ESM, like Jest. This is not done to support projects without \"type\": \"module\" set\n    runnerModule =\n      typeof require === 'function'\n        ? await eval(`require('${runnerPath.replaceAll('\\\\', '/')}')`)\n        : await eval(`import('${pathToFileURL(runnerPath).href}')`)\n  } catch (e) {\n    throw new Error(\n      `Error importing job queue handler module for path ${path}. This is an advanced feature that may require a sophisticated build pipeline, especially when using it in production or within Next.js, e.g. by calling opening the /api/payload-jobs/run endpoint. You will have to transpile the handler files separately and ensure they are available in the same location when the job is run. If you're using an endpoint to execute your jobs, it's recommended to define your handlers as functions directly in your Payload Config, or use import paths handlers outside of Next.js. Import Error: \\n${e.message}`,\n    )\n  }\n\n  // If the path has indicated an #exportName, try to get it\n  if (runnerImportName && runnerModule[runnerImportName]) {\n    runner = runnerModule[runnerImportName]\n  }\n\n  // If there is a default export, use it\n  if (!runner && runnerModule.default) {\n    runner = runnerModule.default\n  }\n\n  // Finally, use whatever was imported\n  if (!runner) {\n    runner = runnerModule\n  }\n\n  return runner\n}\n"],"names":["pathToFileURL","importHandlerPath","path","runner","runnerPath","runnerImportName","split","runnerModule","require","eval","replaceAll","href","e","Error","message","default"],"mappings":";;;AAAA,SAASA,aAAa,QAAQ,MAAK;;AAE5B,eAAeC,kBAAqBC,IAAY;IACrD,IAAIC;IACJ,MAAM,CAACC,YAAYC,iBAAiB,GAAGH,KAAKI,KAAK,CAAC;IAElD,IAAIC;IACJ,IAAI;QACF,wFAAwF;QACxF,qGAAqG;QACrGA,eACE,OAAOC,YAAY,oBACf,MAAMC,KAAK,CAAC,SAAS,EAAEL,WAAWM,UAAU,CAAC,MAAM,KAAK,EAAE,CAAC,IAC3D,MAAMD,KAAK,CAAC,QAAQ,EAAET,cAAcI,YAAYO,IAAI,CAAC,EAAE,CAAC;IAChE,EAAE,OAAOC,GAAG;QACV,MAAM,IAAIC,MACR,CAAC,kDAAkD,EAAEX,KAAK,+gBAA+gB,EAAEU,EAAEE,OAAO,EAAE;IAE1lB;IAEA,0DAA0D;IAC1D,IAAIT,oBAAoBE,YAAY,CAACF,iBAAiB,EAAE;QACtDF,SAASI,YAAY,CAACF,iBAAiB;IACzC;IAEA,uCAAuC;IACvC,IAAI,CAACF,UAAUI,aAAaQ,OAAO,EAAE;QACnCZ,SAASI,aAAaQ,OAAO;IAC/B;IAEA,qCAAqC;IACrC,IAAI,CAACZ,QAAQ;QACXA,SAASI;IACX;IAEA,OAAOJ;AACT","ignoreList":[0]}},
    {"offset": {"line": 5150, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5156, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/operations/runJobs/runJob/calculateBackoffWaitUntil.ts"],"sourcesContent":["import type { RetryConfig } from '../../../config/types/taskTypes.js'\n\nexport function calculateBackoffWaitUntil({\n  retriesConfig,\n  totalTried,\n}: {\n  retriesConfig: number | RetryConfig\n  totalTried: number\n}): Date {\n  let waitUntil: Date = new Date()\n  if (typeof retriesConfig === 'object') {\n    if (retriesConfig.backoff) {\n      if (retriesConfig.backoff.type === 'fixed') {\n        waitUntil = retriesConfig.backoff.delay\n          ? new Date(new Date().getTime() + retriesConfig.backoff.delay)\n          : new Date()\n      } else if (retriesConfig.backoff.type === 'exponential') {\n        // 2 ^ (attempts - 1) * delay (current attempt is not included in totalTried, thus no need for -1)\n        const delay = retriesConfig.backoff.delay ? retriesConfig.backoff.delay : 0\n        waitUntil = new Date(new Date().getTime() + Math.pow(2, totalTried) * delay)\n      }\n    }\n  }\n\n  /*\n  const differenceInMSBetweenNowAndWaitUntil = waitUntil.getTime() - new Date().getTime()\n\n  const differenceInSBetweenNowAndWaitUntil = differenceInMSBetweenNowAndWaitUntil / 1000\n  console.log('Calculated backoff', {\n    differenceInMSBetweenNowAndWaitUntil,\n    differenceInSBetweenNowAndWaitUntil,\n    retriesConfig,\n    totalTried,\n  })*/\n  return waitUntil\n}\n"],"names":["calculateBackoffWaitUntil","retriesConfig","totalTried","waitUntil","Date","backoff","type","delay","getTime","Math","pow"],"mappings":";;;AAEO,SAASA,0BAA0B,EACxCC,aAAa,EACbC,UAAU,EAIX;IACC,IAAIC,YAAkB,IAAIC;IAC1B,IAAI,OAAOH,kBAAkB,UAAU;QACrC,IAAIA,cAAcI,OAAO,EAAE;YACzB,IAAIJ,cAAcI,OAAO,CAACC,IAAI,KAAK,SAAS;gBAC1CH,YAAYF,cAAcI,OAAO,CAACE,KAAK,GACnC,IAAIH,KAAK,IAAIA,OAAOI,OAAO,KAAKP,cAAcI,OAAO,CAACE,KAAK,IAC3D,IAAIH;YACV,OAAO,IAAIH,cAAcI,OAAO,CAACC,IAAI,KAAK,eAAe;gBACvD,kGAAkG;gBAClG,MAAMC,QAAQN,cAAcI,OAAO,CAACE,KAAK,GAAGN,cAAcI,OAAO,CAACE,KAAK,GAAG;gBAC1EJ,YAAY,IAAIC,KAAK,IAAIA,OAAOI,OAAO,KAAKC,KAAKC,GAAG,CAAC,GAAGR,cAAcK;YACxE;QACF;IACF;IAEA;;;;;;;;;IASE,GACF,OAAOJ;AACT","ignoreList":[0]}},
    {"offset": {"line": 5183, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5189, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/operations/runJobs/runJob/getRunTaskFunction.ts"],"sourcesContent":["import type { PayloadRequest } from '../../../../types/index.js'\nimport type {\n  RetryConfig,\n  RunInlineTaskFunction,\n  RunTaskFunction,\n  RunTaskFunctions,\n  TaskConfig,\n  TaskHandler,\n  TaskHandlerResult,\n  TaskType,\n} from '../../../config/types/taskTypes.js'\nimport type {\n  BaseJob,\n  RunningJob,\n  SingleTaskStatus,\n  WorkflowConfig,\n  WorkflowTypes,\n} from '../../../config/types/workflowTypes.js'\nimport type { UpdateJobFunction } from './getUpdateJobFunction.js'\n\nimport { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'\nimport { importHandlerPath } from './importHandlerPath.js'\n\n// Helper object type to force being passed by reference\nexport type RunTaskFunctionState = {\n  reachedMaxRetries: boolean\n}\n\nasync function getTaskHandlerFromConfig(taskConfig: TaskConfig<string>) {\n  let handler: TaskHandler<TaskType>\n\n  if (typeof taskConfig.handler === 'function') {\n    handler = taskConfig.handler\n  } else {\n    handler = await importHandlerPath<TaskHandler<TaskType>>(taskConfig.handler)\n  }\n  return handler\n}\n\nexport async function handleTaskFailed({\n  error,\n  executedAt,\n  input,\n  job,\n  maxRetries,\n  output,\n  req,\n  retriesConfig,\n  runnerOutput,\n  state,\n  taskConfig,\n  taskID,\n  taskSlug,\n  taskStatus,\n  updateJob,\n}: {\n  error?: Error\n  executedAt: Date\n  input: object\n  job: BaseJob\n  maxRetries: number\n  output: object\n  req: PayloadRequest\n  retriesConfig: number | RetryConfig\n  runnerOutput?: TaskHandlerResult<string>\n  state: RunTaskFunctionState\n  taskConfig?: TaskConfig<string>\n  taskID: string\n  taskSlug: string\n  taskStatus: null | SingleTaskStatus<string>\n  updateJob: UpdateJobFunction\n}): Promise<never> {\n  req.payload.logger.error({ err: error, job, msg: `Error running task ${taskID}`, taskSlug })\n\n  if (taskConfig?.onFail) {\n    await taskConfig.onFail()\n  }\n\n  if (!job.log) {\n    job.log = []\n  }\n  const errorJSON = error\n    ? {\n        name: error.name,\n        message: error.message,\n        stack: error.stack,\n      }\n    : runnerOutput.state\n\n  job.log.push({\n    completedAt: new Date().toISOString(),\n    error: errorJSON,\n    executedAt: executedAt.toISOString(),\n    input,\n    output,\n    state: 'failed',\n    taskID,\n    taskSlug,\n  })\n\n  if (job.waitUntil) {\n    // Check if waitUntil is in the past\n    const waitUntil = new Date(job.waitUntil)\n    if (waitUntil < new Date()) {\n      // Outdated waitUntil, remove it\n      delete job.waitUntil\n    }\n  }\n\n  if (!taskStatus?.complete && (taskStatus?.totalTried ?? 0) >= maxRetries) {\n    state.reachedMaxRetries = true\n\n    await updateJob({\n      error,\n      hasError: true,\n      log: job.log,\n      processing: false,\n      waitUntil: job.waitUntil,\n    })\n\n    throw new Error(\n      `Task ${taskSlug} has failed more than the allowed retries in workflow ${job.workflowSlug}${error ? `. Error: ${String(error)}` : ''}`,\n    )\n  } else {\n    // Job will retry. Let's determine when!\n    const waitUntil: Date = calculateBackoffWaitUntil({\n      retriesConfig,\n      totalTried: taskStatus?.totalTried ?? 0,\n    })\n\n    // Update job's waitUntil only if this waitUntil is later than the current one\n    if (!job.waitUntil || waitUntil > new Date(job.waitUntil)) {\n      job.waitUntil = waitUntil.toISOString()\n    }\n\n    await updateJob({\n      log: job.log,\n      processing: false,\n      waitUntil: job.waitUntil,\n    })\n    throw error ?? new Error('Task failed')\n  }\n}\n\nexport const getRunTaskFunction = <TIsInline extends boolean>(\n  state: RunTaskFunctionState,\n  job: BaseJob,\n  workflowConfig: WorkflowConfig<string>,\n  req: PayloadRequest,\n  isInline: TIsInline,\n  updateJob: UpdateJobFunction,\n): TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions => {\n  const runTask: <TTaskSlug extends string>(\n    taskSlug: TTaskSlug,\n  ) => TTaskSlug extends 'inline' ? RunInlineTaskFunction : RunTaskFunction<TTaskSlug> = (\n    taskSlug,\n  ) =>\n    (async (\n      taskID: Parameters<RunInlineTaskFunction>[0],\n      {\n        input,\n        retries,\n        task,\n      }: Parameters<RunInlineTaskFunction>[1] & Parameters<RunTaskFunction<string>>[1],\n    ) => {\n      const executedAt = new Date()\n\n      let inlineRunner: TaskHandler<TaskType> = null\n      if (isInline) {\n        inlineRunner = task\n      }\n\n      let taskConfig: TaskConfig<string>\n      if (!isInline) {\n        taskConfig = req.payload.config.jobs.tasks.find((t) => t.slug === taskSlug)\n\n        if (!taskConfig) {\n          throw new Error(`Task ${taskSlug} not found in workflow ${job.workflowSlug}`)\n        }\n      }\n\n      const retriesConfigFromPropsNormalized =\n        retries == undefined || retries == null\n          ? {}\n          : typeof retries === 'number'\n            ? { attempts: retries }\n            : retries\n      const retriesConfigFromTaskConfigNormalized = taskConfig\n        ? typeof taskConfig.retries === 'number'\n          ? { attempts: taskConfig.retries }\n          : taskConfig.retries\n        : {}\n\n      const finalRetriesConfig: RetryConfig = {\n        ...retriesConfigFromTaskConfigNormalized,\n        ...retriesConfigFromPropsNormalized, // Retry config from props takes precedence\n      }\n\n      const taskStatus: null | SingleTaskStatus<string> = job?.taskStatus?.[taskSlug]\n        ? job.taskStatus[taskSlug][taskID]\n        : null\n\n      // Handle restoration of task if it succeeded in a previous run\n      if (taskStatus && taskStatus.complete === true) {\n        let shouldRestore = true\n        if (finalRetriesConfig?.shouldRestore === false) {\n          shouldRestore = false\n        } else if (typeof finalRetriesConfig?.shouldRestore === 'function') {\n          shouldRestore = await finalRetriesConfig.shouldRestore({ input, job, req, taskStatus })\n        }\n        if (shouldRestore) {\n          return taskStatus.output\n        }\n      }\n\n      let runner: TaskHandler<TaskType>\n      if (isInline) {\n        runner = inlineRunner\n      } else {\n        if (!taskConfig) {\n          throw new Error(`Task ${taskSlug} not found in workflow ${job.workflowSlug}`)\n        }\n        runner = await getTaskHandlerFromConfig(taskConfig)\n      }\n\n      if (!runner || typeof runner !== 'function') {\n        const errorMessage = isInline\n          ? `Can't find runner for inline task with ID ${taskID}`\n          : `Can't find runner while importing with the path ${typeof workflowConfig.handler === 'string' ? workflowConfig.handler : 'unknown - no string path'} in job type ${job.workflowSlug} for task ${taskSlug}.`\n        req.payload.logger.error(errorMessage)\n\n        await updateJob({\n          error: {\n            error: errorMessage,\n          },\n          hasError: true,\n          log: [\n            ...job.log,\n            {\n              completedAt: new Date().toISOString(),\n              error: errorMessage,\n              executedAt: executedAt.toISOString(),\n              state: 'failed',\n              taskID,\n              taskSlug,\n            },\n          ],\n          processing: false,\n        })\n\n        return\n      }\n\n      let output: object = {}\n\n      let maxRetries: number | undefined = finalRetriesConfig?.attempts\n\n      if (maxRetries === undefined || maxRetries === null) {\n        // Inherit retries from workflow config, if they are undefined and the workflow config has retries configured\n        if (workflowConfig.retries !== undefined && workflowConfig.retries !== null) {\n          maxRetries =\n            typeof workflowConfig.retries === 'object'\n              ? workflowConfig.retries.attempts\n              : workflowConfig.retries\n        } else {\n          maxRetries = 0\n        }\n      }\n\n      try {\n        const runnerOutput = await runner({\n          input,\n          job: job as unknown as RunningJob<WorkflowTypes>, // TODO: Type this better\n          req,\n        })\n\n        if (runnerOutput.state === 'failed') {\n          await handleTaskFailed({\n            executedAt,\n            input,\n            job,\n            maxRetries,\n            output,\n            req,\n            retriesConfig: finalRetriesConfig,\n            runnerOutput,\n            state,\n            taskConfig,\n            taskID,\n            taskSlug,\n            taskStatus,\n            updateJob,\n          })\n          throw new Error('Task failed')\n        } else {\n          output = runnerOutput.output\n        }\n      } catch (err) {\n        await handleTaskFailed({\n          error: err,\n          executedAt,\n          input,\n          job,\n          maxRetries,\n          output,\n          req,\n          retriesConfig: finalRetriesConfig,\n          state,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          updateJob,\n        })\n        throw new Error('Task failed')\n      }\n\n      if (taskConfig?.onSuccess) {\n        await taskConfig.onSuccess()\n      }\n\n      if (!job.log) {\n        job.log = []\n      }\n      job.log.push({\n        completedAt: new Date().toISOString(),\n        executedAt: executedAt.toISOString(),\n        input,\n        output,\n        state: 'succeeded',\n        taskID,\n        taskSlug,\n      })\n\n      await updateJob({\n        log: job.log,\n      })\n\n      return output\n    }) as any\n\n  if (isInline) {\n    return runTask('inline') as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions\n  } else {\n    const tasks: RunTaskFunctions = {}\n    for (const task of req?.payload?.config?.jobs?.tasks ?? []) {\n      tasks[task.slug] = runTask(task.slug)\n    }\n    return tasks as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions\n  }\n}\n"],"names":["calculateBackoffWaitUntil","importHandlerPath","getTaskHandlerFromConfig","taskConfig","handler","handleTaskFailed","error","executedAt","input","job","maxRetries","output","req","retriesConfig","runnerOutput","state","taskID","taskSlug","taskStatus","updateJob","payload","logger","err","msg","onFail","log","errorJSON","name","message","stack","push","completedAt","Date","toISOString","waitUntil","complete","totalTried","reachedMaxRetries","hasError","processing","Error","workflowSlug","String","getRunTaskFunction","workflowConfig","isInline","runTask","retries","task","inlineRunner","config","jobs","tasks","find","t","slug","retriesConfigFromPropsNormalized","undefined","attempts","retriesConfigFromTaskConfigNormalized","finalRetriesConfig","shouldRestore","runner","errorMessage","onSuccess"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5430, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5436, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/operations/runJobs/runJob/handleWorkflowError.ts"],"sourcesContent":["import type { PayloadRequest } from '../../../../types/index.js'\nimport type { BaseJob, WorkflowConfig, WorkflowTypes } from '../../../config/types/workflowTypes.js'\nimport type { RunTaskFunctionState } from './getRunTaskFunction.js'\n\nimport { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'\n\n/**\n * This is called if a workflow catches an error. It determines if it's a final error\n * or not and handles logging.\n */\nexport function handleWorkflowError({\n  error,\n  job,\n  req,\n  state,\n  workflowConfig,\n}: {\n  error: Error\n  job: BaseJob\n  req: PayloadRequest\n  state: RunTaskFunctionState\n  workflowConfig: WorkflowConfig<WorkflowTypes>\n}): {\n  hasFinalError: boolean\n} {\n  const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n\n  let hasFinalError = state.reachedMaxRetries // If any TASK reached max retries, the job has an error\n  const maxWorkflowRetries: number =\n    (typeof workflowConfig.retries === 'object'\n      ? workflowConfig.retries.attempts\n      : workflowConfig.retries) ?? undefined\n\n  if (\n    maxWorkflowRetries !== undefined &&\n    maxWorkflowRetries !== null &&\n    job.totalTried >= maxWorkflowRetries\n  ) {\n    hasFinalError = true\n    state.reachedMaxRetries = true\n  }\n\n  // Now let's handle workflow retries\n  if (!hasFinalError) {\n    if (job.waitUntil) {\n      // Check if waitUntil is in the past\n      const waitUntil = new Date(job.waitUntil)\n      if (waitUntil < new Date()) {\n        // Outdated waitUntil, remove it\n        delete job.waitUntil\n      }\n    }\n\n    // Job will retry. Let's determine when!\n    const waitUntil: Date = calculateBackoffWaitUntil({\n      retriesConfig: workflowConfig.retries,\n      totalTried: job.totalTried ?? 0,\n    })\n\n    // Update job's waitUntil only if this waitUntil is later than the current one\n    if (!job.waitUntil || waitUntil > new Date(job.waitUntil)) {\n      job.waitUntil = waitUntil.toISOString()\n    }\n  }\n\n  req.payload.logger.error({\n    err: error,\n    msg: `Error running job ${jobLabel} id: ${job.id} attempt ${job.totalTried + 1}${maxWorkflowRetries !== undefined ? '/' + (maxWorkflowRetries + 1) : ''}`,\n  })\n\n  return {\n    hasFinalError,\n  }\n}\n"],"names":["calculateBackoffWaitUntil","handleWorkflowError","error","job","req","state","workflowConfig","jobLabel","workflowSlug","taskSlug","hasFinalError","reachedMaxRetries","maxWorkflowRetries","retries","attempts","undefined","totalTried","waitUntil","Date","retriesConfig","toISOString","payload","logger","err","msg","id"],"mappings":";;;AAIA,SAASA,yBAAyB,QAAQ,iCAAgC;;AAMnE,SAASC,oBAAoB,EAClCC,KAAK,EACLC,GAAG,EACHC,GAAG,EACHC,KAAK,EACLC,cAAc,EAOf;IAGC,MAAMC,WAAWJ,IAAIK,YAAY,IAAI,CAAC,MAAM,EAAEL,IAAIM,QAAQ,EAAE;IAE5D,IAAIC,gBAAgBL,MAAMM,iBAAiB,CAAC,wDAAwD;;IACpG,MAAMC,qBACH,CAAA,OAAON,eAAeO,OAAO,KAAK,WAC/BP,eAAeO,OAAO,CAACC,QAAQ,GAC/BR,eAAeO,OAAM,KAAME;IAEjC,IACEH,uBAAuBG,aACvBH,uBAAuB,QACvBT,IAAIa,UAAU,IAAIJ,oBAClB;QACAF,gBAAgB;QAChBL,MAAMM,iBAAiB,GAAG;IAC5B;IAEA,oCAAoC;IACpC,IAAI,CAACD,eAAe;QAClB,IAAIP,IAAIc,SAAS,EAAE;YACjB,oCAAoC;YACpC,MAAMA,YAAY,IAAIC,KAAKf,IAAIc,SAAS;YACxC,IAAIA,YAAY,IAAIC,QAAQ;gBAC1B,gCAAgC;gBAChC,OAAOf,IAAIc,SAAS;YACtB;QACF;QAEA,wCAAwC;QACxC,MAAMA,gbAAkBjB,4BAAAA,EAA0B;YAChDmB,eAAeb,eAAeO,OAAO;YACrCG,YAAYb,IAAIa,UAAU,IAAI;QAChC;QAEA,8EAA8E;QAC9E,IAAI,CAACb,IAAIc,SAAS,IAAIA,YAAY,IAAIC,KAAKf,IAAIc,SAAS,GAAG;YACzDd,IAAIc,SAAS,GAAGA,UAAUG,WAAW;QACvC;IACF;IAEAhB,IAAIiB,OAAO,CAACC,MAAM,CAACpB,KAAK,CAAC;QACvBqB,KAAKrB;QACLsB,KAAK,CAAC,kBAAkB,EAAEjB,SAAS,KAAK,EAAEJ,IAAIsB,EAAE,CAAC,SAAS,EAAEtB,IAAIa,UAAU,GAAG,IAAIJ,uBAAuBG,YAAY,MAAOH,CAAAA,qBAAqB,CAAA,IAAK,IAAI;IAC3J;IAEA,OAAO;QACLF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 5478, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5484, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/operations/runJobs/runJSONJob/index.ts"],"sourcesContent":["import type { PayloadRequest } from '../../../../types/index.js'\nimport type { WorkflowJSON, WorkflowStep } from '../../../config/types/workflowJSONTypes.js'\nimport type {\n  BaseJob,\n  RunningJob,\n  WorkflowConfig,\n  WorkflowTypes,\n} from '../../../config/types/workflowTypes.js'\nimport type { UpdateJobFunction } from '../runJob/getUpdateJobFunction.js'\nimport type { JobRunStatus } from '../runJob/index.js'\n\nimport { getRunTaskFunction, type RunTaskFunctionState } from '../runJob/getRunTaskFunction.js'\nimport { handleWorkflowError } from '../runJob/handleWorkflowError.js'\n\ntype Args = {\n  job: BaseJob\n  req: PayloadRequest\n  updateJob: UpdateJobFunction\n  workflowConfig: WorkflowConfig<WorkflowTypes>\n  workflowHandler: WorkflowJSON<WorkflowTypes>\n}\n\nexport type RunJSONJobResult = {\n  status: JobRunStatus\n}\n\nexport const runJSONJob = async ({\n  job,\n  req,\n  updateJob,\n  workflowConfig,\n  workflowHandler,\n}: Args): Promise<RunJSONJobResult> => {\n  // Object so that we can pass contents by reference, not value.\n  // We want any mutations to be reflected in here.\n  const state: RunTaskFunctionState = {\n    reachedMaxRetries: false,\n  }\n\n  const stepsToRun: WorkflowStep<string, string>[] = []\n\n  for (const step of workflowHandler) {\n    if ('task' in step) {\n      if (job?.taskStatus?.[step.task]?.[step.id]?.complete) {\n        continue\n      }\n    } else {\n      if (job?.taskStatus?.['inline']?.[step.id]?.complete) {\n        continue\n      }\n    }\n    if (step.condition && !step.condition({ job: job as RunningJob<any> })) {\n      // TODO: Improve RunningJob type see todo below\n      continue\n    }\n    stepsToRun.push(step)\n  }\n\n  const tasks = getRunTaskFunction(state, job, workflowConfig, req, false, updateJob)\n  const inlineTask = getRunTaskFunction(state, job, workflowConfig, req, true, updateJob)\n\n  // Run the job\n  let hasFinalError = false\n  let error: Error | undefined\n  try {\n    await Promise.all(\n      stepsToRun.map(async (step) => {\n        if ('task' in step) {\n          await tasks[step.task](step.id, {\n            input: step.input ? step.input({ job: job as RunningJob<any> }) : {}, // TODO: Type better. We should use RunningJob anywhere and make TypedCollection['payload-jobs'] be BaseJob if type not generated\n            retries: step.retries,\n          })\n        } else {\n          await inlineTask(step.id, {\n            retries: step.retries,\n            task: step.inlineTask as any, // TODO: Fix type\n          })\n        }\n      }),\n    )\n  } catch (err) {\n    const errorResult = handleWorkflowError({\n      error: err,\n      job,\n      req,\n      state,\n      workflowConfig,\n    })\n    error = err\n    hasFinalError = errorResult.hasFinalError\n  }\n\n  // Check if workflow has completed\n  let workflowCompleted = false\n  for (const [slug, map] of Object.entries(job.taskStatus)) {\n    for (const [id, taskStatus] of Object.entries(map)) {\n      if (taskStatus.complete) {\n        const step = workflowHandler.find((step) => {\n          if ('task' in step) {\n            return step.task === slug && step.id === id\n          } else {\n            return step.id === id && slug === 'inline'\n          }\n        })\n        if (step.completesJob) {\n          workflowCompleted = true\n          break\n        }\n      }\n    }\n  }\n\n  if (workflowCompleted) {\n    if (error) {\n      // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n      // we need to ensure the job is updated to reflect the error\n      await updateJob({\n        completedAt: new Date().toISOString(),\n        error: hasFinalError ? error : undefined,\n        hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n        processing: false,\n        totalTried: (job.totalTried ?? 0) + 1,\n      })\n    } else {\n      await updateJob({\n        completedAt: new Date().toISOString(),\n        processing: false,\n        totalTried: (job.totalTried ?? 0) + 1,\n      })\n    }\n\n    return {\n      status: 'success',\n    }\n  } else {\n    if (error) {\n      // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n      // we need to ensure the job is updated to reflect the error\n      await updateJob({\n        error: hasFinalError ? error : undefined,\n        hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n        processing: false,\n        totalTried: (job.totalTried ?? 0) + 1,\n      })\n      return {\n        status: hasFinalError ? 'error-reached-max-retries' : 'error',\n      }\n    } else {\n      // Retry the job - no need to bump processing or totalTried as this does not count as a retry. A condition of a different task might have just opened up!\n      return await runJSONJob({\n        job,\n        req,\n        updateJob,\n        workflowConfig,\n        workflowHandler,\n      })\n    }\n  }\n}\n"],"names":["getRunTaskFunction","handleWorkflowError","runJSONJob","job","req","updateJob","workflowConfig","workflowHandler","state","reachedMaxRetries","stepsToRun","step","taskStatus","task","id","complete","condition","push","tasks","inlineTask","hasFinalError","error","Promise","all","map","input","retries","err","errorResult","workflowCompleted","slug","Object","entries","find","completesJob","completedAt","Date","toISOString","undefined","hasError","processing","totalTried","status"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5612, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5618, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/operations/runJobs/runJob/index.ts"],"sourcesContent":["import type { PayloadRequest } from '../../../../types/index.js'\nimport type {\n  BaseJob,\n  RunningJob,\n  WorkflowConfig,\n  WorkflowHandler,\n  WorkflowTypes,\n} from '../../../config/types/workflowTypes.js'\nimport type { RunTaskFunctionState } from './getRunTaskFunction.js'\nimport type { UpdateJobFunction } from './getUpdateJobFunction.js'\n\nimport { getRunTaskFunction } from './getRunTaskFunction.js'\nimport { handleWorkflowError } from './handleWorkflowError.js'\n\ntype Args = {\n  job: BaseJob\n  req: PayloadRequest\n  updateJob: UpdateJobFunction\n  workflowConfig: WorkflowConfig<WorkflowTypes>\n  workflowHandler: WorkflowHandler<WorkflowTypes>\n}\n\nexport type JobRunStatus = 'error' | 'error-reached-max-retries' | 'success'\n\nexport type RunJobResult = {\n  status: JobRunStatus\n}\n\nexport const runJob = async ({\n  job,\n  req,\n  updateJob,\n  workflowConfig,\n  workflowHandler,\n}: Args): Promise<RunJobResult> => {\n  // Object so that we can pass contents by reference, not value.\n  // We want any mutations to be reflected in here.\n  const state: RunTaskFunctionState = {\n    reachedMaxRetries: false,\n  }\n\n  // Run the job\n  try {\n    await workflowHandler({\n      inlineTask: getRunTaskFunction(state, job, workflowConfig, req, true, updateJob),\n      job: job as unknown as RunningJob<WorkflowTypes>, //TODO: Type this better\n      req,\n      tasks: getRunTaskFunction(state, job, workflowConfig, req, false, updateJob),\n    })\n  } catch (err) {\n    const { hasFinalError } = handleWorkflowError({\n      error: err,\n      job,\n      req,\n      state,\n      workflowConfig,\n    })\n\n    const errorJSON = hasFinalError\n      ? {\n          name: err.name,\n          message: err.message,\n          stack: err.stack,\n        }\n      : undefined\n    // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n    // we need to ensure the job is updated to reflect the error\n    await updateJob({\n      error: errorJSON,\n      hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n      processing: false,\n      totalTried: (job.totalTried ?? 0) + 1,\n    })\n\n    return {\n      status: hasFinalError ? 'error-reached-max-retries' : 'error',\n    }\n  }\n\n  // Workflow has completed\n  await updateJob({\n    completedAt: new Date().toISOString(),\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n  })\n\n  return {\n    status: 'success',\n  }\n}\n"],"names":["getRunTaskFunction","handleWorkflowError","runJob","job","req","updateJob","workflowConfig","workflowHandler","state","reachedMaxRetries","inlineTask","tasks","err","hasFinalError","error","errorJSON","name","message","stack","undefined","hasError","processing","totalTried","status","completedAt","Date","toISOString"],"mappings":";;;AAWA,SAASA,kBAAkB,QAAQ,0BAAyB;AAC5D,SAASC,mBAAmB,QAAQ,2BAA0B;;;AAgBvD,MAAMC,SAAS,OAAO,EAC3BC,GAAG,EACHC,GAAG,EACHC,SAAS,EACTC,cAAc,EACdC,eAAe,EACV;IACL,+DAA+D;IAC/D,iDAAiD;IACjD,MAAMC,QAA8B;QAClCC,mBAAmB;IACrB;IAEA,cAAc;IACd,IAAI;QACF,MAAMF,gBAAgB;YACpBG,yaAAYV,qBAAAA,EAAmBQ,OAAOL,KAAKG,gBAAgBF,KAAK,MAAMC;YACtEF,KAAKA;YACLC;YACAO,oaAAOX,qBAAAA,EAAmBQ,OAAOL,KAAKG,gBAAgBF,KAAK,OAAOC;QACpE;IACF,EAAE,OAAOO,KAAK;QACZ,MAAM,EAAEC,aAAa,EAAE,iaAAGZ,sBAAAA,EAAoB;YAC5Ca,OAAOF;YACPT;YACAC;YACAI;YACAF;QACF;QAEA,MAAMS,YAAYF,gBACd;YACEG,MAAMJ,IAAII,IAAI;YACdC,SAASL,IAAIK,OAAO;YACpBC,OAAON,IAAIM,KAAK;QAClB,IACAC;QACJ,4HAA4H;QAC5H,4DAA4D;QAC5D,MAAMd,UAAU;YACdS,OAAOC;YACPK,UAAUP;YACVQ,YAAY;YACZC,YAAanB,CAAAA,IAAImB,UAAU,IAAI,CAAA,IAAK;QACtC;QAEA,OAAO;YACLC,QAAQV,gBAAgB,8BAA8B;QACxD;IACF;IAEA,yBAAyB;IACzB,MAAMR,UAAU;QACdmB,aAAa,IAAIC,OAAOC,WAAW;QACnCL,YAAY;QACZC,YAAanB,CAAAA,IAAImB,UAAU,IAAI,CAAA,IAAK;IACtC;IAEA,OAAO;QACLC,QAAQ;IACV;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 5674, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5680, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/operations/runJobs/index.ts"],"sourcesContent":["import type { PaginatedDocs } from '../../../database/types.js'\nimport type { PayloadRequest, Where } from '../../../types/index.js'\nimport type { WorkflowJSON } from '../../config/types/workflowJSONTypes.js'\nimport type {\n  BaseJob,\n  WorkflowConfig,\n  WorkflowHandler,\n  WorkflowTypes,\n} from '../../config/types/workflowTypes.js'\nimport type { RunJobResult } from './runJob/index.js'\n\nimport { Forbidden } from '../../../errors/Forbidden.js'\nimport isolateObjectProperty from '../../../utilities/isolateObjectProperty.js'\nimport { getUpdateJobFunction } from './runJob/getUpdateJobFunction.js'\nimport { importHandlerPath } from './runJob/importHandlerPath.js'\nimport { runJob } from './runJob/index.js'\nimport { runJSONJob } from './runJSONJob/index.js'\n\nexport type RunJobsArgs = {\n  /**\n   * ID of the job to run\n   */\n  id?: number | string\n  limit?: number\n  overrideAccess?: boolean\n  queue?: string\n  req: PayloadRequest\n  where?: Where\n}\n\nexport type RunJobsResult = {\n  jobStatus?: Record<string, RunJobResult>\n  /**\n   * If this is false, there for sure are no jobs remaining, regardless of the limit\n   */\n  noJobsRemaining?: boolean\n  /**\n   * Out of the jobs that were queried & processed (within the set limit), how many are remaining and retryable?\n   */\n  remainingJobsFromQueried: number\n}\n\nexport const runJobs = async ({\n  id,\n  limit = 10,\n  overrideAccess,\n  queue,\n  req,\n  where: whereFromProps,\n}: RunJobsArgs): Promise<RunJobsResult> => {\n  if (!overrideAccess) {\n    const hasAccess = await req.payload.config.jobs.access.run({ req })\n    if (!hasAccess) {\n      throw new Forbidden(req.t)\n    }\n  }\n  const where: Where = {\n    and: [\n      {\n        completedAt: {\n          exists: false,\n        },\n      },\n      {\n        hasError: {\n          not_equals: true,\n        },\n      },\n      {\n        processing: {\n          equals: false,\n        },\n      },\n      {\n        or: [\n          {\n            waitUntil: {\n              exists: false,\n            },\n          },\n          {\n            waitUntil: {\n              less_than: new Date().toISOString(),\n            },\n          },\n        ],\n      },\n    ],\n  }\n\n  if (queue) {\n    where.and.push({\n      queue: {\n        equals: queue,\n      },\n    })\n  }\n\n  if (whereFromProps) {\n    where.and.push(whereFromProps)\n  }\n\n  // Find all jobs and ensure we set job to processing: true as early as possible to reduce the chance of\n  // the same job being picked up by another worker\n  const jobsQuery: {\n    docs: BaseJob[]\n  } = id\n    ? {\n        docs: [\n          (await req.payload.update({\n            id,\n            collection: 'payload-jobs',\n            data: {\n              processing: true,\n              seenByWorker: true,\n            },\n            depth: req.payload.config.jobs.depth,\n            disableTransaction: true,\n            showHiddenFields: true,\n          })) as BaseJob,\n        ],\n      }\n    : ((await req.payload.update({\n        collection: 'payload-jobs',\n        data: {\n          processing: true,\n          seenByWorker: true,\n        },\n        depth: req.payload.config.jobs.depth,\n        disableTransaction: true,\n        limit,\n        showHiddenFields: true,\n        where,\n      })) as unknown as PaginatedDocs<BaseJob>)\n\n  /**\n   * Just for logging purposes, we want to know how many jobs are new and how many are existing (= already been tried).\n   * This is only for logs - in the end we still want to run all jobs, regardless of whether they are new or existing.\n   */\n  const { newJobs } = jobsQuery.docs.reduce(\n    (acc, job) => {\n      if (job.totalTried > 0) {\n        acc.existingJobs.push(job)\n      } else {\n        acc.newJobs.push(job)\n      }\n      return acc\n    },\n    { existingJobs: [], newJobs: [] },\n  )\n\n  if (!jobsQuery.docs.length) {\n    return {\n      noJobsRemaining: true,\n      remainingJobsFromQueried: 0,\n    }\n  }\n\n  if (jobsQuery?.docs?.length) {\n    req.payload.logger.info(`Running ${jobsQuery.docs.length} jobs.`)\n  }\n  const jobsToDelete: (number | string)[] | undefined = req.payload.config.jobs.deleteJobOnComplete\n    ? []\n    : undefined\n\n  const jobPromises = jobsQuery.docs.map(async (job) => {\n    if (!job.workflowSlug && !job.taskSlug) {\n      throw new Error('Job must have either a workflowSlug or a taskSlug')\n    }\n    const jobReq = isolateObjectProperty(req, 'transactionID')\n\n    const workflowConfig: WorkflowConfig<WorkflowTypes> = job.workflowSlug\n      ? req.payload.config.jobs?.workflows.find(({ slug }) => slug === job.workflowSlug)\n      : {\n          slug: 'singleTask',\n          handler: async ({ job, tasks }) => {\n            await tasks[job.taskSlug as string]('1', {\n              input: job.input,\n            })\n          },\n        }\n\n    if (!workflowConfig) {\n      return null // Skip jobs with no workflow configuration\n    }\n\n    const updateJob = getUpdateJobFunction(job, jobReq)\n\n    // the runner will either be passed to the config\n    // OR it will be a path, which we will need to import via eval to avoid\n    // Next.js compiler dynamic import expression errors\n    let workflowHandler: WorkflowHandler<WorkflowTypes> | WorkflowJSON<WorkflowTypes>\n\n    if (\n      typeof workflowConfig.handler === 'function' ||\n      (typeof workflowConfig.handler === 'object' && Array.isArray(workflowConfig.handler))\n    ) {\n      workflowHandler = workflowConfig.handler\n    } else {\n      workflowHandler = await importHandlerPath<typeof workflowHandler>(workflowConfig.handler)\n\n      if (!workflowHandler) {\n        const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n        const errorMessage = `Can't find runner while importing with the path ${workflowConfig.handler} in job type ${jobLabel}.`\n        req.payload.logger.error(errorMessage)\n\n        await updateJob({\n          error: {\n            error: errorMessage,\n          },\n          hasError: true,\n          processing: false,\n        })\n\n        return\n      }\n    }\n\n    if (typeof workflowHandler === 'function') {\n      const result = await runJob({\n        job,\n        req: jobReq,\n        updateJob,\n        workflowConfig,\n        workflowHandler,\n      })\n\n      if (result.status !== 'error' && jobsToDelete) {\n        jobsToDelete.push(job.id)\n      }\n\n      return { id: job.id, result }\n    } else {\n      const result = await runJSONJob({\n        job,\n        req: jobReq,\n        updateJob,\n        workflowConfig,\n        workflowHandler,\n      })\n\n      if (result.status !== 'error' && jobsToDelete) {\n        jobsToDelete.push(job.id)\n      }\n\n      return { id: job.id, result }\n    }\n  })\n\n  const resultsArray = await Promise.all(jobPromises)\n\n  if (jobsToDelete && jobsToDelete.length > 0) {\n    try {\n      await req.payload.delete({\n        collection: 'payload-jobs',\n        req,\n        where: { id: { in: jobsToDelete } },\n      })\n    } catch (err) {\n      req.payload.logger.error({\n        err,\n        msg: `failed to delete jobs ${jobsToDelete.join(', ')} on complete`,\n      })\n    }\n  }\n\n  const resultsObject: RunJobsResult['jobStatus'] = resultsArray.reduce((acc, cur) => {\n    if (cur !== null) {\n      // Check if there's a valid result to include\n      acc[cur.id] = cur.result\n    }\n    return acc\n  }, {})\n\n  let remainingJobsFromQueried = 0\n  for (const jobID in resultsObject) {\n    const jobResult = resultsObject[jobID]\n    if (jobResult.status === 'error') {\n      remainingJobsFromQueried++ // Can be retried\n    }\n  }\n\n  return {\n    jobStatus: resultsObject,\n    remainingJobsFromQueried,\n  }\n}\n"],"names":["Forbidden","isolateObjectProperty","getUpdateJobFunction","importHandlerPath","runJob","runJSONJob","runJobs","id","limit","overrideAccess","queue","req","where","whereFromProps","hasAccess","payload","config","jobs","access","run","t","and","completedAt","exists","hasError","not_equals","processing","equals","or","waitUntil","less_than","Date","toISOString","push","jobsQuery","docs","update","collection","data","seenByWorker","depth","disableTransaction","showHiddenFields","newJobs","reduce","acc","job","totalTried","existingJobs","length","noJobsRemaining","remainingJobsFromQueried","logger","info","jobsToDelete","deleteJobOnComplete","undefined","jobPromises","map","workflowSlug","taskSlug","Error","jobReq","workflowConfig","workflows","find","slug","handler","tasks","input","updateJob","workflowHandler","Array","isArray","jobLabel","errorMessage","error","result","status","resultsArray","Promise","all","delete","in","err","msg","join","resultsObject","cur","jobID","jobResult","jobStatus"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5910, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5916, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/restEndpointRun.ts"],"sourcesContent":["import type { Endpoint, SanitizedConfig } from '../config/types.js'\n\nimport { runJobs, type RunJobsArgs } from './operations/runJobs/index.js'\n\nconst configHasJobs = (config: SanitizedConfig): boolean => {\n  if (!config.jobs) {\n    return false\n  }\n\n  if (config.jobs.tasks.length > 0) {\n    return true\n  }\n  if (Array.isArray(config.jobs.workflows) && config.jobs.workflows.length > 0) {\n    return true\n  }\n\n  return false\n}\n\nexport const runJobsEndpoint: Endpoint = {\n  handler: async (req) => {\n    if (!configHasJobs(req.payload.config)) {\n      return Response.json(\n        {\n          message: 'No jobs to run.',\n        },\n        { status: 200 },\n      )\n    }\n\n    const hasAccess = await req.payload.config.jobs.access.run({ req })\n\n    if (!hasAccess) {\n      return Response.json(\n        {\n          message: req.i18n.t('error:unauthorized'),\n        },\n        { status: 401 },\n      )\n    }\n\n    const { limit, queue } = req.query\n\n    const runJobsArgs: RunJobsArgs = {\n      queue: 'default',\n      req,\n      // We are checking access above, so we can override it here\n      overrideAccess: true,\n    }\n\n    if (typeof queue === 'string') {\n      runJobsArgs.queue = queue\n    }\n\n    if (typeof limit !== 'undefined') {\n      runJobsArgs.limit = Number(limit)\n    }\n\n    let noJobsRemaining = false\n    let remainingJobsFromQueried = 0\n    try {\n      const result = await runJobs(runJobsArgs)\n      noJobsRemaining = result.noJobsRemaining\n      remainingJobsFromQueried = result.remainingJobsFromQueried\n    } catch (err) {\n      req.payload.logger.error({\n        err,\n        msg: 'There was an error running jobs:',\n        queue: runJobsArgs.queue,\n      })\n\n      return Response.json(\n        {\n          message: req.i18n.t('error:unknown'),\n          noJobsRemaining: true,\n          remainingJobsFromQueried,\n        },\n        { status: 500 },\n      )\n    }\n\n    return Response.json(\n      {\n        message: req.i18n.t('general:success'),\n        noJobsRemaining,\n        remainingJobsFromQueried,\n      },\n      { status: 200 },\n    )\n  },\n  method: 'get',\n  path: '/run',\n}\n"],"names":["runJobs","configHasJobs","config","jobs","tasks","length","Array","isArray","workflows","runJobsEndpoint","handler","req","payload","Response","json","message","status","hasAccess","access","run","i18n","t","limit","queue","query","runJobsArgs","overrideAccess","Number","noJobsRemaining","remainingJobsFromQueried","result","err","logger","error","msg","method","path"],"mappings":";;;AAEA,SAASA,OAAO,QAA0B,gCAA+B;;AAEzE,MAAMC,gBAAgB,CAACC;IACrB,IAAI,CAACA,OAAOC,IAAI,EAAE;QAChB,OAAO;IACT;IAEA,IAAID,OAAOC,IAAI,CAACC,KAAK,CAACC,MAAM,GAAG,GAAG;QAChC,OAAO;IACT;IACA,IAAIC,MAAMC,OAAO,CAACL,OAAOC,IAAI,CAACK,SAAS,KAAKN,OAAOC,IAAI,CAACK,SAAS,CAACH,MAAM,GAAG,GAAG;QAC5E,OAAO;IACT;IAEA,OAAO;AACT;AAEO,MAAMI,kBAA4B;IACvCC,SAAS,OAAOC;QACd,IAAI,CAACV,cAAcU,IAAIC,OAAO,CAACV,MAAM,GAAG;YACtC,OAAOW,SAASC,IAAI,CAClB;gBACEC,SAAS;YACX,GACA;gBAAEC,QAAQ;YAAI;QAElB;QAEA,MAAMC,YAAY,MAAMN,IAAIC,OAAO,CAACV,MAAM,CAACC,IAAI,CAACe,MAAM,CAACC,GAAG,CAAC;YAAER;QAAI;QAEjE,IAAI,CAACM,WAAW;YACd,OAAOJ,SAASC,IAAI,CAClB;gBACEC,SAASJ,IAAIS,IAAI,CAACC,CAAC,CAAC;YACtB,GACA;gBAAEL,QAAQ;YAAI;QAElB;QAEA,MAAM,EAAEM,KAAK,EAAEC,KAAK,EAAE,GAAGZ,IAAIa,KAAK;QAElC,MAAMC,cAA2B;YAC/BF,OAAO;YACPZ;YACA,2DAA2D;YAC3De,gBAAgB;QAClB;QAEA,IAAI,OAAOH,UAAU,UAAU;YAC7BE,YAAYF,KAAK,GAAGA;QACtB;QAEA,IAAI,OAAOD,UAAU,aAAa;YAChCG,YAAYH,KAAK,GAAGK,OAAOL;QAC7B;QAEA,IAAIM,kBAAkB;QACtB,IAAIC,2BAA2B;QAC/B,IAAI;YACF,MAAMC,SAAS,4YAAM9B,UAAAA,EAAQyB;YAC7BG,kBAAkBE,OAAOF,eAAe;YACxCC,2BAA2BC,OAAOD,wBAAwB;QAC5D,EAAE,OAAOE,KAAK;YACZpB,IAAIC,OAAO,CAACoB,MAAM,CAACC,KAAK,CAAC;gBACvBF;gBACAG,KAAK;gBACLX,OAAOE,YAAYF,KAAK;YAC1B;YAEA,OAAOV,SAASC,IAAI,CAClB;gBACEC,SAASJ,IAAIS,IAAI,CAACC,CAAC,CAAC;gBACpBO,iBAAiB;gBACjBC;YACF,GACA;gBAAEb,QAAQ;YAAI;QAElB;QAEA,OAAOH,SAASC,IAAI,CAClB;YACEC,SAASJ,IAAIS,IAAI,CAACC,CAAC,CAAC;YACpBO;YACAC;QACF,GACA;YAAEb,QAAQ;QAAI;IAElB;IACAmB,QAAQ;IACRC,MAAM;AACR,EAAC","ignoreList":[0]}},
    {"offset": {"line": 5996, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6002, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/utilities/getJobTaskStatus.ts"],"sourcesContent":["import type { TaskConfig, TaskType } from '../config/types/taskTypes.js'\nimport type { BaseJob, JobTaskStatus } from '../config/types/workflowTypes.js'\n\ntype Args = {\n  jobLog: BaseJob['log']\n  tasksConfig: TaskConfig<TaskType>[]\n}\n\nexport const getJobTaskStatus = ({ jobLog }: Args): JobTaskStatus => {\n  const taskStatus: JobTaskStatus = {}\n\n  // First, add (in order) the steps from the config to\n  // our status map\n  for (const loggedJob of jobLog) {\n    if (!taskStatus[loggedJob.taskSlug]) {\n      taskStatus[loggedJob.taskSlug] = {}\n    }\n    if (!taskStatus[loggedJob.taskSlug][loggedJob.taskID]) {\n      taskStatus[loggedJob.taskSlug][loggedJob.taskID] = {\n        complete: loggedJob.state === 'succeeded',\n        input: loggedJob.input,\n        output: loggedJob.output,\n        taskSlug: loggedJob.taskSlug,\n        totalTried: 1,\n      }\n    } else {\n      const newTaskStatus = taskStatus[loggedJob.taskSlug][loggedJob.taskID]\n      newTaskStatus.totalTried += 1\n\n      if (loggedJob.state === 'succeeded') {\n        newTaskStatus.complete = true\n        // As the task currently saved in taskStatus has likely failed and thus has no\n        // Output data, we need to update it with the new data from the successful task\n        newTaskStatus.output = loggedJob.output\n        newTaskStatus.input = loggedJob.input\n        newTaskStatus.taskSlug = loggedJob.taskSlug\n      }\n      taskStatus[loggedJob.taskSlug][loggedJob.taskID] = newTaskStatus\n    }\n  }\n\n  return taskStatus\n}\n"],"names":["getJobTaskStatus","jobLog","taskStatus","loggedJob","taskSlug","taskID","complete","state","input","output","totalTried","newTaskStatus"],"mappings":";;;AAQO,MAAMA,mBAAmB,CAAC,EAAEC,MAAM,EAAQ;IAC/C,MAAMC,aAA4B,CAAC;IAEnC,qDAAqD;IACrD,iBAAiB;IACjB,KAAK,MAAMC,aAAaF,OAAQ;QAC9B,IAAI,CAACC,UAAU,CAACC,UAAUC,QAAQ,CAAC,EAAE;YACnCF,UAAU,CAACC,UAAUC,QAAQ,CAAC,GAAG,CAAC;QACpC;QACA,IAAI,CAACF,UAAU,CAACC,UAAUC,QAAQ,CAAC,CAACD,UAAUE,MAAM,CAAC,EAAE;YACrDH,UAAU,CAACC,UAAUC,QAAQ,CAAC,CAACD,UAAUE,MAAM,CAAC,GAAG;gBACjDC,UAAUH,UAAUI,KAAK,KAAK;gBAC9BC,OAAOL,UAAUK,KAAK;gBACtBC,QAAQN,UAAUM,MAAM;gBACxBL,UAAUD,UAAUC,QAAQ;gBAC5BM,YAAY;YACd;QACF,OAAO;YACL,MAAMC,gBAAgBT,UAAU,CAACC,UAAUC,QAAQ,CAAC,CAACD,UAAUE,MAAM,CAAC;YACtEM,cAAcD,UAAU,IAAI;YAE5B,IAAIP,UAAUI,KAAK,KAAK,aAAa;gBACnCI,cAAcL,QAAQ,GAAG;gBACzB,8EAA8E;gBAC9E,+EAA+E;gBAC/EK,cAAcF,MAAM,GAAGN,UAAUM,MAAM;gBACvCE,cAAcH,KAAK,GAAGL,UAAUK,KAAK;gBACrCG,cAAcP,QAAQ,GAAGD,UAAUC,QAAQ;YAC7C;YACAF,UAAU,CAACC,UAAUC,QAAQ,CAAC,CAACD,UAAUE,MAAM,CAAC,GAAGM;QACrD;IACF;IAEA,OAAOT;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 6037, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6043, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/config/jobsCollection.ts"],"sourcesContent":["import type { CollectionConfig } from '../../collections/config/types.js'\nimport type { Config } from '../../config/types.js'\nimport type { Field } from '../../fields/config/types.js'\n\nimport { runJobsEndpoint } from '../restEndpointRun.js'\nimport { getJobTaskStatus } from '../utilities/getJobTaskStatus.js'\n\nexport const getDefaultJobsCollection: (config: Config) => CollectionConfig | null = (config) => {\n  if (!Array.isArray(config?.jobs?.workflows)) {\n    return null\n  }\n\n  const workflowSlugs: Set<string> = new Set()\n  const taskSlugs: Set<string> = new Set(['inline'])\n\n  if (config.jobs?.workflows.length) {\n    config.jobs?.workflows.forEach((workflow) => {\n      workflowSlugs.add(workflow.slug)\n    })\n  }\n\n  if (config.jobs?.tasks.length) {\n    config.jobs.tasks.forEach((task) => {\n      if (workflowSlugs.has(task.slug)) {\n        throw new Error(\n          `Task slug \"${task.slug}\" is already used by a workflow. No tasks are allowed to have the same slug as a workflow.`,\n        )\n      }\n      taskSlugs.add(task.slug)\n    })\n  }\n\n  const jobsCollection: CollectionConfig = {\n    slug: 'payload-jobs',\n    admin: {\n      group: 'System',\n      hidden: true,\n    },\n    endpoints: [runJobsEndpoint],\n    fields: [\n      {\n        name: 'input',\n        type: 'json',\n        admin: {\n          description: 'Input data provided to the job',\n        },\n      },\n      {\n        name: 'taskStatus',\n        type: 'json',\n        virtual: true,\n      },\n      {\n        type: 'tabs',\n        tabs: [\n          {\n            fields: [\n              {\n                name: 'completedAt',\n                type: 'date',\n                index: true,\n              },\n              {\n                name: 'totalTried',\n                type: 'number',\n                defaultValue: 0,\n                index: true,\n              },\n              {\n                name: 'hasError',\n                type: 'checkbox',\n                admin: {\n                  description: 'If hasError is true this job will not be retried',\n                },\n                defaultValue: false,\n                index: true,\n              },\n              {\n                name: 'error',\n                type: 'json',\n                admin: {\n                  condition: (data) => data.hasError,\n                  description: 'If hasError is true, this is the error that caused it',\n                },\n              },\n              {\n                name: 'log',\n                type: 'array',\n                admin: {\n                  description: 'Task execution log',\n                },\n                fields: [\n                  {\n                    name: 'executedAt',\n                    type: 'date',\n                    required: true,\n                  },\n                  {\n                    name: 'completedAt',\n                    type: 'date',\n                    required: true,\n                  },\n                  {\n                    name: 'taskSlug',\n                    type: 'select',\n                    options: [...taskSlugs],\n                    required: true,\n                  },\n                  {\n                    name: 'taskID',\n                    type: 'text',\n                    required: true,\n                  },\n                  {\n                    name: 'input',\n                    type: 'json',\n                  },\n                  {\n                    name: 'output',\n                    type: 'json',\n                  },\n                  {\n                    name: 'state',\n                    type: 'radio',\n                    options: ['failed', 'succeeded'],\n                    required: true,\n                  },\n                  {\n                    name: 'error',\n                    type: 'json',\n                    admin: {\n                      condition: (_, data) => data.state === 'failed',\n                    },\n                    required: true,\n                  },\n                ],\n              },\n            ],\n            label: 'Status',\n          },\n        ],\n      },\n      // only include the workflowSlugs field if workflows exist\n      ...((workflowSlugs.size > 0\n        ? [\n            {\n              name: 'workflowSlug',\n              type: 'select',\n              admin: {\n                position: 'sidebar',\n              },\n              index: true,\n              options: [...workflowSlugs],\n            },\n          ]\n        : []) as Field[]),\n      {\n        name: 'taskSlug',\n        type: 'select',\n        admin: {\n          position: 'sidebar',\n        },\n        index: true,\n        options: [...taskSlugs],\n        required: false,\n      },\n      {\n        name: 'queue',\n        type: 'text',\n        admin: {\n          position: 'sidebar',\n        },\n        defaultValue: 'default',\n        index: true,\n      },\n      {\n        name: 'waitUntil',\n        type: 'date',\n        index: true,\n      },\n      {\n        name: 'processing',\n        type: 'checkbox',\n        admin: {\n          position: 'sidebar',\n        },\n        defaultValue: false,\n        index: true,\n      },\n    ],\n    hooks: {\n      afterRead: [\n        ({ doc, req }) => {\n          // This hook is used to add the virtual `tasks` field to the document, that is computed from the `log` field\n\n          doc.taskStatus = getJobTaskStatus({\n            jobLog: doc.log,\n            tasksConfig: req.payload.config.jobs.tasks,\n          })\n\n          return doc\n        },\n      ],\n    },\n    lockDocuments: false,\n  }\n  return jobsCollection\n}\n"],"names":["runJobsEndpoint","getJobTaskStatus","getDefaultJobsCollection","config","Array","isArray","jobs","workflows","workflowSlugs","Set","taskSlugs","length","forEach","workflow","add","slug","tasks","task","has","Error","jobsCollection","admin","group","hidden","endpoints","fields","name","type","description","virtual","tabs","index","defaultValue","condition","data","hasError","required","options","_","state","label","size","position","hooks","afterRead","doc","req","taskStatus","jobLog","log","tasksConfig","payload","lockDocuments"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6254, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6260, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/config/generateJobsJSONSchemas.ts"],"sourcesContent":["import type { I18n } from '@payloadcms/translations'\nimport type { JSONSchema4 } from 'json-schema'\n\nimport type { SanitizedConfig } from '../../config/types.js'\nimport type { JobsConfig } from './types/index.js'\n\nimport { fieldsToJSONSchema } from '../../utilities/configToJSONSchema.js'\nimport { flattenAllFields } from '../../utilities/flattenAllFields.js'\nexport function generateJobsJSONSchemas(\n  config: SanitizedConfig,\n  jobsConfig: JobsConfig,\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  /**\n   * Used for relationship fields, to determine whether to use a string or number type for the ID.\n   * While there is a default ID field type set by the db adapter, they can differ on a collection-level\n   * if they have custom ID fields.\n   */\n  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },\n  i18n?: I18n,\n): {\n  definitions?: Map<string, JSONSchema4>\n  properties?: { tasks: JSONSchema4 }\n} {\n  const properties: { tasks: JSONSchema4; workflows: JSONSchema4 } = {\n    tasks: {},\n    workflows: {},\n  }\n  const definitions: Map<string, JSONSchema4> = new Map()\n\n  if (jobsConfig?.tasks?.length) {\n    for (const task of jobsConfig.tasks) {\n      const fullTaskJsonSchema: JSONSchema4 = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n          input: {},\n          output: {},\n        },\n        required: [],\n      }\n      if (task?.inputSchema?.length) {\n        const inputJsonSchema = fieldsToJSONSchema(\n          collectionIDFieldTypes,\n          flattenAllFields({ fields: task.inputSchema }),\n          interfaceNameDefinitions,\n          config,\n          i18n,\n        )\n\n        const fullInputJsonSchema: JSONSchema4 = {\n          type: 'object',\n          additionalProperties: false,\n          properties: inputJsonSchema.properties,\n          required: inputJsonSchema.required,\n        }\n\n        fullTaskJsonSchema.properties.input = fullInputJsonSchema\n        ;(fullTaskJsonSchema.required as string[]).push('input')\n      }\n      if (task?.outputSchema?.length) {\n        const outputJsonSchema = fieldsToJSONSchema(\n          collectionIDFieldTypes,\n          flattenAllFields({ fields: task.outputSchema }),\n          interfaceNameDefinitions,\n          config,\n          i18n,\n        )\n\n        const fullOutputJsonSchema: JSONSchema4 = {\n          type: 'object',\n          additionalProperties: false,\n          properties: outputJsonSchema.properties,\n          required: outputJsonSchema.required,\n        }\n\n        fullTaskJsonSchema.properties.output = fullOutputJsonSchema\n        ;(fullTaskJsonSchema.required as string[]).push('output')\n      }\n\n      const normalizedTaskSlug = task.slug[0].toUpperCase() + task.slug.slice(1)\n\n      definitions.set(task.interfaceName ?? `Task${normalizedTaskSlug}`, fullTaskJsonSchema)\n    }\n    // Now add properties.tasks definition that references the types in definitions keyed by task slug:\n    properties.tasks = {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        ...Object.fromEntries(\n          jobsConfig.tasks.map((task) => {\n            const normalizedTaskSlug = task.slug[0].toUpperCase() + task.slug.slice(1)\n\n            const toReturn: JSONSchema4 = {\n              $ref: task.interfaceName\n                ? `#/definitions/${task.interfaceName}`\n                : `#/definitions/Task${normalizedTaskSlug}`,\n            }\n\n            return [task.slug, toReturn]\n          }),\n        ),\n        inline: {\n          type: 'object',\n          additionalProperties: false,\n          properties: {\n            input: {},\n            output: {},\n          },\n          required: ['input', 'output'],\n        },\n      },\n      required: [...jobsConfig.tasks.map((task) => task.slug), 'inline'],\n    }\n  }\n\n  if (jobsConfig?.workflows?.length) {\n    for (const workflow of jobsConfig.workflows) {\n      const fullWorkflowJsonSchema: JSONSchema4 = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n          input: {},\n        },\n        required: [],\n      }\n\n      if (workflow?.inputSchema?.length) {\n        const inputJsonSchema = fieldsToJSONSchema(\n          collectionIDFieldTypes,\n          flattenAllFields({ fields: workflow.inputSchema }),\n          interfaceNameDefinitions,\n          config,\n          i18n,\n        )\n\n        const fullInputJsonSchema: JSONSchema4 = {\n          type: 'object',\n          additionalProperties: false,\n          properties: inputJsonSchema.properties,\n          required: inputJsonSchema.required,\n        }\n\n        fullWorkflowJsonSchema.properties.input = fullInputJsonSchema\n        ;(fullWorkflowJsonSchema.required as string[]).push('input')\n      }\n      const normalizedWorkflowSlug = workflow.slug[0].toUpperCase() + workflow.slug.slice(1)\n\n      definitions.set(\n        workflow.interfaceName ?? `Workflow${normalizedWorkflowSlug}`,\n        fullWorkflowJsonSchema,\n      )\n\n      properties.workflows = {\n        type: 'object',\n        additionalProperties: false,\n        properties: Object.fromEntries(\n          jobsConfig.workflows.map((workflow) => {\n            const normalizedWorkflowSlug = workflow.slug[0].toUpperCase() + workflow.slug.slice(1)\n\n            const toReturn: JSONSchema4 = {\n              $ref: workflow.interfaceName\n                ? `#/definitions/${workflow.interfaceName}`\n                : `#/definitions/Workflow${normalizedWorkflowSlug}`,\n            }\n\n            return [workflow.slug, toReturn]\n          }),\n        ),\n        required: jobsConfig.workflows.map((workflow) => workflow.slug),\n      }\n    }\n  }\n\n  return {\n    definitions,\n    properties,\n  }\n}\n"],"names":["fieldsToJSONSchema","flattenAllFields","generateJobsJSONSchemas","config","jobsConfig","interfaceNameDefinitions","collectionIDFieldTypes","i18n","properties","tasks","workflows","definitions","Map","length","task","fullTaskJsonSchema","type","additionalProperties","input","output","required","inputSchema","inputJsonSchema","fields","fullInputJsonSchema","push","outputSchema","outputJsonSchema","fullOutputJsonSchema","normalizedTaskSlug","slug","toUpperCase","slice","set","interfaceName","Object","fromEntries","map","toReturn","$ref","inline","workflow","fullWorkflowJsonSchema","normalizedWorkflowSlug"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6398, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6404, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/queues/localAPI.ts"],"sourcesContent":["import type { BaseJob, RunningJobFromTask } from './config/types/workflowTypes.js'\n\nimport {\n  createLocalReq,\n  type Payload,\n  type PayloadRequest,\n  type RunningJob,\n  type TypedJobs,\n  type Where,\n} from '../index.js'\nimport { runJobs } from './operations/runJobs/index.js'\n\nexport const getJobsLocalAPI = (payload: Payload) => ({\n  queue: async <\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] | keyof TypedJobs['workflows'],\n  >(\n    args:\n      | {\n          input: TypedJobs['tasks'][TTaskOrWorkflowSlug]['input']\n          queue?: string\n          req?: PayloadRequest\n          // TTaskOrWorkflowlug with keyof TypedJobs['workflows'] removed:\n          task: TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] ? TTaskOrWorkflowSlug : never\n          waitUntil?: Date\n          workflow?: never\n        }\n      | {\n          input: TypedJobs['workflows'][TTaskOrWorkflowSlug]['input']\n          queue?: string\n          req?: PayloadRequest\n          task?: never\n          waitUntil?: Date\n          workflow: TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n            ? TTaskOrWorkflowSlug\n            : never\n        },\n  ): Promise<\n    TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n      ? RunningJob<TTaskOrWorkflowSlug>\n      : RunningJobFromTask<TTaskOrWorkflowSlug>\n  > => {\n    let queue: string\n\n    // If user specifies queue, use that\n    if (args.queue) {\n      queue = args.queue\n    } else if (args.workflow) {\n      // Otherwise, if there is a workflow specified, and it has a default queue to use,\n      // use that\n      const workflow = payload.config.jobs?.workflows?.find(({ slug }) => slug === args.workflow)\n      if (workflow?.queue) {\n        queue = workflow.queue\n      }\n    }\n\n    return (await payload.create({\n      collection: 'payload-jobs',\n      data: {\n        input: args.input,\n        queue,\n        taskSlug: 'task' in args ? args.task : undefined,\n        waitUntil: args.waitUntil?.toISOString() ?? undefined,\n        workflowSlug: 'workflow' in args ? args.workflow : undefined,\n      } as BaseJob,\n      req: args.req,\n    })) as TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n      ? RunningJob<TTaskOrWorkflowSlug>\n      : RunningJobFromTask<TTaskOrWorkflowSlug> // Type assertion is still needed here\n  },\n\n  run: async (args?: {\n    limit?: number\n    overrideAccess?: boolean\n    queue?: string\n    req?: PayloadRequest\n    where?: Where\n  }): Promise<ReturnType<typeof runJobs>> => {\n    const newReq: PayloadRequest = args?.req ?? (await createLocalReq({}, payload))\n    const result = await runJobs({\n      limit: args?.limit,\n      overrideAccess: args?.overrideAccess !== false,\n      queue: args?.queue,\n      req: newReq,\n      where: args?.where,\n    })\n    return result\n  },\n\n  runByID: async (args: {\n    id: number | string\n    overrideAccess?: boolean\n    req?: PayloadRequest\n  }): Promise<ReturnType<typeof runJobs>> => {\n    const newReq: PayloadRequest = args?.req ?? (await createLocalReq({}, payload))\n    const result = await runJobs({\n      id: args.id,\n      overrideAccess: args?.overrideAccess !== false,\n      req: newReq,\n    })\n    return result\n  },\n})\n"],"names":["createLocalReq","runJobs","getJobsLocalAPI","payload","queue","args","workflow","config","jobs","workflows","find","slug","create","collection","data","input","taskSlug","task","undefined","waitUntil","toISOString","workflowSlug","req","run","newReq","result","limit","overrideAccess","where","runByID","id"],"mappings":";;;AAEA,SACEA,cAAc,QAMT,cAAa;AACpB,SAASC,OAAO,QAAQ,gCAA+B;;;AAEhD,MAAMC,kBAAkB,CAACC,UAAsB,CAAA;QACpDC,OAAO,OAILC;YAyBA,IAAID;YAEJ,oCAAoC;YACpC,IAAIC,KAAKD,KAAK,EAAE;gBACdA,QAAQC,KAAKD,KAAK;YACpB,OAAO,IAAIC,KAAKC,QAAQ,EAAE;gBACxB,kFAAkF;gBAClF,WAAW;gBACX,MAAMA,WAAWH,QAAQI,MAAM,CAACC,IAAI,EAAEC,WAAWC,KAAK,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASN,KAAKC,QAAQ;gBAC1F,IAAIA,UAAUF,OAAO;oBACnBA,QAAQE,SAASF,KAAK;gBACxB;YACF;YAEA,OAAQ,MAAMD,QAAQS,MAAM,CAAC;gBAC3BC,YAAY;gBACZC,MAAM;oBACJC,OAAOV,KAAKU,KAAK;oBACjBX;oBACAY,UAAU,UAAUX,OAAOA,KAAKY,IAAI,GAAGC;oBACvCC,WAAWd,KAAKc,SAAS,EAAEC,iBAAiBF;oBAC5CG,cAAc,cAAchB,OAAOA,KAAKC,QAAQ,GAAGY;gBACrD;gBACAI,KAAKjB,KAAKiB,GAAG;YACf;QAE4C,sCAAsC;QACpF;QAEAC,KAAK,OAAOlB;YAOV,MAAMmB,SAAyBnB,MAAMiB,OAAQ,MAAMtB,0YAAAA,EAAe,CAAC,GAAGG;YACtE,MAAMsB,SAAS,4YAAMxB,UAAAA,EAAQ;gBAC3ByB,OAAOrB,MAAMqB;gBACbC,gBAAgBtB,MAAMsB,mBAAmB;gBACzCvB,OAAOC,MAAMD;gBACbkB,KAAKE;gBACLI,OAAOvB,MAAMuB;YACf;YACA,OAAOH;QACT;QAEAI,SAAS,OAAOxB;YAKd,MAAMmB,SAAyBnB,MAAMiB,OAAQ,MAAMtB,0YAAAA,EAAe,CAAC,GAAGG;YACtE,MAAMsB,SAAS,4YAAMxB,UAAAA,EAAQ;gBAC3B6B,IAAIzB,KAAKyB,EAAE;gBACXH,gBAAgBtB,MAAMsB,mBAAmB;gBACzCL,KAAKE;YACP;YACA,OAAOC;QACT;IACF,CAAA,EAAE","ignoreList":[0]}},
    {"offset": {"line": 6459, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6465, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/lockedDocuments/lockedDocumentsCollection.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Config } from '../config/types.js'\n\nexport const getLockedDocumentsCollection = (config: Config): CollectionConfig => ({\n  slug: 'payload-locked-documents',\n  admin: {\n    hidden: true,\n  },\n  fields: [\n    {\n      name: 'document',\n      type: 'relationship',\n      index: true,\n      maxDepth: 0,\n      relationTo: [...config.collections.map((collectionConfig) => collectionConfig.slug)],\n    },\n    {\n      name: 'globalSlug',\n      type: 'text',\n      index: true,\n    },\n    {\n      name: 'user',\n      type: 'relationship',\n      maxDepth: 1,\n      relationTo: config.collections\n        .filter((collectionConfig) => collectionConfig.auth)\n        .map((collectionConfig) => collectionConfig.slug),\n      required: true,\n    },\n  ],\n  lockDocuments: false,\n})\n"],"names":["getLockedDocumentsCollection","config","slug","admin","hidden","fields","name","type","index","maxDepth","relationTo","collections","map","collectionConfig","filter","auth","required","lockDocuments"],"mappings":";;;AAGO,MAAMA,+BAA+B,CAACC,SAAsC,CAAA;QACjFC,MAAM;QACNC,OAAO;YACLC,QAAQ;QACV;QACAC,QAAQ;YACN;gBACEC,MAAM;gBACNC,MAAM;gBACNC,OAAO;gBACPC,UAAU;gBACVC,YAAY;uBAAIT,OAAOU,WAAW,CAACC,GAAG,CAAC,CAACC,mBAAqBA,iBAAiBX,IAAI;iBAAE;YACtF;YACA;gBACEI,MAAM;gBACNC,MAAM;gBACNC,OAAO;YACT;YACA;gBACEF,MAAM;gBACNC,MAAM;gBACNE,UAAU;gBACVC,YAAYT,OAAOU,WAAW,CAC3BG,MAAM,CAAC,CAACD,mBAAqBA,iBAAiBE,IAAI,EAClDH,GAAG,CAAC,CAACC,mBAAqBA,iBAAiBX,IAAI;gBAClDc,UAAU;YACZ;SACD;QACDC,eAAe;IACjB,CAAA,EAAE","ignoreList":[0]}},
    {"offset": {"line": 6498, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6504, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/preferences/operations/findOne.ts"],"sourcesContent":["import type { TypedCollection } from '../../index.js'\nimport type { Where } from '../../types/index.js'\nimport type { PreferenceRequest } from '../types.js'\n\nexport async function findOne(args: PreferenceRequest): Promise<TypedCollection['_preference']> {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n  } = args\n\n  if (!user) {\n    return null\n  }\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const { docs } = await payload.db.find({\n    collection: 'payload-preferences',\n    limit: 1,\n    pagination: false,\n    req,\n    sort: '-updatedAt',\n    where,\n  })\n\n  return docs?.[0] || null\n}\n"],"names":["findOne","args","key","req","payload","user","where","and","equals","id","collection","docs","db","find","limit","pagination","sort"],"mappings":";;;AAIO,eAAeA,QAAQC,IAAuB;IACnD,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACL,GAAGJ;IAEJ,IAAI,CAACI,MAAM;QACT,OAAO;IACT;IAEA,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAEL,KAAK;oBAAEM,QAAQN;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAEM,QAAQH,KAAKI,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQH,KAAKK,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAM,EAAEC,IAAI,EAAE,GAAG,MAAMP,QAAQQ,EAAE,CAACC,IAAI,CAAC;QACrCH,YAAY;QACZI,OAAO;QACPC,YAAY;QACZZ;QACAa,MAAM;QACNV;IACF;IAEA,OAAOK,MAAM,CAAC,EAAE,IAAI;AACtB","ignoreList":[0]}},
    {"offset": {"line": 6541, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6547, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/preferences/requestHandlers/findOne.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { findOne } from '../operations/findOne.js'\n\nexport const findByIDHandler: PayloadHandler = async (incomingReq): Promise<Response> => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json()\n  } catch (error) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const result = await findOne({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData.user,\n  })\n\n  return Response.json(\n    {\n      ...(result\n        ? result\n        : {\n            message: reqWithData.t('general:notFound'),\n            value: null,\n          }),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["httpStatus","findOne","findByIDHandler","incomingReq","data","json","error","reqWithData","Promise","resolve","result","key","routeParams","req","user","Response","message","t","value","status","OK"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAKpC,SAASC,OAAO,QAAQ,2BAA0B;;;AAE3C,MAAMC,kBAAkC,OAAOC;IACpD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,OAAO;QACdF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,SAAS,OAAMT,2YAAAA,EAAQ;QAC3BU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,YAAYO,IAAI;IACxB;IAEA,OAAOC,SAASV,IAAI,CAClB;QACE,GAAIK,SACAA,SACA;YACEM,SAAST,YAAYU,CAAC,CAAC;YACvBC,OAAO;QACT,CAAC;IACP,GACA;QACEC,kNAAQnB,UAAAA,CAAWoB,EAAE;IACvB;AAEJ,EAAC","ignoreList":[0]}},
    {"offset": {"line": 6582, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6588, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/preferences/operations/delete.ts"],"sourcesContent":["import type { Document, Where } from '../../types/index.js'\nimport type { PreferenceRequest } from '../types.js'\n\nimport { NotFound } from '../../errors/NotFound.js'\nimport { UnauthorizedError } from '../../errors/UnathorizedError.js'\n\nexport async function deleteOperation(args: PreferenceRequest): Promise<Document> {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n  } = args\n\n  if (!user) {\n    throw new UnauthorizedError(req.t)\n  }\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const result = await payload.db.deleteOne({\n    collection: 'payload-preferences',\n    req,\n    where,\n  })\n\n  if (result) {\n    return result\n  }\n  throw new NotFound(req.t)\n}\n"],"names":["NotFound","UnauthorizedError","deleteOperation","args","key","req","payload","user","t","where","and","equals","id","collection","result","db","deleteOne"],"mappings":";;;AAIA,SAASC,iBAAiB,QAAQ,mCAAkC;AADpE,SAASD,QAAQ,QAAQ,2BAA0B;;;AAG5C,eAAeE,gBAAgBC,IAAuB;IAC3D,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACL,GAAGJ;IAEJ,IAAI,CAACI,MAAM;QACT,MAAM,wXAAIN,oBAAAA,CAAkBI,IAAIG,CAAC;IACnC;IAEA,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAEN,KAAK;oBAAEO,QAAQP;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAEO,QAAQJ,KAAKK,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQJ,KAAKM,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAMC,SAAS,MAAMR,QAAQS,EAAE,CAACC,SAAS,CAAC;QACxCH,YAAY;QACZR;QACAI;IACF;IAEA,IAAIK,QAAQ;QACV,OAAOA;IACT;IACA,MAAM,gXAAId,WAAAA,CAASK,IAAIG,CAAC;AAC1B","ignoreList":[0]}},
    {"offset": {"line": 6629, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6635, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/preferences/requestHandlers/delete.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { deleteOperation } from '../operations/delete.js'\n\nexport const deleteHandler: PayloadHandler = async (incomingReq): Promise<Response> => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json()\n  } catch (error) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const result = await deleteOperation({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData.user,\n  })\n\n  return Response.json(\n    {\n      ...result,\n      message: reqWithData.t('general:deletedSuccessfully'),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["httpStatus","deleteOperation","deleteHandler","incomingReq","data","json","error","reqWithData","Promise","resolve","result","key","routeParams","req","user","Response","message","t","status","OK"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAKpC,SAASC,eAAe,QAAQ,0BAAyB;;;AAElD,MAAMC,gBAAgC,OAAOC;IAClD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,OAAO;QACdF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,SAAS,MAAMT,mZAAAA,EAAgB;QACnCU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,YAAYO,IAAI;IACxB;IAEA,OAAOC,SAASV,IAAI,CAClB;QACE,GAAGK,MAAM;QACTM,SAAST,YAAYU,CAAC,CAAC;IACzB,GACA;QACEC,kNAAQlB,UAAAA,CAAWmB,EAAE;IACvB;AAEJ,EAAC","ignoreList":[0]}},
    {"offset": {"line": 6668, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6674, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/preferences/operations/update.ts"],"sourcesContent":["import type { Where } from '../../types/index.js'\nimport type { PreferenceUpdateRequest } from '../types.js'\n\nimport { UnauthorizedError } from '../../errors/UnathorizedError.js'\n\nexport async function update(args: PreferenceUpdateRequest) {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n    value,\n  } = args\n\n  if (!user) {\n    throw new UnauthorizedError(req.t)\n  }\n\n  const collection = 'payload-preferences'\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const preference = {\n    key,\n    user: {\n      relationTo: user.collection,\n      value: user.id,\n    },\n    value,\n  }\n\n  return await payload.db.upsert({\n    collection,\n    data: preference,\n    req,\n    where,\n  })\n}\n"],"names":["UnauthorizedError","update","args","key","req","payload","user","value","t","collection","where","and","equals","id","preference","relationTo","db","upsert","data"],"mappings":";;;AAGA,SAASA,iBAAiB,QAAQ,mCAAkC;;AAE7D,eAAeC,OAAOC,IAA6B;IACxD,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACJC,KAAK,EACN,GAAGL;IAEJ,IAAI,CAACI,MAAM;QACT,MAAM,wXAAIN,oBAAAA,CAAkBI,IAAII,CAAC;IACnC;IAEA,MAAMC,aAAa;IAEnB,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAER,KAAK;oBAAES,QAAQT;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAES,QAAQN,KAAKO,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQN,KAAKG,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAMK,aAAa;QACjBX;QACAG,MAAM;YACJS,YAAYT,KAAKG,UAAU;YAC3BF,OAAOD,KAAKO,EAAE;QAChB;QACAN;IACF;IAEA,OAAO,MAAMF,QAAQW,EAAE,CAACC,MAAM,CAAC;QAC7BR;QACAS,MAAMJ;QACNV;QACAM;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 6719, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6725, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/preferences/requestHandlers/update.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { update } from '../operations/update.js'\n\nexport const updateHandler: PayloadHandler = async (incomingReq) => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json()\n  } catch (error) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const doc = await update({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData?.user,\n    value: reqWithData.data.value || reqWithData.data,\n  })\n\n  return Response.json(\n    {\n      doc,\n      message: reqWithData.t('general:updatedSuccessfully'),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["httpStatus","update","updateHandler","incomingReq","data","json","error","reqWithData","Promise","resolve","doc","key","routeParams","req","user","value","Response","message","t","status","OK"],"mappings":";;;AAAA,OAAOA,gBAAgB,cAAa;AAKpC,SAASC,MAAM,QAAQ,0BAAyB;;;AAEzC,MAAMC,gBAAgC,OAAOC;IAClD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,OAAO;QACdF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,MAAM,OAAMT,yYAAAA,EAAO;QACvBU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,aAAaO;QACnBC,OAAOR,YAAYH,IAAI,CAACW,KAAK,IAAIR,YAAYH,IAAI;IACnD;IAEA,OAAOY,SAASX,IAAI,CAClB;QACEK;QACAO,SAASV,YAAYW,CAAC,CAAC;IACzB,GACA;QACEC,kNAAQnB,UAAAA,CAAWoB,EAAE;IACvB;AAEJ,EAAC","ignoreList":[0]}},
    {"offset": {"line": 6759, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6765, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/preferences/preferencesCollection.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Access, Config } from '../config/types.js'\n\nimport { deleteHandler } from './requestHandlers/delete.js'\nimport { findByIDHandler } from './requestHandlers/findOne.js'\nimport { updateHandler } from './requestHandlers/update.js'\n\nconst preferenceAccess: Access = ({ req }) => {\n  if (!req.user) return false\n\n  return {\n    'user.value': {\n      equals: req?.user?.id,\n    },\n  }\n}\n\nconst getPreferencesCollection = (config: Config): CollectionConfig => ({\n  slug: 'payload-preferences',\n  access: {\n    delete: preferenceAccess,\n    read: preferenceAccess,\n  },\n  admin: {\n    hidden: true,\n  },\n  endpoints: [\n    {\n      handler: findByIDHandler,\n      method: 'get',\n      path: '/:key',\n    },\n    {\n      handler: deleteHandler,\n      method: 'delete',\n      path: '/:key',\n    },\n    {\n      handler: updateHandler,\n      method: 'post',\n      path: '/:key',\n    },\n  ],\n  fields: [\n    {\n      name: 'user',\n      type: 'relationship',\n      hooks: {\n        beforeValidate: [\n          ({ req }) => {\n            if (!req?.user) {\n              return null\n            }\n            return {\n              relationTo: req?.user.collection,\n              value: req?.user.id,\n            }\n          },\n        ],\n      },\n      index: true,\n      relationTo: config.collections\n        .filter((collectionConfig) => collectionConfig.auth)\n        .map((collectionConfig) => collectionConfig.slug),\n      required: true,\n    },\n    {\n      name: 'key',\n      type: 'text',\n      index: true,\n    },\n    {\n      name: 'value',\n      type: 'json',\n    },\n  ],\n  lockDocuments: false,\n})\n\nexport default getPreferencesCollection\n"],"names":["deleteHandler","findByIDHandler","updateHandler","preferenceAccess","req","user","equals","id","getPreferencesCollection","config","slug","access","delete","read","admin","hidden","endpoints","handler","method","path","fields","name","type","hooks","beforeValidate","relationTo","collection","value","index","collections","filter","collectionConfig","auth","map","required","lockDocuments"],"mappings":";;;AAIA,SAASC,eAAe,QAAQ,+BAA8B;AAD9D,SAASD,aAAa,QAAQ,8BAA6B;AAE3D,SAASE,aAAa,QAAQ,8BAA6B;;;;AAE3D,MAAMC,mBAA2B,CAAC,EAAEC,GAAG,EAAE;IACvC,IAAI,CAACA,IAAIC,IAAI,EAAE,OAAO;IAEtB,OAAO;QACL,cAAc;YACZC,QAAQF,KAAKC,MAAME;QACrB;IACF;AACF;AAEA,MAAMC,2BAA2B,CAACC,SAAsC,CAAA;QACtEC,MAAM;QACNC,QAAQ;YACNC,QAAQT;YACRU,MAAMV;QACR;QACAW,OAAO;YACLC,QAAQ;QACV;QACAC,WAAW;YACT;gBACEC,4YAAShB,kBAAAA;gBACTiB,QAAQ;gBACRC,MAAM;YACR;YACA;gBACEF,2YAASjB,gBAAAA;gBACTkB,QAAQ;gBACRC,MAAM;YACR;YACA;gBACEF,2YAASf,gBAAAA;gBACTgB,QAAQ;gBACRC,MAAM;YACR;SACD;QACDC,QAAQ;YACN;gBACEC,MAAM;gBACNC,MAAM;gBACNC,OAAO;oBACLC,gBAAgB;wBACd,CAAC,EAAEpB,GAAG,EAAE;4BACN,IAAI,CAACA,KAAKC,MAAM;gCACd,OAAO;4BACT;4BACA,OAAO;gCACLoB,YAAYrB,KAAKC,KAAKqB;gCACtBC,OAAOvB,KAAKC,KAAKE;4BACnB;wBACF;qBACD;gBACH;gBACAqB,OAAO;gBACPH,YAAYhB,OAAOoB,WAAW,CAC3BC,MAAM,CAAC,CAACC,mBAAqBA,iBAAiBC,IAAI,EAClDC,GAAG,CAAC,CAACF,mBAAqBA,iBAAiBrB,IAAI;gBAClDwB,UAAU;YACZ;YACA;gBACEb,MAAM;gBACNC,MAAM;gBACNM,OAAO;YACT;YACA;gBACEP,MAAM;gBACNC,MAAM;YACR;SACD;QACDa,eAAe;IACjB,CAAA;uCAEe3B,yBAAwB","ignoreList":[0]}},
    {"offset": {"line": 6843, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6849, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/preferences/deleteUserPreferences.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  /**\n   * User IDs to delete\n   */\n  ids: (number | string)[]\n  payload: Payload\n  req: PayloadRequest\n}\nexport const deleteUserPreferences = async ({ collectionConfig, ids, payload, req }: Args) => {\n  if (collectionConfig.auth) {\n    await payload.db.deleteMany({\n      collection: 'payload-preferences',\n      req,\n      where: {\n        and: [\n          {\n            'user.value': { in: ids },\n          },\n          {\n            'user.relationTo': { equals: collectionConfig.slug },\n          },\n        ],\n      },\n    })\n  }\n  await payload.db.deleteMany({\n    collection: 'payload-preferences',\n    req,\n    where: {\n      key: { in: ids.map((id) => `collection-${collectionConfig.slug}-${id}`) },\n    },\n  })\n}\n"],"names":["deleteUserPreferences","collectionConfig","ids","payload","req","auth","db","deleteMany","collection","where","and","in","equals","slug","key","map","id"],"mappings":";;;AAaO,MAAMA,wBAAwB,OAAO,EAAEC,gBAAgB,EAAEC,GAAG,EAAEC,OAAO,EAAEC,GAAG,EAAQ;IACvF,IAAIH,iBAAiBI,IAAI,EAAE;QACzB,MAAMF,QAAQG,EAAE,CAACC,UAAU,CAAC;YAC1BC,YAAY;YACZJ;YACAK,OAAO;gBACLC,KAAK;oBACH;wBACE,cAAc;4BAAEC,IAAIT;wBAAI;oBAC1B;oBACA;wBACE,mBAAmB;4BAAEU,QAAQX,iBAAiBY,IAAI;wBAAC;oBACrD;iBACD;YACH;QACF;IACF;IACA,MAAMV,QAAQG,EAAE,CAACC,UAAU,CAAC;QAC1BC,YAAY;QACZJ;QACAK,OAAO;YACLK,KAAK;gBAAEH,IAAIT,IAAIa,GAAG,CAAC,CAACC,KAAO,CAAC,WAAW,EAAEf,iBAAiBY,IAAI,CAAC,CAAC,EAAEG,IAAI;YAAE;QAC1E;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 6883, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6889, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/duplicateDocument/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { FindOneArgs } from '../database/types.js'\nimport type { JsonObject, PayloadRequest } from '../types/index.js'\n\nimport executeAccess from '../auth/executeAccess.js'\nimport { hasWhereAccessResult } from '../auth/types.js'\nimport { combineQueries } from '../database/combineQueries.js'\nimport { Forbidden } from '../errors/Forbidden.js'\nimport { NotFound } from '../errors/NotFound.js'\nimport { afterRead } from '../fields/hooks/afterRead/index.js'\nimport { beforeDuplicate } from '../fields/hooks/beforeDuplicate/index.js'\nimport { getLatestCollectionVersion } from '../versions/getLatestCollectionVersion.js'\n\ntype GetDuplicateDocumentArgs = {\n  collectionConfig: SanitizedCollectionConfig\n  draftArg?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  req: PayloadRequest\n  shouldSaveDraft?: boolean\n}\nexport const getDuplicateDocumentData = async ({\n  id,\n  collectionConfig,\n  draftArg,\n  overrideAccess,\n  req,\n  shouldSaveDraft,\n}: GetDuplicateDocumentArgs): Promise<{\n  duplicatedFromDoc: JsonObject\n  duplicatedFromDocWithLocales: JsonObject\n}> => {\n  const { payload } = req\n  // /////////////////////////////////////\n  // Read Access\n  // /////////////////////////////////////\n\n  const accessResults = !overrideAccess\n    ? await executeAccess({ id, req }, collectionConfig.access.read)\n    : true\n  const hasWherePolicy = hasWhereAccessResult(accessResults)\n\n  // /////////////////////////////////////\n  // Retrieve document\n  // /////////////////////////////////////\n  const findOneArgs: FindOneArgs = {\n    collection: collectionConfig.slug,\n    locale: req.locale,\n    req,\n    where: combineQueries({ id: { equals: id } }, accessResults),\n  }\n\n  let duplicatedFromDocWithLocales = await getLatestCollectionVersion({\n    id,\n    config: collectionConfig,\n    payload,\n    query: findOneArgs,\n    req,\n  })\n\n  if (!duplicatedFromDocWithLocales && !hasWherePolicy) {\n    throw new NotFound(req.t)\n  }\n  if (!duplicatedFromDocWithLocales && hasWherePolicy) {\n    throw new Forbidden(req.t)\n  }\n\n  // remove the createdAt timestamp and rely on the db to set it\n  if ('createdAt' in duplicatedFromDocWithLocales) {\n    delete duplicatedFromDocWithLocales.createdAt\n  }\n  // remove the id and rely on the db to set it\n  if ('id' in duplicatedFromDocWithLocales) {\n    delete duplicatedFromDocWithLocales.id\n  }\n\n  duplicatedFromDocWithLocales = await beforeDuplicate({\n    id,\n    collection: collectionConfig,\n    context: req.context,\n    doc: duplicatedFromDocWithLocales,\n    overrideAccess,\n    req,\n  })\n\n  // for version enabled collections, override the current status with draft, unless draft is explicitly set to false\n  if (shouldSaveDraft) {\n    duplicatedFromDocWithLocales._status = 'draft'\n  }\n\n  const duplicatedFromDoc = await afterRead({\n    collection: collectionConfig,\n    context: req.context,\n    depth: 0,\n    doc: duplicatedFromDocWithLocales,\n    draft: draftArg,\n    fallbackLocale: null,\n    global: null,\n    locale: req.locale,\n    overrideAccess: true,\n    req,\n    showHiddenFields: true,\n  })\n\n  return { duplicatedFromDoc, duplicatedFromDocWithLocales }\n}\n"],"names":["executeAccess","hasWhereAccessResult","combineQueries","Forbidden","NotFound","afterRead","beforeDuplicate","getLatestCollectionVersion","getDuplicateDocumentData","id","collectionConfig","draftArg","overrideAccess","req","shouldSaveDraft","payload","accessResults","access","read","hasWherePolicy","findOneArgs","collection","slug","locale","where","equals","duplicatedFromDocWithLocales","config","query","t","createdAt","context","doc","_status","duplicatedFromDoc","depth","draft","fallbackLocale","global","showHiddenFields"],"mappings":";;;AAIA,OAAOA,mBAAmB,2BAA0B;AACpD,SAASC,oBAAoB,QAAQ,mBAAkB;AACvD,SAASC,cAAc,QAAQ,gCAA+B;AAK9D,SAASK,0BAA0B,QAAQ,4CAA2C;AAHtF,SAASH,QAAQ,QAAQ,wBAAuB;AADhD,SAASD,SAAS,QAAQ,yBAAwB;AAGlD,SAASG,eAAe,QAAQ,2CAA0C;AAD1E,SAASD,SAAS,QAAQ,qCAAoC;;;;;;;;;AAYvD,MAAMG,2BAA2B,OAAO,EAC7CC,EAAE,EACFC,gBAAgB,EAChBC,QAAQ,EACRC,cAAc,EACdC,GAAG,EACHC,eAAe,EACU;IAIzB,MAAM,EAAEC,OAAO,EAAE,GAAGF;IACpB,wCAAwC;IACxC,cAAc;IACd,wCAAwC;IAExC,MAAMG,gBAAgB,CAACJ,iBACnB,UAAMZ,yXAAAA,EAAc;QAAES;QAAII;IAAI,GAAGH,iBAAiBO,MAAM,CAACC,IAAI,IAC7D;IACJ,MAAMC,qBAAiBlB,8XAAAA,EAAqBe;IAE5C,wCAAwC;IACxC,oBAAoB;IACpB,wCAAwC;IACxC,MAAMI,cAA2B;QAC/BC,YAAYX,iBAAiBY,IAAI;QACjCC,QAAQV,IAAIU,MAAM;QAClBV;QACAW,+XAAOtB,iBAAAA,EAAe;YAAEO,IAAI;gBAAEgB,QAAQhB;YAAG;QAAE,GAAGO;IAChD;IAEA,IAAIU,+BAA+B,OAAMnB,gaAAAA,EAA2B;QAClEE;QACAkB,QAAQjB;QACRK;QACAa,OAAOR;QACPP;IACF;IAEA,IAAI,CAACa,gCAAgC,CAACP,gBAAgB;QACpD,MAAM,gXAAIf,WAAAA,CAASS,IAAIgB,CAAC;IAC1B;IACA,IAAI,CAACH,gCAAgCP,gBAAgB;QACnD,MAAM,iXAAIhB,YAAAA,CAAUU,IAAIgB,CAAC;IAC3B;IAEA,8DAA8D;IAC9D,IAAI,eAAeH,8BAA8B;QAC/C,OAAOA,6BAA6BI,SAAS;IAC/C;IACA,6CAA6C;IAC7C,IAAI,QAAQJ,8BAA8B;QACxC,OAAOA,6BAA6BjB,EAAE;IACxC;IAEAiB,+BAA+B,+YAAMpB,kBAAAA,EAAgB;QACnDG;QACAY,YAAYX;QACZqB,SAASlB,IAAIkB,OAAO;QACpBC,KAAKN;QACLd;QACAC;IACF;IAEA,mHAAmH;IACnH,IAAIC,iBAAiB;QACnBY,6BAA6BO,OAAO,GAAG;IACzC;IAEA,MAAMC,oBAAoB,yYAAM7B,YAAAA,EAAU;QACxCgB,YAAYX;QACZqB,SAASlB,IAAIkB,OAAO;QACpBI,OAAO;QACPH,KAAKN;QACLU,OAAOzB;QACP0B,gBAAgB;QAChBC,QAAQ;QACRf,QAAQV,IAAIU,MAAM;QAClBX,gBAAgB;QAChBC;QACA0B,kBAAkB;IACpB;IAEA,OAAO;QAAEL;QAAmBR;IAA6B;AAC3D,EAAC","ignoreList":[0]}},
    {"offset": {"line": 6982, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6988, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/checkPayloadDependencies.ts"],"sourcesContent":["import { checkDependencies } from './utilities/dependencies/dependencyChecker.js'\nimport { PAYLOAD_PACKAGE_LIST } from './versions/payloadPackageList.js'\n\nexport function checkPayloadDependencies() {\n  const dependencies = [...PAYLOAD_PACKAGE_LIST]\n\n  if (process.env.PAYLOAD_CI_DEPENDENCY_CHECKER !== 'true') {\n    dependencies.push('@payloadcms/plugin-sentry')\n  }\n\n  // First load. First check if there are mismatching dependency versions of payload packages\n  void checkDependencies({\n    dependencyGroups: [\n      {\n        name: 'payload',\n        dependencies,\n        targetVersionDependency: 'payload',\n      },\n    ],\n  })\n}\n"],"names":["checkDependencies","PAYLOAD_PACKAGE_LIST","checkPayloadDependencies","dependencies","process","env","PAYLOAD_CI_DEPENDENCY_CHECKER","push","dependencyGroups","name","targetVersionDependency"],"mappings":";;;AACA,SAASC,oBAAoB,QAAQ,mCAAkC;AADvE,SAASD,iBAAiB,QAAQ,gDAA+C;;;AAG1E,SAASE;IACd,MAAMC,eAAe;mYAAIF,uBAAAA;KAAqB;IAE9C,IAAIG,QAAQC,GAAG,CAACC,6BAA6B,KAAK,QAAQ;QACxDH,aAAaI,IAAI,CAAC;IACpB;IAEA,2FAA2F;IAC3F,iZAAKP,oBAAAA,EAAkB;QACrBQ,kBAAkB;YAChB;gBACEC,MAAM;gBACNN;gBACAO,yBAAyB;YAC3B;SACD;IACH;AACF","ignoreList":[0]}},
    {"offset": {"line": 7013, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7019, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/email/defaults.ts"],"sourcesContent":["import type { InitializedEmailAdapter } from './types.js'\n\nexport const emailDefaults: Pick<\n  InitializedEmailAdapter,\n  'defaultFromAddress' | 'defaultFromName'\n> = {\n  defaultFromAddress: 'info@payloadcms.com',\n  defaultFromName: 'Payload',\n}\n"],"names":["emailDefaults","defaultFromAddress","defaultFromName"],"mappings":";;;AAEO,MAAMA,gBAGT;IACFC,oBAAoB;IACpBC,iBAAiB;AACnB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 7026, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7032, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/email/getStringifiedToAddress.ts"],"sourcesContent":["import type { SendEmailOptions } from './types.js'\n\nexport const getStringifiedToAddress = (message: SendEmailOptions): string | undefined => {\n  let stringifiedTo: string | undefined\n\n  if (typeof message.to === 'string') {\n    stringifiedTo = message.to\n  } else if (Array.isArray(message.to)) {\n    stringifiedTo = message.to\n      .map((to) => {\n        if (typeof to === 'string') {\n          return to\n        } else if (to.address) {\n          return to.address\n        }\n        return ''\n      })\n      .join(', ')\n  } else if (message.to.address) {\n    stringifiedTo = message.to.address\n  }\n  return stringifiedTo\n}\n"],"names":["getStringifiedToAddress","message","stringifiedTo","to","Array","isArray","map","address","join"],"mappings":";;;AAEO,MAAMA,0BAA0B,CAACC;IACtC,IAAIC;IAEJ,IAAI,OAAOD,QAAQE,EAAE,KAAK,UAAU;QAClCD,gBAAgBD,QAAQE,EAAE;IAC5B,OAAO,IAAIC,MAAMC,OAAO,CAACJ,QAAQE,EAAE,GAAG;QACpCD,gBAAgBD,QAAQE,EAAE,CACvBG,GAAG,CAAC,CAACH;YACJ,IAAI,OAAOA,OAAO,UAAU;gBAC1B,OAAOA;YACT,OAAO,IAAIA,GAAGI,OAAO,EAAE;gBACrB,OAAOJ,GAAGI,OAAO;YACnB;YACA,OAAO;QACT,GACCC,IAAI,CAAC;IACV,OAAO,IAAIP,QAAQE,EAAE,CAACI,OAAO,EAAE;QAC7BL,gBAAgBD,QAAQE,EAAE,CAACI,OAAO;IACpC;IACA,OAAOL;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 7053, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7059, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/email/consoleEmailAdapter.ts"],"sourcesContent":["import type { EmailAdapter } from './types.js'\n\nimport { emailDefaults } from './defaults.js'\nimport { getStringifiedToAddress } from './getStringifiedToAddress.js'\n\nexport const consoleEmailAdapter: EmailAdapter<void> = ({ payload }) => ({\n  name: 'console',\n  defaultFromAddress: emailDefaults.defaultFromAddress,\n  defaultFromName: emailDefaults.defaultFromName,\n  sendEmail: async (message) => {\n    const stringifiedTo = getStringifiedToAddress(message)\n    const res = `Email attempted without being configured. To: '${stringifiedTo}', Subject: '${message.subject}'`\n    payload.logger.info({ msg: res })\n    return Promise.resolve()\n  },\n})\n"],"names":["emailDefaults","getStringifiedToAddress","consoleEmailAdapter","payload","name","defaultFromAddress","defaultFromName","sendEmail","message","stringifiedTo","res","subject","logger","info","msg","Promise","resolve"],"mappings":";;;AAEA,SAASA,aAAa,QAAQ,gBAAe;AAC7C,SAASC,uBAAuB,QAAQ,+BAA8B;;;AAE/D,MAAMC,sBAA0C,CAAC,EAAEC,OAAO,EAAE,GAAM,CAAA;QACvEC,MAAM;QACNC,+XAAoBL,gBAAAA,CAAcK,kBAAkB;QACpDC,2XAAiBN,iBAAAA,CAAcM,eAAe;QAC9CC,WAAW,OAAOC;YAChB,MAAMC,8YAAgBR,0BAAAA,EAAwBO;YAC9C,MAAME,MAAM,CAAC,+CAA+C,EAAED,cAAc,aAAa,EAAED,QAAQG,OAAO,CAAC,CAAC,CAAC;YAC7GR,QAAQS,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAKJ;YAAI;YAC/B,OAAOK,QAAQC,OAAO;QACxB;IACF,CAAA,EAAE","ignoreList":[0]}},
    {"offset": {"line": 7079, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7085, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/index.ts"],"sourcesContent":["import type { ExecutionResult, GraphQLSchema, ValidationRule } from 'graphql'\nimport type { Request as graphQLRequest, OperationArgs } from 'graphql-http'\nimport type { Logger } from 'pino'\nimport type { NonNever } from 'ts-essentials'\n\nimport { spawn } from 'child_process'\nimport crypto from 'crypto'\nimport { fileURLToPath } from 'node:url'\nimport path from 'path'\nimport WebSocket from 'ws'\n\nimport type { AuthArgs } from './auth/operations/auth.js'\nimport type { Result as ForgotPasswordResult } from './auth/operations/forgotPassword.js'\nimport type { Options as ForgotPasswordOptions } from './auth/operations/local/forgotPassword.js'\nimport type { Options as LoginOptions } from './auth/operations/local/login.js'\nimport type { Options as ResetPasswordOptions } from './auth/operations/local/resetPassword.js'\nimport type { Options as UnlockOptions } from './auth/operations/local/unlock.js'\nimport type { Options as VerifyEmailOptions } from './auth/operations/local/verifyEmail.js'\nimport type { Result as LoginResult } from './auth/operations/login.js'\nimport type { Result as ResetPasswordResult } from './auth/operations/resetPassword.js'\nimport type { AuthStrategy, User } from './auth/types.js'\nimport type {\n  BulkOperationResult,\n  Collection,\n  DataFromCollectionSlug,\n  SelectFromCollectionSlug,\n  TypeWithID,\n} from './collections/config/types.js'\nimport type { Options as CountOptions } from './collections/operations/local/count.js'\nimport type { Options as CreateOptions } from './collections/operations/local/create.js'\nimport type {\n  ByIDOptions as DeleteByIDOptions,\n  ManyOptions as DeleteManyOptions,\n  Options as DeleteOptions,\n} from './collections/operations/local/delete.js'\nimport type { Options as DuplicateOptions } from './collections/operations/local/duplicate.js'\nimport type { Options as FindOptions } from './collections/operations/local/find.js'\nimport type { Options as FindByIDOptions } from './collections/operations/local/findByID.js'\nimport type { Options as FindVersionByIDOptions } from './collections/operations/local/findVersionByID.js'\nimport type { Options as FindVersionsOptions } from './collections/operations/local/findVersions.js'\nimport type { Options as RestoreVersionOptions } from './collections/operations/local/restoreVersion.js'\nimport type {\n  ByIDOptions as UpdateByIDOptions,\n  ManyOptions as UpdateManyOptions,\n  Options as UpdateOptions,\n} from './collections/operations/local/update.js'\nimport type { InitOptions, SanitizedConfig } from './config/types.js'\nimport type { BaseDatabaseAdapter, PaginatedDocs } from './database/types.js'\nimport type { InitializedEmailAdapter } from './email/types.js'\nimport type { DataFromGlobalSlug, Globals, SelectFromGlobalSlug } from './globals/config/types.js'\nimport type { CountGlobalVersionsOptions } from './globals/operations/local/countGlobalVersions.js'\nimport type { Options as FindGlobalOptions } from './globals/operations/local/findOne.js'\nimport type { Options as FindGlobalVersionByIDOptions } from './globals/operations/local/findVersionByID.js'\nimport type { Options as FindGlobalVersionsOptions } from './globals/operations/local/findVersions.js'\nimport type { Options as RestoreGlobalVersionOptions } from './globals/operations/local/restoreVersion.js'\nimport type { Options as UpdateGlobalOptions } from './globals/operations/local/update.js'\nimport type {\n  ApplyDisableErrors,\n  JsonObject,\n  SelectType,\n  TransformCollectionWithSelect,\n  TransformGlobalWithSelect,\n} from './types/index.js'\nimport type { TraverseFieldsCallback } from './utilities/traverseFields.js'\nimport type { TypeWithVersion } from './versions/types.js'\n\nimport { decrypt, encrypt } from './auth/crypto.js'\nimport { APIKeyAuthentication } from './auth/strategies/apiKey.js'\nimport { JWTAuthentication } from './auth/strategies/jwt.js'\nimport { generateImportMap, type ImportMap } from './bin/generateImportMap/index.js'\nimport { checkPayloadDependencies } from './checkPayloadDependencies.js'\nimport localOperations from './collections/operations/local/index.js'\nimport { consoleEmailAdapter } from './email/consoleEmailAdapter.js'\nimport { fieldAffectsData } from './fields/config/types.js'\nimport localGlobalOperations from './globals/operations/local/index.js'\nimport { getJobsLocalAPI } from './queues/localAPI.js'\nimport { getLogger } from './utilities/logger.js'\nimport { serverInit as serverInitTelemetry } from './utilities/telemetry/events/serverInit.js'\nimport { traverseFields } from './utilities/traverseFields.js'\n\nexport type { FieldState } from './admin/forms/Form.js'\nexport type * from './admin/types.js'\n\nexport interface GeneratedTypes {\n  authUntyped: {\n    [slug: string]: {\n      forgotPassword: {\n        email: string\n      }\n      login: {\n        email: string\n        password: string\n      }\n      registerFirstUser: {\n        email: string\n        password: string\n      }\n      unlock: {\n        email: string\n      }\n    }\n  }\n\n  collectionsJoinsUntyped: {\n    [slug: string]: {\n      [schemaPath: string]: CollectionSlug\n    }\n  }\n  collectionsSelectUntyped: {\n    [slug: string]: SelectType\n  }\n\n  collectionsUntyped: {\n    [slug: string]: JsonObject & TypeWithID\n  }\n  dbUntyped: {\n    defaultIDType: number | string\n  }\n  globalsSelectUntyped: {\n    [slug: string]: SelectType\n  }\n\n  globalsUntyped: {\n    [slug: string]: JsonObject\n  }\n  jobsUntyped: {\n    tasks: {\n      [slug: string]: {\n        input?: JsonObject\n        output?: JsonObject\n      }\n    }\n    workflows: {\n      [slug: string]: {\n        input: JsonObject\n      }\n    }\n  }\n  localeUntyped: null | string\n  userUntyped: User\n}\n\n// Helper type to resolve the correct type using conditional types\ntype ResolveCollectionType<T> = 'collections' extends keyof T\n  ? T['collections']\n  : // @ts-expect-error\n    T['collectionsUntyped']\n\ntype ResolveCollectionSelectType<T> = 'collectionsSelect' extends keyof T\n  ? T['collectionsSelect']\n  : // @ts-expect-error\n    T['collectionsSelectUntyped']\n\ntype ResolveCollectionJoinsType<T> = 'collectionsJoins' extends keyof T\n  ? T['collectionsJoins']\n  : // @ts-expect-error\n    T['collectionsJoinsUntyped']\n\ntype ResolveGlobalType<T> = 'globals' extends keyof T\n  ? T['globals']\n  : // @ts-expect-error\n    T['globalsUntyped']\n\ntype ResolveGlobalSelectType<T> = 'globalsSelect' extends keyof T\n  ? T['globalsSelect']\n  : // @ts-expect-error\n    T['globalsSelectUntyped']\n\n// Applying helper types to GeneratedTypes\nexport type TypedCollection = ResolveCollectionType<GeneratedTypes>\n\nexport type TypedUploadCollection = NonNever<{\n  [K in keyof TypedCollection]:\n    | 'filename'\n    | 'filesize'\n    | 'mimeType'\n    | 'url' extends keyof TypedCollection[K]\n    ? TypedCollection[K]\n    : never\n}>\n\nexport type TypedCollectionSelect = ResolveCollectionSelectType<GeneratedTypes>\n\nexport type TypedCollectionJoins = ResolveCollectionJoinsType<GeneratedTypes>\n\nexport type TypedGlobal = ResolveGlobalType<GeneratedTypes>\n\nexport type TypedGlobalSelect = ResolveGlobalSelectType<GeneratedTypes>\n\n// Extract string keys from the type\nexport type StringKeyOf<T> = Extract<keyof T, string>\n\n// Define the types for slugs using the appropriate collections and globals\nexport type CollectionSlug = StringKeyOf<TypedCollection>\n\nexport type UploadCollectionSlug = StringKeyOf<TypedUploadCollection>\n\ntype ResolveDbType<T> = 'db' extends keyof T\n  ? T['db']\n  : // @ts-expect-error\n    T['dbUntyped']\n\nexport type DefaultDocumentIDType = ResolveDbType<GeneratedTypes>['defaultIDType']\nexport type GlobalSlug = StringKeyOf<TypedGlobal>\n\n// now for locale and user\n\n// @ts-expect-error\ntype ResolveLocaleType<T> = 'locale' extends keyof T ? T['locale'] : T['localeUntyped']\n// @ts-expect-error\ntype ResolveUserType<T> = 'user' extends keyof T ? T['user'] : T['userUntyped']\n\nexport type TypedLocale = ResolveLocaleType<GeneratedTypes>\nexport type TypedUser = ResolveUserType<GeneratedTypes>\n\n// @ts-expect-error\ntype ResolveAuthOperationsType<T> = 'auth' extends keyof T ? T['auth'] : T['authUntyped']\nexport type TypedAuthOperations = ResolveAuthOperationsType<GeneratedTypes>\n\n// @ts-expect-error\ntype ResolveJobOperationsType<T> = 'jobs' extends keyof T ? T['jobs'] : T['jobsUntyped']\nexport type TypedJobs = ResolveJobOperationsType<GeneratedTypes>\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nlet checkedDependencies = false\n\n/**\n * @description Payload\n */\nexport class BasePayload {\n  /**\n   * @description Authorization and Authentication using headers and cookies to run auth user strategies\n   * @returns permissions: Permissions\n   * @returns user: User\n   */\n  auth = async (options: AuthArgs) => {\n    const { auth } = localOperations.auth\n    return auth(this, options)\n  }\n\n  authStrategies: AuthStrategy[]\n\n  collections: Record<CollectionSlug, Collection> = {}\n\n  config: SanitizedConfig\n  /**\n   * @description Performs count operation\n   * @param options\n   * @returns count of documents satisfying query\n   */\n  count = async <T extends CollectionSlug>(\n    options: CountOptions<T>,\n  ): Promise<{ totalDocs: number }> => {\n    const { count } = localOperations\n    return count(this, options)\n  }\n\n  /**\n   * @description Performs countGlobalVersions operation\n   * @param options\n   * @returns count of global document versions satisfying query\n   */\n  countGlobalVersions = async <T extends GlobalSlug>(\n    options: CountGlobalVersionsOptions<T>,\n  ): Promise<{ totalDocs: number }> => {\n    const { countGlobalVersions } = localGlobalOperations\n    return countGlobalVersions(this, options)\n  }\n\n  /**\n   * @description Performs countVersions operation\n   * @param options\n   * @returns count of document versions satisfying query\n   */\n  countVersions = async <T extends CollectionSlug>(\n    options: CountOptions<T>,\n  ): Promise<{ totalDocs: number }> => {\n    const { countVersions } = localOperations\n    return countVersions(this, options)\n  }\n\n  /**\n   * @description Performs create operation\n   * @param options\n   * @returns created document\n   */\n  create = async <TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: CreateOptions<TSlug, TSelect>,\n  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {\n    const { create } = localOperations\n    return create<TSlug, TSelect>(this, options)\n  }\n\n  db: DatabaseAdapter\n  decrypt = decrypt\n\n  duplicate = async <TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: DuplicateOptions<TSlug, TSelect>,\n  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {\n    const { duplicate } = localOperations\n    return duplicate<TSlug, TSelect>(this, options)\n  }\n\n  email: InitializedEmailAdapter\n\n  encrypt = encrypt\n\n  // TODO: re-implement or remove?\n  // errorHandler: ErrorHandler\n\n  extensions: (args: {\n    args: OperationArgs<any>\n    req: graphQLRequest<unknown, unknown>\n    result: ExecutionResult\n  }) => Promise<any>\n\n  /**\n   * @description Find documents with criteria\n   * @param options\n   * @returns documents satisfying query\n   */\n  find = async <TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: FindOptions<TSlug, TSelect>,\n  ): Promise<PaginatedDocs<TransformCollectionWithSelect<TSlug, TSelect>>> => {\n    const { find } = localOperations\n    return find<TSlug, TSelect>(this, options)\n  }\n\n  /**\n   * @description Find document by ID\n   * @param options\n   * @returns document with specified ID\n   */\n  findByID = async <\n    TSlug extends CollectionSlug,\n    TDisableErrors extends boolean,\n    TSelect extends SelectFromCollectionSlug<TSlug>,\n  >(\n    options: FindByIDOptions<TSlug, TDisableErrors, TSelect>,\n  ): Promise<ApplyDisableErrors<TransformCollectionWithSelect<TSlug, TSelect>, TDisableErrors>> => {\n    const { findByID } = localOperations\n    return findByID<TSlug, TDisableErrors, TSelect>(this, options)\n  }\n\n  findGlobal = async <TSlug extends GlobalSlug, TSelect extends SelectFromGlobalSlug<TSlug>>(\n    options: FindGlobalOptions<TSlug, TSelect>,\n  ): Promise<TransformGlobalWithSelect<TSlug, TSelect>> => {\n    const { findOne } = localGlobalOperations\n    return findOne<TSlug, TSelect>(this, options)\n  }\n\n  /**\n   * @description Find global version by ID\n   * @param options\n   * @returns global version with specified ID\n   */\n  findGlobalVersionByID = async <TSlug extends GlobalSlug>(\n    options: FindGlobalVersionByIDOptions<TSlug>,\n  ): Promise<TypeWithVersion<DataFromGlobalSlug<TSlug>>> => {\n    const { findVersionByID } = localGlobalOperations\n    return findVersionByID<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find global versions with criteria\n   * @param options\n   * @returns versions satisfying query\n   */\n  findGlobalVersions = async <TSlug extends GlobalSlug>(\n    options: FindGlobalVersionsOptions<TSlug>,\n  ): Promise<PaginatedDocs<TypeWithVersion<DataFromGlobalSlug<TSlug>>>> => {\n    const { findVersions } = localGlobalOperations\n    return findVersions<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find version by ID\n   * @param options\n   * @returns version with specified ID\n   */\n  findVersionByID = async <TSlug extends CollectionSlug>(\n    options: FindVersionByIDOptions<TSlug>,\n  ): Promise<TypeWithVersion<DataFromCollectionSlug<TSlug>>> => {\n    const { findVersionByID } = localOperations\n    return findVersionByID<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find versions with criteria\n   * @param options\n   * @returns versions satisfying query\n   */\n  findVersions = async <TSlug extends CollectionSlug>(\n    options: FindVersionsOptions<TSlug>,\n  ): Promise<PaginatedDocs<TypeWithVersion<DataFromCollectionSlug<TSlug>>>> => {\n    const { findVersions } = localOperations\n    return findVersions<TSlug>(this, options)\n  }\n\n  forgotPassword = async <TSlug extends CollectionSlug>(\n    options: ForgotPasswordOptions<TSlug>,\n  ): Promise<ForgotPasswordResult> => {\n    const { forgotPassword } = localOperations.auth\n    return forgotPassword<TSlug>(this, options)\n  }\n\n  getAdminURL = (): string => `${this.config.serverURL}${this.config.routes.admin}`\n\n  getAPIURL = (): string => `${this.config.serverURL}${this.config.routes.api}`\n\n  globals: Globals\n\n  importMap: ImportMap\n\n  jobs = getJobsLocalAPI(this)\n\n  logger: Logger\n\n  login = async <TSlug extends CollectionSlug>(\n    options: LoginOptions<TSlug>,\n  ): Promise<{ user: DataFromCollectionSlug<TSlug> } & LoginResult> => {\n    const { login } = localOperations.auth\n    return login<TSlug>(this, options)\n  }\n\n  resetPassword = async <TSlug extends CollectionSlug>(\n    options: ResetPasswordOptions<TSlug>,\n  ): Promise<ResetPasswordResult> => {\n    const { resetPassword } = localOperations.auth\n    return resetPassword<TSlug>(this, options)\n  }\n\n  /**\n   * @description Restore global version by ID\n   * @param options\n   * @returns version with specified ID\n   */\n  restoreGlobalVersion = async <TSlug extends GlobalSlug>(\n    options: RestoreGlobalVersionOptions<TSlug>,\n  ): Promise<DataFromGlobalSlug<TSlug>> => {\n    const { restoreVersion } = localGlobalOperations\n    return restoreVersion<TSlug>(this, options)\n  }\n\n  /**\n   * @description Restore version by ID\n   * @param options\n   * @returns version with specified ID\n   */\n  restoreVersion = async <TSlug extends CollectionSlug>(\n    options: RestoreVersionOptions<TSlug>,\n  ): Promise<DataFromCollectionSlug<TSlug>> => {\n    const { restoreVersion } = localOperations\n    return restoreVersion<TSlug>(this, options)\n  }\n\n  schema: GraphQLSchema\n\n  secret: string\n\n  sendEmail: InitializedEmailAdapter['sendEmail']\n\n  types: {\n    arrayTypes: any\n    blockInputTypes: any\n    blockTypes: any\n    fallbackLocaleInputType?: any\n    groupTypes: any\n    localeInputType?: any\n    tabTypes: any\n  }\n\n  unlock = async <TSlug extends CollectionSlug>(\n    options: UnlockOptions<TSlug>,\n  ): Promise<boolean> => {\n    const { unlock } = localOperations.auth\n    return unlock<TSlug>(this, options)\n  }\n\n  updateGlobal = async <TSlug extends GlobalSlug, TSelect extends SelectFromGlobalSlug<TSlug>>(\n    options: UpdateGlobalOptions<TSlug, TSelect>,\n  ): Promise<TransformGlobalWithSelect<TSlug, TSelect>> => {\n    const { update } = localGlobalOperations\n    return update<TSlug, TSelect>(this, options)\n  }\n\n  validationRules: (args: OperationArgs<any>) => ValidationRule[]\n\n  verifyEmail = async <TSlug extends CollectionSlug>(\n    options: VerifyEmailOptions<TSlug>,\n  ): Promise<boolean> => {\n    const { verifyEmail } = localOperations.auth\n    return verifyEmail(this, options)\n  }\n\n  versions: {\n    [slug: string]: any // TODO: Type this\n  } = {}\n\n  async bin({\n    args,\n    cwd,\n    log,\n  }: {\n    args: string[]\n    cwd?: string\n    log?: boolean\n  }): Promise<{ code: number }> {\n    return new Promise((resolve, reject) => {\n      const spawned = spawn('node', [path.resolve(dirname, '../bin.js'), ...args], {\n        cwd,\n        stdio: log || log === undefined ? 'inherit' : 'ignore',\n      })\n\n      spawned.on('exit', (code) => {\n        resolve({ code })\n      })\n\n      spawned.on('error', (error) => {\n        reject(error)\n      })\n    })\n  }\n\n  /**\n   * @description delete one or more documents\n   * @param options\n   * @returns Updated document(s)\n   */\n  delete<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: DeleteByIDOptions<TSlug, TSelect>,\n  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>>\n\n  delete<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: DeleteManyOptions<TSlug, TSelect>,\n  ): Promise<BulkOperationResult<TSlug, TSelect>>\n\n  delete<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: DeleteOptions<TSlug, TSelect>,\n  ): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {\n    const { deleteLocal } = localOperations\n    return deleteLocal<TSlug, TSelect>(this, options)\n  }\n\n  /**\n   * @description Initializes Payload\n   * @param options\n   */\n  async init(options: InitOptions): Promise<Payload> {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      process.env.PAYLOAD_DISABLE_DEPENDENCY_CHECKER !== 'true' &&\n      !checkedDependencies\n    ) {\n      checkedDependencies = true\n      void checkPayloadDependencies()\n    }\n\n    this.importMap = options.importMap\n\n    if (!options?.config) {\n      throw new Error('Error: the payload config is required to initialize payload.')\n    }\n\n    this.config = await options.config\n    this.logger = getLogger('payload', this.config.logger)\n\n    if (!this.config.secret) {\n      throw new Error('Error: missing secret key. A secret key is needed to secure Payload.')\n    }\n\n    this.secret = crypto.createHash('sha256').update(this.config.secret).digest('hex').slice(0, 32)\n\n    this.globals = {\n      config: this.config.globals,\n    }\n\n    this.config.collections.forEach((collection) => {\n      let customIDType = undefined\n      const findCustomID: TraverseFieldsCallback = ({ field, next }) => {\n        if (\n          ['array', 'blocks', 'group'].includes(field.type) ||\n          (field.type === 'tab' && 'name' in field)\n        ) {\n          return true\n        }\n\n        if (!fieldAffectsData(field)) {\n          return\n        }\n\n        if (field.name === 'id') {\n          customIDType = field.type\n          return true\n        }\n      }\n\n      traverseFields({ callback: findCustomID, fields: collection.fields })\n\n      this.collections[collection.slug] = {\n        config: collection,\n        customIDType,\n      }\n    })\n\n    // Generate types on startup\n    if (process.env.NODE_ENV !== 'production' && this.config.typescript.autoGenerate !== false) {\n      // We cannot run it directly here, as generate-types imports json-schema-to-typescript, which breaks on turbopack.\n      // see: https://github.com/vercel/next.js/issues/66723\n      void this.bin({\n        args: ['generate:types'],\n        log: false,\n      })\n    }\n\n    this.db = this.config.db.init({ payload: this })\n    this.db.payload = this\n\n    if (this.db?.init) {\n      await this.db.init()\n    }\n\n    if (!options.disableDBConnect && this.db.connect) {\n      await this.db.connect()\n    }\n\n    // Load email adapter\n    if (this.config.email instanceof Promise) {\n      const awaitedAdapter = await this.config.email\n      this.email = awaitedAdapter({ payload: this })\n    } else if (this.config.email) {\n      this.email = this.config.email({ payload: this })\n    } else {\n      if (process.env.NEXT_PHASE !== 'phase-production-build') {\n        this.logger.warn(\n          `No email adapter provided. Email will be written to console. More info at https://payloadcms.com/docs/email/overview.`,\n        )\n      }\n\n      this.email = consoleEmailAdapter({ payload: this })\n    }\n\n    // Warn if image resizing is enabled but sharp is not installed\n    if (\n      !this.config.sharp &&\n      this.config.collections.some((c) => c.upload.imageSizes || c.upload.formatOptions)\n    ) {\n      this.logger.warn(\n        `Image resizing is enabled for one or more collections, but sharp not installed. Please install 'sharp' and pass into the config.`,\n      )\n    }\n\n    this.sendEmail = this.email['sendEmail']\n\n    serverInitTelemetry(this)\n\n    // 1. loop over collections, if collection has auth strategy, initialize and push to array\n    let jwtStrategyEnabled = false\n    this.authStrategies = this.config.collections.reduce((authStrategies, collection) => {\n      if (collection?.auth) {\n        if (collection.auth.strategies.length > 0) {\n          authStrategies.push(...collection.auth.strategies)\n        }\n\n        // 2. if api key enabled, push api key strategy into the array\n        if (collection.auth?.useAPIKey) {\n          authStrategies.push({\n            name: `${collection.slug}-api-key`,\n            authenticate: APIKeyAuthentication(collection),\n          })\n        }\n\n        // 3. if localStrategy flag is true\n        if (!collection.auth.disableLocalStrategy && !jwtStrategyEnabled) {\n          jwtStrategyEnabled = true\n        }\n      }\n\n      return authStrategies\n    }, [] as AuthStrategy[])\n\n    // 4. if enabled, push jwt strategy into authStrategies last\n    if (jwtStrategyEnabled) {\n      this.authStrategies.push({\n        name: 'local-jwt',\n        authenticate: JWTAuthentication,\n      })\n    }\n\n    if (!options.disableOnInit) {\n      if (typeof options.onInit === 'function') {\n        await options.onInit(this)\n      }\n      if (typeof this.config.onInit === 'function') {\n        await this.config.onInit(this)\n      }\n    }\n\n    return this\n  }\n\n  update<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: UpdateManyOptions<TSlug, TSelect>,\n  ): Promise<BulkOperationResult<TSlug, TSelect>>\n\n  /**\n   * @description Update one or more documents\n   * @param options\n   * @returns Updated document(s)\n   */\n  update<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: UpdateByIDOptions<TSlug, TSelect>,\n  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>>\n\n  update<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: UpdateOptions<TSlug, TSelect>,\n  ): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {\n    const { update } = localOperations\n    return update<TSlug, TSelect>(this, options)\n  }\n}\n\nconst initialized = new BasePayload()\n\nexport default initialized\n\nlet cached: {\n  payload: null | Payload\n  promise: null | Promise<Payload>\n  reload: boolean | Promise<void>\n  ws: null | WebSocket\n} = global._payload\n\nif (!cached) {\n  cached = global._payload = { payload: null, promise: null, reload: false, ws: null }\n}\n\nexport const reload = async (\n  config: SanitizedConfig,\n  payload: Payload,\n  skipImportMapGeneration?: boolean,\n): Promise<void> => {\n  if (typeof payload.db.destroy === 'function') {\n    await payload.db.destroy()\n  }\n\n  payload.config = config\n\n  payload.collections = config.collections.reduce((collections, collection) => {\n    collections[collection.slug] = {\n      config: collection,\n      customIDType: payload.collections[collection.slug]?.customIDType,\n    }\n    return collections\n  }, {})\n\n  payload.globals = {\n    config: config.globals,\n  }\n\n  // TODO: support HMR for other props in the future (see payload/src/index init()) that may change on Payload singleton\n\n  // Generate types\n  if (config.typescript.autoGenerate !== false) {\n    // We cannot run it directly here, as generate-types imports json-schema-to-typescript, which breaks on turbopack.\n    // see: https://github.com/vercel/next.js/issues/66723\n    void payload.bin({\n      args: ['generate:types'],\n      log: false,\n    })\n  }\n\n  // Generate component map\n  if (skipImportMapGeneration !== true && config.admin?.importMap?.autoGenerate !== false) {\n    await generateImportMap(config, {\n      log: true,\n    })\n  }\n\n  await payload.db.init()\n  if (payload.db.connect) {\n    await payload.db.connect({ hotReload: true })\n  }\n  global._payload_clientConfig = null\n  global._payload_schemaMap = null\n  global._payload_clientSchemaMap = null\n  global._payload_doNotCacheClientConfig = true // This will help refreshing the client config cache more reliably. If you remove this, please test HMR + client config refreshing (do new fields appear in the document?)\n  global._payload_doNotCacheSchemaMap = true\n  global._payload_doNotCacheClientSchemaMap = true\n}\n\nexport const getPayload = async (\n  options: Pick<InitOptions, 'config' | 'importMap'>,\n): Promise<Payload> => {\n  if (!options?.config) {\n    throw new Error('Error: the payload config is required for getPayload to work.')\n  }\n\n  if (cached.payload) {\n    if (cached.reload === true) {\n      let resolve: () => void\n\n      // getPayload is called multiple times, in parallel. However, we only want to run `await reload` once. By immediately setting cached.reload to a promise,\n      // we can ensure that all subsequent calls will wait for the first reload to finish. So if we set it here, the 2nd call of getPayload\n      // will reach `if (cached.reload instanceof Promise) {` which then waits for the first reload to finish.\n      cached.reload = new Promise((res) => (resolve = res))\n      const config = await options.config\n      await reload(config, cached.payload, !options.importMap)\n\n      resolve()\n    }\n\n    if (cached.reload instanceof Promise) {\n      await cached.reload\n    }\n    if (options?.importMap) {\n      cached.payload.importMap = options.importMap\n    }\n    return cached.payload\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  if (!cached.promise) {\n    // no need to await options.config here, as it's already awaited in the BasePayload.init\n    cached.promise = new BasePayload().init(options)\n  }\n\n  try {\n    cached.payload = await cached.promise\n\n    if (\n      !cached.ws &&\n      process.env.NODE_ENV !== 'production' &&\n      process.env.NODE_ENV !== 'test' &&\n      process.env.DISABLE_PAYLOAD_HMR !== 'true'\n    ) {\n      try {\n        const port = process.env.PORT || '3000'\n\n        cached.ws = new WebSocket(\n          `ws://localhost:${port}${process.env.NEXT_BASE_PATH ?? ''}/_next/webpack-hmr`,\n        )\n\n        cached.ws.onmessage = (event) => {\n          if (typeof event.data === 'string') {\n            const data = JSON.parse(event.data)\n\n            if ('action' in data && data.action === 'serverComponentChanges') {\n              cached.reload = true\n            }\n          }\n        }\n\n        cached.ws.onerror = (_) => {\n          // swallow any websocket connection error\n        }\n      } catch (_) {\n        // swallow e\n      }\n    }\n  } catch (e) {\n    cached.promise = null\n    throw e\n  }\n\n  if (options?.importMap) {\n    cached.payload.importMap = options.importMap\n  }\n\n  return cached.payload\n}\n\ntype Payload = BasePayload\n\ninterface RequestContext {\n  [key: string]: unknown\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface DatabaseAdapter extends BaseDatabaseAdapter {}\nexport type { Payload, RequestContext }\nexport { default as executeAccess } from './auth/executeAccess.js'\nexport { executeAuthStrategies } from './auth/executeAuthStrategies.js'\nexport { getAccessResults } from './auth/getAccessResults.js'\nexport { getFieldsToSign } from './auth/getFieldsToSign.js'\nexport * from './auth/index.js'\nexport { accessOperation } from './auth/operations/access.js'\nexport { forgotPasswordOperation } from './auth/operations/forgotPassword.js'\nexport { initOperation } from './auth/operations/init.js'\nexport { loginOperation } from './auth/operations/login.js'\nexport { logoutOperation } from './auth/operations/logout.js'\nexport type { MeOperationResult } from './auth/operations/me.js'\nexport { meOperation } from './auth/operations/me.js'\nexport { refreshOperation } from './auth/operations/refresh.js'\nexport { registerFirstUserOperation } from './auth/operations/registerFirstUser.js'\nexport { resetPasswordOperation } from './auth/operations/resetPassword.js'\nexport { unlockOperation } from './auth/operations/unlock.js'\nexport { verifyEmailOperation } from './auth/operations/verifyEmail.js'\n\nexport type {\n  AuthStrategyFunction,\n  AuthStrategyFunctionArgs,\n  CollectionPermission,\n  DocumentPermissions,\n  FieldPermissions,\n  GlobalPermission,\n  IncomingAuthType,\n  Permission,\n  Permissions,\n  SanitizedCollectionPermission,\n  SanitizedDocumentPermissions,\n  SanitizedFieldPermissions,\n  SanitizedGlobalPermission,\n  SanitizedPermissions,\n  User,\n  VerifyConfig,\n} from './auth/types.js'\n\nexport { generateImportMap } from './bin/generateImportMap/index.js'\nexport type { ImportMap } from './bin/generateImportMap/index.js'\n\nexport { genImportMapIterateFields } from './bin/generateImportMap/iterateFields.js'\n\nexport {\n  type ClientCollectionConfig,\n  createClientCollectionConfig,\n  createClientCollectionConfigs,\n  type ServerOnlyCollectionAdminProperties,\n  type ServerOnlyCollectionProperties,\n  type ServerOnlyUploadProperties,\n} from './collections/config/client.js'\n\nexport type {\n  AfterChangeHook as CollectionAfterChangeHook,\n  AfterDeleteHook as CollectionAfterDeleteHook,\n  AfterErrorHook as CollectionAfterErrorHook,\n  AfterForgotPasswordHook as CollectionAfterForgotPasswordHook,\n  AfterLoginHook as CollectionAfterLoginHook,\n  AfterLogoutHook as CollectionAfterLogoutHook,\n  AfterMeHook as CollectionAfterMeHook,\n  AfterOperationHook as CollectionAfterOperationHook,\n  AfterReadHook as CollectionAfterReadHook,\n  AfterRefreshHook as CollectionAfterRefreshHook,\n  AuthCollection,\n  AuthOperationsFromCollectionSlug,\n  BaseListFilter,\n  BeforeChangeHook as CollectionBeforeChangeHook,\n  BeforeDeleteHook as CollectionBeforeDeleteHook,\n  BeforeLoginHook as CollectionBeforeLoginHook,\n  BeforeOperationHook as CollectionBeforeOperationHook,\n  BeforeReadHook as CollectionBeforeReadHook,\n  BeforeValidateHook as CollectionBeforeValidateHook,\n  BulkOperationResult,\n  Collection,\n  CollectionAdminOptions,\n  CollectionConfig,\n  DataFromCollectionSlug,\n  HookOperationType,\n  MeHook as CollectionMeHook,\n  RefreshHook as CollectionRefreshHook,\n  RequiredDataFromCollection,\n  RequiredDataFromCollectionSlug,\n  SanitizedCollectionConfig,\n  SanitizedJoins,\n  TypeWithID,\n  TypeWithTimestamps,\n} from './collections/config/types.js'\nexport { createDataloaderCacheKey, getDataLoader } from './collections/dataloader.js'\nexport { countOperation } from './collections/operations/count.js'\nexport { createOperation } from './collections/operations/create.js'\nexport { deleteOperation } from './collections/operations/delete.js'\nexport { deleteByIDOperation } from './collections/operations/deleteByID.js'\nexport { docAccessOperation } from './collections/operations/docAccess.js'\nexport { duplicateOperation } from './collections/operations/duplicate.js'\nexport { findOperation } from './collections/operations/find.js'\nexport { findByIDOperation } from './collections/operations/findByID.js'\nexport { findVersionByIDOperation } from './collections/operations/findVersionByID.js'\nexport { findVersionsOperation } from './collections/operations/findVersions.js'\nexport { restoreVersionOperation } from './collections/operations/restoreVersion.js'\nexport { updateOperation } from './collections/operations/update.js'\nexport { updateByIDOperation } from './collections/operations/updateByID.js'\nexport { buildConfig } from './config/build.js'\nexport {\n  type ClientConfig,\n  createClientConfig,\n  serverOnlyAdminConfigProperties,\n  serverOnlyConfigProperties,\n} from './config/client.js'\n\nexport { defaults } from './config/defaults.js'\nexport { sanitizeConfig } from './config/sanitize.js'\nexport type * from './config/types.js'\nexport { combineQueries } from './database/combineQueries.js'\nexport { createDatabaseAdapter } from './database/createDatabaseAdapter.js'\nexport { defaultBeginTransaction } from './database/defaultBeginTransaction.js'\nexport { default as flattenWhereToOperators } from './database/flattenWhereToOperators.js'\nexport { getLocalizedPaths } from './database/getLocalizedPaths.js'\nexport { createMigration } from './database/migrations/createMigration.js'\nexport { getMigrations } from './database/migrations/getMigrations.js'\nexport { getPredefinedMigration } from './database/migrations/getPredefinedMigration.js'\nexport { migrate } from './database/migrations/migrate.js'\nexport { migrateDown } from './database/migrations/migrateDown.js'\nexport { migrateRefresh } from './database/migrations/migrateRefresh.js'\nexport { migrateReset } from './database/migrations/migrateReset.js'\nexport { migrateStatus } from './database/migrations/migrateStatus.js'\nexport { migrationsCollection } from './database/migrations/migrationsCollection.js'\nexport { migrationTemplate } from './database/migrations/migrationTemplate.js'\nexport { readMigrationFiles } from './database/migrations/readMigrationFiles.js'\nexport { writeMigrationIndex } from './database/migrations/writeMigrationIndex.js'\nexport type * from './database/queryValidation/types.js'\nexport type { EntityPolicies, PathToQuery } from './database/queryValidation/types.js'\nexport { validateQueryPaths } from './database/queryValidation/validateQueryPaths.js'\nexport { validateSearchParam } from './database/queryValidation/validateSearchParams.js'\nexport type {\n  BaseDatabaseAdapter,\n  BeginTransaction,\n  CommitTransaction,\n  Connect,\n  Count,\n  CountArgs,\n  CountGlobalVersions,\n  CountVersions,\n  Create,\n  CreateArgs,\n  CreateGlobal,\n  CreateGlobalArgs,\n  CreateGlobalVersion,\n  CreateGlobalVersionArgs,\n  CreateMigration,\n  CreateVersion,\n  CreateVersionArgs,\n  DatabaseAdapterResult as DatabaseAdapterObj,\n  DBIdentifierName,\n  DeleteMany,\n  DeleteManyArgs,\n  DeleteOne,\n  DeleteOneArgs,\n  DeleteVersions,\n  DeleteVersionsArgs,\n  Destroy,\n  Find,\n  FindArgs,\n  FindGlobal,\n  FindGlobalArgs,\n  FindGlobalVersions,\n  FindGlobalVersionsArgs,\n  FindOne,\n  FindOneArgs,\n  FindVersions,\n  FindVersionsArgs,\n  GenerateSchema,\n  Init,\n  Migration,\n  MigrationData,\n  MigrationTemplateArgs,\n  PaginatedDocs,\n  QueryDrafts,\n  QueryDraftsArgs,\n  RollbackTransaction,\n  Transaction,\n  UpdateGlobal,\n  UpdateGlobalArgs,\n  UpdateGlobalVersion,\n  UpdateGlobalVersionArgs,\n  UpdateOne,\n  UpdateOneArgs,\n  UpdateVersion,\n  UpdateVersionArgs,\n  Upsert,\n} from './database/types.js'\nexport type { EmailAdapter as PayloadEmailAdapter, SendEmailOptions } from './email/types.js'\nexport {\n  APIError,\n  APIErrorName,\n  AuthenticationError,\n  DuplicateCollection,\n  DuplicateFieldName,\n  DuplicateGlobal,\n  ErrorDeletingFile,\n  FileRetrievalError,\n  FileUploadError,\n  Forbidden,\n  InvalidConfiguration,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  Locked,\n  LockedAuth,\n  MissingCollectionLabel,\n  MissingEditorProp,\n  MissingFieldInputOptions,\n  MissingFieldType,\n  MissingFile,\n  NotFound,\n  QueryError,\n  ValidationError,\n  ValidationErrorName,\n} from './errors/index.js'\nexport type { ValidationFieldError } from './errors/index.js'\n\nexport { baseBlockFields } from './fields/baseFields/baseBlockFields.js'\nexport { baseIDField } from './fields/baseFields/baseIDField.js'\nexport {\n  createClientField,\n  createClientFields,\n  type ServerOnlyFieldAdminProperties,\n  type ServerOnlyFieldProperties,\n} from './fields/config/client.js'\nexport { sanitizeFields } from './fields/config/sanitize.js'\nexport type {\n  AdminClient,\n  ArrayField,\n  ArrayFieldClient,\n  BaseValidateOptions,\n  Block,\n  BlockJSX,\n  BlocksField,\n  BlocksFieldClient,\n  CheckboxField,\n  CheckboxFieldClient,\n  ClientBlock,\n  ClientField,\n  ClientFieldProps,\n  CodeField,\n  CodeFieldClient,\n  CollapsibleField,\n  CollapsibleFieldClient,\n  Condition,\n  DateField,\n  DateFieldClient,\n  EmailField,\n  EmailFieldClient,\n  Field,\n  FieldAccess,\n  FieldAffectingData,\n  FieldAffectingDataClient,\n  FieldBase,\n  FieldBaseClient,\n  FieldHook,\n  FieldHookArgs,\n  FieldPresentationalOnly,\n  FieldPresentationalOnlyClient,\n  FieldTypes,\n  FieldWithMany,\n  FieldWithManyClient,\n  FieldWithMaxDepth,\n  FieldWithMaxDepthClient,\n  FieldWithPath,\n  FieldWithPathClient,\n  FieldWithSubFields,\n  FieldWithSubFieldsClient,\n  FilterOptions,\n  FilterOptionsProps,\n  FlattenedArrayField,\n  FlattenedBlock,\n  FlattenedBlocksField,\n  FlattenedField,\n  FlattenedGroupField,\n  FlattenedTabAsField,\n  GroupField,\n  GroupFieldClient,\n  HookName,\n  JoinField,\n  JoinFieldClient,\n  JSONField,\n  JSONFieldClient,\n  Labels,\n  LabelsClient,\n  NamedTab,\n  NonPresentationalField,\n  NonPresentationalFieldClient,\n  NumberField,\n  NumberFieldClient,\n  Option,\n  OptionObject,\n  PointField,\n  PointFieldClient,\n  PolymorphicRelationshipField,\n  PolymorphicRelationshipFieldClient,\n  RadioField,\n  RadioFieldClient,\n  RelationshipField,\n  RelationshipFieldClient,\n  RelationshipValue,\n  RichTextField,\n  RichTextFieldClient,\n  RowField,\n  RowFieldClient,\n  SelectField,\n  SelectFieldClient,\n  SingleRelationshipField,\n  SingleRelationshipFieldClient,\n  Tab,\n  TabAsField,\n  TabAsFieldClient,\n  TabsField,\n  TabsFieldClient,\n  TextareaField,\n  TextareaFieldClient,\n  TextField,\n  TextFieldClient,\n  UIField,\n  UIFieldClient,\n  UnnamedTab,\n  UploadField,\n  UploadFieldClient,\n  Validate,\n  ValidateOptions,\n  ValueWithRelation,\n} from './fields/config/types.js'\n\nexport { getDefaultValue } from './fields/getDefaultValue.js'\nexport { traverseFields as afterChangeTraverseFields } from './fields/hooks/afterChange/traverseFields.js'\nexport { promise as afterReadPromise } from './fields/hooks/afterRead/promise.js'\nexport { traverseFields as afterReadTraverseFields } from './fields/hooks/afterRead/traverseFields.js'\nexport { traverseFields as beforeChangeTraverseFields } from './fields/hooks/beforeChange/traverseFields.js'\nexport { traverseFields as beforeValidateTraverseFields } from './fields/hooks/beforeValidate/traverseFields.js'\nexport { default as sortableFieldTypes } from './fields/sortableFieldTypes.js'\n\nexport { validations } from './fields/validations.js'\nexport type {\n  ArrayFieldValidation,\n  BlocksFieldValidation,\n  CheckboxFieldValidation,\n  CodeFieldValidation,\n  ConfirmPasswordFieldValidation,\n  DateFieldValidation,\n  EmailFieldValidation,\n  JSONFieldValidation,\n  NumberFieldManyValidation,\n  NumberFieldSingleValidation,\n  NumberFieldValidation,\n  PasswordFieldValidation,\n  PointFieldValidation,\n  RadioFieldValidation,\n  RelationshipFieldManyValidation,\n  RelationshipFieldSingleValidation,\n  RelationshipFieldValidation,\n  RichTextFieldValidation,\n  SelectFieldManyValidation,\n  SelectFieldSingleValidation,\n  SelectFieldValidation,\n  TextareaFieldValidation,\n  TextFieldManyValidation,\n  TextFieldSingleValidation,\n  TextFieldValidation,\n  UploadFieldManyValidation,\n  UploadFieldSingleValidation,\n  UploadFieldValidation,\n  UsernameFieldValidation,\n} from './fields/validations.js'\n\nexport {\n  type ClientGlobalConfig,\n  createClientGlobalConfig,\n  createClientGlobalConfigs,\n  type ServerOnlyGlobalAdminProperties,\n  type ServerOnlyGlobalProperties,\n} from './globals/config/client.js'\n\nexport type {\n  AfterChangeHook as GlobalAfterChangeHook,\n  AfterReadHook as GlobalAfterReadHook,\n  BeforeChangeHook as GlobalBeforeChangeHook,\n  BeforeReadHook as GlobalBeforeReadHook,\n  BeforeValidateHook as GlobalBeforeValidateHook,\n  DataFromGlobalSlug,\n  GlobalAdminOptions,\n  GlobalConfig,\n  SanitizedGlobalConfig,\n} from './globals/config/types.js'\n\nexport { docAccessOperation as docAccessOperationGlobal } from './globals/operations/docAccess.js'\nexport { findOneOperation } from './globals/operations/findOne.js'\nexport { findVersionByIDOperation as findVersionByIDOperationGlobal } from './globals/operations/findVersionByID.js'\nexport { findVersionsOperation as findVersionsOperationGlobal } from './globals/operations/findVersions.js'\nexport { restoreVersionOperation as restoreVersionOperationGlobal } from './globals/operations/restoreVersion.js'\nexport { updateOperation as updateOperationGlobal } from './globals/operations/update.js'\nexport type {\n  CollapsedPreferences,\n  DocumentPreferences,\n  FieldsPreferences,\n  InsideFieldsPreferences,\n  PreferenceRequest,\n  PreferenceUpdateRequest,\n  TabsPreferences,\n} from './preferences/types.js'\nexport type { JobsConfig, RunJobAccess, RunJobAccessArgs } from './queues/config/types/index.js'\nexport type {\n  RunTaskFunction,\n  TaskConfig,\n  TaskHandler,\n  TaskHandlerArgs,\n  TaskHandlerResult,\n  TaskHandlerResults,\n  TaskInput,\n  TaskOutput,\n  TaskType,\n} from './queues/config/types/taskTypes.js'\nexport type {\n  BaseJob,\n  JobLog,\n  JobTaskStatus,\n  RunningJob,\n  SingleTaskStatus,\n  WorkflowConfig,\n  WorkflowHandler,\n  WorkflowTypes,\n} from './queues/config/types/workflowTypes.js'\nexport { importHandlerPath } from './queues/operations/runJobs/runJob/importHandlerPath.js'\nexport { getLocalI18n } from './translations/getLocalI18n.js'\nexport * from './types/index.js'\nexport { getFileByPath } from './uploads/getFileByPath.js'\nexport type * from './uploads/types.js'\nexport { commitTransaction } from './utilities/commitTransaction.js'\nexport {\n  configToJSONSchema,\n  entityToJSONSchema,\n  fieldsToJSONSchema,\n  withNullableJSONSchemaType,\n} from './utilities/configToJSONSchema.js'\nexport { createArrayFromCommaDelineated } from './utilities/createArrayFromCommaDelineated.js'\nexport { createLocalReq } from './utilities/createLocalReq.js'\nexport {\n  deepCopyObject,\n  deepCopyObjectComplex,\n  deepCopyObjectSimple,\n} from './utilities/deepCopyObject.js'\nexport {\n  deepMerge,\n  deepMergeWithCombinedArrays,\n  deepMergeWithReactComponents,\n  deepMergeWithSourceArrays,\n} from './utilities/deepMerge.js'\nexport {\n  checkDependencies,\n  type CustomVersionParser,\n} from './utilities/dependencies/dependencyChecker.js'\nexport { getDependencies } from './utilities/dependencies/getDependencies.js'\nexport {\n  findUp,\n  findUpSync,\n  pathExistsAndIsAccessible,\n  pathExistsAndIsAccessibleSync,\n} from './utilities/findUp.js'\nexport { flattenAllFields } from './utilities/flattenAllFields.js'\nexport { default as flattenTopLevelFields } from './utilities/flattenTopLevelFields.js'\nexport { formatErrors } from './utilities/formatErrors.js'\nexport { formatLabels, formatNames, toWords } from './utilities/formatLabels.js'\nexport { getCollectionIDFieldTypes } from './utilities/getCollectionIDFieldTypes.js'\nexport { getObjectDotNotation } from './utilities/getObjectDotNotation.js'\nexport { initTransaction } from './utilities/initTransaction.js'\nexport { isEntityHidden } from './utilities/isEntityHidden.js'\nexport { default as isolateObjectProperty } from './utilities/isolateObjectProperty.js'\nexport { isPlainObject } from './utilities/isPlainObject.js'\nexport { isValidID } from './utilities/isValidID.js'\nexport { killTransaction } from './utilities/killTransaction.js'\nexport { mapAsync } from './utilities/mapAsync.js'\nexport { sanitizeFallbackLocale } from './utilities/sanitizeFallbackLocale.js'\nexport { sanitizeJoinParams } from './utilities/sanitizeJoinParams.js'\nexport { sanitizePopulateParam } from './utilities/sanitizePopulateParam.js'\nexport { sanitizeSelectParam } from './utilities/sanitizeSelectParam.js'\nexport { traverseFields } from './utilities/traverseFields.js'\nexport type { TraverseFieldsCallback } from './utilities/traverseFields.js'\nexport { buildVersionCollectionFields } from './versions/buildCollectionFields.js'\nexport { buildVersionGlobalFields } from './versions/buildGlobalFields.js'\nexport { versionDefaults } from './versions/defaults.js'\nexport { deleteCollectionVersions } from './versions/deleteCollectionVersions.js'\nexport { enforceMaxVersions } from './versions/enforceMaxVersions.js'\nexport { getLatestCollectionVersion } from './versions/getLatestCollectionVersion.js'\nexport { getLatestGlobalVersion } from './versions/getLatestGlobalVersion.js'\n\nexport { saveVersion } from './versions/saveVersion.js'\nexport type { TypeWithVersion } from './versions/types.js'\nexport { deepMergeSimple } from '@payloadcms/translations/utilities'\n"],"names":["spawn","crypto","fileURLToPath","path","WebSocket","decrypt","encrypt","APIKeyAuthentication","JWTAuthentication","generateImportMap","checkPayloadDependencies","localOperations","consoleEmailAdapter","fieldAffectsData","localGlobalOperations","getJobsLocalAPI","getLogger","serverInit","serverInitTelemetry","traverseFields","filename","url","dirname","checkedDependencies","BasePayload","auth","options","authStrategies","collections","config","count","countGlobalVersions","countVersions","create","db","duplicate","email","extensions","find","findByID","findGlobal","findOne","findGlobalVersionByID","findVersionByID","findGlobalVersions","findVersions","forgotPassword","getAdminURL","serverURL","routes","admin","getAPIURL","api","globals","importMap","jobs","logger","login","resetPassword","restoreGlobalVersion","restoreVersion","schema","secret","sendEmail","types","unlock","updateGlobal","update","validationRules","verifyEmail","versions","bin","args","cwd","log","Promise","resolve","reject","spawned","stdio","undefined","on","code","error","delete","deleteLocal","init","process","env","NODE_ENV","PAYLOAD_DISABLE_DEPENDENCY_CHECKER","Error","createHash","digest","slice","forEach","collection","customIDType","findCustomID","field","next","includes","type","name","callback","fields","slug","typescript","autoGenerate","payload","disableDBConnect","connect","awaitedAdapter","NEXT_PHASE","warn","sharp","some","c","upload","imageSizes","formatOptions","jwtStrategyEnabled","reduce","strategies","length","push","useAPIKey","authenticate","disableLocalStrategy","disableOnInit","onInit","initialized","cached","global","_payload","promise","reload","ws","skipImportMapGeneration","destroy","hotReload","_payload_clientConfig","_payload_schemaMap","_payload_clientSchemaMap","_payload_doNotCacheClientConfig","_payload_doNotCacheSchemaMap","_payload_doNotCacheClientSchemaMap","getPayload","res","DISABLE_PAYLOAD_HMR","port","PORT","NEXT_BASE_PATH","onmessage","event","data","JSON","parse","action","onerror","_","e","default","executeAccess","executeAuthStrategies","getAccessResults","getFieldsToSign","accessOperation","forgotPasswordOperation","initOperation","loginOperation","logoutOperation","meOperation","refreshOperation","registerFirstUserOperation","resetPasswordOperation","unlockOperation","verifyEmailOperation","genImportMapIterateFields","createClientCollectionConfig","createClientCollectionConfigs","createDataloaderCacheKey","getDataLoader","countOperation","createOperation","deleteOperation","deleteByIDOperation","docAccessOperation","duplicateOperation","findOperation","findByIDOperation","findVersionByIDOperation","findVersionsOperation","restoreVersionOperation","updateOperation","updateByIDOperation","buildConfig","createClientConfig","serverOnlyAdminConfigProperties","serverOnlyConfigProperties","defaults","sanitizeConfig","combineQueries","createDatabaseAdapter","defaultBeginTransaction","flattenWhereToOperators","getLocalizedPaths","createMigration","getMigrations","getPredefinedMigration","migrate","migrateDown","migrateRefresh","migrateReset","migrateStatus","migrationsCollection","migrationTemplate","readMigrationFiles","writeMigrationIndex","validateQueryPaths","validateSearchParam","APIError","APIErrorName","AuthenticationError","DuplicateCollection","DuplicateFieldName","DuplicateGlobal","ErrorDeletingFile","FileRetrievalError","FileUploadError","Forbidden","InvalidConfiguration","InvalidFieldName","InvalidFieldRelationship","Locked","LockedAuth","MissingCollectionLabel","MissingEditorProp","MissingFieldInputOptions","MissingFieldType","MissingFile","NotFound","QueryError","ValidationError","ValidationErrorName","baseBlockFields","baseIDField","createClientField","createClientFields","sanitizeFields","getDefaultValue","afterChangeTraverseFields","afterReadPromise","afterReadTraverseFields","beforeChangeTraverseFields","beforeValidateTraverseFields","sortableFieldTypes","validations","createClientGlobalConfig","createClientGlobalConfigs","docAccessOperationGlobal","findOneOperation","findVersionByIDOperationGlobal","findVersionsOperationGlobal","restoreVersionOperationGlobal","updateOperationGlobal","importHandlerPath","getLocalI18n","getFileByPath","commitTransaction","configToJSONSchema","entityToJSONSchema","fieldsToJSONSchema","withNullableJSONSchemaType","createArrayFromCommaDelineated","createLocalReq","deepCopyObject","deepCopyObjectComplex","deepCopyObjectSimple","deepMerge","deepMergeWithCombinedArrays","deepMergeWithReactComponents","deepMergeWithSourceArrays","checkDependencies","getDependencies","findUp","findUpSync","pathExistsAndIsAccessible","pathExistsAndIsAccessibleSync","flattenAllFields","flattenTopLevelFields","formatErrors","formatLabels","formatNames","toWords","getCollectionIDFieldTypes","getObjectDotNotation","initTransaction","isEntityHidden","isolateObjectProperty","isPlainObject","isValidID","killTransaction","mapAsync","sanitizeFallbackLocale","sanitizeJoinParams","sanitizePopulateParam","sanitizeSelectParam","buildVersionCollectionFields","buildVersionGlobalFields","versionDefaults","deleteCollectionVersions","enforceMaxVersions","getLatestCollectionVersion","getLatestGlobalVersion","saveVersion","deepMergeSimple"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7686, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}