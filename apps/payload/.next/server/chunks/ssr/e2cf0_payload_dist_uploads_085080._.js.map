{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fetchAPI-multipart/isEligibleRequest.ts"],"sourcesContent":["// eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/no-obscure-range\nconst ACCEPTABLE_CONTENT_TYPE = /multipart\\/['\"()+-_]+(?:; ?['\"()+-_]*)+$/i\nconst UNACCEPTABLE_METHODS = new Set(['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'TRACE'])\n\nconst hasBody = (req: Request): boolean => {\n  return Boolean(\n    req.headers.get('transfer-encoding') ||\n      (req.headers.get('content-length') && req.headers.get('content-length') !== '0'),\n  )\n}\n\nconst hasAcceptableMethod = (req: Request): boolean => !UNACCEPTABLE_METHODS.has(req.method)\n\nconst hasAcceptableContentType = (req: Request): boolean => {\n  const contType = req.headers.get('content-type')\n  return contType.includes('boundary=') && ACCEPTABLE_CONTENT_TYPE.test(contType)\n}\n\nexport const isEligibleRequest = (req: Request): boolean => {\n  try {\n    return hasBody(req) && hasAcceptableMethod(req) && hasAcceptableContentType(req)\n  } catch (e) {\n    return false\n  }\n}\n"],"names":["ACCEPTABLE_CONTENT_TYPE","UNACCEPTABLE_METHODS","Set","hasBody","req","Boolean","headers","get","hasAcceptableMethod","has","method","hasAcceptableContentType","contType","includes","test","isEligibleRequest","e"],"mappings":"AAAA,wFAAwF;;;;AACxF,MAAMA,0BAA0B;AAChC,MAAMC,uBAAuB,IAAIC,IAAI;IAAC;IAAW;IAAU;IAAO;IAAQ;IAAW;CAAQ;AAE7F,MAAMC,UAAU,CAACC;IACf,OAAOC,QACLD,IAAIE,OAAO,CAACC,GAAG,CAAC,wBACbH,IAAIE,OAAO,CAACC,GAAG,CAAC,qBAAqBH,IAAIE,OAAO,CAACC,GAAG,CAAC,sBAAsB;AAElF;AAEA,MAAMC,sBAAsB,CAACJ,MAA0B,CAACH,qBAAqBQ,GAAG,CAACL,IAAIM,MAAM;AAE3F,MAAMC,2BAA2B,CAACP;IAChC,MAAMQ,WAAWR,IAAIE,OAAO,CAACC,GAAG,CAAC;IACjC,OAAOK,SAASC,QAAQ,CAAC,gBAAgBb,wBAAwBc,IAAI,CAACF;AACxE;AAEO,MAAMG,oBAAoB,CAACX;IAChC,IAAI;QACF,OAAOD,QAAQC,QAAQI,oBAAoBJ,QAAQO,yBAAyBP;IAC9E,EAAE,OAAOY,GAAG;QACV,OAAO;IACT;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 35, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 41, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fetchAPI-multipart/utilities.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport { Readable } from 'stream'\n\nimport type { FetchAPIFileUploadOptions } from '../../config/types.js'\n\n// Parameters for safe file name parsing.\nconst SAFE_FILE_NAME_REGEX = /[^\\w-]/g\nconst MAX_EXTENSION_LENGTH = 3\n\n// Parameters to generate unique temporary file names:\nconst TEMP_COUNTER_MAX = 65536\nconst TEMP_PREFIX = 'tmp'\nlet tempCounter = 0\n\n/**\n * Logs message to console if options.debug option set to true.\n */\nexport const debugLog = (options: FetchAPIFileUploadOptions, msg: string) => {\n  const opts = options || {}\n  if (!opts.debug) {\n    return false\n  }\n  console.log(`Next-file-upload: ${msg}`) // eslint-disable-line\n  return true\n}\n\n/**\n * Generates unique temporary file name. e.g. tmp-5000-156788789789.\n */\nexport const getTempFilename = (prefix: string = TEMP_PREFIX) => {\n  tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1\n  return `${prefix}-${tempCounter}-${Date.now()}`\n}\n\ntype FuncType = (...args: any[]) => any\nexport const isFunc = (value: any): value is FuncType => {\n  return typeof value === 'function'\n}\n\n/**\n * Set errorFunc to the same value as successFunc for callback mode.\n */\ntype ErrorFunc = (resolve: () => void, reject: (err: Error) => void) => (err: Error) => void\nconst errorFunc: ErrorFunc = (resolve, reject) => (isFunc(reject) ? reject : resolve)\n\n/**\n * Return a callback function for promise resole/reject args.\n * Ensures that callback is called only once.\n */\ntype PromiseCallback = (resolve: () => void, reject: (err: Error) => void) => (err: Error) => void\nexport const promiseCallback: PromiseCallback = (resolve, reject) => {\n  let hasFired = false\n  return (err: Error) => {\n    if (hasFired) {\n      return\n    }\n\n    hasFired = true\n    return err ? errorFunc(resolve, reject)(err) : resolve()\n  }\n}\n\n// The default prototypes for both objects and arrays.\n// Used by isSafeFromPollution\nconst OBJECT_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Object.prototype)\nconst ARRAY_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Array.prototype)\n\n/**\n * Determines whether a key insertion into an object could result in a prototype pollution\n */\ntype IsSafeFromPollution = (base: any, key: string) => boolean\nexport const isSafeFromPollution: IsSafeFromPollution = (base, key) => {\n  // We perform an instanceof check instead of Array.isArray as the former is more\n  // permissive for cases in which the object as an Array prototype but was not constructed\n  // via an Array constructor or literal.\n  const TOUCHES_ARRAY_PROTOTYPE = base instanceof Array && ARRAY_PROTOTYPE_KEYS.includes(key)\n  const TOUCHES_OBJECT_PROTOTYPE = OBJECT_PROTOTYPE_KEYS.includes(key)\n\n  return !TOUCHES_ARRAY_PROTOTYPE && !TOUCHES_OBJECT_PROTOTYPE\n}\n\n/**\n * Build request field/file objects to return\n */\ntype BuildFields = (instance: any, field: string, value: any) => any\nexport const buildFields: BuildFields = (instance, field, value) => {\n  // Do nothing if value is not set.\n  if (value === null || value === undefined) {\n    return instance\n  }\n  instance = instance || Object.create(null)\n\n  if (!isSafeFromPollution(instance, field)) {\n    return instance\n  }\n  // Non-array fields\n  if (!instance[field]) {\n    instance[field] = value\n    return instance\n  }\n  // Array fields\n  if (instance[field] instanceof Array) {\n    instance[field].push(value)\n  } else {\n    instance[field] = [instance[field], value]\n  }\n  return instance\n}\n\n/**\n * Creates a folder if it does not exist\n * for file specified in the path variable\n */\ntype CheckAndMakeDir = (fileUploadOptions: FetchAPIFileUploadOptions, filePath: string) => boolean\nexport const checkAndMakeDir: CheckAndMakeDir = (fileUploadOptions, filePath) => {\n  if (!fileUploadOptions.createParentPath) {\n    return false\n  }\n  // Check whether folder for the file exists.\n  const parentPath = path.dirname(filePath)\n  // Create folder if it doesn't exist.\n  if (!fs.existsSync(parentPath)) {\n    fs.mkdirSync(parentPath, { recursive: true })\n  }\n  // Checks folder again and return a results.\n  return fs.existsSync(parentPath)\n}\n\n/**\n * Delete a file.\n */\ntype DeleteFile = (filePath: string, callback: (args: any) => void) => void\nexport const deleteFile: DeleteFile = (filePath, callback: (args) => void) =>\n  fs.unlink(filePath, callback)\n\n/**\n * Copy file via streams\n */\ntype CopyFile = (src: string, dst: string, callback: (err: Error) => void) => void\nconst copyFile: CopyFile = (src, dst, callback) => {\n  // cbCalled flag and runCb helps to run cb only once.\n  let cbCalled = false\n  const runCb = (err?: Error) => {\n    if (cbCalled) {\n      return\n    }\n    cbCalled = true\n    callback(err)\n  }\n  // Create read stream\n  const readable = fs.createReadStream(src)\n  readable.on('error', runCb)\n  // Create write stream\n  const writable = fs.createWriteStream(dst)\n  writable.on('error', (err: Error) => {\n    readable.destroy()\n    runCb(err)\n  })\n  writable.on('close', () => runCb())\n  // Copy file via piping streams.\n  readable.pipe(writable)\n}\n\n/**\n * moveFile: moves the file from src to dst.\n * Firstly trying to rename the file if no luck copying it to dst and then deleting src.\n */\ntype MoveFile = (\n  src: string,\n  dst: string,\n  callback: (err: Error, renamed?: boolean) => void,\n) => void\nexport const moveFile: MoveFile = (src, dst, callback) =>\n  fs.rename(src, dst, (err) => {\n    if (err) {\n      // Try to copy file if rename didn't work.\n      copyFile(src, dst, (cpErr) => (cpErr ? callback(cpErr) : deleteFile(src, callback)))\n      return\n    }\n    // File was renamed successfully: Add true to the callback to indicate that.\n    callback(null, true)\n  })\n\n/**\n * Save buffer data to a file.\n * @param {Buffer} buffer - buffer to save to a file.\n * @param {string} filePath - path to a file.\n */\nexport const saveBufferToFile = (buffer, filePath, callback) => {\n  if (!Buffer.isBuffer(buffer)) {\n    return callback(new Error('buffer variable should be type of Buffer!'))\n  }\n  // Setup readable stream from buffer.\n  let streamData = buffer\n  const readStream = new Readable()\n  readStream._read = () => {\n    readStream.push(streamData)\n    streamData = null\n  }\n  // Setup file system writable stream.\n  const fstream = fs.createWriteStream(filePath)\n  // console.log(\"Calling saveBuffer\");\n  fstream.on('error', (err) => {\n    // console.log(\"err cb\")\n    callback(err)\n  })\n  fstream.on('close', () => {\n    // console.log(\"close cb\");\n    callback()\n  })\n  // Copy file via piping streams.\n  readStream.pipe(fstream)\n}\n\n/**\n * Decodes uriEncoded file names.\n * @param {Object} opts - middleware options.\n * @param fileName {String} - file name to decode.\n * @returns {String}\n */\nconst uriDecodeFileName = (opts, fileName) => {\n  if (!opts || !opts.uriDecodeFileNames) {\n    return fileName\n  }\n  // Decode file name from URI with checking URI malformed errors.\n  // See Issue https://github.com/richardgirges/express-fileupload/issues/342.\n  try {\n    return decodeURIComponent(fileName)\n  } catch (err) {\n    const matcher = /(%[a-f\\d]{2})/gi\n    return fileName\n      .split(matcher)\n      .map((str) => {\n        try {\n          return decodeURIComponent(str)\n        } catch (err) {\n          return ''\n        }\n      })\n      .join('')\n  }\n}\n\n/**\n * Parses filename and extension and returns object {name, extension}.\n */\ntype ParseFileNameExtension = (\n  preserveExtension: boolean | number,\n  fileName: string,\n) => {\n  extension: string\n  name: string\n}\nexport const parseFileNameExtension: ParseFileNameExtension = (preserveExtension, fileName) => {\n  const defaultResult = {\n    name: fileName,\n    extension: '',\n  }\n  if (!preserveExtension) {\n    return defaultResult\n  }\n\n  // Define maximum extension length\n  const maxExtLength =\n    typeof preserveExtension === 'boolean' ? MAX_EXTENSION_LENGTH : preserveExtension\n\n  const nameParts = fileName.split('.')\n  if (nameParts.length < 2) {\n    return defaultResult\n  }\n\n  let extension = nameParts.pop()\n  if (extension.length > maxExtLength && maxExtLength > 0) {\n    nameParts[nameParts.length - 1] += '.' + extension.substr(0, extension.length - maxExtLength)\n    extension = extension.substr(-maxExtLength)\n  }\n\n  return {\n    name: nameParts.join('.'),\n    extension: maxExtLength ? extension : '',\n  }\n}\n\n/**\n * Parse file name and extension.\n */\ntype ParseFileName = (opts: FetchAPIFileUploadOptions, fileName: string) => string\nexport const parseFileName: ParseFileName = (opts, fileName) => {\n  // Check fileName argument\n  if (!fileName || typeof fileName !== 'string') {\n    return getTempFilename()\n  }\n  // Cut off file name if it's length more then 255.\n  let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255)\n  // Decode file name if uriDecodeFileNames option set true.\n  parsedName = uriDecodeFileName(opts, parsedName)\n  // Stop parsing file name if safeFileNames options hasn't been set.\n  if (!opts.safeFileNames) {\n    return parsedName\n  }\n  // Set regular expression for the file name.\n  const nameRegex =\n    typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp\n      ? opts.safeFileNames\n      : SAFE_FILE_NAME_REGEX\n  // Parse file name extension.\n  const parsedFileName = parseFileNameExtension(opts.preserveExtension, parsedName)\n  if (parsedFileName.extension.length) {\n    parsedFileName.extension = '.' + parsedFileName.extension.replace(nameRegex, '')\n  }\n\n  return parsedFileName.name.replace(nameRegex, '').concat(parsedFileName.extension)\n}\n"],"names":["fs","path","Readable","SAFE_FILE_NAME_REGEX","MAX_EXTENSION_LENGTH","TEMP_COUNTER_MAX","TEMP_PREFIX","tempCounter","debugLog","options","msg","opts","debug","console","log","getTempFilename","prefix","Date","now","isFunc","value","errorFunc","resolve","reject","promiseCallback","hasFired","err","OBJECT_PROTOTYPE_KEYS","Object","getOwnPropertyNames","prototype","ARRAY_PROTOTYPE_KEYS","Array","isSafeFromPollution","base","key","TOUCHES_ARRAY_PROTOTYPE","includes","TOUCHES_OBJECT_PROTOTYPE","buildFields","instance","field","undefined","create","push","checkAndMakeDir","fileUploadOptions","filePath","createParentPath","parentPath","dirname","existsSync","mkdirSync","recursive","deleteFile","callback","unlink","copyFile","src","dst","cbCalled","runCb","readable","createReadStream","on","writable","createWriteStream","destroy","pipe","moveFile","rename","cpErr","saveBufferToFile","buffer","Buffer","isBuffer","Error","streamData","readStream","_read","fstream","uriDecodeFileName","fileName","uriDecodeFileNames","decodeURIComponent","matcher","split","map","str","join","parseFileNameExtension","preserveExtension","defaultResult","name","extension","maxExtLength","nameParts","length","pop","substr","parseFileName","parsedName","safeFileNames","nameRegex","RegExp","parsedFileName","replace","concat"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 275, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fetchAPI-multipart/handlers.ts"],"sourcesContent":["import crypto from 'crypto'\nimport fs, { WriteStream } from 'fs'\nimport path from 'path'\n\nimport type { FetchAPIFileUploadOptions } from '../../config/types.js'\n\nimport { checkAndMakeDir, debugLog, deleteFile, getTempFilename } from './utilities.js'\n\ntype Handler = (\n  options: FetchAPIFileUploadOptions,\n  fieldname: string,\n  filename: string,\n) => {\n  cleanup: () => void\n  complete: () => Buffer\n  dataHandler: (data: Buffer) => void\n  getFilePath: () => string\n  getFileSize: () => number\n  getHash: () => string\n  getWritePromise: () => Promise<boolean>\n}\n\nexport const tempFileHandler: Handler = (options, fieldname, filename) => {\n  const dir = path.normalize(options.tempFileDir)\n  const tempFilePath = path.join(process.cwd(), dir, getTempFilename())\n  checkAndMakeDir({ createParentPath: true }, tempFilePath)\n\n  debugLog(options, `Temporary file path is ${tempFilePath}`)\n\n  const hash = crypto.createHash('md5')\n  let fileSize = 0\n  let completed = false\n\n  debugLog(options, `Opening write stream for ${fieldname}->${filename}...`)\n  const writeStream = fs.createWriteStream(tempFilePath)\n  const writePromise = new Promise<boolean>((resolve, reject) => {\n    writeStream.on('finish', () => resolve(true))\n    writeStream.on('error', (err) => {\n      debugLog(options, `Error write temp file: ${err}`)\n      reject(err)\n    })\n  })\n\n  return {\n    cleanup: () => {\n      completed = true\n      debugLog(options, `Cleaning up temporary file ${tempFilePath}...`)\n      writeStream.end()\n      deleteFile(tempFilePath, (err) =>\n        err\n          ? debugLog(options, `Cleaning up temporary file ${tempFilePath} failed: ${err}`)\n          : debugLog(options, `Cleaning up temporary file ${tempFilePath} done.`),\n      )\n    },\n    complete: () => {\n      completed = true\n      debugLog(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`)\n      if (writeStream instanceof WriteStream) {\n        writeStream.end()\n      }\n      // Return empty buff since data was uploaded into a temp file.\n      return Buffer.concat([])\n    },\n    dataHandler: (data) => {\n      if (completed === true) {\n        debugLog(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`)\n        return\n      }\n      writeStream.write(data)\n      hash.update(data)\n      fileSize += data.length\n      debugLog(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`)\n    },\n    getFilePath: () => tempFilePath,\n    getFileSize: () => fileSize,\n    getHash: () => hash.digest('hex'),\n    getWritePromise: () => writePromise,\n  }\n}\n\nexport const memHandler: Handler = (options, fieldname, filename) => {\n  const buffers: Buffer[] = []\n  const hash = crypto.createHash('md5')\n  let fileSize = 0\n  let completed = false\n\n  const getBuffer = () => Buffer.concat(buffers, fileSize)\n\n  return {\n    cleanup: () => {\n      completed = true\n    },\n    complete: () => {\n      debugLog(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`)\n      completed = true\n      return getBuffer()\n    },\n    dataHandler: (data) => {\n      if (completed === true) {\n        debugLog(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`)\n        return\n      }\n      buffers.push(data)\n      hash.update(data)\n      fileSize += data.length\n      debugLog(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`)\n    },\n    getFilePath: () => '',\n    getFileSize: () => fileSize,\n    getHash: () => hash.digest('hex'),\n    getWritePromise: () => Promise.resolve(true),\n  }\n}\n"],"names":["crypto","fs","WriteStream","path","checkAndMakeDir","debugLog","deleteFile","getTempFilename","tempFileHandler","options","fieldname","filename","dir","normalize","tempFileDir","tempFilePath","join","process","cwd","createParentPath","hash","createHash","fileSize","completed","writeStream","createWriteStream","writePromise","Promise","resolve","reject","on","err","cleanup","end","complete","Buffer","concat","dataHandler","data","write","update","length","getFilePath","getFileSize","getHash","digest","getWritePromise","memHandler","buffers","getBuffer","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 375, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 381, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fetchAPI-multipart/uploadTimer.ts"],"sourcesContent":["type CreateUploadTimer = (\n  timeout?: number,\n  callback?: () => void,\n) => {\n  clear: () => void\n  set: () => boolean\n}\n\nexport const createUploadTimer: CreateUploadTimer = (timeout = 0, callback = () => {}) => {\n  let timer = null\n\n  const clear = () => {\n    clearTimeout(timer)\n  }\n\n  const set = () => {\n    // Do not start a timer if zero timeout or it hasn't been set.\n    if (!timeout) {\n      return false\n    }\n    clear()\n    timer = setTimeout(callback, timeout)\n    return true\n  }\n\n  return { clear, set }\n}\n"],"names":["createUploadTimer","timeout","callback","timer","clear","clearTimeout","set","setTimeout"],"mappings":";;;AAQO,MAAMA,oBAAuC,CAACC,UAAU,CAAC,EAAEC,WAAW,KAAO,CAAC;IACnF,IAAIC,QAAQ;IAEZ,MAAMC,QAAQ;QACZC,aAAaF;IACf;IAEA,MAAMG,MAAM;QACV,8DAA8D;QAC9D,IAAI,CAACL,SAAS;YACZ,OAAO;QACT;QACAG;QACAD,QAAQI,WAAWL,UAAUD;QAC7B,OAAO;IACT;IAEA,OAAO;QAAEG;QAAOE;IAAI;AACtB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 403, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 409, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fetchAPI-multipart/fileFactory.ts"],"sourcesContent":["import type { FetchAPIFileUploadOptions } from '../../config/types.js'\nimport type { FileShape } from './index.js'\n\nimport {\n  checkAndMakeDir,\n  debugLog,\n  isFunc,\n  moveFile,\n  promiseCallback,\n  saveBufferToFile,\n} from './utilities.js'\n\ntype MoveFile = (\n  filePath: string,\n  options: FileFactoryOptions,\n  fileUploadOptions: FetchAPIFileUploadOptions,\n) => (resolve: () => void, reject: () => void) => void\n\n/**\n * Returns Local function that moves the file to a different location on the filesystem\n * which takes two function arguments to make it compatible w/ Promise or Callback APIs\n */\nconst moveFromTemp: MoveFile = (filePath, options, fileUploadOptions) => (resolve, reject) => {\n  debugLog(fileUploadOptions, `Moving temporary file ${options.tempFilePath} to ${filePath}`)\n  moveFile(options.tempFilePath, filePath, promiseCallback(resolve, reject))\n}\n\n/**\n * Returns Local function that moves the file from buffer to a different location on the filesystem\n * which takes two function arguments to make it compatible w/ Promise or Callback APIs\n */\nconst moveFromBuffer: MoveFile = (filePath, options, fileUploadOptions) => (resolve, reject) => {\n  debugLog(fileUploadOptions, `Moving uploaded buffer to ${filePath}`)\n  saveBufferToFile(options.buffer, filePath, promiseCallback(resolve, reject))\n}\n\ntype FileFactoryOptions = {\n  buffer: Buffer\n  encoding: string\n  hash: Buffer | string\n  mimetype: string\n  name: string\n  size: number\n  tempFilePath: string\n  truncated: boolean\n}\ntype FileFactory = (\n  options: FileFactoryOptions,\n  fileUploadOptions: FetchAPIFileUploadOptions,\n) => FileShape\nexport const fileFactory: FileFactory = (options, fileUploadOptions) => {\n  // see: https://github.com/richardgirges/express-fileupload/issues/14\n  // firefox uploads empty file in case of cache miss when f5ing page.\n  // resulting in unexpected behavior. if there is no file data, the file is invalid.\n  // if (!fileUploadOptions.useTempFiles && !options.buffer.length) return;\n\n  // Create and return file object.\n  return {\n    name: options.name,\n    data: options.buffer,\n    encoding: options.encoding,\n    md5: options.hash,\n    mimetype: options.mimetype,\n    mv: (filePath: string, callback) => {\n      // Define a proper move function.\n      const moveFunc = fileUploadOptions.useTempFiles\n        ? moveFromTemp(filePath, options, fileUploadOptions)\n        : moveFromBuffer(filePath, options, fileUploadOptions)\n      // Create a folder for a file.\n      checkAndMakeDir(fileUploadOptions, filePath)\n      // If callback is passed in, use the callback API, otherwise return a promise.\n      const defaultReject = () => undefined\n      return isFunc(callback) ? moveFunc(callback, defaultReject) : new Promise(moveFunc)\n    },\n    size: options.size,\n    tempFilePath: options.tempFilePath,\n    truncated: options.truncated,\n  }\n}\n"],"names":["checkAndMakeDir","debugLog","isFunc","moveFile","promiseCallback","saveBufferToFile","moveFromTemp","filePath","options","fileUploadOptions","resolve","reject","tempFilePath","moveFromBuffer","buffer","fileFactory","name","data","encoding","md5","hash","mimetype","mv","callback","moveFunc","useTempFiles","defaultReject","undefined","Promise","size","truncated"],"mappings":";;;AAGA,SACEA,eAAe,EACfC,QAAQ,EACRC,MAAM,EACNC,QAAQ,EACRC,eAAe,EACfC,gBAAgB,QACX,iBAAgB;;AAQvB;;;CAGC,GACD,MAAMC,eAAyB,CAACC,UAAUC,SAASC,oBAAsB,CAACC,SAASC;mZACjFV,WAAAA,EAASQ,mBAAmB,CAAC,sBAAsB,EAAED,QAAQI,YAAY,CAAC,IAAI,EAAEL,UAAU;YAC1FJ,kZAAAA,EAASK,QAAQI,YAAY,EAAEL,qZAAUH,kBAAAA,EAAgBM,SAASC;IACpE;AAEA;;;CAGC,GACD,MAAME,iBAA2B,CAACN,UAAUC,SAASC,oBAAsB,CAACC,SAASC;QACnFV,sZAAAA,EAASQ,mBAAmB,CAAC,0BAA0B,EAAEF,UAAU;mZACnEF,mBAAAA,EAAiBG,QAAQM,MAAM,EAAEP,UAAUH,6ZAAAA,EAAgBM,SAASC;IACtE;AAgBO,MAAMI,cAA2B,CAACP,SAASC;IAChD,qEAAqE;IACrE,oEAAoE;IACpE,mFAAmF;IACnF,yEAAyE;IAEzE,iCAAiC;IACjC,OAAO;QACLO,MAAMR,QAAQQ,IAAI;QAClBC,MAAMT,QAAQM,MAAM;QACpBI,UAAUV,QAAQU,QAAQ;QAC1BC,KAAKX,QAAQY,IAAI;QACjBC,UAAUb,QAAQa,QAAQ;QAC1BC,IAAI,CAACf,UAAkBgB;YACrB,iCAAiC;YACjC,MAAMC,WAAWf,kBAAkBgB,YAAY,GAC3CnB,aAAaC,UAAUC,SAASC,qBAChCI,eAAeN,UAAUC,SAASC;YACtC,8BAA8B;uZAC9BT,kBAAAA,EAAgBS,mBAAmBF;YACnC,8EAA8E;YAC9E,MAAMmB,gBAAgB,IAAMC;YAC5B,kZAAOzB,SAAAA,EAAOqB,YAAYC,SAASD,UAAUG,iBAAiB,IAAIE,QAAQJ;QAC5E;QACAK,MAAMrB,QAAQqB,IAAI;QAClBjB,cAAcJ,QAAQI,YAAY;QAClCkB,WAAWtB,QAAQsB,SAAS;IAC9B;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 454, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 460, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fetchAPI-multipart/processNested.ts"],"sourcesContent":["import { isSafeFromPollution } from './utilities.js'\n\nexport const processNested = function (data) {\n  if (!data || data.length < 1) {\n    return Object.create(null)\n  }\n\n  const d = Object.create(null),\n    keys = Object.keys(data)\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i],\n      keyParts = key.replace(new RegExp(/\\[/g), '.').replace(new RegExp(/\\]/g), '').split('.'),\n      value = data[key]\n    let current = d\n\n    for (let index = 0; index < keyParts.length; index++) {\n      const k = keyParts[index]\n\n      // Ensure we don't allow prototype pollution\n      if (!isSafeFromPollution(current, k)) {\n        continue\n      }\n\n      if (index >= keyParts.length - 1) {\n        current[k] = value\n      } else {\n        if (!current[k]) {\n          current[k] = !keyParts[index + 1] ? [] : Object.create(null)\n        }\n        current = current[k]\n      }\n    }\n  }\n  return d\n}\n"],"names":["isSafeFromPollution","processNested","data","length","Object","create","d","keys","i","key","keyParts","replace","RegExp","split","value","current","index","k"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ,iBAAgB;;AAE7C,MAAMC,gBAAgB,SAAUC,IAAI;IACzC,IAAI,CAACA,QAAQA,KAAKC,MAAM,GAAG,GAAG;QAC5B,OAAOC,OAAOC,MAAM,CAAC;IACvB;IAEA,MAAMC,IAAIF,OAAOC,MAAM,CAAC,OACtBE,OAAOH,OAAOG,IAAI,CAACL;IAErB,IAAK,IAAIM,IAAI,GAAGA,IAAID,KAAKJ,MAAM,EAAEK,IAAK;QACpC,MAAMC,MAAMF,IAAI,CAACC,EAAE,EACjBE,WAAWD,IAAIE,OAAO,CAAC,IAAIC,OAAO,QAAQ,KAAKD,OAAO,CAAC,IAAIC,OAAO,QAAQ,IAAIC,KAAK,CAAC,MACpFC,QAAQZ,IAAI,CAACO,IAAI;QACnB,IAAIM,UAAUT;QAEd,IAAK,IAAIU,QAAQ,GAAGA,QAAQN,SAASP,MAAM,EAAEa,QAAS;YACpD,MAAMC,IAAIP,QAAQ,CAACM,MAAM;YAEzB,4CAA4C;YAC5C,IAAI,4YAAChB,sBAAAA,EAAoBe,SAASE,IAAI;gBACpC;YACF;YAEA,IAAID,SAASN,SAASP,MAAM,GAAG,GAAG;gBAChCY,OAAO,CAACE,EAAE,GAAGH;YACf,OAAO;gBACL,IAAI,CAACC,OAAO,CAACE,EAAE,EAAE;oBACfF,OAAO,CAACE,EAAE,GAAG,CAACP,QAAQ,CAACM,QAAQ,EAAE,GAAG,EAAE,GAAGZ,OAAOC,MAAM,CAAC;gBACzD;gBACAU,UAAUA,OAAO,CAACE,EAAE;YACtB;QACF;IACF;IACA,OAAOX;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 491, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 497, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fetchAPI-multipart/processMultipart.ts"],"sourcesContent":["import type { Readable } from 'stream'\n\nimport Busboy from 'busboy'\nimport { status as httpStatus } from 'http-status'\n\nimport type { FetchAPIFileUploadOptions } from '../../config/types.js'\nimport type { FetchAPIFileUploadResponse } from './index.js'\n\nimport { APIError } from '../../errors/APIError.js'\nimport { fileFactory } from './fileFactory.js'\nimport { memHandler, tempFileHandler } from './handlers.js'\nimport { processNested } from './processNested.js'\nimport { createUploadTimer } from './uploadTimer.js'\nimport { buildFields, debugLog, isFunc, parseFileName } from './utilities.js'\n\nconst waitFlushProperty = Symbol('wait flush property symbol')\n\ntype ProcessMultipart = (args: {\n  options: FetchAPIFileUploadOptions\n  request: Request\n}) => Promise<FetchAPIFileUploadResponse>\nexport const processMultipart: ProcessMultipart = async ({ options, request }) => {\n  let parsingRequest = true\n\n  let shouldAbortProccessing = false\n  let fileCount = 0\n  let filesCompleted = 0\n  let allFilesHaveResolved: (value?: unknown) => void\n  let failedResolvingFiles: (err: Error) => void\n\n  const allFilesComplete = new Promise((res, rej) => {\n    allFilesHaveResolved = res\n    failedResolvingFiles = rej\n  })\n\n  const result: FetchAPIFileUploadResponse = {\n    fields: undefined,\n    files: undefined,\n  }\n\n  const headersObject = {}\n  request.headers.forEach((value, name) => {\n    headersObject[name] = value\n  })\n\n  const reader = request.body.getReader()\n\n  const busboy = Busboy({ ...options, headers: headersObject })\n\n  function abortAndDestroyFile(file: Readable, err: APIError) {\n    file.destroy()\n    shouldAbortProccessing = true\n    failedResolvingFiles(err)\n  }\n\n  // Build multipart req.body fields\n  busboy.on('field', (field, val) => {\n    result.fields = buildFields(result.fields, field, val)\n  })\n\n  // Build req.files fields\n  busboy.on('file', (field, file, info) => {\n    fileCount += 1\n    // Parse file name(cutting huge names, decoding, etc..).\n    const { encoding, filename: name, mimeType: mime } = info\n    const filename = parseFileName(options, name)\n\n    // Define methods and handlers for upload process.\n    const { cleanup, complete, dataHandler, getFilePath, getFileSize, getHash, getWritePromise } =\n      options.useTempFiles\n        ? tempFileHandler(options, field, filename) // Upload into temporary file.\n        : memHandler(options, field, filename) // Upload into RAM.\n\n    const writePromise = options.useTempFiles\n      ? getWritePromise().catch((err) => {\n          busboy.end()\n          cleanup()\n        })\n      : getWritePromise()\n\n    const uploadTimer = createUploadTimer(options.uploadTimeout, () => {\n      return abortAndDestroyFile(\n        file,\n        new APIError(`Upload timeout for ${field}->${filename}, bytes:${getFileSize()}`),\n      )\n    })\n\n    file.on('limit', () => {\n      debugLog(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`)\n      uploadTimer.clear()\n\n      if (isFunc(options.limitHandler)) {\n        options.limitHandler({ request, size: getFileSize() })\n      }\n\n      // Return error and cleanup files if abortOnLimit set.\n      if (options.abortOnLimit) {\n        debugLog(options, `Upload file size limit reached ${field}->${filename}.`)\n        cleanup()\n        abortAndDestroyFile(\n          file,\n          new APIError(options.responseOnLimit, httpStatus.REQUEST_ENTITY_TOO_LARGE, {\n            size: getFileSize(),\n          }),\n        )\n      }\n    })\n\n    file.on('data', (data) => {\n      uploadTimer.set()\n      dataHandler(data)\n    })\n\n    file.on('end', () => {\n      const size = getFileSize()\n      debugLog(options, `Upload finished ${field}->${filename}, bytes:${size}`)\n      uploadTimer.clear()\n\n      if (!name && size === 0) {\n        fileCount -= 1\n        if (options.useTempFiles) {\n          cleanup()\n          debugLog(options, `Removing the empty file ${field}->${filename}`)\n        }\n        return debugLog(options, `Don't add file instance if original name and size are empty`)\n      }\n\n      filesCompleted += 1\n\n      result.files = buildFields(\n        result.files,\n        field,\n        fileFactory(\n          {\n            name: filename,\n            buffer: complete(),\n            encoding,\n            hash: getHash(),\n            mimetype: mime,\n            size,\n            tempFilePath: getFilePath(),\n            truncated: Boolean('truncated' in file && file.truncated) || false,\n          },\n          options,\n        ),\n      )\n\n      if (!request[waitFlushProperty]) {\n        request[waitFlushProperty] = []\n      }\n      request[waitFlushProperty].push(writePromise)\n\n      if (filesCompleted === fileCount) {\n        allFilesHaveResolved()\n      }\n    })\n\n    file.on('error', (err) => {\n      uploadTimer.clear()\n      debugLog(options, `File Error: ${err.message}`)\n      cleanup()\n      failedResolvingFiles(err)\n    })\n\n    // Start upload process.\n    debugLog(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`)\n    uploadTimer.set()\n  })\n\n  busboy.on('finish', async () => {\n    debugLog(options, `Busboy finished parsing request.`)\n    if (options.parseNested) {\n      result.fields = processNested(result.fields)\n      result.files = processNested(result.files)\n    }\n\n    if (request[waitFlushProperty]) {\n      try {\n        await Promise.all(request[waitFlushProperty]).then(() => {\n          delete request[waitFlushProperty]\n        })\n      } catch (err) {\n        debugLog(options, `Error waiting for file write promises: ${err}`)\n      }\n    }\n\n    return result\n  })\n\n  busboy.on(\n    'error',\n    (err = new APIError('Busboy error parsing multipart request', httpStatus.BAD_REQUEST)) => {\n      debugLog(options, `Busboy error`)\n      throw err\n    },\n  )\n\n  while (parsingRequest) {\n    const { done, value } = await reader.read()\n\n    if (done) {\n      parsingRequest = false\n    }\n\n    if (value && !shouldAbortProccessing) {\n      busboy.write(value)\n    }\n  }\n\n  if (fileCount !== 0) {\n    await allFilesComplete.catch((e) => {\n      throw e\n    })\n  }\n\n  return result\n}\n"],"names":["Busboy","status","httpStatus","APIError","fileFactory","memHandler","tempFileHandler","processNested","createUploadTimer","buildFields","debugLog","isFunc","parseFileName","waitFlushProperty","Symbol","processMultipart","options","request","parsingRequest","shouldAbortProccessing","fileCount","filesCompleted","allFilesHaveResolved","failedResolvingFiles","allFilesComplete","Promise","res","rej","result","fields","undefined","files","headersObject","headers","forEach","value","name","reader","body","getReader","busboy","abortAndDestroyFile","file","err","destroy","on","field","val","info","encoding","filename","mimeType","mime","cleanup","complete","dataHandler","getFilePath","getFileSize","getHash","getWritePromise","useTempFiles","writePromise","catch","end","uploadTimer","uploadTimeout","clear","limitHandler","size","abortOnLimit","responseOnLimit","REQUEST_ENTITY_TOO_LARGE","data","set","buffer","hash","mimetype","tempFilePath","truncated","Boolean","push","message","parseNested","all","then","BAD_REQUEST","done","read","write","e"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 668, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 674, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fetchAPI-multipart/index.ts"],"sourcesContent":["import path from 'path'\n\nimport type { FetchAPIFileUploadOptions } from '../../config/types.js'\n\nimport { APIError } from '../../errors/APIError.js'\nimport { isEligibleRequest } from './isEligibleRequest.js'\nimport { processMultipart } from './processMultipart.js'\nimport { debugLog } from './utilities.js'\n\nconst DEFAULT_OPTIONS: FetchAPIFileUploadOptions = {\n  abortOnLimit: false,\n  createParentPath: false,\n  debug: false,\n  defParamCharset: 'utf8',\n  limitHandler: false,\n  parseNested: false,\n  preserveExtension: false,\n  responseOnLimit: 'File size limit has been reached',\n  safeFileNames: false,\n  tempFileDir: path.join(process.cwd(), 'tmp'),\n  uploadTimeout: 60000,\n  uriDecodeFileNames: false,\n  useTempFiles: false,\n}\n\nexport type FileShape = {\n  data: Buffer\n  encoding: string\n  md5: Buffer | string\n  mimetype: string\n  mv: (filePath: string, callback: () => void) => Promise<void> | void\n  name: string\n  size: number\n  tempFilePath: string\n  truncated: boolean\n}\n\ntype FetchAPIFileUploadResponseFile = {\n  data: Buffer\n  mimetype: string\n  name: string\n  size: number\n  tempFilePath?: string\n}\n\nexport type FetchAPIFileUploadResponse = {\n  error?: APIError\n  fields: Record<string, string>\n  files: Record<string, FetchAPIFileUploadResponseFile>\n}\n\ntype FetchAPIFileUpload = (args: {\n  options?: FetchAPIFileUploadOptions\n  request: Request\n}) => Promise<FetchAPIFileUploadResponse>\nexport const fetchAPIFileUpload: FetchAPIFileUpload = async ({ options, request }) => {\n  const uploadOptions: FetchAPIFileUploadOptions = { ...DEFAULT_OPTIONS, ...options }\n  if (!isEligibleRequest(request)) {\n    debugLog(uploadOptions, 'Request is not eligible for file upload!')\n    return {\n      error: new APIError('Request is not eligible for file upload', 500),\n      fields: undefined,\n      files: undefined,\n    }\n  } else {\n    return processMultipart({ options: uploadOptions, request })\n  }\n}\n"],"names":["path","APIError","isEligibleRequest","processMultipart","debugLog","DEFAULT_OPTIONS","abortOnLimit","createParentPath","debug","defParamCharset","limitHandler","parseNested","preserveExtension","responseOnLimit","safeFileNames","tempFileDir","join","process","cwd","uploadTimeout","uriDecodeFileNames","useTempFiles","fetchAPIFileUpload","options","request","uploadOptions","error","fields","undefined","files"],"mappings":";;;AAAA,OAAOA,UAAU,OAAM;AAKvB,SAASE,iBAAiB,QAAQ,yBAAwB;AAC1D,SAASC,gBAAgB,QAAQ,wBAAuB;AACxD,SAASC,QAAQ,QAAQ,iBAAgB;AAHzC,SAASH,QAAQ,QAAQ,2BAA0B;;;;;;AAKnD,MAAMI,kBAA6C;IACjDC,cAAc;IACdC,kBAAkB;IAClBC,OAAO;IACPC,iBAAiB;IACjBC,cAAc;IACdC,aAAa;IACbC,mBAAmB;IACnBC,iBAAiB;IACjBC,eAAe;IACfC,8GAAaf,WAAAA,CAAKgB,IAAI,CAACC,QAAQC,GAAG,IAAI;IACtCC,eAAe;IACfC,oBAAoB;IACpBC,cAAc;AAChB;AAgCO,MAAMC,qBAAyC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAE;IAC/E,MAAMC,gBAA2C;QAAE,GAAGpB,eAAe;QAAE,GAAGkB,OAAO;IAAC;IAClF,IAAI,oZAACrB,oBAAAA,EAAkBsB,UAAU;mZAC/BpB,WAAAA,EAASqB,eAAe;QACxB,OAAO;YACLC,OAAO,IAAIzB,uXAAAA,CAAS,2CAA2C;YAC/D0B,QAAQC;YACRC,OAAOD;QACT;IACF,OAAO;QACL,yZAAOzB,mBAAAA,EAAiB;YAAEoB,SAASE;YAAeD;QAAQ;IAC5D;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 721, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 727, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getExternalFile.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\nimport type { File, FileData, UploadConfig } from './types.js'\n\nimport { APIError } from '../errors/index.js'\n\ntype Args = {\n  data: FileData\n  req: PayloadRequest\n  uploadConfig: UploadConfig\n}\nexport const getExternalFile = async ({ data, req, uploadConfig }: Args): Promise<File> => {\n  const { filename, url } = data\n\n  if (typeof url === 'string') {\n    let fileURL = url\n    if (!url.startsWith('http')) {\n      const baseUrl = req.headers.get('origin') || `${req.protocol}://${req.headers.get('host')}`\n      fileURL = `${baseUrl}${url}`\n    }\n\n    const headers = uploadConfig.externalFileHeaderFilter\n      ? uploadConfig.externalFileHeaderFilter(Object.fromEntries(new Headers(req.headers)))\n      : { cookie: req.headers?.get('cookie') }\n\n    const res = await fetch(fileURL, {\n      credentials: 'include',\n      headers,\n      method: 'GET',\n    })\n\n    if (!res.ok) {\n      throw new APIError(`Failed to fetch file from ${fileURL}`, res.status)\n    }\n\n    const data = await res.arrayBuffer()\n\n    return {\n      name: filename,\n      data: Buffer.from(data),\n      mimetype: res.headers.get('content-type') || undefined,\n      size: Number(res.headers.get('content-length')) || 0,\n    }\n  }\n\n  throw new APIError('Invalid file url', 400)\n}\n"],"names":["APIError","getExternalFile","data","req","uploadConfig","filename","url","fileURL","startsWith","baseUrl","headers","get","protocol","externalFileHeaderFilter","Object","fromEntries","Headers","cookie","res","fetch","credentials","method","ok","status","arrayBuffer","name","Buffer","from","mimetype","undefined","size","Number"],"mappings":";;;AAGA,SAASA,QAAQ,QAAQ,qBAAoB;;AAOtC,MAAMC,kBAAkB,OAAO,EAAEC,IAAI,EAAEC,GAAG,EAAEC,YAAY,EAAQ;IACrE,MAAM,EAAEC,QAAQ,EAAEC,GAAG,EAAE,GAAGJ;IAE1B,IAAI,OAAOI,QAAQ,UAAU;QAC3B,IAAIC,UAAUD;QACd,IAAI,CAACA,IAAIE,UAAU,CAAC,SAAS;YAC3B,MAAMC,UAAUN,IAAIO,OAAO,CAACC,GAAG,CAAC,aAAa,GAAGR,IAAIS,QAAQ,CAAC,GAAG,EAAET,IAAIO,OAAO,CAACC,GAAG,CAAC,SAAS;YAC3FJ,UAAU,GAAGE,UAAUH,KAAK;QAC9B;QAEA,MAAMI,UAAUN,aAAaS,wBAAwB,GACjDT,aAAaS,wBAAwB,CAACC,OAAOC,WAAW,CAAC,IAAIC,QAAQb,IAAIO,OAAO,MAChF;YAAEO,QAAQd,IAAIO,OAAO,EAAEC,IAAI;QAAU;QAEzC,MAAMO,MAAM,MAAMC,MAAMZ,SAAS;YAC/Ba,aAAa;YACbV;YACAW,QAAQ;QACV;QAEA,IAAI,CAACH,IAAII,EAAE,EAAE;YACX,MAAM,gXAAItB,WAAAA,CAAS,CAAC,0BAA0B,EAAEO,SAAS,EAAEW,IAAIK,MAAM;QACvE;QAEA,MAAMrB,OAAO,MAAMgB,IAAIM,WAAW;QAElC,OAAO;YACLC,MAAMpB;YACNH,MAAMwB,OAAOC,IAAI,CAACzB;YAClB0B,UAAUV,IAAIR,OAAO,CAACC,GAAG,CAAC,mBAAmBkB;YAC7CC,MAAMC,OAAOb,IAAIR,OAAO,CAACC,GAAG,CAAC,sBAAsB;QACrD;IACF;IAEA,MAAM,gXAAIX,WAAAA,CAAS,oBAAoB;AACzC,EAAC","ignoreList":[0]}},
    {"offset": {"line": 761, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 767, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getFileByPath.ts"],"sourcesContent":["import { fileTypeFromFile } from 'file-type'\nimport fs from 'fs'\nimport path from 'path'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nconst mimeTypeEstimate = {\n  svg: 'image/svg+xml',\n}\n\nexport const getFileByPath = async (filePath: string): Promise<PayloadRequest['file']> => {\n  if (typeof filePath === 'string') {\n    const data = fs.readFileSync(filePath)\n    const mimetype = fileTypeFromFile(filePath)\n    const { size } = fs.statSync(filePath)\n\n    const name = path.basename(filePath)\n    const ext = path.extname(filePath).slice(1)\n\n    const mime = (await mimetype)?.mime || mimeTypeEstimate[ext]\n\n    return {\n      name,\n      data,\n      mimetype: mime,\n      size,\n    }\n  }\n\n  return undefined\n}\n"],"names":["fileTypeFromFile","fs","path","mimeTypeEstimate","svg","getFileByPath","filePath","data","readFileSync","mimetype","size","statSync","name","basename","ext","extname","slice","mime","undefined"],"mappings":";;;AACA,OAAOC,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;AAFvB,SAASF,gBAAgB,QAAQ,YAAW;;;;AAM5C,MAAMG,mBAAmB;IACvBC,KAAK;AACP;AAEO,MAAMC,gBAAgB,OAAOC;IAClC,IAAI,OAAOA,aAAa,UAAU;QAChC,MAAMC,qGAAON,UAAAA,CAAGO,YAAY,CAACF;QAC7B,MAAMG,+NAAWT,mBAAAA,EAAiBM;QAClC,MAAM,EAAEI,IAAI,EAAE,iGAAGT,UAAAA,CAAGU,QAAQ,CAACL;QAE7B,MAAMM,yGAAOV,UAAAA,CAAKW,QAAQ,CAACP;QAC3B,MAAMQ,wGAAMZ,UAAAA,CAAKa,OAAO,CAACT,UAAUU,KAAK,CAAC;QAEzC,MAAMC,OAAQ,CAAA,MAAMR,QAAO,GAAIQ,QAAQd,gBAAgB,CAACW,IAAI;QAE5D,OAAO;YACLF;YACAL;YACAE,UAAUQ;YACVP;QACF;IACF;IAEA,OAAOQ;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 796, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 802, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/canResizeImage.ts"],"sourcesContent":["export function canResizeImage(mimeType: string): boolean {\n  return ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/tiff'].indexOf(mimeType) > -1\n}\n"],"names":["canResizeImage","mimeType","indexOf"],"mappings":";;;AAAO,SAASA,eAAeC,QAAgB;IAC7C,OAAO;QAAC;QAAc;QAAa;QAAa;QAAc;KAAa,CAACC,OAAO,CAACD,YAAY,CAAC;AACnG","ignoreList":[0]}},
    {"offset": {"line": 814, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 820, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/isImage.ts"],"sourcesContent":["export function isImage(mimeType: string): boolean {\n  return (\n    [\n      'image/jpeg',\n      'image/png',\n      'image/gif',\n      'image/svg+xml',\n      'image/webp',\n      'image/avif',\n      'image/jxl',\n    ].indexOf(mimeType) > -1\n  )\n}\n"],"names":["isImage","mimeType","indexOf"],"mappings":";;;AAAO,SAASA,QAAQC,QAAgB;IACtC,OACE;QACE;QACA;QACA;QACA;QACA;QACA;QACA;KACD,CAACC,OAAO,CAACD,YAAY,CAAC;AAE3B","ignoreList":[0]}},
    {"offset": {"line": 834, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 840, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/tempFile.ts"],"sourcesContent":["import { promises as fsPromises } from 'fs'\nimport os from 'node:os'\nimport path from 'node:path'\nimport { v4 as uuid } from 'uuid'\n\nasync function runTask(temporaryPath: string, callback) {\n  try {\n    return await callback(temporaryPath)\n  } finally {\n    await fsPromises.rm(temporaryPath, { force: true, maxRetries: 2, recursive: true })\n  }\n}\n\ntype Options = {\n  extension?: string\n  name?: string\n}\n\nexport const temporaryFileTask = async (callback, options: Options = {}) => {\n  const filePath = await temporaryFile(options)\n  return runTask(filePath, callback)\n}\n\nasync function temporaryFile(options: Options) {\n  if (options.name) {\n    if (options.extension !== undefined && options.extension !== null) {\n      throw new Error('The `name` and `extension` options are mutually exclusive')\n    }\n\n    return path.join(await temporaryDirectory(), options.name)\n  }\n\n  return (\n    (await getPath()) +\n    (options.extension === undefined || options.extension === null\n      ? ''\n      : '.' + options.extension.replace(/^\\./, ''))\n  )\n}\n\nasync function temporaryDirectory({ prefix = '' } = {}) {\n  const directory = await getPath(prefix)\n  await fsPromises.mkdir(directory)\n  return directory\n}\n\nasync function getPath(prefix = ''): Promise<string> {\n  const temporaryDirectory = await fsPromises.realpath(os.tmpdir())\n  return path.join(temporaryDirectory, prefix + uuid())\n}\n"],"names":["promises","fsPromises","os","path","v4","uuid","runTask","temporaryPath","callback","rm","force","maxRetries","recursive","temporaryFileTask","options","filePath","temporaryFile","name","extension","undefined","Error","join","temporaryDirectory","getPath","replace","prefix","directory","mkdir","realpath","tmpdir"],"mappings":";;;AAAA,SAASA,YAAYC,UAAU,QAAQ,KAAI;AAC3C,OAAOC,QAAQ,UAAS;AACxB,OAAOC,UAAU,YAAW;AAC5B,SAASC,MAAMC,IAAI,QAAQ,OAAM;;;;;AAEjC,eAAeC,QAAQC,aAAqB,EAAEC,QAAQ;IACpD,IAAI;QACF,OAAO,MAAMA,SAASD;IACxB,SAAU;QACR,oGAAMN,WAAAA,CAAWQ,EAAE,CAACF,eAAe;YAAEG,OAAO;YAAMC,YAAY;YAAGC,WAAW;QAAK;IACnF;AACF;AAOO,MAAMC,oBAAoB,OAAOL,UAAUM,UAAmB,CAAC,CAAC;IACrE,MAAMC,WAAW,MAAMC,cAAcF;IACrC,OAAOR,QAAQS,UAAUP;AAC3B,EAAC;AAED,eAAeQ,cAAcF,OAAgB;IAC3C,IAAIA,QAAQG,IAAI,EAAE;QAChB,IAAIH,QAAQI,SAAS,KAAKC,aAAaL,QAAQI,SAAS,KAAK,MAAM;YACjE,MAAM,IAAIE,MAAM;QAClB;QAEA,yHAAOjB,UAAAA,CAAKkB,IAAI,CAAC,MAAMC,sBAAsBR,QAAQG,IAAI;IAC3D;IAEA,OACG,MAAMM,YACNT,CAAAA,QAAQI,SAAS,KAAKC,aAAaL,QAAQI,SAAS,KAAK,OACtD,KACA,MAAMJ,QAAQI,SAAS,CAACM,OAAO,CAAC,OAAO,GAAE;AAEjD;AAEA,eAAeF,mBAAmB,EAAEG,SAAS,EAAE,EAAE,GAAG,CAAC,CAAC;IACpD,MAAMC,YAAY,MAAMH,QAAQE;IAChC,oGAAMxB,WAAAA,CAAW0B,KAAK,CAACD;IACvB,OAAOA;AACT;AAEA,eAAeH,QAAQE,SAAS,EAAE;IAChC,MAAMH,qBAAqB,oGAAMrB,WAAAA,CAAW2B,QAAQ,+GAAC1B,UAAAA,CAAG2B,MAAM;IAC9D,yHAAO1B,UAAAA,CAAKkB,IAAI,CAACC,oBAAoBG,kPAASpB,KAAAA;AAChD","ignoreList":[0]}},
    {"offset": {"line": 884, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 890, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getImageSize.ts"],"sourcesContent":["import fs from 'fs'\nimport sizeOfImport from 'image-size'\nimport { promisify } from 'util'\n\nimport type { PayloadRequest } from '../types/index.js'\nimport type { ProbedImageSize } from './types.js'\n\nimport { temporaryFileTask } from './tempFile.js'\n\nconst { imageSize } = sizeOfImport\nconst imageSizePromise = promisify(imageSize)\n\nexport async function getImageSize(file: PayloadRequest['file']): Promise<ProbedImageSize> {\n  if (file.tempFilePath) {\n    return imageSizePromise(file.tempFilePath)\n  }\n\n  // Tiff file do not support buffers or streams, so we must write to file first\n  // then retrieve dimensions. https://github.com/image-size/image-size/issues/103\n  if (file.mimetype === 'image/tiff') {\n    const dimensions = await temporaryFileTask(\n      async (filepath: string) => {\n        fs.writeFileSync(filepath, file.data)\n        return imageSizePromise(filepath)\n      },\n      { extension: 'tiff' },\n    )\n    return dimensions\n  }\n\n  return imageSize(file.data)\n}\n"],"names":["fs","sizeOfImport","promisify","temporaryFileTask","imageSize","imageSizePromise","getImageSize","file","tempFilePath","mimetype","dimensions","filepath","writeFileSync","data","extension"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,kBAAkB,aAAY;AACrC,SAASC,SAAS,QAAQ,OAAM;AAKhC,SAASC,iBAAiB,QAAQ,gBAAe;;;;;AAEjD,MAAM,EAAEC,SAAS,EAAE,4MAAGH,UAAAA;AACtB,MAAMI,yHAAmBH,YAAAA,EAAUE;AAE5B,eAAeE,aAAaC,IAA4B;IAC7D,IAAIA,KAAKC,YAAY,EAAE;QACrB,OAAOH,iBAAiBE,KAAKC,YAAY;IAC3C;IAEA,8EAA8E;IAC9E,gFAAgF;IAChF,IAAID,KAAKE,QAAQ,KAAK,cAAc;QAClC,MAAMC,aAAa,uXAAMP,oBAAAA,EACvB,OAAOQ;0GACLX,UAAAA,CAAGY,aAAa,CAACD,UAAUJ,KAAKM,IAAI;YACpC,OAAOR,iBAAiBM;QAC1B,GACA;YAAEG,WAAW;QAAO;QAEtB,OAAOJ;IACT;IAEA,OAAON,UAAUG,KAAKM,IAAI;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 920, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 926, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/optionallyAppendMetadata.ts"],"sourcesContent":["import type { Sharp, Metadata as SharpMetadata } from 'sharp'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nexport type WithMetadata =\n  | ((options: { metadata: SharpMetadata; req: PayloadRequest }) => Promise<boolean>)\n  | boolean\n\nexport async function optionallyAppendMetadata({\n  req,\n  sharpFile,\n  withMetadata,\n}: {\n  req: PayloadRequest\n  sharpFile: Sharp\n  withMetadata: WithMetadata\n}): Promise<Sharp> {\n  const metadata = await sharpFile.metadata()\n\n  if (withMetadata === true) {\n    return sharpFile.withMetadata()\n  } else if (typeof withMetadata === 'function') {\n    const useMetadata = await withMetadata({ metadata, req })\n\n    if (useMetadata) {\n      return sharpFile.withMetadata()\n    }\n  }\n\n  return sharpFile\n}\n"],"names":["optionallyAppendMetadata","req","sharpFile","withMetadata","metadata","useMetadata"],"mappings":";;;AAQO,eAAeA,yBAAyB,EAC7CC,GAAG,EACHC,SAAS,EACTC,YAAY,EAKb;IACC,MAAMC,WAAW,MAAMF,UAAUE,QAAQ;IAEzC,IAAID,iBAAiB,MAAM;QACzB,OAAOD,UAAUC,YAAY;IAC/B,OAAO,IAAI,OAAOA,iBAAiB,YAAY;QAC7C,MAAME,cAAc,MAAMF,aAAa;YAAEC;YAAUH;QAAI;QAEvD,IAAII,aAAa;YACf,OAAOH,UAAUC,YAAY;QAC/B;IACF;IAEA,OAAOD;AACT","ignoreList":[0]}},
    {"offset": {"line": 944, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 950, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/docWithFilenameExists.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\ntype Args = {\n  collectionSlug: string\n  filename: string\n  path: string\n  req: PayloadRequest\n}\n\nconst docWithFilenameExists = async ({ collectionSlug, filename, req }: Args): Promise<boolean> => {\n  const doc = await req.payload.db.findOne({\n    collection: collectionSlug,\n    req,\n    where: {\n      filename: {\n        equals: filename,\n      },\n    },\n  })\n  if (doc) {\n    return true\n  }\n\n  return false\n}\n\nexport default docWithFilenameExists\n"],"names":["docWithFilenameExists","collectionSlug","filename","req","doc","payload","db","findOne","collection","where","equals"],"mappings":";;;AASA,MAAMA,wBAAwB,OAAO,EAAEC,cAAc,EAAEC,QAAQ,EAAEC,GAAG,EAAQ;IAC1E,MAAMC,MAAM,MAAMD,IAAIE,OAAO,CAACC,EAAE,CAACC,OAAO,CAAC;QACvCC,YAAYP;QACZE;QACAM,OAAO;YACLP,UAAU;gBACRQ,QAAQR;YACV;QACF;IACF;IACA,IAAIE,KAAK;QACP,OAAO;IACT;IAEA,OAAO;AACT;uCAEeJ,sBAAqB","ignoreList":[0]}},
    {"offset": {"line": 970, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 976, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fileExists.ts"],"sourcesContent":["import fs from 'fs'\n\nconst fileExists = async (filename: string): Promise<boolean> => {\n  try {\n    await fs.promises.stat(filename)\n\n    return true\n  } catch (err) {\n    return false\n  }\n}\n\nexport default fileExists\n"],"names":["fs","fileExists","filename","promises","stat","err"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;;AAEnB,MAAMC,aAAa,OAAOC;IACxB,IAAI;QACF,oGAAMF,UAAAA,CAAGG,QAAQ,CAACC,IAAI,CAACF;QAEvB,OAAO;IACT,EAAE,OAAOG,KAAK;QACZ,OAAO;IACT;AACF;uCAEeJ,WAAU","ignoreList":[0]}},
    {"offset": {"line": 991, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 997, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getSafeFilename.ts"],"sourcesContent":["import sanitize from 'sanitize-filename'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nimport docWithFilenameExists from './docWithFilenameExists.js'\nimport fileExists from './fileExists.js'\n\nconst incrementName = (name: string) => {\n  const extension = name.split('.').pop()\n  const baseFilename = sanitize(name.substring(0, name.lastIndexOf('.')) || name)\n  let incrementedName = baseFilename\n  const regex = /(.*)-(\\d+)$/\n  const found = baseFilename.match(regex)\n  if (found === null) {\n    incrementedName += '-1'\n  } else {\n    const matchedName = found[1]\n    const matchedNumber = found[2]\n    const incremented = Number(matchedNumber) + 1\n    incrementedName = `${matchedName}-${incremented}`\n  }\n  return `${incrementedName}.${extension}`\n}\n\ntype Args = {\n  collectionSlug: string\n  desiredFilename: string\n  req: PayloadRequest\n  staticPath: string\n}\n\nexport async function getSafeFileName({\n  collectionSlug,\n  desiredFilename,\n  req,\n  staticPath,\n}: Args): Promise<string> {\n  let modifiedFilename = desiredFilename\n\n  while (\n    (await docWithFilenameExists({\n      collectionSlug,\n      filename: modifiedFilename,\n      path: staticPath,\n      req,\n    })) ||\n    (await fileExists(`${staticPath}/${modifiedFilename}`))\n  ) {\n    modifiedFilename = incrementName(modifiedFilename)\n  }\n  return modifiedFilename\n}\n"],"names":["sanitize","docWithFilenameExists","fileExists","incrementName","name","extension","split","pop","baseFilename","substring","lastIndexOf","incrementedName","regex","found","match","matchedName","matchedNumber","incremented","Number","getSafeFileName","collectionSlug","desiredFilename","req","staticPath","modifiedFilename","filename","path"],"mappings":";;;AAAA,OAAOA,cAAc,oBAAmB;AAIxC,OAAOC,2BAA2B,6BAA4B;AAC9D,OAAOC,gBAAgB,kBAAiB;;;;AAExC,MAAMC,gBAAgB,CAACC;IACrB,MAAMC,YAAYD,KAAKE,KAAK,CAAC,KAAKC,GAAG;IACrC,MAAMC,kOAAeR,UAAAA,EAASI,KAAKK,SAAS,CAAC,GAAGL,KAAKM,WAAW,CAAC,SAASN;IAC1E,IAAIO,kBAAkBH;IACtB,MAAMI,QAAQ;IACd,MAAMC,QAAQL,aAAaM,KAAK,CAACF;IACjC,IAAIC,UAAU,MAAM;QAClBF,mBAAmB;IACrB,OAAO;QACL,MAAMI,cAAcF,KAAK,CAAC,EAAE;QAC5B,MAAMG,gBAAgBH,KAAK,CAAC,EAAE;QAC9B,MAAMI,cAAcC,OAAOF,iBAAiB;QAC5CL,kBAAkB,GAAGI,YAAY,CAAC,EAAEE,aAAa;IACnD;IACA,OAAO,GAAGN,gBAAgB,CAAC,EAAEN,WAAW;AAC1C;AASO,eAAec,gBAAgB,EACpCC,cAAc,EACdC,eAAe,EACfC,GAAG,EACHC,UAAU,EACL;IACL,IAAIC,mBAAmBH;IAEvB,MACG,oYAAMpB,UAAAA,EAAsB;QAC3BmB;QACAK,UAAUD;QACVE,MAAMH;QACND;IACF,MACC,yXAAMpB,UAAAA,EAAW,GAAGqB,WAAW,CAAC,EAAEC,kBAAkB,EACrD;QACAA,mBAAmBrB,cAAcqB;IACnC;IACA,OAAOA;AACT","ignoreList":[0]}},
    {"offset": {"line": 1034, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1040, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/cropImage.ts"],"sourcesContent":["import type { SharpOptions } from 'sharp'\n\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { WithMetadata } from './optionallyAppendMetadata.js'\nimport type { UploadEdits } from './types.js'\n\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\nexport const percentToPixel = (value, dimension) => {\n  return Math.floor((parseFloat(value) / 100) * dimension)\n}\n\ntype CropImageArgs = {\n  cropData: UploadEdits['crop']\n  dimensions: { height: number; width: number }\n  file: PayloadRequest['file']\n  heightInPixels: number\n  req?: PayloadRequest\n  sharp: SanitizedConfig['sharp']\n  widthInPixels: number\n  withMetadata?: WithMetadata\n}\nexport async function cropImage({\n  cropData,\n  dimensions,\n  file,\n  heightInPixels,\n  req,\n  sharp,\n  widthInPixels,\n  withMetadata,\n}: CropImageArgs) {\n  try {\n    const { x, y } = cropData\n\n    const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n\n    const sharpOptions: SharpOptions = {}\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    const formattedCropData = {\n      height: Number(heightInPixels),\n      left: percentToPixel(x, dimensions.width),\n      top: percentToPixel(y, dimensions.height),\n      width: Number(widthInPixels),\n    }\n\n    let cropped = sharp(file.tempFilePath || file.data, sharpOptions).extract(formattedCropData)\n\n    cropped = await optionallyAppendMetadata({\n      req,\n      sharpFile: cropped,\n      withMetadata,\n    })\n\n    return await cropped.toBuffer({\n      resolveWithObject: true,\n    })\n  } catch (error) {\n    console.error(`Error cropping image:`, error)\n    throw error\n  }\n}\n"],"names":["optionallyAppendMetadata","percentToPixel","value","dimension","Math","floor","parseFloat","cropImage","cropData","dimensions","file","heightInPixels","req","sharp","widthInPixels","withMetadata","x","y","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","formattedCropData","height","Number","left","width","top","cropped","tempFilePath","data","extract","sharpFile","toBuffer","resolveWithObject","error","console"],"mappings":";;;;AAOA,SAASA,wBAAwB,QAAQ,gCAA+B;;AAEjE,MAAMC,iBAAiB,CAACC,OAAOC;IACpC,OAAOC,KAAKC,KAAK,CAAEC,WAAWJ,SAAS,MAAOC;AAChD,EAAC;AAYM,eAAeI,UAAU,EAC9BC,QAAQ,EACRC,UAAU,EACVC,IAAI,EACJC,cAAc,EACdC,GAAG,EACHC,KAAK,EACLC,aAAa,EACbC,YAAY,EACE;IACd,IAAI;QACF,MAAM,EAAEC,CAAC,EAAEC,CAAC,EAAE,GAAGT;QAEjB,MAAMU,qBAAqB;YAAC;YAAc;YAAa;SAAa,CAACC,QAAQ,CAACT,KAAKU,QAAQ;QAE3F,MAAMC,eAA6B,CAAC;QAEpC,IAAIH,oBAAoB;YACtBG,aAAaC,QAAQ,GAAG;QAC1B;QAEA,MAAMC,oBAAoB;YACxBC,QAAQC,OAAOd;YACfe,MAAMzB,eAAee,GAAGP,WAAWkB,KAAK;YACxCC,KAAK3B,eAAegB,GAAGR,WAAWe,MAAM;YACxCG,OAAOF,OAAOX;QAChB;QAEA,IAAIe,UAAUhB,MAAMH,KAAKoB,YAAY,IAAIpB,KAAKqB,IAAI,EAAEV,cAAcW,OAAO,CAACT;QAE1EM,UAAU,uYAAM7B,2BAAAA,EAAyB;YACvCY;YACAqB,WAAWJ;YACXd;QACF;QAEA,OAAO,MAAMc,QAAQK,QAAQ,CAAC;YAC5BC,mBAAmB;QACrB;IACF,EAAE,OAAOC,OAAO;QACdC,QAAQD,KAAK,CAAC,CAAC,qBAAqB,CAAC,EAAEA;QACvC,MAAMA;IACR;AACF","ignoreList":[0]}},
    {"offset": {"line": 1081, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1087, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/imageResizer.ts"],"sourcesContent":["import type { Sharp, Metadata as SharpMetadata, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs'\nimport sanitize from 'sanitize-filename'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SharpDependency } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { WithMetadata } from './optionallyAppendMetadata.js'\nimport type {\n  FileSize,\n  FileSizes,\n  FileToSave,\n  ImageSize,\n  ProbedImageSize,\n  UploadEdits,\n} from './types.js'\n\nimport { isNumber } from '../utilities/isNumber.js'\nimport fileExists from './fileExists.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\ntype ResizeArgs = {\n  config: SanitizedCollectionConfig\n  dimensions: ProbedImageSize\n  file: PayloadRequest['file']\n  mimeType: string\n  req: PayloadRequest\n  savedFilename: string\n  sharp?: SharpDependency\n  staticPath: string\n  uploadEdits?: UploadEdits\n  withMetadata?: WithMetadata\n}\n\n/** Result from resizing and transforming the requested image sizes */\ntype ImageSizesResult = {\n  focalPoint?: UploadEdits['focalPoint']\n  sizeData: FileSizes\n  sizesToSave: FileToSave[]\n}\n\ntype SanitizedImageData = {\n  ext: string\n  name: string\n}\n\n/**\n * Sanitize the image name and extract the extension from the source image\n *\n * @param sourceImage - the source image\n * @returns the sanitized name and extension\n */\nconst getSanitizedImageData = (sourceImage: string): SanitizedImageData => {\n  const extension = sourceImage.split('.').pop()\n  const name = sanitize(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage)\n  return { name, ext: extension }\n}\n\n/**\n * Create a new image name based on the output image name, the dimensions and\n * the extension.\n *\n * Ignore the fact that duplicate names could happen if the there is one\n * size with `width AND height` and one with only `height OR width`. Because\n * space is expensive, we will reuse the same image for both sizes.\n *\n * @param outputImageName - the sanitized image name\n * @param bufferInfo - the buffer info\n * @param extension - the extension to use\n * @returns the new image name that is not taken\n */\ntype CreateImageNameArgs = {\n  extension: string\n  height: number\n  outputImageName: string\n  width: number\n}\nconst createImageName = ({\n  extension,\n  height,\n  outputImageName,\n  width,\n}: CreateImageNameArgs): string => {\n  return `${outputImageName}-${width}x${height}.${extension}`\n}\n\ntype CreateResultArgs = {\n  filename?: FileSize['filename']\n  filesize?: FileSize['filesize']\n  height?: FileSize['height']\n  mimeType?: FileSize['mimeType']\n  name: string\n  sizesToSave?: FileToSave[]\n  width?: FileSize['width']\n}\n\n/**\n * Create the result object for the image resize operation based on the\n * provided parameters. If the name is not provided, an empty result object\n * is returned.\n *\n * @param name - the name of the image\n * @param filename - the filename of the image\n * @param width - the width of the image\n * @param height - the height of the image\n * @param filesize - the filesize of the image\n * @param mimeType - the mime type of the image\n * @param sizesToSave - the sizes to save\n * @returns the result object\n */\nconst createResult = ({\n  name,\n  filename = null,\n  filesize = null,\n  height = null,\n  mimeType = null,\n  sizesToSave = [],\n  width = null,\n}: CreateResultArgs): ImageSizesResult => {\n  return {\n    sizeData: {\n      [name]: {\n        filename,\n        filesize,\n        height,\n        mimeType,\n        width,\n      },\n    },\n    sizesToSave,\n  }\n}\n\n/**\n * Determine whether or not to resize the image.\n * - resize using image config\n * - resize using image config with focal adjustments\n * - do not resize at all\n *\n * `imageResizeConfig.withoutEnlargement`:\n * - undefined [default]: uploading images with smaller width AND height than the image size will return null\n * - false: always enlarge images to the image size\n * - true: if the image is smaller than the image size, return the original image\n *\n * `imageResizeConfig.withoutReduction`:\n * - false [default]: always enlarge images to the image size\n * - true: if the image is smaller than the image size, return the original image\n *\n * @return 'omit' | 'resize' | 'resizeWithFocalPoint'\n */\nconst getImageResizeAction = ({\n  dimensions: originalImage,\n  hasFocalPoint,\n  imageResizeConfig,\n}: {\n  dimensions: ProbedImageSize\n  hasFocalPoint?: boolean\n  imageResizeConfig: ImageSize\n}): 'omit' | 'resize' | 'resizeWithFocalPoint' => {\n  const {\n    fit,\n    height: targetHeight,\n    width: targetWidth,\n    withoutEnlargement,\n    withoutReduction,\n  } = imageResizeConfig\n\n  // prevent upscaling by default when x and y are both smaller than target image size\n  if (targetHeight && targetWidth) {\n    const originalImageIsSmallerXAndY =\n      originalImage.width < targetWidth && originalImage.height < targetHeight\n    if (withoutEnlargement === undefined && originalImageIsSmallerXAndY) {\n      return 'omit' // prevent image size from being enlarged\n    }\n  }\n\n  if (withoutEnlargement === undefined && (!targetWidth || !targetHeight)) {\n    if (\n      (targetWidth && originalImage.width < targetWidth) ||\n      (targetHeight && originalImage.height < targetHeight)\n    ) {\n      return 'omit'\n    }\n  }\n\n  const originalImageIsSmallerXOrY =\n    originalImage.width < targetWidth || originalImage.height < targetHeight\n  if (fit === 'contain' || fit === 'inside') {\n    return 'resize'\n  }\n  if (!isNumber(targetHeight) && !isNumber(targetWidth)) {\n    return 'resize'\n  }\n\n  const targetAspectRatio = targetWidth / targetHeight\n  const originalAspectRatio = originalImage.width / originalImage.height\n  if (originalAspectRatio === targetAspectRatio) {\n    return 'resize'\n  }\n\n  if (withoutEnlargement && originalImageIsSmallerXOrY) {\n    return 'resize'\n  }\n  if (withoutReduction && !originalImageIsSmallerXOrY) {\n    return 'resize'\n  }\n\n  return hasFocalPoint ? 'resizeWithFocalPoint' : 'resize'\n}\n\n/**\n * Sanitize the resize config. If the resize config has the `withoutReduction`\n * property set to true, the `fit` and `position` properties will be set to `contain`\n * and `top left` respectively.\n *\n * @param resizeConfig - the resize config\n * @returns a sanitized resize config\n */\nconst sanitizeResizeConfig = (resizeConfig: ImageSize): ImageSize => {\n  if (resizeConfig.withoutReduction) {\n    return {\n      ...resizeConfig,\n      // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595\n      fit: resizeConfig?.fit || 'contain',\n      position: resizeConfig?.position || 'left top',\n    }\n  }\n  return resizeConfig\n}\n\n/**\n * Used to extract height from images, animated or not.\n *\n * @param sharpMetadata - the sharp metadata\n * @returns the height of the image\n */\nfunction extractHeightFromImage(sharpMetadata: SharpMetadata): number {\n  if (sharpMetadata?.pages) {\n    return sharpMetadata.height / sharpMetadata.pages\n  }\n  return sharpMetadata.height\n}\n\n/**\n * For the provided image sizes, handle the resizing and the transforms\n * (format, trim, etc.) of each requested image size and return the result object.\n * This only handles the image sizes. The transforms of the original image\n * are handled in {@link ./generateFileData.ts}.\n *\n * The image will be resized according to the provided\n * resize config. If no image sizes are requested, the resolved data will be empty.\n * For every image that does not need to be resized, a result object with `null`\n * parameters will be returned.\n *\n * @param resizeConfig - the resize config\n * @returns the result of the resize operation(s)\n */\nexport async function resizeAndTransformImageSizes({\n  config,\n  dimensions,\n  file,\n  mimeType,\n  req,\n  savedFilename,\n  sharp,\n  staticPath,\n  uploadEdits,\n  withMetadata,\n}: ResizeArgs): Promise<ImageSizesResult> {\n  const { focalPoint: focalPointEnabled = true, imageSizes } = config.upload\n\n  // Focal point adjustments\n  const incomingFocalPoint = uploadEdits.focalPoint\n    ? {\n        x: isNumber(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,\n        y: isNumber(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50,\n      }\n    : undefined\n\n  const defaultResult: ImageSizesResult = {\n    ...(focalPointEnabled && incomingFocalPoint && { focalPoint: incomingFocalPoint }),\n    sizeData: {},\n    sizesToSave: [],\n  }\n\n  if (!imageSizes || !sharp) {\n    return defaultResult\n  }\n\n  // Determine if the file is animated\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const sharpOptions: SharpOptions = {}\n\n  if (fileIsAnimatedType) {\n    sharpOptions.animated = true\n  }\n\n  const sharpBase: Sharp | undefined = sharp(file.tempFilePath || file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n  const originalImageMeta = await sharpBase.metadata()\n\n  let adjustedDimensions = { ...dimensions }\n\n  // Images with an exif orientation of 5, 6, 7, or 8 are auto-rotated by sharp\n  // Need to adjust the dimensions to match the original image\n  if ([5, 6, 7, 8].includes(originalImageMeta.orientation)) {\n    adjustedDimensions = {\n      ...dimensions,\n      height: dimensions.width,\n      width: dimensions.height,\n    }\n  }\n\n  const resizeImageMeta = {\n    height: extractHeightFromImage(originalImageMeta),\n    width: originalImageMeta.width,\n  }\n\n  const results: ImageSizesResult[] = await Promise.all(\n    imageSizes.map(async (imageResizeConfig): Promise<ImageSizesResult> => {\n      imageResizeConfig = sanitizeResizeConfig(imageResizeConfig)\n\n      const resizeAction = getImageResizeAction({\n        dimensions,\n        hasFocalPoint: Boolean(incomingFocalPoint),\n        imageResizeConfig,\n      })\n      if (resizeAction === 'omit') {\n        return createResult({ name: imageResizeConfig.name })\n      }\n\n      const imageToResize = sharpBase.clone()\n      let resized = imageToResize\n\n      if (resizeAction === 'resizeWithFocalPoint') {\n        let { height: resizeHeight, width: resizeWidth } = imageResizeConfig\n\n        const originalAspectRatio = adjustedDimensions.width / adjustedDimensions.height\n\n        // Calculate resizeWidth based on original aspect ratio if it's undefined\n        if (resizeHeight && !resizeWidth) {\n          resizeWidth = Math.round(resizeHeight * originalAspectRatio)\n        }\n\n        // Calculate resizeHeight based on original aspect ratio if it's undefined\n        if (resizeWidth && !resizeHeight) {\n          resizeHeight = Math.round(resizeWidth / originalAspectRatio)\n        }\n\n        if (!resizeHeight) {\n          resizeHeight = resizeImageMeta.height\n        }\n        if (!resizeWidth) {\n          resizeWidth = resizeImageMeta.width\n        }\n\n        const resizeAspectRatio = resizeWidth / resizeHeight\n        const prioritizeHeight = resizeAspectRatio < originalAspectRatio\n        // Scales the image before extracting from it\n        resized = imageToResize.resize({\n          height: prioritizeHeight ? resizeHeight : undefined,\n          width: prioritizeHeight ? undefined : resizeWidth,\n        })\n\n        const metadataAppendedFile = await optionallyAppendMetadata({\n          req,\n          sharpFile: resized,\n          withMetadata,\n        })\n\n        // Must read from buffer, resized.metadata will return the original image metadata\n        const { info } = await metadataAppendedFile.toBuffer({ resolveWithObject: true })\n\n        resizeImageMeta.height = extractHeightFromImage({\n          ...originalImageMeta,\n          height: info.height,\n        })\n        resizeImageMeta.width = info.width\n\n        const halfResizeX = resizeWidth / 2\n        const xFocalCenter = resizeImageMeta.width * (incomingFocalPoint.x / 100)\n        const calculatedRightPixelBound = xFocalCenter + halfResizeX\n        let leftBound = xFocalCenter - halfResizeX\n\n        // if the right bound is greater than the image width, adjust the left bound\n        // keeping focus on the right\n        if (calculatedRightPixelBound > resizeImageMeta.width) {\n          leftBound = resizeImageMeta.width - resizeWidth\n        }\n\n        // if the left bound is less than 0, adjust the left bound to 0\n        // keeping the focus on the left\n        if (leftBound < 0) {\n          leftBound = 0\n        }\n\n        const halfResizeY = resizeHeight / 2\n        const yFocalCenter = resizeImageMeta.height * (incomingFocalPoint.y / 100)\n        const calculatedBottomPixelBound = yFocalCenter + halfResizeY\n        let topBound = yFocalCenter - halfResizeY\n\n        // if the bottom bound is greater than the image height, adjust the top bound\n        // keeping the image as far right as possible\n        if (calculatedBottomPixelBound > resizeImageMeta.height) {\n          topBound = resizeImageMeta.height - resizeHeight\n        }\n\n        // if the top bound is less than 0, adjust the top bound to 0\n        // keeping the image focus near the top\n        if (topBound < 0) {\n          topBound = 0\n        }\n\n        resized = resized.extract({\n          height: resizeHeight,\n          left: Math.floor(leftBound),\n          top: Math.floor(topBound),\n          width: resizeWidth,\n        })\n      } else {\n        resized = imageToResize.resize(imageResizeConfig)\n      }\n\n      if (imageResizeConfig.formatOptions) {\n        resized = resized.toFormat(\n          imageResizeConfig.formatOptions.format,\n          imageResizeConfig.formatOptions.options,\n        )\n      }\n\n      if (imageResizeConfig.trimOptions) {\n        resized = resized.trim(imageResizeConfig.trimOptions)\n      }\n\n      const metadataAppendedFile = await optionallyAppendMetadata({\n        req,\n        sharpFile: resized,\n        withMetadata,\n      })\n\n      const { data: bufferData, info: bufferInfo } = await metadataAppendedFile.toBuffer({\n        resolveWithObject: true,\n      })\n\n      const sanitizedImage = getSanitizedImageData(savedFilename)\n\n      if (req.payloadUploadSizes) {\n        req.payloadUploadSizes[imageResizeConfig.name] = bufferData\n      }\n\n      const mimeInfo = await fileTypeFromBuffer(bufferData)\n\n      const imageNameWithDimensions = imageResizeConfig.generateImageName\n        ? imageResizeConfig.generateImageName({\n            extension: mimeInfo?.ext || sanitizedImage.ext,\n            height: extractHeightFromImage({\n              ...originalImageMeta,\n              height: bufferInfo.height,\n            }),\n            originalName: sanitizedImage.name,\n            sizeName: imageResizeConfig.name,\n            width: bufferInfo.width,\n          })\n        : createImageName({\n            extension: mimeInfo?.ext || sanitizedImage.ext,\n            height: extractHeightFromImage({\n              ...originalImageMeta,\n              height: bufferInfo.height,\n            }),\n            outputImageName: sanitizedImage.name,\n            width: bufferInfo.width,\n          })\n\n      const imagePath = `${staticPath}/${imageNameWithDimensions}`\n\n      if (await fileExists(imagePath)) {\n        try {\n          fs.unlinkSync(imagePath)\n        } catch {\n          // Ignore unlink errors\n        }\n      }\n\n      const { height, size, width } = bufferInfo\n      return createResult({\n        name: imageResizeConfig.name,\n        filename: imageNameWithDimensions,\n        filesize: size,\n        height:\n          fileIsAnimatedType && originalImageMeta.pages ? height / originalImageMeta.pages : height,\n        mimeType: mimeInfo?.mime || mimeType,\n        sizesToSave: [{ buffer: bufferData, path: imagePath }],\n        width,\n      })\n    }),\n  )\n\n  return results.reduce(\n    (acc, result) => {\n      Object.assign(acc.sizeData, result.sizeData)\n      acc.sizesToSave.push(...result.sizesToSave)\n      return acc\n    },\n    { ...defaultResult },\n  )\n}\n"],"names":["fileTypeFromBuffer","fs","sanitize","isNumber","fileExists","optionallyAppendMetadata","getSanitizedImageData","sourceImage","extension","split","pop","name","substring","lastIndexOf","ext","createImageName","height","outputImageName","width","createResult","filename","filesize","mimeType","sizesToSave","sizeData","getImageResizeAction","dimensions","originalImage","hasFocalPoint","imageResizeConfig","fit","targetHeight","targetWidth","withoutEnlargement","withoutReduction","originalImageIsSmallerXAndY","undefined","originalImageIsSmallerXOrY","targetAspectRatio","originalAspectRatio","sanitizeResizeConfig","resizeConfig","position","extractHeightFromImage","sharpMetadata","pages","resizeAndTransformImageSizes","config","file","req","savedFilename","sharp","staticPath","uploadEdits","withMetadata","focalPoint","focalPointEnabled","imageSizes","upload","incomingFocalPoint","x","Math","round","y","defaultResult","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","sharpBase","tempFilePath","data","rotate","originalImageMeta","metadata","adjustedDimensions","orientation","resizeImageMeta","results","Promise","all","map","resizeAction","Boolean","imageToResize","clone","resized","resizeHeight","resizeWidth","resizeAspectRatio","prioritizeHeight","resize","metadataAppendedFile","sharpFile","info","toBuffer","resolveWithObject","halfResizeX","xFocalCenter","calculatedRightPixelBound","leftBound","halfResizeY","yFocalCenter","calculatedBottomPixelBound","topBound","extract","left","floor","top","formatOptions","toFormat","format","options","trimOptions","trim","bufferData","bufferInfo","sanitizedImage","payloadUploadSizes","mimeInfo","imageNameWithDimensions","generateImageName","originalName","sizeName","imagePath","unlinkSync","size","mime","buffer","path","reduce","acc","result","Object","assign","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1434, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1440, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/generateFileData.ts"],"sourcesContent":["import type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs'\nimport { mkdirSync } from 'node:fs'\nimport sanitize from 'sanitize-filename'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'\n\nimport { FileRetrievalError, FileUploadError, MissingFile } from '../errors/index.js'\nimport { canResizeImage } from './canResizeImage.js'\nimport { cropImage } from './cropImage.js'\nimport { getExternalFile } from './getExternalFile.js'\nimport { getFileByPath } from './getFileByPath.js'\nimport { getImageSize } from './getImageSize.js'\nimport { getSafeFileName } from './getSafeFilename.js'\nimport { resizeAndTransformImageSizes } from './imageResizer.js'\nimport { isImage } from './isImage.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\ntype Args<T> = {\n  collection: Collection\n  config: SanitizedConfig\n  data: T\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc?: T\n  overwriteExistingFiles?: boolean\n  req: PayloadRequest\n  throwOnMissingFile?: boolean\n}\n\ntype Result<T> = Promise<{\n  data: T\n  files: FileToSave[]\n}>\n\nexport const generateFileData = async <T>({\n  collection: { config: collectionConfig },\n  data,\n  isDuplicating,\n  operation,\n  originalDoc,\n  overwriteExistingFiles,\n  req,\n  throwOnMissingFile,\n}: Args<T>): Result<T> => {\n  if (!collectionConfig.upload) {\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  const { sharp } = req.payload.config\n\n  let file = req.file\n\n  const uploadEdits = parseUploadEditsFromReqOrIncomingData({\n    data,\n    isDuplicating,\n    operation,\n    originalDoc,\n    req,\n  })\n\n  const {\n    disableLocalStorage,\n    focalPoint: focalPointEnabled = true,\n    formatOptions,\n    imageSizes,\n    resizeOptions,\n    staticDir,\n    trimOptions,\n    withMetadata,\n  } = collectionConfig.upload\n\n  const staticPath = staticDir\n\n  const incomingFileData = isDuplicating ? originalDoc : data\n\n  if (!file && uploadEdits && incomingFileData) {\n    const { filename, url } = incomingFileData as FileData\n\n    try {\n      if (url && url.startsWith('/') && !disableLocalStorage) {\n        const filePath = `${staticPath}/${filename}`\n        const response = await getFileByPath(filePath)\n        file = response\n        overwriteExistingFiles = true\n      } else if (filename && url) {\n        file = await getExternalFile({\n          data: incomingFileData as FileData,\n          req,\n          uploadConfig: collectionConfig.upload,\n        })\n        overwriteExistingFiles = true\n      }\n    } catch (err: unknown) {\n      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)\n    }\n  }\n\n  if (isDuplicating) {\n    overwriteExistingFiles = false\n  }\n\n  if (!file) {\n    if (throwOnMissingFile) {\n      throw new MissingFile(req.t)\n    }\n\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  if (!disableLocalStorage) {\n    mkdirSync(staticPath, { recursive: true })\n  }\n\n  let newData = data\n  const filesToSave: FileToSave[] = []\n  const fileData: Partial<FileData> = {}\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const cropData =\n    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined\n\n  try {\n    const fileSupportsResize = canResizeImage(file.mimetype)\n    let fsSafeName: string\n    let sharpFile: Sharp | undefined\n    let dimensions: ProbedImageSize | undefined\n    let fileBuffer: { data: Buffer; info: OutputInfo }\n    let ext\n    let mime: string\n    const fileHasAdjustments =\n      fileSupportsResize &&\n      Boolean(resizeOptions || formatOptions || imageSizes || trimOptions || file.tempFilePath)\n\n    const sharpOptions: SharpOptions = {}\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {\n      if (file.tempFilePath) {\n        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      } else {\n        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      }\n\n      if (fileHasAdjustments) {\n        if (resizeOptions) {\n          sharpFile = sharpFile.resize(resizeOptions)\n        }\n        if (formatOptions) {\n          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)\n        }\n        if (trimOptions) {\n          sharpFile = sharpFile.trim(trimOptions)\n        }\n      }\n    }\n\n    if (fileSupportsResize || isImage(file.mimetype)) {\n      dimensions = await getImageSize(file)\n      fileData.width = dimensions.width\n      fileData.height = dimensions.height\n    }\n\n    if (sharpFile) {\n      const metadata = await sharpFile.metadata()\n      sharpFile = await optionallyAppendMetadata({\n        req,\n        sharpFile,\n        withMetadata,\n      })\n      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })\n      ;({ ext, mime } = await fileTypeFromBuffer(fileBuffer.data)) // This is getting an incorrect gif height back.\n      fileData.width = fileBuffer.info.width\n      fileData.height = fileBuffer.info.height\n      fileData.filesize = fileBuffer.info.size\n\n      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages\n      if (metadata.pages) {\n        fileData.height = fileBuffer.info.height / metadata.pages\n        fileData.filesize = fileBuffer.data.length\n      }\n    } else {\n      mime = file.mimetype\n      fileData.filesize = file.size\n\n      if (file.name.includes('.')) {\n        ext = file.name.split('.').pop().split('?')[0]\n      } else {\n        ext = ''\n      }\n    }\n\n    // Adjust SVG mime type. fromBuffer modifies it.\n    if (mime === 'application/xml' && ext === 'svg') {\n      mime = 'image/svg+xml'\n    }\n    fileData.mimeType = mime\n\n    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)\n    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`\n\n    if (!overwriteExistingFiles) {\n      fsSafeName = await getSafeFileName({\n        collectionSlug: collectionConfig.slug,\n        desiredFilename: fsSafeName,\n        req,\n        staticPath,\n      })\n    }\n\n    fileData.filename = fsSafeName\n    let fileForResize = file\n\n    if (cropData && sharp) {\n      const { data: croppedImage, info } = await cropImage({\n        cropData,\n        dimensions,\n        file,\n        heightInPixels: uploadEdits.heightInPixels,\n        req,\n        sharp,\n        widthInPixels: uploadEdits.widthInPixels,\n        withMetadata,\n      })\n\n      // Apply resize after cropping to ensure it conforms to resizeOptions\n      if (resizeOptions) {\n        const resizedAfterCrop = await sharp(croppedImage)\n          .resize({\n            fit: resizeOptions?.fit || 'cover',\n            height: resizeOptions?.height,\n            position: resizeOptions?.position || 'center',\n            width: resizeOptions?.width,\n          })\n          .toBuffer({ resolveWithObject: true })\n\n        filesToSave.push({\n          buffer: resizedAfterCrop.data,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...fileForResize,\n          data: resizedAfterCrop.data,\n          size: resizedAfterCrop.info.size,\n        }\n\n        fileData.width = resizedAfterCrop.info.width\n        fileData.height = resizedAfterCrop.info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile.metadata()\n          fileData.height = metadata.pages\n            ? resizedAfterCrop.info.height / metadata.pages\n            : resizedAfterCrop.info.height\n        }\n        fileData.filesize = resizedAfterCrop.info.size\n      } else {\n        // If resizeOptions is not present, just save the cropped image\n        filesToSave.push({\n          buffer: croppedImage,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...file,\n          data: croppedImage,\n          size: info.size,\n        }\n\n        fileData.width = info.width\n        fileData.height = info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile.metadata()\n          fileData.height = metadata.pages ? info.height / metadata.pages : info.height\n        }\n        fileData.filesize = info.size\n      }\n\n      if (file.tempFilePath) {\n        await fs.promises.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path\n      } else {\n        req.file = fileForResize\n      }\n    } else {\n      filesToSave.push({\n        buffer: fileBuffer?.data || file.data,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      // If using temp files and the image is being resized, write the file to the temp path\n      if (fileBuffer?.data || file.data.length > 0) {\n        if (file.tempFilePath) {\n          await fs.promises.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path\n        } else {\n          // Assign the _possibly modified_ file to the request object\n          req.file = {\n            ...file,\n            data: fileBuffer?.data || file.data,\n            size: fileBuffer?.info.size,\n          }\n        }\n      }\n    }\n\n    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {\n      req.payloadUploadSizes = {}\n      const { focalPoint, sizeData, sizesToSave } = await resizeAndTransformImageSizes({\n        config: collectionConfig,\n        dimensions: !cropData\n          ? dimensions\n          : {\n              ...dimensions,\n              height: fileData.height,\n              width: fileData.width,\n            },\n        file: fileForResize,\n        mimeType: fileData.mimeType,\n        req,\n        savedFilename: fsSafeName || file.name,\n        sharp,\n        staticPath,\n        uploadEdits,\n        withMetadata,\n      })\n\n      fileData.sizes = sizeData\n      fileData.focalX = focalPoint?.x\n      fileData.focalY = focalPoint?.y\n      filesToSave.push(...sizesToSave)\n    }\n  } catch (err) {\n    req.payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n\n  newData = {\n    ...newData,\n    ...fileData,\n  }\n\n  return {\n    data: newData,\n    files: filesToSave,\n  }\n}\n\n/**\n * Parse upload edits from req or incoming data\n */\nfunction parseUploadEditsFromReqOrIncomingData(args: {\n  data: unknown\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc: unknown\n  req: PayloadRequest\n}): UploadEdits {\n  const { data, isDuplicating, operation, originalDoc, req } = args\n\n  // Get intended focal point change from query string or incoming data\n  const uploadEdits =\n    req.query?.uploadEdits && typeof req.query.uploadEdits === 'object'\n      ? (req.query.uploadEdits as UploadEdits)\n      : {}\n\n  if (uploadEdits.focalPoint) {\n    return uploadEdits\n  }\n\n  const incomingData = data as FileData\n  const origDoc = originalDoc as FileData\n\n  if (origDoc && 'focalX' in origDoc && 'focalY' in origDoc) {\n    // If no change in focal point, return undefined.\n    // This prevents a refocal operation triggered from admin, because it always sends the focal point.\n    if (incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {\n      return undefined\n    }\n\n    if (isDuplicating) {\n      uploadEdits.focalPoint = {\n        x: incomingData?.focalX || origDoc.focalX,\n        y: incomingData?.focalY || origDoc.focalX,\n      }\n    }\n  }\n\n  if (incomingData?.focalX && incomingData?.focalY) {\n    uploadEdits.focalPoint = {\n      x: incomingData.focalX,\n      y: incomingData.focalY,\n    }\n    return uploadEdits\n  }\n\n  // If no focal point is set, default to center\n  if (operation === 'create') {\n    uploadEdits.focalPoint = {\n      x: 50,\n      y: 50,\n    }\n  }\n\n  return uploadEdits\n}\n"],"names":["fileTypeFromBuffer","fs","mkdirSync","sanitize","FileRetrievalError","FileUploadError","MissingFile","canResizeImage","cropImage","getExternalFile","getFileByPath","getImageSize","getSafeFileName","resizeAndTransformImageSizes","isImage","optionallyAppendMetadata","generateFileData","collection","config","collectionConfig","data","isDuplicating","operation","originalDoc","overwriteExistingFiles","req","throwOnMissingFile","upload","files","sharp","payload","file","uploadEdits","parseUploadEditsFromReqOrIncomingData","disableLocalStorage","focalPoint","focalPointEnabled","formatOptions","imageSizes","resizeOptions","staticDir","trimOptions","withMetadata","staticPath","incomingFileData","filename","url","startsWith","filePath","response","uploadConfig","err","t","Error","message","undefined","recursive","newData","filesToSave","fileData","fileIsAnimatedType","includes","mimetype","cropData","crop","fileSupportsResize","fsSafeName","sharpFile","dimensions","fileBuffer","ext","mime","fileHasAdjustments","Boolean","tempFilePath","sharpOptions","animated","rotate","resize","toFormat","format","options","trim","width","height","metadata","toBuffer","resolveWithObject","info","filesize","size","pages","length","name","split","pop","mimeType","baseFilename","substring","lastIndexOf","collectionSlug","slug","desiredFilename","fileForResize","croppedImage","heightInPixels","widthInPixels","resizedAfterCrop","fit","position","push","buffer","path","promises","writeFile","Array","isArray","payloadUploadSizes","sizeData","sizesToSave","savedFilename","sizes","focalX","x","focalY","y","logger","error","args","query","incomingData","origDoc"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1780, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1786, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/saveBufferToFile.ts"],"sourcesContent":["import fs from 'fs'\nimport { Readable } from 'stream'\n\n/**\n * Save buffer data to a file.\n * @param {Buffer} buffer - buffer to save to a file.\n * @param {string} filePath - path to a file.\n */\nconst saveBufferToFile = async (buffer: Buffer, filePath: string): Promise<void> => {\n  // Setup readable stream from buffer.\n  let streamData = buffer\n  const readStream = new Readable()\n  readStream._read = () => {\n    readStream.push(streamData)\n    streamData = null\n  }\n  // Setup file system writable stream.\n  return fs.writeFileSync(filePath, buffer)\n}\n\nexport default saveBufferToFile\n"],"names":["fs","Readable","saveBufferToFile","buffer","filePath","streamData","readStream","_read","push","writeFileSync"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,QAAQ,QAAQ,SAAQ;;;AAEjC;;;;CAIC,GACD,MAAMC,mBAAmB,OAAOC,QAAgBC;IAC9C,qCAAqC;IACrC,IAAIC,aAAaF;IACjB,MAAMG,aAAa,0GAAIL,WAAAA;IACvBK,WAAWC,KAAK,GAAG;QACjBD,WAAWE,IAAI,CAACH;QAChBA,aAAa;IACf;IACA,qCAAqC;IACrC,qGAAOL,UAAAA,CAAGS,aAAa,CAACL,UAAUD;AACpC;uCAEeD,iBAAgB","ignoreList":[0]}},
    {"offset": {"line": 1810, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1816, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/uploadFiles.ts"],"sourcesContent":["import type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileToSave } from './types.js'\n\nimport { FileUploadError } from '../errors/index.js'\nimport saveBufferToFile from './saveBufferToFile.js'\n\nexport const uploadFiles = async (\n  payload: Payload,\n  files: FileToSave[],\n  req: PayloadRequest,\n): Promise<void> => {\n  try {\n    await Promise.all(\n      files.map(async ({ buffer, path }) => {\n        await saveBufferToFile(buffer, path)\n      }),\n    )\n  } catch (err) {\n    payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n}\n"],"names":["FileUploadError","saveBufferToFile","uploadFiles","payload","files","req","Promise","all","map","buffer","path","err","logger","error","t"],"mappings":";;;AAKA,OAAOC,sBAAsB,wBAAuB;AADpD,SAASD,eAAe,QAAQ,qBAAoB;;;AAG7C,MAAME,cAAc,OACzBC,SACAC,OACAC;IAEA,IAAI;QACF,MAAMC,QAAQC,GAAG,CACfH,MAAMI,GAAG,CAAC,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAE;YAC/B,+XAAMT,UAAAA,EAAiBQ,QAAQC;QACjC;IAEJ,EAAE,OAAOC,KAAK;QACZR,QAAQS,MAAM,CAACC,KAAK,CAACF;QACrB,MAAM,uXAAIX,kBAAAA,CAAgBK,IAAIS,CAAC;IACjC;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1833, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1839, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/unlinkTempFiles.ts"],"sourcesContent":["import fs from 'fs'\nimport { promisify } from 'util'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { mapAsync } from '../utilities/mapAsync.js'\n\nconst unlinkFile = promisify(fs.unlink)\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  req: PayloadRequest\n}\n/**\n * Cleanup temp files after operation lifecycle\n */\nexport const unlinkTempFiles: (args: Args) => Promise<void> = async ({\n  collectionConfig,\n  config,\n  req,\n}) => {\n  if (config.upload?.useTempFiles && collectionConfig.upload) {\n    const { file } = req\n    const fileArray = [{ file }]\n    await mapAsync(fileArray, async ({ file }) => {\n      // Still need this check because this will not be populated if using local API\n      if (file?.tempFilePath) {\n        await unlinkFile(file.tempFilePath)\n      }\n    })\n  }\n}\n"],"names":["fs","promisify","mapAsync","unlinkFile","unlink","unlinkTempFiles","collectionConfig","config","req","upload","useTempFiles","file","fileArray","tempFilePath"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,SAAS,QAAQ,OAAM;AAMhC,SAASC,QAAQ,QAAQ,2BAA0B;;;;AAEnD,MAAMC,mHAAaF,YAAAA,gGAAUD,UAAAA,CAAGI,MAAM;AAU/B,MAAMC,kBAAiD,OAAO,EACnEC,gBAAgB,EAChBC,MAAM,EACNC,GAAG,EACJ;IACC,IAAID,OAAOE,MAAM,EAAEC,gBAAgBJ,iBAAiBG,MAAM,EAAE;QAC1D,MAAM,EAAEE,IAAI,EAAE,GAAGH;QACjB,MAAMI,YAAY;YAAC;gBAAED;YAAK;SAAE;QAC5B,yXAAMT,WAAAA,EAASU,WAAW,OAAO,EAAED,IAAI,EAAE;YACvC,8EAA8E;YAC9E,IAAIA,MAAME,cAAc;gBACtB,MAAMV,WAAWQ,KAAKE,YAAY;YACpC;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1865, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1871, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/deleteAssociatedFiles.ts"],"sourcesContent":["import fs from 'fs'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave } from './types.js'\n\nimport { ErrorDeletingFile } from '../errors/index.js'\nimport fileExists from './fileExists.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  doc: Record<string, unknown>\n  files?: FileToSave[]\n  overrideDelete: boolean\n  req: PayloadRequest\n}\n\nexport const deleteAssociatedFiles: (args: Args) => Promise<void> = async ({\n  collectionConfig,\n  doc,\n  files = [],\n  overrideDelete,\n  req,\n}) => {\n  if (!collectionConfig.upload) {\n    return\n  }\n  if (overrideDelete || files.length > 0) {\n    const { staticDir: staticPath } = collectionConfig.upload\n\n    const fileToDelete = `${staticPath}/${doc.filename as string}`\n\n    try {\n      if (await fileExists(fileToDelete)) {\n        fs.unlinkSync(fileToDelete)\n      }\n    } catch (err) {\n      throw new ErrorDeletingFile(req.t)\n    }\n\n    if (doc.sizes) {\n      const sizes: FileData[] = Object.values(doc.sizes)\n      // Since forEach will not wait until unlink is finished it could\n      // happen that two operations will try to delete the same file.\n      // To avoid this it is recommended to use \"sync\" instead\n\n      for (const size of sizes) {\n        const sizeToDelete = `${staticPath}/${size.filename}`\n        try {\n          if (await fileExists(sizeToDelete)) {\n            fs.unlinkSync(sizeToDelete)\n          }\n        } catch (err) {\n          throw new ErrorDeletingFile(req.t)\n        }\n      }\n    }\n  }\n}\n"],"names":["fs","ErrorDeletingFile","fileExists","deleteAssociatedFiles","collectionConfig","doc","files","overrideDelete","req","upload","length","staticDir","staticPath","fileToDelete","filename","unlinkSync","err","t","sizes","Object","values","size","sizeToDelete"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AAQnB,OAAOE,gBAAgB,kBAAiB;AADxC,SAASD,iBAAiB,QAAQ,qBAAoB;;;;AAY/C,MAAME,wBAAuD,OAAO,EACzEC,gBAAgB,EAChBC,GAAG,EACHC,QAAQ,EAAE,EACVC,cAAc,EACdC,GAAG,EACJ;IACC,IAAI,CAACJ,iBAAiBK,MAAM,EAAE;QAC5B;IACF;IACA,IAAIF,kBAAkBD,MAAMI,MAAM,GAAG,GAAG;QACtC,MAAM,EAAEC,WAAWC,UAAU,EAAE,GAAGR,iBAAiBK,MAAM;QAEzD,MAAMI,eAAe,GAAGD,WAAW,CAAC,EAAEP,IAAIS,QAAQ,EAAY;QAE9D,IAAI;YACF,IAAI,yXAAMZ,UAAAA,EAAWW,eAAe;gBAClCb,wGAAAA,CAAGe,UAAU,CAACF;YAChB;QACF,EAAE,OAAOG,KAAK;YACZ,MAAM,yXAAIf,oBAAAA,CAAkBO,IAAIS,CAAC;QACnC;QAEA,IAAIZ,IAAIa,KAAK,EAAE;YACb,MAAMA,QAAoBC,OAAOC,MAAM,CAACf,IAAIa,KAAK;YACjD,gEAAgE;YAChE,+DAA+D;YAC/D,wDAAwD;YAExD,KAAK,MAAMG,QAAQH,MAAO;gBACxB,MAAMI,eAAe,GAAGV,WAAW,CAAC,EAAES,KAAKP,QAAQ,EAAE;gBACrD,IAAI;oBACF,IAAI,OAAMZ,4XAAAA,EAAWoB,eAAe;sHAClCtB,UAAAA,CAAGe,UAAU,CAACO;oBAChB;gBACF,EAAE,OAAON,KAAK;oBACZ,MAAM,yXAAIf,oBAAAA,CAAkBO,IAAIS,CAAC;gBACnC;YACF;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1912, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1918, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/checkFileAccess.ts"],"sourcesContent":["import type { Collection, TypeWithID } from '../collections/config/types.js'\nimport type { PayloadRequest, Where } from '../types/index.js'\n\nimport executeAccess from '../auth/executeAccess.js'\nimport { Forbidden } from '../errors/Forbidden.js'\n\nexport const checkFileAccess = async ({\n  collection,\n  filename,\n  req,\n}: {\n  collection: Collection\n  filename: string\n  req: PayloadRequest\n}): Promise<TypeWithID> => {\n  if (filename.includes('../') || filename.includes('..\\\\')) {\n    throw new Forbidden(req.t)\n  }\n\n  const { config } = collection\n  const accessResult = await executeAccess({ isReadingStaticFile: true, req }, config.access.read)\n\n  if (typeof accessResult === 'object') {\n    const queryToBuild: Where = {\n      and: [\n        {\n          or: [\n            {\n              filename: {\n                equals: filename,\n              },\n            },\n          ],\n        },\n        accessResult,\n      ],\n    }\n\n    if (config.upload.imageSizes) {\n      config.upload.imageSizes.forEach(({ name }) => {\n        queryToBuild.and[0].or.push({\n          [`sizes.${name}.filename`]: {\n            equals: filename,\n          },\n        })\n      })\n    }\n\n    const doc = await req.payload.db.findOne({\n      collection: config.slug,\n      req,\n      where: queryToBuild,\n    })\n\n    if (!doc) {\n      throw new Forbidden(req.t)\n    }\n\n    return doc\n  }\n}\n"],"names":["executeAccess","Forbidden","checkFileAccess","collection","filename","req","includes","t","config","accessResult","isReadingStaticFile","access","read","queryToBuild","and","or","equals","upload","imageSizes","forEach","name","push","doc","payload","db","findOne","slug","where"],"mappings":";;;AAIA,SAASC,SAAS,QAAQ,yBAAwB;AADlD,OAAOD,mBAAmB,2BAA0B;;;AAG7C,MAAME,kBAAkB,OAAO,EACpCC,UAAU,EACVC,QAAQ,EACRC,GAAG,EAKJ;IACC,IAAID,SAASE,QAAQ,CAAC,UAAUF,SAASE,QAAQ,CAAC,SAAS;QACzD,MAAM,iXAAIL,YAAAA,CAAUI,IAAIE,CAAC;IAC3B;IAEA,MAAM,EAAEC,MAAM,EAAE,GAAGL;IACnB,MAAMM,eAAe,yXAAMT,UAAAA,EAAc;QAAEU,qBAAqB;QAAML;IAAI,GAAGG,OAAOG,MAAM,CAACC,IAAI;IAE/F,IAAI,OAAOH,iBAAiB,UAAU;QACpC,MAAMI,eAAsB;YAC1BC,KAAK;gBACH;oBACEC,IAAI;wBACF;4BACEX,UAAU;gCACRY,QAAQZ;4BACV;wBACF;qBACD;gBACH;gBACAK;aACD;QACH;QAEA,IAAID,OAAOS,MAAM,CAACC,UAAU,EAAE;YAC5BV,OAAOS,MAAM,CAACC,UAAU,CAACC,OAAO,CAAC,CAAC,EAAEC,IAAI,EAAE;gBACxCP,aAAaC,GAAG,CAAC,EAAE,CAACC,EAAE,CAACM,IAAI,CAAC;oBAC1B,CAAC,CAAC,MAAM,EAAED,KAAK,SAAS,CAAC,CAAC,EAAE;wBAC1BJ,QAAQZ;oBACV;gBACF;YACF;QACF;QAEA,MAAMkB,MAAM,MAAMjB,IAAIkB,OAAO,CAACC,EAAE,CAACC,OAAO,CAAC;YACvCtB,YAAYK,OAAOkB,IAAI;YACvBrB;YACAsB,OAAOd;QACT;QAEA,IAAI,CAACS,KAAK;YACR,MAAM,iXAAIrB,YAAAA,CAAUI,IAAIE,CAAC;QAC3B;QAEA,OAAOe;IACT;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1969, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1975, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/fetchAPI-stream-file/index.ts"],"sourcesContent":["import fs from 'fs'\n\nexport function iteratorToStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next()\n      if (done) {\n        controller.close()\n      } else {\n        controller.enqueue(value)\n      }\n    },\n  })\n}\n\nexport async function* nodeStreamToIterator(stream: fs.ReadStream) {\n  for await (const chunk of stream) {\n    yield new Uint8Array(chunk)\n  }\n}\n\nexport function streamFile(path: string): ReadableStream {\n  const nodeStream = fs.createReadStream(path)\n  const data: ReadableStream = iteratorToStream(nodeStreamToIterator(nodeStream))\n  return data\n}\n"],"names":["fs","iteratorToStream","iterator","ReadableStream","pull","controller","done","value","next","close","enqueue","nodeStreamToIterator","stream","chunk","Uint8Array","streamFile","path","nodeStream","createReadStream","data"],"mappings":";;;;;AAAA,OAAOA,QAAQ,KAAI;;AAEZ,SAASC,iBAAiBC,QAAQ;IACvC,OAAO,IAAIC,eAAe;QACxB,MAAMC,MAAKC,UAAU;YACnB,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAE,GAAG,MAAML,SAASM,IAAI;YAC3C,IAAIF,MAAM;gBACRD,WAAWI,KAAK;YAClB,OAAO;gBACLJ,WAAWK,OAAO,CAACH;YACrB;QACF;IACF;AACF;AAEO,gBAAgBI,qBAAqBC,MAAqB;IAC/D,WAAW,MAAMC,SAASD,OAAQ;QAChC,MAAM,IAAIE,WAAWD;IACvB;AACF;AAEO,SAASE,WAAWC,IAAY;IACrC,MAAMC,2GAAajB,UAAAA,CAAGkB,gBAAgB,CAACF;IACvC,MAAMG,OAAuBlB,iBAAiBU,qBAAqBM;IACnE,OAAOE;AACT","ignoreList":[0]}},
    {"offset": {"line": 2004, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2010, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getFileTypeFallback.ts"],"sourcesContent":["type ReturnType = {\n  ext: string\n  mime: string\n}\n\nconst extensionMap: {\n  [ext: string]: string\n} = {\n  css: 'text/css',\n  csv: 'text/csv',\n  htm: 'text/html',\n  html: 'text/html',\n  js: 'application/javascript',\n  json: 'application/json',\n  md: 'text/markdown',\n  svg: 'image/svg+xml',\n  xml: 'application/xml',\n  yml: 'application/x-yaml',\n}\n\nexport const getFileTypeFallback = (path: string): ReturnType => {\n  const ext = path.split('.').pop() || 'txt'\n\n  return {\n    ext,\n    mime: extensionMap[ext] || 'text/plain',\n  }\n}\n"],"names":["extensionMap","css","csv","htm","html","js","json","md","svg","xml","yml","getFileTypeFallback","path","ext","split","pop","mime"],"mappings":";;;AAKA,MAAMA,eAEF;IACFC,KAAK;IACLC,KAAK;IACLC,KAAK;IACLC,MAAM;IACNC,IAAI;IACJC,MAAM;IACNC,IAAI;IACJC,KAAK;IACLC,KAAK;IACLC,KAAK;AACP;AAEO,MAAMC,sBAAsB,CAACC;IAClC,MAAMC,MAAMD,KAAKE,KAAK,CAAC,KAAKC,GAAG,MAAM;IAErC,OAAO;QACLF;QACAG,MAAMhB,YAAY,CAACa,IAAI,IAAI;IAC7B;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2032, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2038, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/mimeTypeValidator.ts"],"sourcesContent":["import type { Validate } from '../fields/config/types.js'\n\nimport { validateMimeType } from '../utilities/validateMimeType.js'\n\nexport const mimeTypeValidator =\n  (mimeTypes: string[]): Validate =>\n  (val: string, { siblingData }) => {\n    if (!siblingData.filename) {\n      return true\n    }\n\n    if (!val) {\n      return 'Invalid file type'\n    }\n\n    const isValidMimeType = validateMimeType(val, mimeTypes)\n    return isValidMimeType ? true : `Invalid file type: '${val}'`\n  }\n"],"names":["validateMimeType","mimeTypeValidator","mimeTypes","val","siblingData","filename","isValidMimeType"],"mappings":";;;AAEA,SAASA,gBAAgB,QAAQ,mCAAkC;;AAE5D,MAAMC,oBACX,CAACC,YACD,CAACC,KAAa,EAAEC,WAAW,EAAE;QAC3B,IAAI,CAACA,YAAYC,QAAQ,EAAE;YACzB,OAAO;QACT;QAEA,IAAI,CAACF,KAAK;YACR,OAAO;QACT;QAEA,MAAMG,6YAAkBN,mBAAAA,EAAiBG,KAAKD;QAC9C,OAAOI,kBAAkB,OAAO,CAAC,oBAAoB,EAAEH,IAAI,CAAC,CAAC;IAC/D,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2053, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2059, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.23.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/uploads/getBaseFields.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Config } from '../config/types.js'\nimport type { Field } from '../fields/config/types.js'\nimport type { UploadConfig } from './types.js'\n\nimport { mimeTypeValidator } from './mimeTypeValidator.js'\n\ntype GenerateURLArgs = {\n  collectionSlug: string\n  config: Config\n  filename?: string\n}\nconst generateURL = ({ collectionSlug, config, filename }: GenerateURLArgs) => {\n  if (filename) {\n    return `${config.serverURL || ''}${config.routes.api || ''}/${collectionSlug}/file/${encodeURIComponent(filename)}`\n  }\n  return undefined\n}\n\ntype Options = {\n  collection: CollectionConfig\n  config: Config\n}\n\nexport const getBaseUploadFields = ({ collection, config }: Options): Field[] => {\n  const uploadOptions: UploadConfig = typeof collection.upload === 'object' ? collection.upload : {}\n\n  const mimeType: Field = {\n    name: 'mimeType',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: 'MIME Type',\n  }\n\n  const thumbnailURL: Field = {\n    name: 'thumbnailURL',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    hooks: {\n      afterRead: [\n        ({ originalDoc }) => {\n          const adminThumbnail =\n            typeof collection.upload !== 'boolean' ? collection.upload?.adminThumbnail : undefined\n\n          if (typeof adminThumbnail === 'function') {\n            return adminThumbnail({ doc: originalDoc })\n          }\n\n          if (\n            typeof adminThumbnail === 'string' &&\n            'sizes' in originalDoc &&\n            originalDoc.sizes?.[adminThumbnail]?.filename\n          ) {\n            return generateURL({\n              collectionSlug: collection.slug,\n              config,\n              filename: originalDoc.sizes?.[adminThumbnail].filename as string,\n            })\n          }\n\n          return null\n        },\n      ],\n    },\n    label: 'Thumbnail URL',\n  }\n\n  const width: Field = {\n    name: 'width',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:width'),\n  }\n\n  const height: Field = {\n    name: 'height',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:height'),\n  }\n\n  const filesize: Field = {\n    name: 'filesize',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:fileSize'),\n  }\n\n  const filename: Field = {\n    name: 'filename',\n    type: 'text',\n    admin: {\n      disableBulkEdit: true,\n      hidden: true,\n      readOnly: true,\n    },\n    index: true,\n    label: ({ t }) => t('upload:fileName'),\n  }\n\n  // Only set unique: true if the collection does not have a compound index\n  if (\n    collection.upload === true ||\n    (typeof collection.upload === 'object' && !collection.upload.filenameCompoundIndex)\n  ) {\n    filename.unique = true\n  }\n\n  const url: Field = {\n    name: 'url',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: 'URL',\n  }\n\n  let uploadFields: Field[] = [\n    {\n      ...url,\n      hooks: {\n        afterRead: [\n          ({ data, value }) => {\n            if (value && !data.filename) {\n              return value\n            }\n\n            return generateURL({\n              collectionSlug: collection.slug,\n              config,\n              filename: data?.filename,\n            })\n          },\n        ],\n      },\n    },\n    thumbnailURL,\n    filename,\n    mimeType,\n    filesize,\n    width,\n    height,\n  ]\n\n  // Add focal point fields if not disabled\n  if (\n    uploadOptions.focalPoint !== false ||\n    uploadOptions.imageSizes ||\n    uploadOptions.resizeOptions\n  ) {\n    uploadFields = uploadFields.concat(\n      ['focalX', 'focalY'].map((name) => {\n        return {\n          name,\n          type: 'number',\n          admin: {\n            disableListColumn: true,\n            disableListFilter: true,\n            hidden: true,\n          },\n        }\n      }),\n    )\n  }\n\n  if (uploadOptions.mimeTypes) {\n    mimeType.validate = mimeTypeValidator(uploadOptions.mimeTypes)\n  }\n\n  if (uploadOptions.imageSizes) {\n    uploadFields = uploadFields.concat([\n      {\n        name: 'sizes',\n        type: 'group',\n        admin: {\n          hidden: true,\n        },\n        fields: uploadOptions.imageSizes.map((size) => ({\n          name: size.name,\n          type: 'group',\n          admin: {\n            hidden: true,\n          },\n          fields: [\n            {\n              ...url,\n              hooks: {\n                afterRead: [\n                  ({ data, value }) => {\n                    if (value && size.height && size.width && !data.filename) {\n                      return value\n                    }\n\n                    const sizeFilename = data?.sizes?.[size.name]?.filename\n\n                    if (sizeFilename) {\n                      return `${config.serverURL}${config.routes.api}/${collection.slug}/file/${sizeFilename}`\n                    }\n\n                    return null\n                  },\n                ],\n              },\n            },\n            width,\n            height,\n            mimeType,\n            filesize,\n            {\n              ...filename,\n              unique: false,\n            },\n          ],\n          label: size.name,\n        })),\n        label: ({ t }) => t('upload:sizes'),\n      },\n    ])\n  }\n  return uploadFields\n}\n"],"names":["mimeTypeValidator","generateURL","collectionSlug","config","filename","serverURL","routes","api","encodeURIComponent","undefined","getBaseUploadFields","collection","uploadOptions","upload","mimeType","name","type","admin","hidden","readOnly","label","thumbnailURL","hooks","afterRead","originalDoc","adminThumbnail","doc","sizes","slug","width","t","height","filesize","disableBulkEdit","index","filenameCompoundIndex","unique","url","uploadFields","data","value","focalPoint","imageSizes","resizeOptions","concat","map","disableListColumn","disableListFilter","mimeTypes","validate","fields","size","sizeFilename"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2255, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}