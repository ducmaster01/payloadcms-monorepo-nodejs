{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/getNameFromDrizzleTable.ts"],"sourcesContent":["import type { Table } from 'drizzle-orm'\n\nexport const getNameFromDrizzleTable = (table: Table): string => {\n  const symbol = Object.getOwnPropertySymbols(table).find((symb) =>\n    symb.description.includes('Name'),\n  )\n\n  return table[symbol]\n}\n"],"names":["getNameFromDrizzleTable","table","symbol","Object","getOwnPropertySymbols","find","symb","description","includes"],"mappings":";;;AAEO,MAAMA,0BAA0B,CAACC;IACtC,MAAMC,SAASC,OAAOC,qBAAqB,CAACH,OAAOI,IAAI,CAAC,CAACC,OACvDA,KAAKC,WAAW,CAACC,QAAQ,CAAC;IAG5B,OAAOP,KAAK,CAACC,OAAO;AACtB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/isPolymorphicRelationship.ts"],"sourcesContent":["import type { CollectionSlug } from 'payload'\n\nexport const isPolymorphicRelationship = (\n  value: unknown,\n): value is {\n  relationTo: CollectionSlug\n  value: number | string\n} => {\n  return (\n    value &&\n    typeof value === 'object' &&\n    'relationTo' in value &&\n    typeof value.relationTo === 'string' &&\n    'value' in value\n  )\n}\n"],"names":["isPolymorphicRelationship","value","relationTo"],"mappings":";;;AAEO,MAAMA,4BAA4B,CACvCC;IAKA,OACEA,SACA,OAAOA,UAAU,YACjB,gBAAgBA,SAChB,OAAOA,MAAMC,UAAU,KAAK,YAC5B,WAAWD;AAEf,EAAC","ignoreList":[0]}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 32, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queries/addJoinTable.ts"],"sourcesContent":["import { type SQL } from 'drizzle-orm'\nimport { type PgTableWithColumns } from 'drizzle-orm/pg-core'\n\nimport type { GenericTable } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\n\nexport const addJoinTable = ({\n  type,\n  condition,\n  joins,\n  queryPath,\n  table,\n}: {\n  condition: SQL\n  joins: BuildQueryJoinAliases\n  queryPath?: string\n  table: GenericTable | PgTableWithColumns<any>\n  type?: 'innerJoin' | 'leftJoin' | 'rightJoin'\n}) => {\n  const name = getNameFromDrizzleTable(table)\n\n  if (!joins.some((eachJoin) => getNameFromDrizzleTable(eachJoin.table) === name)) {\n    joins.push({ type, condition, queryPath, table })\n  }\n}\n"],"names":["getNameFromDrizzleTable","addJoinTable","type","condition","joins","queryPath","table","name","some","eachJoin","push"],"mappings":";;;AAMA,SAASA,uBAAuB,QAAQ,0CAAyC;;AAE1E,MAAMC,eAAe,CAAC,EAC3BC,IAAI,EACJC,SAAS,EACTC,KAAK,EACLC,SAAS,EACTC,KAAK,EAON;IACC,MAAMC,sZAAOP,0BAAAA,EAAwBM;IAErC,IAAI,CAACF,MAAMI,IAAI,CAAC,CAACC,0ZAAaT,0BAAAA,EAAwBS,SAASH,KAAK,MAAMC,OAAO;QAC/EH,MAAMM,IAAI,CAAC;YAAER;YAAMC;YAAWE;YAAWC;QAAM;IACjD;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queries/getTableAlias.ts"],"sourcesContent":["import type { PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport type { SQLiteTableWithColumns } from 'drizzle-orm/sqlite-core'\n\nimport { alias } from 'drizzle-orm/pg-core'\nimport { alias as aliasSQLite } from 'drizzle-orm/sqlite-core/alias'\nimport toSnakeCase from 'to-snake-case'\nimport { v4 as uuid } from 'uuid'\n\nimport type { DrizzleAdapter } from '../types.js'\n\ntype Table = PgTableWithColumns<any> | SQLiteTableWithColumns<any>\nexport const getTableAlias = ({\n  adapter,\n  tableName,\n}: {\n  adapter: DrizzleAdapter\n  tableName: string\n}): {\n  newAliasTable: Table\n  newAliasTableName: string\n} => {\n  const newAliasTableName = toSnakeCase(uuid())\n  let newAliasTable\n\n  if (adapter.name === 'postgres') {\n    newAliasTable = alias(adapter.tables[tableName], newAliasTableName)\n  }\n  if (adapter.name === 'sqlite') {\n    newAliasTable = aliasSQLite(adapter.tables[tableName], newAliasTableName)\n  }\n\n  return { newAliasTable, newAliasTableName }\n}\n"],"names":["alias","aliasSQLite","toSnakeCase","v4","uuid","getTableAlias","adapter","tableName","newAliasTableName","newAliasTable","name","tables"],"mappings":";;;AAKA,OAAOE,iBAAiB,gBAAe;AACvC,SAASC,MAAMC,IAAI,QAAQ,OAAM;AAHjC,SAASJ,KAAK,QAAQ,sBAAqB;AAC3C,SAASA,SAASC,WAAW,QAAQ,gCAA+B;;;;;AAO7D,MAAMI,gBAAgB,CAAC,EAC5BC,OAAO,EACPC,SAAS,EAIV;IAIC,MAAMC,qOAAoBN,UAAAA,0OAAYE,KAAAA;IACtC,IAAIK;IAEJ,IAAIH,QAAQI,IAAI,KAAK,YAAY;QAC/BD,kVAAgBT,QAAAA,EAAMM,QAAQK,MAAM,CAACJ,UAAU,EAAEC;IACnD;IACA,IAAIF,QAAQI,IAAI,KAAK,UAAU;QAC7BD,sVAAgBR,QAAAA,EAAYK,QAAQK,MAAM,CAACJ,UAAU,EAAEC;IACzD;IAEA,OAAO;QAAEC;QAAeD;IAAkB;AAC5C,EAAC","ignoreList":[0]}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queries/getTableColumnFromPath.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\nimport type { SQLiteTableWithColumns } from 'drizzle-orm/sqlite-core'\nimport type { FlattenedField, NumberField, TextField } from 'payload'\n\nimport { and, eq, like, sql } from 'drizzle-orm'\nimport { type PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport { APIError } from 'payload'\nimport { tabHasName } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\nimport { validate as uuidValidate } from 'uuid'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { isPolymorphicRelationship } from '../utilities/isPolymorphicRelationship.js'\nimport { addJoinTable } from './addJoinTable.js'\nimport { getTableAlias } from './getTableAlias.js'\n\ntype Constraint = {\n  columnName: string\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  value: unknown\n}\n\ntype TableColumn = {\n  columnName?: string\n  columns?: {\n    idType: 'number' | 'text' | 'uuid'\n    rawColumn: SQL<unknown>\n  }[]\n  constraints: Constraint[]\n  field: FlattenedField\n  getNotNullColumnByValue?: (val: unknown) => string\n  pathSegments?: string[]\n  rawColumn?: SQL\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n}\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  collectionPath: string\n  columnPrefix?: string\n  constraintPath?: string\n  constraints?: Constraint[]\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  pathSegments: string[]\n  rootTableName?: string\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  /**\n   * If creating a new table name for arrays and blocks, this suffix should be appended to the table name\n   */\n  tableNameSuffix?: string\n  /**\n   * The raw value of the query before sanitization\n   */\n  value: unknown\n}\n/**\n * Transforms path to table and column name or to a list of OR columns\n * Adds tables to `join`\n * @returns TableColumn\n */\nexport const getTableColumnFromPath = ({\n  adapter,\n  aliasTable,\n  collectionPath,\n  columnPrefix = '',\n  constraintPath: incomingConstraintPath,\n  constraints = [],\n  fields,\n  joins,\n  locale: incomingLocale,\n  pathSegments: incomingSegments,\n  rootTableName: incomingRootTableName,\n  selectFields,\n  selectLocale,\n  tableName,\n  tableNameSuffix = '',\n  value,\n}: Args): TableColumn => {\n  const fieldPath = incomingSegments[0]\n  let locale = incomingLocale\n  const rootTableName = incomingRootTableName || tableName\n  let constraintPath = incomingConstraintPath || ''\n\n  const field = fields.find((fieldToFind) => fieldToFind.name === fieldPath)\n  let newTableName = tableName\n\n  if (!field && fieldPath === 'id') {\n    selectFields.id = adapter.tables[newTableName].id\n    return {\n      columnName: 'id',\n      constraints,\n      field: {\n        name: 'id',\n        type: adapter.idType === 'uuid' ? 'text' : 'number',\n      } as NumberField | TextField,\n      table: adapter.tables[newTableName],\n    }\n  }\n\n  if (field) {\n    const pathSegments = [...incomingSegments]\n\n    // If next segment is a locale,\n    // we need to take it out and use it as the locale from this point on\n    if ('localized' in field && field.localized && adapter.payload.config.localization) {\n      const matchedLocale = adapter.payload.config.localization.localeCodes.find(\n        (locale) => locale === pathSegments[1],\n      )\n\n      if (matchedLocale) {\n        locale = matchedLocale\n        pathSegments.splice(1, 1)\n      }\n    }\n\n    switch (field.type) {\n      case 'array': {\n        newTableName = adapter.tableNameMap.get(\n          `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n        )\n\n        const arrayParentTable = aliasTable || adapter.tables[tableName]\n\n        constraintPath = `${constraintPath}${field.name}.%.`\n        if (locale && field.localized && adapter.payload.config.localization) {\n          const conditions = [eq(arrayParentTable.id, adapter.tables[newTableName]._parentID)]\n\n          if (selectLocale) {\n            selectFields._locale = adapter.tables[newTableName]._locale\n          }\n\n          if (locale !== 'all') {\n            conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n          }\n          addJoinTable({\n            condition: and(...conditions),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        } else {\n          addJoinTable({\n            condition: eq(arrayParentTable.id, adapter.tables[newTableName]._parentID),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          collectionPath,\n          constraintPath,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          value,\n        })\n      }\n      case 'blocks': {\n        let blockTableColumn: TableColumn\n        let newTableName: string\n\n        // handle blockType queries\n        if (pathSegments[1] === 'blockType') {\n          // find the block config using the value\n          const blockTypes = Array.isArray(value) ? value : [value]\n          blockTypes.forEach((blockType) => {\n            const block = field.blocks.find((block) => block.slug === blockType)\n            newTableName = adapter.tableNameMap.get(\n              `${tableName}_blocks_${toSnakeCase(block.slug)}`,\n            )\n\n            const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n            joins.push({\n              condition: eq(adapter.tables[tableName].id, newAliasTable._parentID),\n              table: newAliasTable,\n            })\n            constraints.push({\n              columnName: '_path',\n              table: newAliasTable,\n              value: pathSegments[0],\n            })\n          })\n          return {\n            constraints,\n            field,\n            getNotNullColumnByValue: () => 'id',\n            table: adapter.tables[tableName],\n          }\n        }\n\n        const hasBlockField = field.blocks.some((block) => {\n          newTableName = adapter.tableNameMap.get(`${tableName}_blocks_${toSnakeCase(block.slug)}`)\n          constraintPath = `${constraintPath}${field.name}.%.`\n\n          let result\n          const blockConstraints = []\n          const blockSelectFields = {}\n          try {\n            result = getTableColumnFromPath({\n              adapter,\n              collectionPath,\n              constraintPath,\n              constraints: blockConstraints,\n              fields: block.flattenedFields,\n              joins,\n              locale,\n              pathSegments: pathSegments.slice(1),\n              rootTableName,\n              selectFields: blockSelectFields,\n              selectLocale,\n              tableName: newTableName,\n              value,\n            })\n          } catch (error) {\n            // this is fine, not every block will have the field\n          }\n          if (!result) {\n            return\n          }\n          blockTableColumn = result\n          constraints = constraints.concat(blockConstraints)\n          selectFields = { ...selectFields, ...blockSelectFields }\n          if (field.localized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            joins.push({\n              condition: and(...conditions),\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            joins.push({\n              condition: eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n              table: adapter.tables[newTableName],\n            })\n          }\n          return true\n        })\n        if (hasBlockField) {\n          return {\n            columnName: blockTableColumn.columnName,\n            constraints,\n            field: blockTableColumn.field,\n            pathSegments: pathSegments.slice(1),\n            rawColumn: blockTableColumn.rawColumn,\n            table: blockTableColumn.table,\n          }\n        }\n        break\n      }\n\n      case 'group': {\n        if (locale && field.localized && adapter.payload.config.localization) {\n          newTableName = `${tableName}${adapter.localesSuffix}`\n\n          let condition = eq(adapter.tables[tableName].id, adapter.tables[newTableName]._parentID)\n\n          if (locale !== 'all') {\n            condition = and(condition, eq(adapter.tables[newTableName]._locale, locale))\n          }\n\n          addJoinTable({\n            condition,\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix: `${columnPrefix}${field.name}_`,\n          constraintPath: `${constraintPath}${field.name}.`,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n          value,\n        })\n      }\n\n      case 'number':\n      case 'text': {\n        if (field.hasMany) {\n          let tableType = 'texts'\n          let columnName = 'text'\n          if (field.type === 'number') {\n            tableType = 'numbers'\n            columnName = 'number'\n          }\n          newTableName = `${rootTableName}_${tableType}`\n          const joinConstraints = [\n            eq(adapter.tables[rootTableName].id, adapter.tables[newTableName].parent),\n            like(adapter.tables[newTableName].path, `${constraintPath}${field.name}`),\n          ]\n\n          if (locale && field.localized && adapter.payload.config.localization) {\n            const conditions = [...joinConstraints]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            addJoinTable({\n              condition: and(...joinConstraints),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName,\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n\n      case 'relationship':\n      case 'upload': {\n        const newCollectionPath = pathSegments.slice(1).join('.')\n\n        if (Array.isArray(field.relationTo) || field.hasMany) {\n          let relationshipFields: FlattenedField[]\n          const relationTableName = `${rootTableName}${adapter.relationshipsSuffix}`\n          const {\n            newAliasTable: aliasRelationshipTable,\n            newAliasTableName: aliasRelationshipTableName,\n          } = getTableAlias({\n            adapter,\n            tableName: relationTableName,\n          })\n\n          if (selectLocale && field.localized && adapter.payload.config.localization) {\n            selectFields._locale = aliasRelationshipTable.locale\n          }\n\n          // Join in the relationships table\n          if (locale && field.localized && adapter.payload.config.localization) {\n            const conditions = [\n              eq((aliasTable || adapter.tables[rootTableName]).id, aliasRelationshipTable.parent),\n              like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(aliasRelationshipTable.locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              queryPath: `${constraintPath}.${field.name}`,\n              table: aliasRelationshipTable,\n            })\n          } else {\n            // Join in the relationships table\n            addJoinTable({\n              condition: and(\n                eq((aliasTable || adapter.tables[rootTableName]).id, aliasRelationshipTable.parent),\n                like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n              ),\n              joins,\n              queryPath: `${constraintPath}.${field.name}`,\n              table: aliasRelationshipTable,\n            })\n          }\n\n          selectFields[`${relationTableName}.path`] = aliasRelationshipTable.path\n\n          let newAliasTable\n\n          if (typeof field.relationTo === 'string') {\n            const relationshipConfig = adapter.payload.collections[field.relationTo].config\n\n            newTableName = adapter.tableNameMap.get(toSnakeCase(relationshipConfig.slug))\n\n            // parent to relationship join table\n            relationshipFields = relationshipConfig.flattenedFields\n            ;({ newAliasTable } = getTableAlias({ adapter, tableName: newTableName }))\n\n            joins.push({\n              condition: eq(newAliasTable.id, aliasRelationshipTable[`${field.relationTo}ID`]),\n              table: newAliasTable,\n            })\n\n            if (newCollectionPath === '' || newCollectionPath === 'id') {\n              return {\n                columnName: `${field.relationTo}ID`,\n                constraints,\n                field,\n                table: aliasRelationshipTable,\n              }\n            }\n          } else if (newCollectionPath === 'value') {\n            const hasCustomCollectionWithCustomID = field.relationTo.some(\n              (relationTo) => !!adapter.payload.collections[relationTo].customIDType,\n            )\n\n            const columns: TableColumn['columns'] = field.relationTo\n              .map((relationTo) => {\n                let idType: 'number' | 'text' | 'uuid' =\n                  adapter.idType === 'uuid' ? 'uuid' : 'number'\n\n                const { customIDType } = adapter.payload.collections[relationTo]\n\n                if (customIDType) {\n                  idType = customIDType\n                }\n\n                const idTypeTextOrUuid = idType === 'text' || idType === 'uuid'\n\n                // Do not add the column to OR if we know that it can't match by the type\n                // We can't do the same with idType: 'number' because `value` can be from the REST search query params\n                if (typeof value === 'number' && idTypeTextOrUuid) {\n                  return null\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  value.every((val) => typeof val === 'number') &&\n                  idTypeTextOrUuid\n                ) {\n                  return null\n                }\n\n                // Do not add the UUID type column if incoming query value doesn't match UUID. If there aren't any collections with\n                // a custom ID type, we skip this check\n                // We need this because Postgres throws an error if querying by UUID column with a value that isn't a valid UUID.\n                if (\n                  value &&\n                  !Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID\n                ) {\n                  if (!uuidValidate(value)) {\n                    return null\n                  }\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID &&\n                  !value.some((val) => uuidValidate(val))\n                ) {\n                  return null\n                }\n\n                const relationTableName = adapter.tableNameMap.get(\n                  toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n                )\n\n                return {\n                  idType,\n                  rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n                }\n              })\n              .filter(Boolean)\n\n            return {\n              columns,\n              constraints,\n              field,\n              table: aliasRelationshipTable,\n            }\n          } else if (newCollectionPath === 'relationTo') {\n            const relationTo = Array.isArray(field.relationTo)\n              ? field.relationTo\n              : [field.relationTo]\n\n            return {\n              constraints,\n              field,\n              getNotNullColumnByValue: (val) => {\n                const matchedRelation = relationTo.find((relation) => relation === val)\n                if (matchedRelation) {\n                  return `${matchedRelation}ID`\n                }\n                return undefined\n              },\n              table: aliasRelationshipTable,\n            }\n          } else if (isPolymorphicRelationship(value)) {\n            const { relationTo } = value\n\n            const relationTableName = adapter.tableNameMap.get(\n              toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n            )\n\n            return {\n              constraints,\n              field,\n              rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n              table: aliasRelationshipTable,\n            }\n          } else {\n            throw new APIError('Not supported')\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            fields: relationshipFields,\n            joins,\n            locale,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: newTableName,\n            selectFields,\n            selectLocale,\n            tableName: newTableName,\n            value,\n          })\n        } else if (\n          pathSegments.length > 1 &&\n          !(pathSegments.length === 2 && pathSegments[1] === 'id')\n        ) {\n          // simple relationships\n          const columnName = `${columnPrefix}${field.name}`\n          const newTableName = adapter.tableNameMap.get(\n            toSnakeCase(adapter.payload.collections[field.relationTo].config.slug),\n          )\n          const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n          if (field.localized && adapter.payload.config.localization) {\n            const { newAliasTable: aliasLocaleTable } = getTableAlias({\n              adapter,\n              tableName: `${rootTableName}${adapter.localesSuffix}`,\n            })\n\n            const condtions = [eq(aliasLocaleTable._parentID, adapter.tables[rootTableName].id)]\n\n            if (selectLocale) {\n              selectFields._locale = aliasLocaleTable._locale\n            }\n\n            if (locale !== 'all') {\n              condtions.push(eq(aliasLocaleTable._locale, locale))\n            }\n\n            const localesTable = adapter.tables[`${rootTableName}${adapter.localesSuffix}`]\n\n            addJoinTable({\n              condition: and(...condtions),\n              joins,\n              table: localesTable,\n            })\n\n            joins.push({\n              condition: eq(localesTable[columnName], newAliasTable.id),\n              table: newAliasTable,\n            })\n          } else {\n            joins.push({\n              condition: eq(\n                newAliasTable.id,\n                aliasTable ? aliasTable[columnName] : adapter.tables[tableName][columnName],\n              ),\n              table: newAliasTable,\n            })\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraintPath: '',\n            constraints,\n            fields: adapter.payload.collections[field.relationTo].config.flattenedFields,\n            joins,\n            locale,\n            pathSegments: pathSegments.slice(1),\n            selectFields,\n            tableName: newTableName,\n            value,\n          })\n        }\n        break\n      }\n\n      case 'select': {\n        if (field.hasMany) {\n          const newTableName = adapter.tableNameMap.get(\n            `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n          )\n\n          if (locale && field.localized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n              eq(adapter.tables[newTableName]._locale, locale),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            addJoinTable({\n              condition: eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName: 'value',\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n\n      case 'tab': {\n        if (tabHasName(field)) {\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable,\n            collectionPath,\n            columnPrefix: `${columnPrefix}${field.name}_`,\n            constraintPath: `${constraintPath}${field.name}.`,\n            constraints,\n            fields: field.flattenedFields,\n            joins,\n            locale,\n            pathSegments: pathSegments.slice(1),\n            rootTableName,\n            selectFields,\n            selectLocale,\n            tableName: newTableName,\n            tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n            value,\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix,\n          constraintPath,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          tableNameSuffix,\n          value,\n        })\n      }\n\n      default: {\n        // fall through\n        break\n      }\n    }\n\n    let newTable = adapter.tables[newTableName]\n\n    if (field.localized && adapter.payload.config.localization) {\n      // If localized, we go to localized table and set aliasTable to undefined\n      // so it is not picked up below to be used as targetTable\n      const parentTable = aliasTable || adapter.tables[tableName]\n      newTableName = `${tableName}${adapter.localesSuffix}`\n\n      newTable = adapter.tables[newTableName]\n\n      let condition = eq(parentTable.id, newTable._parentID)\n\n      if (locale !== 'all') {\n        condition = and(condition, eq(newTable._locale, locale))\n      }\n\n      if (selectLocale) {\n        selectFields._locale = newTable._locale\n      }\n\n      addJoinTable({\n        condition,\n        joins,\n        table: newTable,\n      })\n\n      aliasTable = undefined\n    }\n\n    const targetTable = aliasTable || newTable\n\n    selectFields[`${newTableName}.${columnPrefix}${field.name}`] =\n      targetTable[`${columnPrefix}${field.name}`]\n\n    return {\n      columnName: `${columnPrefix}${field.name}`,\n      constraints,\n      field,\n      pathSegments,\n      table: targetTable,\n    }\n  }\n\n  throw new APIError(`Cannot find field for path at ${fieldPath}`)\n}\n"],"names":["and","eq","like","sql","APIError","tabHasName","toSnakeCase","validate","uuidValidate","isPolymorphicRelationship","addJoinTable","getTableAlias","getTableColumnFromPath","adapter","aliasTable","collectionPath","columnPrefix","constraintPath","incomingConstraintPath","constraints","fields","joins","locale","incomingLocale","pathSegments","incomingSegments","rootTableName","incomingRootTableName","selectFields","selectLocale","tableName","tableNameSuffix","value","fieldPath","field","find","fieldToFind","name","newTableName","id","tables","columnName","type","idType","table","localized","payload","config","localization","matchedLocale","localeCodes","splice","tableNameMap","get","arrayParentTable","conditions","_parentID","_locale","push","condition","flattenedFields","slice","blockTableColumn","blockTypes","Array","isArray","forEach","blockType","block","blocks","slug","newAliasTable","getNotNullColumnByValue","hasBlockField","some","result","blockConstraints","blockSelectFields","error","concat","rawColumn","localesSuffix","hasMany","tableType","joinConstraints","parent","path","newCollectionPath","join","relationTo","relationshipFields","relationTableName","relationshipsSuffix","aliasRelationshipTable","newAliasTableName","aliasRelationshipTableName","queryPath","relationshipConfig","collections","hasCustomCollectionWithCustomID","customIDType","columns","map","idTypeTextOrUuid","every","val","raw","filter","Boolean","matchedRelation","relation","undefined","length","aliasLocaleTable","condtions","localesTable","newTable","parentTable","targetTable"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 667, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 673, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queries/buildOrderBy.ts"],"sourcesContent":["import type { Table } from 'drizzle-orm'\nimport type { FlattenedField, Sort } from 'payload'\n\nimport { asc, desc } from 'drizzle-orm'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases, BuildQueryResult } from './buildQuery.js'\n\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\nimport { getTableColumnFromPath } from './getTableColumnFromPath.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  selectFields: Record<string, GenericColumn>\n  sort?: Sort\n  tableName: string\n}\n\n/**\n * Gets the order by column and direction constructed from the sort argument adds the column to the select fields and joins if necessary\n */\nexport const buildOrderBy = ({\n  adapter,\n  aliasTable,\n  fields,\n  joins,\n  locale,\n  selectFields,\n  sort,\n  tableName,\n}: Args): BuildQueryResult['orderBy'] => {\n  const orderBy: BuildQueryResult['orderBy'] = []\n\n  if (!sort) {\n    const createdAt = adapter.tables[tableName]?.createdAt\n    if (createdAt) {\n      sort = '-createdAt'\n    } else {\n      sort = '-id'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  for (const sortItem of sort) {\n    let sortProperty: string\n    let sortDirection: 'asc' | 'desc'\n    if (sortItem[0] === '-') {\n      sortProperty = sortItem.substring(1)\n      sortDirection = 'desc'\n    } else {\n      sortProperty = sortItem\n      sortDirection = 'asc'\n    }\n    try {\n      const { columnName: sortTableColumnName, table: sortTable } = getTableColumnFromPath({\n        adapter,\n        collectionPath: sortProperty,\n        fields,\n        joins,\n        locale,\n        pathSegments: sortProperty.replace(/__/g, '.').split('.'),\n        selectFields,\n        tableName,\n        value: sortProperty,\n      })\n      if (sortTable?.[sortTableColumnName]) {\n        orderBy.push({\n          column:\n            aliasTable && tableName === getNameFromDrizzleTable(sortTable)\n              ? aliasTable[sortTableColumnName]\n              : sortTable[sortTableColumnName],\n          order: sortDirection === 'asc' ? asc : desc,\n        })\n\n        selectFields[sortTableColumnName] = sortTable[sortTableColumnName]\n      }\n    } catch (err) {\n      // continue\n    }\n  }\n\n  return orderBy\n}\n"],"names":["asc","desc","getNameFromDrizzleTable","getTableColumnFromPath","buildOrderBy","adapter","aliasTable","fields","joins","locale","selectFields","sort","tableName","orderBy","createdAt","tables","sortItem","sortProperty","sortDirection","substring","columnName","sortTableColumnName","table","sortTable","collectionPath","pathSegments","replace","split","value","push","column","order","err"],"mappings":";;;AAQA,SAASE,uBAAuB,QAAQ,0CAAyC;AACjF,SAASC,sBAAsB,QAAQ,8BAA6B;AANpE,SAASH,GAAG,EAAEC,IAAI,QAAQ,cAAa;;;;AAsBhC,MAAMG,eAAe,CAAC,EAC3BC,OAAO,EACPC,UAAU,EACVC,MAAM,EACNC,KAAK,EACLC,MAAM,EACNC,YAAY,EACZC,IAAI,EACJC,SAAS,EACJ;IACL,MAAMC,UAAuC,EAAE;IAE/C,IAAI,CAACF,MAAM;QACT,MAAMG,YAAYT,QAAQU,MAAM,CAACH,UAAU,EAAEE;QAC7C,IAAIA,WAAW;YACbH,OAAO;QACT,OAAO;YACLA,OAAO;QACT;IACF;IAEA,IAAI,OAAOA,SAAS,UAAU;QAC5BA,OAAO;YAACA;SAAK;IACf;IAEA,KAAK,MAAMK,YAAYL,KAAM;QAC3B,IAAIM;QACJ,IAAIC;QACJ,IAAIF,QAAQ,CAAC,EAAE,KAAK,KAAK;YACvBC,eAAeD,SAASG,SAAS,CAAC;YAClCD,gBAAgB;QAClB,OAAO;YACLD,eAAeD;YACfE,gBAAgB;QAClB;QACA,IAAI;YACF,MAAM,EAAEE,YAAYC,mBAAmB,EAAEC,OAAOC,SAAS,EAAE,+YAAGpB,yBAAAA,EAAuB;gBACnFE;gBACAmB,gBAAgBP;gBAChBV;gBACAC;gBACAC;gBACAgB,cAAcR,aAAaS,OAAO,CAAC,OAAO,KAAKC,KAAK,CAAC;gBACrDjB;gBACAE;gBACAgB,OAAOX;YACT;YACA,IAAIM,WAAW,CAACF,oBAAoB,EAAE;gBACpCR,QAAQgB,IAAI,CAAC;oBACXC,QACExB,cAAcM,6ZAAcV,0BAAAA,EAAwBqB,aAChDjB,UAAU,CAACe,oBAAoB,GAC/BE,SAAS,CAACF,oBAAoB;oBACpCU,OAAOb,kBAAkB,+UAAQlB,MAAAA,0UAAMC,OAAAA;gBACzC;gBAEAS,YAAY,CAACW,oBAAoB,GAAGE,SAAS,CAACF,oBAAoB;YACpE;QACF,EAAE,OAAOW,KAAK;QACZ,WAAW;QACb;IACF;IAEA,OAAOnB;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 732, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 738, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queries/buildAndOrConditions.ts"],"sourcesContent":["import type { SQL, Table } from 'drizzle-orm'\nimport type { FlattenedField, Where } from 'payload'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { parseParams } from './parseParams.js'\n\nexport function buildAndOrConditions({\n  adapter,\n  aliasTable,\n  fields,\n  joins,\n  locale,\n  selectFields,\n  selectLocale,\n  tableName,\n  where,\n}: {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  joins: BuildQueryJoinAliases\n  locale?: string\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  where: Where[]\n}): SQL[] {\n  const completedConditions = []\n  // Loop over all AND / OR operations and add them to the AND / OR query param\n  // Operations should come through as an array\n\n  for (const condition of where) {\n    // If the operation is properly formatted as an object\n    if (typeof condition === 'object') {\n      const result = parseParams({\n        adapter,\n        aliasTable,\n        fields,\n        joins,\n        locale,\n        selectFields,\n        selectLocale,\n        tableName,\n        where: condition,\n      })\n      if (result && Object.keys(result).length > 0) {\n        completedConditions.push(result)\n      }\n    }\n  }\n  return completedConditions\n}\n"],"names":["parseParams","buildAndOrConditions","adapter","aliasTable","fields","joins","locale","selectFields","selectLocale","tableName","where","completedConditions","condition","result","Object","keys","length","push"],"mappings":";;;AAMA,SAASA,WAAW,QAAQ,mBAAkB;;AAEvC,SAASC,qBAAqB,EACnCC,OAAO,EACPC,UAAU,EACVC,MAAM,EACNC,KAAK,EACLC,MAAM,EACNC,YAAY,EACZC,YAAY,EACZC,SAAS,EACTC,KAAK,EAaN;IACC,MAAMC,sBAAsB,EAAE;IAC9B,6EAA6E;IAC7E,6CAA6C;IAE7C,KAAK,MAAMC,aAAaF,MAAO;QAC7B,sDAAsD;QACtD,IAAI,OAAOE,cAAc,UAAU;YACjC,MAAMC,SAASb,+YAAAA,EAAY;gBACzBE;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC,OAAOE;YACT;YACA,IAAIC,UAAUC,OAAOC,IAAI,CAACF,QAAQG,MAAM,GAAG,GAAG;gBAC5CL,oBAAoBM,IAAI,CAACJ;YAC3B;QACF;IACF;IACA,OAAOF;AACT","ignoreList":[0]}},
    {"offset": {"line": 768, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 774, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/getCollectionIdType.ts"],"sourcesContent":["import type { Collection } from 'payload'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nconst typeMap: Record<string, 'number' | 'text'> = {\n  number: 'number',\n  serial: 'number',\n  text: 'text',\n  uuid: 'text',\n}\n\nexport const getCollectionIdType = ({\n  adapter,\n  collection,\n}: {\n  adapter: DrizzleAdapter\n  collection: Collection\n}) => {\n  return collection.customIDType ?? typeMap[adapter.idType]\n}\n"],"names":["typeMap","number","serial","text","uuid","getCollectionIdType","adapter","collection","customIDType","idType"],"mappings":";;;AAIA,MAAMA,UAA6C;IACjDC,QAAQ;IACRC,QAAQ;IACRC,MAAM;IACNC,MAAM;AACR;AAEO,MAAMC,sBAAsB,CAAC,EAClCC,OAAO,EACPC,UAAU,EAIX;IACC,OAAOA,WAAWC,YAAY,IAAIR,OAAO,CAACM,QAAQG,MAAM,CAAC;AAC3D,EAAC","ignoreList":[0]}},
    {"offset": {"line": 786, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 792, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/rawConstraint.ts"],"sourcesContent":["const RawConstraintSymbol = Symbol('RawConstraint')\n\n/**\n * You can use this to inject a raw query to where\n */\nexport const rawConstraint = (value: unknown) => ({\n  type: RawConstraintSymbol,\n  value,\n})\n\nexport const isRawConstraint = (value: unknown): value is ReturnType<typeof rawConstraint> => {\n  return value && typeof value === 'object' && 'type' in value && value.type === RawConstraintSymbol\n}\n"],"names":["RawConstraintSymbol","Symbol","rawConstraint","value","type","isRawConstraint"],"mappings":";;;;AAAA,MAAMA,sBAAsBC,OAAO;AAK5B,MAAMC,gBAAgB,CAACC,QAAoB,CAAA;QAChDC,MAAMJ;QACNG;IACF,CAAA,EAAE;AAEK,MAAME,kBAAkB,CAACF;IAC9B,OAAOA,SAAS,OAAOA,UAAU,YAAY,UAAUA,SAASA,MAAMC,IAAI,KAAKJ;AACjF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 804, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queries/sanitizeQueryValue.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\n\nimport { APIError, createArrayFromCommaDelineated, type Field, type TabAsField } from 'payload'\nimport { fieldAffectsData } from 'payload/shared'\nimport { validate as uuidValidate } from 'uuid'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nimport { getCollectionIdType } from '../utilities/getCollectionIdType.js'\nimport { isPolymorphicRelationship } from '../utilities/isPolymorphicRelationship.js'\nimport { isRawConstraint } from '../utilities/rawConstraint.js'\n\ntype SanitizeQueryValueArgs = {\n  adapter: DrizzleAdapter\n  columns?: {\n    idType: 'number' | 'text' | 'uuid'\n    rawColumn: SQL<unknown>\n  }[]\n  field: Field | TabAsField\n  isUUID: boolean\n  operator: string\n  relationOrPath: string\n  val: any\n}\n\ntype SanitizedColumn = {\n  rawColumn: SQL<unknown>\n  value: unknown\n}\n\nexport const sanitizeQueryValue = ({\n  adapter,\n  columns,\n  field,\n  isUUID,\n  operator: operatorArg,\n  relationOrPath,\n  val,\n}: SanitizeQueryValueArgs): {\n  columns?: SanitizedColumn[]\n  operator: string\n  value: unknown\n} => {\n  let operator = operatorArg\n  let formattedValue = val\n  let formattedColumns: SanitizedColumn[]\n\n  if (!fieldAffectsData(field)) {\n    return { operator, value: formattedValue }\n  }\n\n  if (isRawConstraint(val)) {\n    return { operator, value: val.value }\n  }\n  if (\n    (field.type === 'relationship' || field.type === 'upload') &&\n    !relationOrPath.endsWith('relationTo') &&\n    Array.isArray(formattedValue)\n  ) {\n    const allPossibleIDTypes: (number | string)[] = []\n    formattedValue.forEach((val) => {\n      if (adapter.idType !== 'uuid' && typeof val === 'string') {\n        allPossibleIDTypes.push(val, parseInt(val))\n      } else if (typeof val === 'string') {\n        allPossibleIDTypes.push(val)\n      } else {\n        allPossibleIDTypes.push(val, String(val))\n      }\n    })\n    formattedValue = allPossibleIDTypes\n  }\n\n  // Cast incoming values as proper searchable types\n  if (field.type === 'checkbox' && typeof val === 'string') {\n    if (val.toLowerCase() === 'true') {\n      formattedValue = true\n    }\n    if (val.toLowerCase() === 'false') {\n      formattedValue = false\n    }\n  }\n\n  if (['all', 'in', 'not_in'].includes(operator)) {\n    if (typeof formattedValue === 'string') {\n      formattedValue = createArrayFromCommaDelineated(formattedValue)\n\n      if (field.type === 'number') {\n        formattedValue = formattedValue.map((arrayVal) => parseFloat(arrayVal))\n      }\n    } else if (typeof formattedValue === 'number') {\n      formattedValue = [formattedValue]\n    }\n\n    if (!Array.isArray(formattedValue)) {\n      return null\n    }\n  }\n\n  if (field.type === 'number' && typeof formattedValue === 'string') {\n    formattedValue = Number(val)\n\n    if (Number.isNaN(formattedValue)) {\n      formattedValue = null\n    }\n  }\n\n  if (isUUID && typeof formattedValue === 'string') {\n    if (!uuidValidate(val)) {\n      formattedValue = null\n    }\n  }\n\n  if (field.type === 'date' && operator !== 'exists') {\n    if (typeof val === 'string') {\n      formattedValue = new Date(val).toISOString()\n      if (Number.isNaN(Date.parse(formattedValue))) {\n        return { operator, value: undefined }\n      }\n    } else if (typeof val === 'number') {\n      formattedValue = new Date(val).toISOString()\n    }\n  }\n\n  if (field.type === 'relationship' || field.type === 'upload') {\n    if (val === 'null') {\n      formattedValue = null\n    } else if (!(formattedValue === null || typeof formattedValue === 'boolean')) {\n      // convert the value to the idType of the relationship\n      let idType: 'number' | 'text'\n      if (typeof field.relationTo === 'string') {\n        idType = getCollectionIdType({\n          adapter,\n          collection: adapter.payload.collections[field.relationTo],\n        })\n      } else {\n        if (isPolymorphicRelationship(val)) {\n          if (operator !== 'equals') {\n            throw new APIError(\n              `Only 'equals' operator is supported for polymorphic relationship object notation. Given - ${operator}`,\n            )\n          }\n          idType = getCollectionIdType({\n            adapter,\n            collection: adapter.payload.collections[val.relationTo],\n          })\n\n          if (isRawConstraint(val.value)) {\n            return {\n              operator,\n              value: val.value.value,\n            }\n          }\n          return {\n            operator,\n            value: idType === 'number' ? Number(val.value) : String(val.value),\n          }\n        }\n\n        formattedColumns = columns\n          .map(({ idType, rawColumn }) => {\n            let formattedValue: number | number[] | string | string[]\n\n            if (Array.isArray(val)) {\n              formattedValue = val\n                .map((eachVal) => {\n                  let formattedValue: number | string\n\n                  if (idType === 'number') {\n                    formattedValue = Number(eachVal)\n\n                    if (Number.isNaN(formattedValue)) {\n                      return null\n                    }\n                  } else {\n                    if (idType === 'uuid' && !uuidValidate(eachVal)) {\n                      return null\n                    }\n\n                    formattedValue = String(eachVal)\n                  }\n\n                  return formattedValue\n                })\n                .filter(Boolean) as number[] | string[]\n            } else if (idType === 'number') {\n              formattedValue = Number(val)\n\n              if (Number.isNaN(formattedValue)) {\n                return null\n              }\n            } else {\n              formattedValue = String(val)\n            }\n\n            return {\n              rawColumn,\n              value: formattedValue,\n            }\n          })\n          .filter(Boolean)\n      }\n      if (Array.isArray(formattedValue)) {\n        formattedValue = formattedValue.map((value) => {\n          if (idType === 'number') {\n            return Number(value)\n          }\n          if (idType === 'text') {\n            return String(value)\n          }\n          return value\n        })\n      } else {\n        if (idType === 'number') {\n          formattedValue = Number(val)\n        }\n        if (idType === 'text') {\n          formattedValue = String(val)\n        }\n      }\n    }\n  }\n\n  if ('hasMany' in field && field.hasMany && operator === 'contains') {\n    operator = 'equals'\n  }\n\n  if (operator === 'near' && field.type === 'point' && typeof formattedValue === 'string') {\n    const [lng, lat, maxDistance, minDistance] = formattedValue.split(',')\n\n    formattedValue = [Number(lng), Number(lat), Number(maxDistance), Number(minDistance)]\n  }\n\n  if (operator === 'contains') {\n    formattedValue = `%${formattedValue}%`\n  }\n\n  if (operator === 'exists') {\n    formattedValue = val === 'true' || val === true\n\n    if (formattedValue) {\n      operator = 'exists'\n    } else {\n      operator = 'isNull'\n    }\n  }\n\n  return {\n    columns: formattedColumns,\n    operator,\n    value: formattedValue,\n  }\n}\n"],"names":["APIError","createArrayFromCommaDelineated","fieldAffectsData","validate","uuidValidate","getCollectionIdType","isPolymorphicRelationship","isRawConstraint","sanitizeQueryValue","adapter","columns","field","isUUID","operator","operatorArg","relationOrPath","val","formattedValue","formattedColumns","value","type","endsWith","Array","isArray","allPossibleIDTypes","forEach","idType","push","parseInt","String","toLowerCase","includes","map","arrayVal","parseFloat","Number","isNaN","Date","toISOString","parse","undefined","relationTo","collection","payload","collections","rawColumn","eachVal","filter","Boolean","hasMany","lng","lat","maxDistance","minDistance","split"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1019, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1025, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queries/parseParams.ts"],"sourcesContent":["import type { SQL, Table } from 'drizzle-orm'\nimport type { FlattenedField, Operator, Where } from 'payload'\n\nimport { and, isNotNull, isNull, ne, notInArray, or, sql } from 'drizzle-orm'\nimport { PgUUID } from 'drizzle-orm/pg-core'\nimport { QueryError } from 'payload'\nimport { validOperatorSet } from 'payload/shared'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\nimport { buildAndOrConditions } from './buildAndOrConditions.js'\nimport { getTableColumnFromPath } from './getTableColumnFromPath.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale: string\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  where: Where\n}\n\nexport function parseParams({\n  adapter,\n  aliasTable,\n  fields,\n  joins,\n  locale,\n  selectFields,\n  selectLocale,\n  tableName,\n  where,\n}: Args): SQL {\n  let result: SQL\n  const constraints: SQL[] = []\n\n  if (typeof where === 'object' && Object.keys(where).length > 0) {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    for (const relationOrPath of Object.keys(where)) {\n      if (relationOrPath) {\n        const condition = where[relationOrPath]\n        let conditionOperator: typeof and | typeof or\n        if (relationOrPath.toLowerCase() === 'and') {\n          conditionOperator = and\n        } else if (relationOrPath.toLowerCase() === 'or') {\n          conditionOperator = or\n        }\n        if (Array.isArray(condition)) {\n          const builtConditions = buildAndOrConditions({\n            adapter,\n            aliasTable,\n            fields,\n            joins,\n            locale,\n            selectFields,\n            selectLocale,\n            tableName,\n            where: condition,\n          })\n          if (builtConditions.length > 0) {\n            result = conditionOperator(...builtConditions)\n          }\n        } else {\n          // It's a path - and there can be multiple comparisons on a single path.\n          // For example - title like 'test' and title not equal to 'tester'\n          // So we need to loop on keys again here to handle each operator independently\n          const pathOperators = where[relationOrPath]\n          if (typeof pathOperators === 'object') {\n            for (let operator of Object.keys(pathOperators)) {\n              if (validOperatorSet.has(operator as Operator)) {\n                const val = where[relationOrPath][operator]\n\n                const {\n                  columnName,\n                  columns,\n                  constraints: queryConstraints,\n                  field,\n                  getNotNullColumnByValue,\n                  pathSegments,\n                  rawColumn,\n                  table,\n                } = getTableColumnFromPath({\n                  adapter,\n                  aliasTable,\n                  collectionPath: relationOrPath,\n                  fields,\n                  joins,\n                  locale,\n                  pathSegments: relationOrPath.replace(/__/g, '.').split('.'),\n                  selectFields,\n                  selectLocale,\n                  tableName,\n                  value: val,\n                })\n\n                queryConstraints.forEach(({ columnName: col, table: constraintTable, value }) => {\n                  if (typeof value === 'string' && value.indexOf('%') > -1) {\n                    constraints.push(adapter.operators.like(constraintTable[col], value))\n                  } else {\n                    constraints.push(adapter.operators.equals(constraintTable[col], value))\n                  }\n                })\n\n                if (\n                  ['json', 'richText'].includes(field.type) &&\n                  Array.isArray(pathSegments) &&\n                  pathSegments.length > 1\n                ) {\n                  if (adapter.name === 'postgres') {\n                    const constraint = adapter.createJSONQuery({\n                      column: rawColumn || table[columnName],\n                      operator,\n                      pathSegments,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(constraint))\n                    break\n                  }\n\n                  const segments = pathSegments.slice(1)\n                  segments.unshift(table[columnName].name)\n\n                  if (field.type === 'richText') {\n                    // use the table name from the nearest join to handle blocks, arrays, etc. or use the tableName arg\n                    const jsonTable =\n                      joins.length === 0\n                        ? tableName\n                        : joins[joins.length - 1].table[\n                            Object.getOwnPropertySymbols(joins[joins.length - 1].table)[0]\n                          ]\n                    const jsonQuery = adapter.createJSONQuery({\n                      operator,\n                      pathSegments: segments,\n                      table: jsonTable,\n                      treatAsArray: ['children'],\n                      treatRootAsArray: true,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(jsonQuery))\n                    break\n                  }\n\n                  const jsonQuery = adapter.convertPathToJSONTraversal(pathSegments)\n                  const operatorKeys: Record<string, { operator: string; wildcard: string }> = {\n                    contains: { operator: 'like', wildcard: '%' },\n                    equals: { operator: '=', wildcard: '' },\n                    exists: { operator: val === true ? 'is not null' : 'is null', wildcard: '' },\n                    in: { operator: 'in', wildcard: '' },\n                    like: { operator: 'like', wildcard: '%' },\n                    not_equals: { operator: '<>', wildcard: '' },\n                    not_in: { operator: 'not in', wildcard: '' },\n                  }\n\n                  let formattedValue = val\n                  if (adapter.name === 'sqlite' && operator === 'equals' && !isNaN(val)) {\n                    formattedValue = val\n                  } else if (['in', 'not_in'].includes(operator) && Array.isArray(val)) {\n                    formattedValue = `(${val.map((v) => `${v}`).join(',')})`\n                  } else {\n                    formattedValue = `'${operatorKeys[operator].wildcard}${val}${operatorKeys[operator].wildcard}'`\n                  }\n                  if (operator === 'exists') {\n                    formattedValue = ''\n                  }\n\n                  constraints.push(\n                    sql.raw(\n                      `${table[columnName].name}${jsonQuery} ${operatorKeys[operator].operator} ${formattedValue}`,\n                    ),\n                  )\n\n                  break\n                }\n\n                if (getNotNullColumnByValue) {\n                  const columnName = getNotNullColumnByValue(val)\n                  if (columnName) {\n                    constraints.push(isNotNull(table[columnName]))\n                  } else {\n                    throw new QueryError([{ path: relationOrPath }])\n                  }\n                  break\n                }\n\n                if (\n                  operator === 'like' &&\n                  (field.type === 'number' || table[columnName].columnType === 'PgUUID')\n                ) {\n                  operator = 'equals'\n                }\n\n                if (operator === 'like') {\n                  constraints.push(\n                    and(\n                      ...val\n                        .split(' ')\n                        .map((word) => adapter.operators.like(table[columnName], `%${word}%`)),\n                    ),\n                  )\n                  break\n                }\n\n                const sanitizedQueryValue = sanitizeQueryValue({\n                  adapter,\n                  columns,\n                  field,\n                  isUUID: table?.[columnName] instanceof PgUUID,\n                  operator,\n                  relationOrPath,\n                  val,\n                })\n\n                if (sanitizedQueryValue === null) {\n                  break\n                }\n\n                const {\n                  columns: queryColumns,\n                  operator: queryOperator,\n                  value: queryValue,\n                } = sanitizedQueryValue\n\n                // Handle polymorphic relationships by value\n                if (queryColumns) {\n                  if (!queryColumns.length) {\n                    break\n                  }\n\n                  let wrapOperator = or\n\n                  if (queryValue === null && ['equals', 'not_equals'].includes(operator)) {\n                    if (operator === 'equals') {\n                      wrapOperator = and\n                    }\n\n                    constraints.push(\n                      wrapOperator(\n                        ...queryColumns.map(({ rawColumn }) =>\n                          operator === 'equals' ? isNull(rawColumn) : isNotNull(rawColumn),\n                        ),\n                      ),\n                    )\n                    break\n                  }\n\n                  if (['not_equals', 'not_in'].includes(operator)) {\n                    wrapOperator = and\n                  }\n\n                  constraints.push(\n                    wrapOperator(\n                      ...queryColumns.map(({ rawColumn, value }) =>\n                        adapter.operators[queryOperator](rawColumn, value),\n                      ),\n                    ),\n                  )\n\n                  break\n                }\n\n                const resolvedColumn =\n                  rawColumn ||\n                  (aliasTable && tableName === getNameFromDrizzleTable(table)\n                    ? aliasTable[columnName]\n                    : table[columnName])\n\n                if (queryOperator === 'not_equals' && queryValue !== null) {\n                  constraints.push(\n                    or(\n                      isNull(resolvedColumn),\n                      /* eslint-disable @typescript-eslint/no-explicit-any */\n                      ne<any>(resolvedColumn, queryValue),\n                    ),\n                  )\n                  break\n                }\n\n                if (\n                  (field.type === 'relationship' || field.type === 'upload') &&\n                  Array.isArray(queryValue) &&\n                  operator === 'not_in'\n                ) {\n                  constraints.push(\n                    sql`(${notInArray(table[columnName], queryValue)} OR\n                    ${table[columnName]}\n                    IS\n                    NULL)`,\n                  )\n\n                  break\n                }\n\n                if (operator === 'equals' && queryValue === null) {\n                  constraints.push(isNull(resolvedColumn))\n                  break\n                }\n\n                if (operator === 'not_equals' && queryValue === null) {\n                  constraints.push(isNotNull(resolvedColumn))\n                  break\n                }\n\n                if (field.type === 'point' && adapter.name === 'postgres') {\n                  switch (operator) {\n                    case 'intersects': {\n                      constraints.push(\n                        sql`ST_Intersects(${table[columnName]}, ST_GeomFromGeoJSON(${JSON.stringify(queryValue)}))`,\n                      )\n                      break\n                    }\n\n                    case 'near': {\n                      const [lng, lat, maxDistance, minDistance] = queryValue as number[]\n                      const geoConstraints: SQL[] = []\n\n                      if (typeof maxDistance === 'number' && !Number.isNaN(maxDistance)) {\n                        geoConstraints.push(\n                          sql`ST_DWithin(ST_Transform(${table[columnName]}, 3857), ST_Transform(ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326), 3857), ${maxDistance})`,\n                        )\n                      }\n\n                      if (typeof minDistance === 'number' && !Number.isNaN(minDistance)) {\n                        geoConstraints.push(\n                          sql`ST_Distance(ST_Transform(${table[columnName]}, 3857), ST_Transform(ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326), 3857)) >= ${minDistance}`,\n                        )\n                      }\n                      if (geoConstraints.length) {\n                        constraints.push(and(...geoConstraints))\n                      }\n                      break\n                    }\n\n                    case 'within': {\n                      constraints.push(\n                        sql`ST_Within(${table[columnName]}, ST_GeomFromGeoJSON(${JSON.stringify(queryValue)}))`,\n                      )\n                      break\n                    }\n\n                    default:\n                      break\n                  }\n                  break\n                }\n\n                constraints.push(adapter.operators[queryOperator](resolvedColumn, queryValue))\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (constraints.length > 0) {\n    if (result) {\n      result = and(result, ...constraints)\n    } else {\n      result = and(...constraints)\n    }\n  }\n  if (constraints.length === 1 && !result) {\n    ;[result] = constraints\n  }\n\n  return result\n}\n"],"names":["and","isNotNull","isNull","ne","notInArray","or","sql","PgUUID","QueryError","validOperatorSet","getNameFromDrizzleTable","buildAndOrConditions","getTableColumnFromPath","sanitizeQueryValue","parseParams","adapter","aliasTable","fields","joins","locale","selectFields","selectLocale","tableName","where","result","constraints","Object","keys","length","relationOrPath","condition","conditionOperator","toLowerCase","Array","isArray","builtConditions","pathOperators","operator","has","val","columnName","columns","queryConstraints","field","getNotNullColumnByValue","pathSegments","rawColumn","table","collectionPath","replace","split","value","forEach","col","constraintTable","indexOf","push","operators","like","equals","includes","type","name","constraint","createJSONQuery","column","raw","segments","slice","unshift","jsonTable","getOwnPropertySymbols","jsonQuery","treatAsArray","treatRootAsArray","convertPathToJSONTraversal","operatorKeys","contains","wildcard","exists","in","not_equals","not_in","formattedValue","isNaN","map","v","join","path","columnType","word","sanitizedQueryValue","isUUID","queryColumns","queryOperator","queryValue","wrapOperator","resolvedColumn","JSON","stringify","lng","lat","maxDistance","minDistance","geoConstraints","Number"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1314, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1320, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queries/buildQuery.ts"],"sourcesContent":["import type { asc, desc, SQL, Table } from 'drizzle-orm'\nimport type { PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport type { FlattenedField, Sort, Where } from 'payload'\n\nimport type { DrizzleAdapter, GenericColumn, GenericTable } from '../types.js'\n\nimport { buildOrderBy } from './buildOrderBy.js'\nimport { parseParams } from './parseParams.js'\n\nexport type BuildQueryJoinAliases = {\n  condition: SQL\n  queryPath?: string\n  table: GenericTable | PgTableWithColumns<any>\n  type?: 'innerJoin' | 'leftJoin' | 'rightJoin'\n}[]\n\ntype BuildQueryArgs = {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  fields: FlattenedField[]\n  joins?: BuildQueryJoinAliases\n  locale?: string\n  selectLocale?: boolean\n  sort?: Sort\n  tableName: string\n  where: Where\n}\n\nexport type BuildQueryResult = {\n  joins: BuildQueryJoinAliases\n  orderBy: {\n    column: GenericColumn\n    order: typeof asc | typeof desc\n  }[]\n  selectFields: Record<string, GenericColumn>\n  where: SQL\n}\nconst buildQuery = function buildQuery({\n  adapter,\n  aliasTable,\n  fields,\n  joins = [],\n  locale,\n  selectLocale,\n  sort,\n  tableName,\n  where: incomingWhere,\n}: BuildQueryArgs): BuildQueryResult {\n  const selectFields: Record<string, GenericColumn> = {\n    id: adapter.tables[tableName].id,\n  }\n\n  const orderBy = buildOrderBy({\n    adapter,\n    aliasTable,\n    fields,\n    joins,\n    locale,\n    selectFields,\n    sort,\n    tableName,\n  })\n\n  let where: SQL\n\n  if (incomingWhere && Object.keys(incomingWhere).length > 0) {\n    where = parseParams({\n      adapter,\n      aliasTable,\n      fields,\n      joins,\n      locale,\n      selectFields,\n      selectLocale,\n      tableName,\n      where: incomingWhere,\n    })\n  }\n\n  return {\n    joins,\n    orderBy,\n    selectFields,\n    where,\n  }\n}\n\nexport default buildQuery\n"],"names":["buildOrderBy","parseParams","buildQuery","adapter","aliasTable","fields","joins","locale","selectLocale","sort","tableName","where","incomingWhere","selectFields","id","tables","orderBy","Object","keys","length"],"mappings":";;;AAMA,SAASA,YAAY,QAAQ,oBAAmB;AAChD,SAASC,WAAW,QAAQ,mBAAkB;;;AA8B9C,MAAMC,aAAa,SAASA,WAAW,EACrCC,OAAO,EACPC,UAAU,EACVC,MAAM,EACNC,QAAQ,EAAE,EACVC,MAAM,EACNC,YAAY,EACZC,IAAI,EACJC,SAAS,EACTC,OAAOC,aAAa,EACL;IACf,MAAMC,eAA8C;QAClDC,IAAIX,QAAQY,MAAM,CAACL,UAAU,CAACI,EAAE;IAClC;IAEA,MAAME,4YAAUhB,eAAAA,EAAa;QAC3BG;QACAC;QACAC;QACAC;QACAC;QACAM;QACAJ;QACAC;IACF;IAEA,IAAIC;IAEJ,IAAIC,iBAAiBK,OAAOC,IAAI,CAACN,eAAeO,MAAM,GAAG,GAAG;QAC1DR,yYAAQV,cAAAA,EAAY;YAClBE;YACAC;YACAC;YACAC;YACAC;YACAM;YACAL;YACAE;YACAC,OAAOC;QACT;IACF;IAEA,OAAO;QACLN;QACAU;QACAH;QACAF;IACF;AACF;uCAEeT,WAAU","ignoreList":[0]}},
    {"offset": {"line": 1364, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1370, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/getTransaction.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport type { DrizzleAdapter } from '../types.js'\n\n/**\n * Returns current db transaction instance from req or adapter.drizzle itself\n */\nexport const getTransaction = async <T extends DrizzleAdapter = DrizzleAdapter>(\n  adapter: T,\n  req?: Partial<PayloadRequest>,\n): Promise<T['drizzle']> => {\n  if (!req?.transactionID) {\n    return adapter.drizzle\n  }\n\n  return (adapter.sessions[await req.transactionID]?.db as T['drizzle']) || adapter.drizzle\n}\n"],"names":["getTransaction","adapter","req","transactionID","drizzle","sessions","db"],"mappings":"AAIA;;CAEC,GACD;;;AAAO,MAAMA,iBAAiB,OAC5BC,SACAC;IAEA,IAAI,CAACA,KAAKC,eAAe;QACvB,OAAOF,QAAQG,OAAO;IACxB;IAEA,OAAQH,QAAQI,QAAQ,CAAC,MAAMH,IAAIC,aAAa,CAAC,EAAEG,MAAuBL,QAAQG,OAAO;AAC3F,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1381, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1387, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/count.ts"],"sourcesContent":["import type { Count, SanitizedCollectionConfig } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport buildQuery from './queries/buildQuery.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const count: Count = async function count(\n  this: DrizzleAdapter,\n  { collection, locale, req, where: whereArg },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  const db = await getTransaction(this, req)\n\n  const { joins, where } = buildQuery({\n    adapter: this,\n    fields: collectionConfig.flattenedFields,\n    locale,\n    tableName,\n    where: whereArg,\n  })\n\n  const countResult = await this.countDistinct({\n    db,\n    joins,\n    tableName,\n    where,\n  })\n\n  return { totalDocs: countResult }\n}\n"],"names":["toSnakeCase","buildQuery","getTransaction","count","collection","locale","req","where","whereArg","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","db","joins","adapter","fields","flattenedFields","countResult","countDistinct","totalDocs"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;AAEvD,MAAMC,QAAe,eAAeA,MAEzC,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAOC,QAAQ,EAAE;IAE5C,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACP,WAAW,CAACQ,MAAM;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kNAACf,UAAAA,EAAYS,iBAAiBO,IAAI;IAEzE,MAAMC,KAAK,4YAAMf,iBAAAA,EAAe,IAAI,EAAEI;IAEtC,MAAM,EAAEY,KAAK,EAAEX,KAAK,EAAE,mYAAGN,UAAAA,EAAW;QAClCkB,SAAS,IAAI;QACbC,QAAQX,iBAAiBY,eAAe;QACxChB;QACAQ;QACAN,OAAOC;IACT;IAEA,MAAMc,cAAc,MAAM,IAAI,CAACC,aAAa,CAAC;QAC3CN;QACAC;QACAL;QACAN;IACF;IAEA,OAAO;QAAEiB,WAAWF;IAAY;AAClC,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1417, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1423, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/countGlobalVersions.ts"],"sourcesContent":["import type { CountGlobalVersions, SanitizedGlobalConfig } from 'payload'\n\nimport { buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport buildQuery from './queries/buildQuery.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const countGlobalVersions: CountGlobalVersions = async function countGlobalVersions(\n  this: DrizzleAdapter,\n  { global, locale, req, where: whereArg },\n) {\n  const globalConfig: SanitizedGlobalConfig = this.payload.globals.config.find(\n    ({ slug }) => slug === global,\n  )\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(globalConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const db = await getTransaction(this, req)\n\n  const fields = buildVersionGlobalFields(this.payload.config, globalConfig, true)\n\n  const { joins, where } = buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    tableName,\n    where: whereArg,\n  })\n\n  const countResult = await this.countDistinct({\n    db,\n    joins,\n    tableName,\n    where,\n  })\n\n  return { totalDocs: countResult }\n}\n"],"names":["buildVersionGlobalFields","toSnakeCase","buildQuery","getTransaction","countGlobalVersions","global","locale","req","where","whereArg","globalConfig","payload","globals","config","find","slug","tableName","tableNameMap","get","versionsSuffix","db","fields","joins","adapter","countResult","countDistinct","totalDocs"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AAIvC,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;AAN9D,SAASH,wBAAwB,QAAQ,UAAS;;;;;AAQ3C,MAAMI,sBAA2C,eAAeA,oBAErE,EAAEC,MAAM,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAOC,QAAQ,EAAE;IAExC,MAAMC,eAAsC,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAC1E,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASV;IAGzB,MAAMW,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mNAAEjB,UAAAA,EAAYS,aAAaK,IAAI,IAAI,IAAI,CAACI,cAAc,EAAE;IAG5D,MAAMC,KAAK,4YAAMjB,iBAAAA,EAAe,IAAI,EAAEI;IAEtC,MAAMc,oYAASrB,2BAAAA,EAAyB,IAAI,CAACW,OAAO,CAACE,MAAM,EAAEH,cAAc;IAE3E,MAAM,EAAEY,KAAK,EAAEd,KAAK,EAAE,IAAGN,yYAAAA,EAAW;QAClCqB,SAAS,IAAI;QACbF;QACAf;QACAU;QACAR,OAAOC;IACT;IAEA,MAAMe,cAAc,MAAM,IAAI,CAACC,aAAa,CAAC;QAC3CL;QACAE;QACAN;QACAR;IACF;IAEA,OAAO;QAAEkB,WAAWF;IAAY;AAClC,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1456, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1462, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/countVersions.ts"],"sourcesContent":["import type { CountVersions, SanitizedCollectionConfig } from 'payload'\n\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport buildQuery from './queries/buildQuery.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const countVersions: CountVersions = async function countVersions(\n  this: DrizzleAdapter,\n  { collection, locale, req, where: whereArg },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const db = await getTransaction(this, req)\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n\n  const { joins, where } = buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    tableName,\n    where: whereArg,\n  })\n\n  const countResult = await this.countDistinct({\n    db,\n    joins,\n    tableName,\n    where,\n  })\n\n  return { totalDocs: countResult }\n}\n"],"names":["buildVersionCollectionFields","toSnakeCase","buildQuery","getTransaction","countVersions","collection","locale","req","where","whereArg","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","versionsSuffix","db","fields","joins","adapter","countResult","countDistinct","totalDocs"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AAIvC,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;AAN9D,SAASH,4BAA4B,QAAQ,UAAS;;;;;AAQ/C,MAAMI,gBAA+B,eAAeA,cAEzD,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAOC,QAAQ,EAAE;IAE5C,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACP,WAAW,CAACQ,MAAM;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,EAAEf,2NAAAA,EAAYS,iBAAiBO,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE;IAGhE,MAAMC,KAAK,4YAAMhB,iBAAAA,EAAe,IAAI,EAAEI;IAEtC,MAAMa,UAASpB,6ZAAAA,EAA6B,IAAI,CAACW,OAAO,CAACE,MAAM,EAAEH,kBAAkB;IAEnF,MAAM,EAAEW,KAAK,EAAEb,KAAK,EAAE,mYAAGN,UAAAA,EAAW;QAClCoB,SAAS,IAAI;QACbF;QACAd;QACAQ;QACAN,OAAOC;IACT;IAEA,MAAMc,cAAc,MAAM,IAAI,CAACC,aAAa,CAAC;QAC3CL;QACAE;QACAP;QACAN;IACF;IAEA,OAAO;QAAEiB,WAAWF;IAAY;AAClC,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1495, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1501, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/json.ts"],"sourcesContent":["import type { Column, SQL } from 'drizzle-orm'\n\nimport { sql } from 'drizzle-orm'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nexport function jsonAgg(adapter: DrizzleAdapter, expression: SQL) {\n  if (adapter.name === 'sqlite') {\n    return sql`coalesce(json_group_array(${expression}), '[]')`\n  }\n\n  return sql`coalesce(json_agg(${expression}), '[]'::json)`\n}\n\n/**\n * @param shape Potential for SQL injections, so you shouldn't allow user-specified key names\n */\nexport function jsonBuildObject<T extends Record<string, Column | SQL>>(\n  adapter: DrizzleAdapter,\n  shape: T,\n) {\n  const chunks: SQL[] = []\n\n  Object.entries(shape).forEach(([key, value]) => {\n    if (chunks.length > 0) {\n      chunks.push(sql.raw(','))\n    }\n    chunks.push(sql.raw(`'${key}',`))\n    chunks.push(sql`${value}`)\n  })\n\n  if (adapter.name === 'sqlite') {\n    return sql`json_object(${sql.join(chunks)})`\n  }\n\n  return sql`json_build_object(${sql.join(chunks)})`\n}\n\nexport const jsonAggBuildObject = <T extends Record<string, Column | SQL>>(\n  adapter: DrizzleAdapter,\n  shape: T,\n) => {\n  return jsonAgg(adapter, jsonBuildObject(adapter, shape))\n}\n"],"names":["sql","jsonAgg","adapter","expression","name","jsonBuildObject","shape","chunks","Object","entries","forEach","key","value","length","push","raw","join","jsonAggBuildObject"],"mappings":";;;;;AAEA,SAASA,GAAG,QAAQ,cAAa;;AAI1B,SAASC,QAAQC,OAAuB,EAAEC,UAAe;IAC9D,IAAID,QAAQE,IAAI,KAAK,UAAU;QAC7B,4TAAOJ,MAAG,CAAC,0BAA0B,EAAEG,WAAW,QAAQ,CAAC;IAC7D;IAEA,4TAAOH,MAAG,CAAC,kBAAkB,EAAEG,WAAW,cAAc,CAAC;AAC3D;AAKO,SAASE,gBACdH,OAAuB,EACvBI,KAAQ;IAER,MAAMC,SAAgB,EAAE;IAExBC,OAAOC,OAAO,CAACH,OAAOI,OAAO,CAAC,CAAC,CAACC,KAAKC,MAAM;QACzC,IAAIL,OAAOM,MAAM,GAAG,GAAG;YACrBN,OAAOO,IAAI,sTAACd,MAAAA,CAAIe,GAAG,CAAC;QACtB;QACAR,OAAOO,IAAI,sTAACd,MAAAA,CAAIe,GAAG,CAAC,CAAC,CAAC,EAAEJ,IAAI,EAAE,CAAC;QAC/BJ,OAAOO,IAAI,sTAACd,MAAG,CAAC,EAAEY,MAAM,CAAC;IAC3B;IAEA,IAAIV,QAAQE,IAAI,KAAK,UAAU;QAC7B,4TAAOJ,MAAG,CAAC,YAAY,uTAAEA,MAAAA,CAAIgB,IAAI,CAACT,QAAQ,CAAC,CAAC;IAC9C;IAEA,4TAAOP,MAAG,CAAC,kBAAkB,uTAAEA,MAAAA,CAAIgB,IAAI,CAACT,QAAQ,CAAC,CAAC;AACpD;AAEO,MAAMU,qBAAqB,CAChCf,SACAI;IAEA,OAAOL,QAAQC,SAASG,gBAAgBH,SAASI;AACnD,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1531, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1537, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/find/chainMethods.ts"],"sourcesContent":["export type ChainedMethods = {\n  args: unknown[]\n  method: string\n}[]\n\n/**\n * Call and returning methods that would normally be chained together but cannot be because of control logic\n * @param methods\n * @param query\n */\nconst chainMethods = <T>({ methods, query }: { methods: ChainedMethods; query: T }): T => {\n  return methods.reduce((query, { args, method }) => {\n    return query[method](...args)\n  }, query)\n}\n\nexport { chainMethods }\n"],"names":["chainMethods","methods","query","reduce","args","method"],"mappings":"AAKA;;;;CAIC;;;AACD,MAAMA,eAAe,CAAI,EAAEC,OAAO,EAAEC,KAAK,EAAyC;IAChF,OAAOD,QAAQE,MAAM,CAAC,CAACD,OAAO,EAAEE,IAAI,EAAEC,MAAM,EAAE;QAC5C,OAAOH,KAAK,CAACG,OAAO,IAAID;IAC1B,GAAGF;AACL","ignoreList":[0]}},
    {"offset": {"line": 1551, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1557, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/find/traverseFields.ts"],"sourcesContent":["import type { LibSQLDatabase } from 'drizzle-orm/libsql'\nimport type { FlattenedField, JoinQuery, SelectMode, SelectType, Where } from 'payload'\n\nimport { sql } from 'drizzle-orm'\nimport { fieldIsVirtual } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { BuildQueryJoinAliases, ChainedMethods, DrizzleAdapter } from '../types.js'\nimport type { Result } from './buildFindManyArgs.js'\n\nimport buildQuery from '../queries/buildQuery.js'\nimport { getTableAlias } from '../queries/getTableAlias.js'\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\nimport { jsonAggBuildObject } from '../utilities/json.js'\nimport { rawConstraint } from '../utilities/rawConstraint.js'\nimport { chainMethods } from './chainMethods.js'\n\ntype TraverseFieldArgs = {\n  _locales: Result\n  adapter: DrizzleAdapter\n  collectionSlug?: string\n  currentArgs: Result\n  currentTableName: string\n  depth?: number\n  fields: FlattenedField[]\n  joinQuery: JoinQuery\n  joins?: BuildQueryJoinAliases\n  locale?: string\n  path: string\n  select?: SelectType\n  selectAllOnCurrentLevel?: boolean\n  selectMode?: SelectMode\n  tablePath: string\n  topLevelArgs: Record<string, unknown>\n  topLevelTableName: string\n  versions?: boolean\n  withinLocalizedField?: boolean\n  withTabledFields: {\n    numbers?: boolean\n    rels?: boolean\n    texts?: boolean\n  }\n}\n\nexport const traverseFields = ({\n  _locales,\n  adapter,\n  collectionSlug,\n  currentArgs,\n  currentTableName,\n  depth,\n  fields,\n  joinQuery = {},\n  joins,\n  locale,\n  path,\n  select,\n  selectAllOnCurrentLevel = false,\n  selectMode,\n  tablePath,\n  topLevelArgs,\n  topLevelTableName,\n  versions,\n  withinLocalizedField = false,\n  withTabledFields,\n}: TraverseFieldArgs) => {\n  fields.forEach((field) => {\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    // handle simple relationship\n    if (\n      depth > 0 &&\n      (field.type === 'upload' || field.type === 'relationship') &&\n      !field.hasMany &&\n      typeof field.relationTo === 'string'\n    ) {\n      if (field.localized) {\n        _locales.with[`${path}${field.name}`] = true\n      } else {\n        currentArgs.with[`${path}${field.name}`] = true\n      }\n    }\n\n    switch (field.type) {\n      case 'array': {\n        const arraySelect = selectAllOnCurrentLevel ? true : select?.[field.name]\n\n        if (select) {\n          if (\n            (selectMode === 'include' && typeof arraySelect === 'undefined') ||\n            (selectMode === 'exclude' && arraySelect === false)\n          ) {\n            break\n          }\n        }\n\n        const withArray: Result = {\n          columns:\n            typeof arraySelect === 'object'\n              ? {\n                  id: true,\n                  _order: true,\n                }\n              : {\n                  _parentID: false,\n                },\n          orderBy: ({ _order }, { asc }) => [asc(_order)],\n          with: {},\n        }\n\n        const arrayTableName = adapter.tableNameMap.get(\n          `${currentTableName}_${tablePath}${toSnakeCase(field.name)}`,\n        )\n\n        if (typeof arraySelect === 'object') {\n          if (adapter.tables[arrayTableName]._locale) {\n            withArray.columns._locale = true\n          }\n\n          if (adapter.tables[arrayTableName]._uuid) {\n            withArray.columns._uuid = true\n          }\n        }\n\n        const arrayTableNameWithLocales = `${arrayTableName}${adapter.localesSuffix}`\n\n        if (adapter.tables[arrayTableNameWithLocales]) {\n          withArray.with._locales = {\n            columns:\n              typeof arraySelect === 'object'\n                ? {\n                    _locale: true,\n                  }\n                : {\n                    id: false,\n                    _parentID: false,\n                  },\n            with: {},\n          }\n        }\n\n        currentArgs.with[`${path}${field.name}`] = withArray\n\n        traverseFields({\n          _locales: withArray.with._locales,\n          adapter,\n          currentArgs: withArray,\n          currentTableName: arrayTableName,\n          depth,\n          fields: field.flattenedFields,\n          joinQuery,\n          locale,\n          path: '',\n          select: typeof arraySelect === 'object' ? arraySelect : undefined,\n          selectMode,\n          tablePath: '',\n          topLevelArgs,\n          topLevelTableName,\n          withinLocalizedField: withinLocalizedField || field.localized,\n          withTabledFields,\n        })\n\n        if (\n          typeof arraySelect === 'object' &&\n          withArray.with._locales &&\n          Object.keys(withArray.with._locales).length === 1\n        ) {\n          delete withArray.with._locales\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const blocksSelect = selectAllOnCurrentLevel ? true : select?.[field.name]\n\n        if (select) {\n          if (\n            (selectMode === 'include' && !blocksSelect) ||\n            (selectMode === 'exclude' && blocksSelect === false)\n          ) {\n            break\n          }\n        }\n\n        field.blocks.forEach((block) => {\n          const blockKey = `_blocks_${block.slug}`\n\n          let blockSelect: boolean | SelectType | undefined\n\n          let blockSelectMode = selectMode\n\n          if (selectMode === 'include' && blocksSelect === true) {\n            blockSelect = true\n          }\n\n          if (typeof blocksSelect === 'object') {\n            if (typeof blocksSelect[block.slug] === 'object') {\n              blockSelect = blocksSelect[block.slug]\n            } else if (\n              (selectMode === 'include' && typeof blocksSelect[block.slug] === 'undefined') ||\n              (selectMode === 'exclude' && blocksSelect[block.slug] === false)\n            ) {\n              blockSelect = {}\n              blockSelectMode = 'include'\n            } else if (selectMode === 'include' && blocksSelect[block.slug] === true) {\n              blockSelect = true\n            }\n          }\n\n          if (!topLevelArgs[blockKey]) {\n            const withBlock: Result = {\n              columns:\n                typeof blockSelect === 'object'\n                  ? {\n                      id: true,\n                      _order: true,\n                      _path: true,\n                    }\n                  : {\n                      _parentID: false,\n                    },\n              orderBy: ({ _order }, { asc }) => [asc(_order)],\n              with: {},\n            }\n\n            const tableName = adapter.tableNameMap.get(\n              `${topLevelTableName}_blocks_${toSnakeCase(block.slug)}`,\n            )\n\n            if (typeof blockSelect === 'object') {\n              if (adapter.tables[tableName]._locale) {\n                withBlock.columns._locale = true\n              }\n\n              if (adapter.tables[tableName]._uuid) {\n                withBlock.columns._uuid = true\n              }\n            }\n\n            if (adapter.tables[`${tableName}${adapter.localesSuffix}`]) {\n              withBlock.with._locales = {\n                with: {},\n              }\n\n              if (typeof blockSelect === 'object') {\n                withBlock.with._locales.columns = {\n                  _locale: true,\n                }\n              }\n            }\n            topLevelArgs.with[blockKey] = withBlock\n\n            traverseFields({\n              _locales: withBlock.with._locales,\n              adapter,\n              currentArgs: withBlock,\n              currentTableName: tableName,\n              depth,\n              fields: block.flattenedFields,\n              joinQuery,\n              locale,\n              path: '',\n              select: typeof blockSelect === 'object' ? blockSelect : undefined,\n              selectMode: blockSelectMode,\n              tablePath: '',\n              topLevelArgs,\n              topLevelTableName,\n              withinLocalizedField: withinLocalizedField || field.localized,\n              withTabledFields,\n            })\n\n            if (\n              typeof blockSelect === 'object' &&\n              withBlock.with._locales &&\n              Object.keys(withBlock.with._locales.columns).length === 1\n            ) {\n              delete withBlock.with._locales\n            }\n          }\n        })\n\n        break\n      }\n\n      case 'group':\n      case 'tab': {\n        const fieldSelect = select?.[field.name]\n\n        if (fieldSelect === false) {\n          break\n        }\n\n        traverseFields({\n          _locales,\n          adapter,\n          collectionSlug,\n          currentArgs,\n          currentTableName,\n          depth,\n          fields: field.flattenedFields,\n          joinQuery,\n          joins,\n          locale,\n          path: `${path}${field.name}_`,\n          select: typeof fieldSelect === 'object' ? fieldSelect : undefined,\n          selectAllOnCurrentLevel:\n            selectAllOnCurrentLevel ||\n            fieldSelect === true ||\n            (selectMode === 'exclude' && typeof fieldSelect === 'undefined'),\n          selectMode,\n          tablePath: `${tablePath}${toSnakeCase(field.name)}_`,\n          topLevelArgs,\n          topLevelTableName,\n          versions,\n          withinLocalizedField: withinLocalizedField || field.localized,\n          withTabledFields,\n        })\n\n        break\n      }\n      case 'join': {\n        // when `joinsQuery` is false, do not join\n        if (joinQuery === false) {\n          break\n        }\n\n        if (\n          (select && selectMode === 'include' && !select[field.name]) ||\n          (selectMode === 'exclude' && select[field.name] === false)\n        ) {\n          break\n        }\n\n        const joinSchemaPath = `${path.replaceAll('_', '.')}${field.name}`\n\n        if (joinQuery[joinSchemaPath] === false) {\n          break\n        }\n\n        const {\n          limit: limitArg = field.defaultLimit ?? 10,\n          sort = field.defaultSort,\n          where,\n        } = joinQuery[joinSchemaPath] || {}\n        let limit = limitArg\n\n        if (limit !== 0) {\n          // get an additional document and slice it later to determine if there is a next page\n          limit += 1\n        }\n\n        const fields = adapter.payload.collections[field.collection].config.flattenedFields\n\n        const joinCollectionTableName = adapter.tableNameMap.get(toSnakeCase(field.collection))\n\n        const joins: BuildQueryJoinAliases = []\n\n        const currentIDColumn = versions\n          ? adapter.tables[currentTableName].parent\n          : adapter.tables[currentTableName].id\n\n        let joinQueryWhere: Where\n\n        if (Array.isArray(field.targetField.relationTo)) {\n          joinQueryWhere = {\n            [field.on]: {\n              equals: {\n                relationTo: collectionSlug,\n                value: rawConstraint(currentIDColumn),\n              },\n            },\n          }\n        } else {\n          joinQueryWhere = {\n            [field.on]: {\n              equals: rawConstraint(currentIDColumn),\n            },\n          }\n        }\n\n        if (where && Object.keys(where).length) {\n          joinQueryWhere = {\n            and: [joinQueryWhere, where],\n          }\n        }\n\n        const columnName = `${path.replaceAll('.', '_')}${field.name}`\n\n        const subQueryAlias = `${columnName}_alias`\n\n        const { newAliasTable } = getTableAlias({\n          adapter,\n          tableName: joinCollectionTableName,\n        })\n\n        const {\n          orderBy,\n          selectFields,\n          where: subQueryWhere,\n        } = buildQuery({\n          adapter,\n          aliasTable: newAliasTable,\n          fields,\n          joins,\n          locale,\n          selectLocale: true,\n          sort,\n          tableName: joinCollectionTableName,\n          where: joinQueryWhere,\n        })\n\n        const chainedMethods: ChainedMethods = []\n\n        joins.forEach(({ type, condition, table }) => {\n          chainedMethods.push({\n            args: [table, condition],\n            method: type ?? 'leftJoin',\n          })\n        })\n\n        if (limit !== 0) {\n          chainedMethods.push({\n            args: [limit],\n            method: 'limit',\n          })\n        }\n\n        const db = adapter.drizzle as LibSQLDatabase\n\n        for (let key in selectFields) {\n          const val = selectFields[key]\n\n          if (val.table && getNameFromDrizzleTable(val.table) === joinCollectionTableName) {\n            delete selectFields[key]\n            key = key.split('.').pop()\n            selectFields[key] = newAliasTable[key]\n          }\n        }\n\n        const subQuery = chainMethods({\n          methods: chainedMethods,\n          query: db\n            .select(selectFields as any)\n            .from(newAliasTable)\n            .where(subQueryWhere)\n            .orderBy(() => orderBy.map(({ column, order }) => order(column))),\n        }).as(subQueryAlias)\n\n        currentArgs.extras[columnName] = sql`${db\n          .select({\n            result: jsonAggBuildObject(adapter, {\n              id: sql.raw(`\"${subQueryAlias}\".id`),\n              ...(selectFields._locale && {\n                locale: sql.raw(`\"${subQueryAlias}\".${selectFields._locale.name}`),\n              }),\n            }),\n          })\n          .from(sql`${subQuery}`)}`.as(subQueryAlias)\n\n        break\n      }\n\n      case 'point': {\n        if (adapter.name === 'sqlite') {\n          break\n        }\n\n        const args = field.localized ? _locales : currentArgs\n        if (!args.columns) {\n          args.columns = {}\n        }\n\n        if (!args.extras) {\n          args.extras = {}\n        }\n\n        const name = `${path}${field.name}`\n\n        // Drizzle handles that poorly. See https://github.com/drizzle-team/drizzle-orm/issues/2526\n        // Additionally, this way we format the column value straight in the database using ST_AsGeoJSON\n        args.columns[name] = false\n\n        let shouldSelect = false\n\n        if (select || selectAllOnCurrentLevel) {\n          if (\n            selectAllOnCurrentLevel ||\n            (selectMode === 'include' && select[field.name] === true) ||\n            (selectMode === 'exclude' && typeof select[field.name] === 'undefined')\n          ) {\n            shouldSelect = true\n          }\n        } else {\n          shouldSelect = true\n        }\n\n        if (shouldSelect) {\n          args.extras[name] = sql.raw(`ST_AsGeoJSON(${toSnakeCase(name)})::jsonb`).as(name)\n        }\n        break\n      }\n\n      case 'select': {\n        if (select && !selectAllOnCurrentLevel) {\n          if (\n            (selectMode === 'include' && !select[field.name]) ||\n            (selectMode === 'exclude' && select[field.name] === false)\n          ) {\n            break\n          }\n        }\n\n        if (field.hasMany) {\n          const withSelect: Result = {\n            columns: {\n              id: false,\n              order: false,\n              parent: false,\n            },\n            orderBy: ({ order }, { asc }) => [asc(order)],\n          }\n\n          currentArgs.with[`${path}${field.name}`] = withSelect\n          break\n        }\n\n        if (select || selectAllOnCurrentLevel) {\n          const fieldPath = `${path}${field.name}`\n\n          if ((field.localized || withinLocalizedField) && _locales) {\n            _locales.columns[fieldPath] = true\n          } else if (adapter.tables[currentTableName]?.[fieldPath]) {\n            currentArgs.columns[fieldPath] = true\n          }\n        }\n\n        break\n      }\n\n      default: {\n        if (!select && !selectAllOnCurrentLevel) {\n          break\n        }\n\n        if (\n          selectAllOnCurrentLevel ||\n          (selectMode === 'include' && select[field.name] === true) ||\n          (selectMode === 'exclude' && typeof select[field.name] === 'undefined')\n        ) {\n          const fieldPath = `${path}${field.name}`\n\n          if ((field.localized || withinLocalizedField) && _locales) {\n            _locales.columns[fieldPath] = true\n          } else if (adapter.tables[currentTableName]?.[fieldPath]) {\n            currentArgs.columns[fieldPath] = true\n          }\n\n          if (\n            !withTabledFields.rels &&\n            (field.type === 'relationship' || field.type === 'upload') &&\n            (field.hasMany || Array.isArray(field.relationTo))\n          ) {\n            withTabledFields.rels = true\n          }\n\n          if (!withTabledFields.numbers && field.type === 'number' && field.hasMany) {\n            withTabledFields.numbers = true\n          }\n\n          if (!withTabledFields.texts && field.type === 'text' && field.hasMany) {\n            withTabledFields.texts = true\n          }\n        }\n\n        break\n      }\n    }\n  })\n\n  return topLevelArgs\n}\n"],"names":["sql","fieldIsVirtual","toSnakeCase","buildQuery","getTableAlias","getNameFromDrizzleTable","jsonAggBuildObject","rawConstraint","chainMethods","traverseFields","_locales","adapter","collectionSlug","currentArgs","currentTableName","depth","fields","joinQuery","joins","locale","path","select","selectAllOnCurrentLevel","selectMode","tablePath","topLevelArgs","topLevelTableName","versions","withinLocalizedField","withTabledFields","forEach","field","type","hasMany","relationTo","localized","with","name","arraySelect","withArray","columns","id","_order","_parentID","orderBy","asc","arrayTableName","tableNameMap","get","tables","_locale","_uuid","arrayTableNameWithLocales","localesSuffix","flattenedFields","undefined","Object","keys","length","blocksSelect","blocks","block","blockKey","slug","blockSelect","blockSelectMode","withBlock","_path","tableName","fieldSelect","joinSchemaPath","replaceAll","limit","limitArg","defaultLimit","sort","defaultSort","where","payload","collections","collection","config","joinCollectionTableName","currentIDColumn","parent","joinQueryWhere","Array","isArray","targetField","on","equals","value","and","columnName","subQueryAlias","newAliasTable","selectFields","subQueryWhere","aliasTable","selectLocale","chainedMethods","condition","table","push","args","method","db","drizzle","key","val","split","pop","subQuery","methods","query","from","map","column","order","as","extras","result","raw","shouldSelect","withSelect","fieldPath","rels","numbers","texts"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1966, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1972, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/find/buildFindManyArgs.ts"],"sourcesContent":["import type { DBQueryConfig } from 'drizzle-orm'\nimport type { FlattenedField, JoinQuery, SelectType } from 'payload'\n\nimport { getSelectMode } from 'payload/shared'\n\nimport type { BuildQueryJoinAliases, DrizzleAdapter } from '../types.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype BuildFindQueryArgs = {\n  adapter: DrizzleAdapter\n  collectionSlug?: string\n  depth: number\n  fields: FlattenedField[]\n  joinQuery?: JoinQuery\n  /**\n   * The joins array will be mutated by pushing any joins needed for the where queries of join field joins\n   */\n  joins?: BuildQueryJoinAliases\n  locale?: string\n  select?: SelectType\n  tableName: string\n  versions?: boolean\n}\n\nexport type Result = {\n  with?: {\n    _locales?: DBQueryConfig<'many', true, any, any>\n  } & DBQueryConfig<'many', true, any, any>\n} & DBQueryConfig<'many', true, any, any>\n\n// Generate the Drizzle query for findMany based on\n// a collection field structure\nexport const buildFindManyArgs = ({\n  adapter,\n  collectionSlug,\n  depth,\n  fields,\n  joinQuery,\n  joins = [],\n  locale,\n  select,\n  tableName,\n  versions,\n}: BuildFindQueryArgs): Record<string, unknown> => {\n  const result: Result = {\n    extras: {},\n    with: {},\n  }\n\n  if (select) {\n    result.columns = {\n      id: true,\n    }\n  }\n\n  const _locales: Result = {\n    columns: select\n      ? { _locale: true }\n      : {\n          id: false,\n          _parentID: false,\n        },\n    extras: {},\n    with: {},\n  }\n\n  const withTabledFields = select\n    ? {}\n    : {\n        numbers: true,\n        rels: true,\n        texts: true,\n      }\n\n  traverseFields({\n    _locales,\n    adapter,\n    collectionSlug,\n    currentArgs: result,\n    currentTableName: tableName,\n    depth,\n    fields,\n    joinQuery,\n    joins,\n    locale,\n    path: '',\n    select,\n    selectMode: select ? getSelectMode(select) : undefined,\n    tablePath: '',\n    topLevelArgs: result,\n    topLevelTableName: tableName,\n    versions,\n    withTabledFields,\n  })\n\n  if (adapter.tables[`${tableName}_texts`] && withTabledFields.texts) {\n    result.with._texts = {\n      columns: {\n        id: false,\n        parent: false,\n      },\n      orderBy: ({ order }, { asc: ASC }) => [ASC(order)],\n    }\n  }\n\n  if (adapter.tables[`${tableName}_numbers`] && withTabledFields.numbers) {\n    result.with._numbers = {\n      columns: {\n        id: false,\n        parent: false,\n      },\n      orderBy: ({ order }, { asc: ASC }) => [ASC(order)],\n    }\n  }\n\n  if (adapter.tables[`${tableName}${adapter.relationshipsSuffix}`] && withTabledFields.rels) {\n    result.with._rels = {\n      columns: {\n        id: false,\n        parent: false,\n      },\n      orderBy: ({ order }, { asc: ASC }) => [ASC(order)],\n    }\n  }\n\n  if (\n    adapter.tables[`${tableName}${adapter.localesSuffix}`] &&\n    (!select || Object.keys(_locales.columns).length > 1)\n  ) {\n    result.with._locales = _locales\n  }\n\n  return result\n}\n"],"names":["getSelectMode","traverseFields","buildFindManyArgs","adapter","collectionSlug","depth","fields","joinQuery","joins","locale","select","tableName","versions","result","extras","with","columns","id","_locales","_locale","_parentID","withTabledFields","numbers","rels","texts","currentArgs","currentTableName","path","selectMode","undefined","tablePath","topLevelArgs","topLevelTableName","tables","_texts","parent","orderBy","order","asc","ASC","_numbers","relationshipsSuffix","_rels","localesSuffix","Object","keys","length"],"mappings":";;;AAOA,SAASC,cAAc,QAAQ,sBAAqB;AAJpD,SAASD,aAAa,QAAQ,iBAAgB;;;AA8BvC,MAAME,oBAAoB,CAAC,EAChCC,OAAO,EACPC,cAAc,EACdC,KAAK,EACLC,MAAM,EACNC,SAAS,EACTC,QAAQ,EAAE,EACVC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,QAAQ,EACW;IACnB,MAAMC,SAAiB;QACrBC,QAAQ,CAAC;QACTC,MAAM,CAAC;IACT;IAEA,IAAIL,QAAQ;QACVG,OAAOG,OAAO,GAAG;YACfC,IAAI;QACN;IACF;IAEA,MAAMC,WAAmB;QACvBF,SAASN,SACL;YAAES,SAAS;QAAK,IAChB;YACEF,IAAI;YACJG,WAAW;QACb;QACJN,QAAQ,CAAC;QACTC,MAAM,CAAC;IACT;IAEA,MAAMM,mBAAmBX,SACrB,CAAC,IACD;QACEY,SAAS;QACTC,MAAM;QACNC,OAAO;IACT;qYAEJvB,iBAAAA,EAAe;QACbiB;QACAf;QACAC;QACAqB,aAAaZ;QACba,kBAAkBf;QAClBN;QACAC;QACAC;QACAC;QACAC;QACAkB,MAAM;QACNjB;QACAkB,YAAYlB,aAASV,oYAAAA,EAAcU,UAAUmB;QAC7CC,WAAW;QACXC,cAAclB;QACdmB,mBAAmBrB;QACnBC;QACAS;IACF;IAEA,IAAIlB,QAAQ8B,MAAM,CAAC,GAAGtB,UAAU,MAAM,CAAC,CAAC,IAAIU,iBAAiBG,KAAK,EAAE;QAClEX,OAAOE,IAAI,CAACmB,MAAM,GAAG;YACnBlB,SAAS;gBACPC,IAAI;gBACJkB,QAAQ;YACV;YACAC,SAAS,CAAC,EAAEC,KAAK,EAAE,EAAE,EAAEC,KAAKC,GAAG,EAAE,GAAK;oBAACA,IAAIF;iBAAO;QACpD;IACF;IAEA,IAAIlC,QAAQ8B,MAAM,CAAC,GAAGtB,UAAU,QAAQ,CAAC,CAAC,IAAIU,iBAAiBC,OAAO,EAAE;QACtET,OAAOE,IAAI,CAACyB,QAAQ,GAAG;YACrBxB,SAAS;gBACPC,IAAI;gBACJkB,QAAQ;YACV;YACAC,SAAS,CAAC,EAAEC,KAAK,EAAE,EAAE,EAAEC,KAAKC,GAAG,EAAE,GAAK;oBAACA,IAAIF;iBAAO;QACpD;IACF;IAEA,IAAIlC,QAAQ8B,MAAM,CAAC,GAAGtB,YAAYR,QAAQsC,mBAAmB,EAAE,CAAC,IAAIpB,iBAAiBE,IAAI,EAAE;QACzFV,OAAOE,IAAI,CAAC2B,KAAK,GAAG;YAClB1B,SAAS;gBACPC,IAAI;gBACJkB,QAAQ;YACV;YACAC,SAAS,CAAC,EAAEC,KAAK,EAAE,EAAE,EAAEC,KAAKC,GAAG,EAAE,GAAK;oBAACA,IAAIF;iBAAO;QACpD;IACF;IAEA,IACElC,QAAQ8B,MAAM,CAAC,GAAGtB,YAAYR,QAAQwC,aAAa,EAAE,CAAC,IACrD,CAAA,CAACjC,UAAUkC,OAAOC,IAAI,CAAC3B,SAASF,OAAO,EAAE8B,MAAM,GAAG,CAAA,GACnD;QACAjC,OAAOE,IAAI,CAACG,QAAQ,GAAGA;IACzB;IAEA,OAAOL;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2062, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2068, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/createBlocksMap.ts"],"sourcesContent":["export type BlocksMap = {\n  [path: string]: Record<string, unknown>[]\n}\n\nexport const createBlocksMap = (data: Record<string, unknown>): BlocksMap => {\n  const blocksMap: BlocksMap = {}\n\n  Object.entries(data).forEach(([key, rows]) => {\n    if (key.startsWith('_blocks_') && Array.isArray(rows)) {\n      const blockType = key.replace('_blocks_', '')\n\n      rows.forEach((row) => {\n        if ('_path' in row) {\n          if (!(row._path in blocksMap)) {\n            blocksMap[row._path] = []\n          }\n\n          row.blockType = blockType\n          blocksMap[row._path].push(row)\n\n          delete row._path\n        }\n      })\n\n      delete data[key]\n    }\n  })\n\n  Object.entries(blocksMap).reduce((sortedBlocksMap, [path, blocks]) => {\n    sortedBlocksMap[path] = blocks.sort((a, b) => {\n      if (typeof a._order === 'number' && typeof b._order === 'number') {\n        return a._order - b._order\n      }\n\n      return 0\n    })\n\n    return sortedBlocksMap\n  }, {})\n\n  return blocksMap\n}\n"],"names":["createBlocksMap","data","blocksMap","Object","entries","forEach","key","rows","startsWith","Array","isArray","blockType","replace","row","_path","push","reduce","sortedBlocksMap","path","blocks","sort","a","b","_order"],"mappings":";;;AAIO,MAAMA,kBAAkB,CAACC;IAC9B,MAAMC,YAAuB,CAAC;IAE9BC,OAAOC,OAAO,CAACH,MAAMI,OAAO,CAAC,CAAC,CAACC,KAAKC,KAAK;QACvC,IAAID,IAAIE,UAAU,CAAC,eAAeC,MAAMC,OAAO,CAACH,OAAO;YACrD,MAAMI,YAAYL,IAAIM,OAAO,CAAC,YAAY;YAE1CL,KAAKF,OAAO,CAAC,CAACQ;gBACZ,IAAI,WAAWA,KAAK;oBAClB,IAAI,CAAEA,CAAAA,IAAIC,KAAK,IAAIZ,SAAQ,GAAI;wBAC7BA,SAAS,CAACW,IAAIC,KAAK,CAAC,GAAG,EAAE;oBAC3B;oBAEAD,IAAIF,SAAS,GAAGA;oBAChBT,SAAS,CAACW,IAAIC,KAAK,CAAC,CAACC,IAAI,CAACF;oBAE1B,OAAOA,IAAIC,KAAK;gBAClB;YACF;YAEA,OAAOb,IAAI,CAACK,IAAI;QAClB;IACF;IAEAH,OAAOC,OAAO,CAACF,WAAWc,MAAM,CAAC,CAACC,iBAAiB,CAACC,MAAMC,OAAO;QAC/DF,eAAe,CAACC,KAAK,GAAGC,OAAOC,IAAI,CAAC,CAACC,GAAGC;YACtC,IAAI,OAAOD,EAAEE,MAAM,KAAK,YAAY,OAAOD,EAAEC,MAAM,KAAK,UAAU;gBAChE,OAAOF,EAAEE,MAAM,GAAGD,EAAEC,MAAM;YAC5B;YAEA,OAAO;QACT;QAEA,OAAON;IACT,GAAG,CAAC;IAEJ,OAAOf;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2100, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2106, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/createRelationshipMap.ts"],"sourcesContent":["// Flatten rows to object with path keys\n// for easier retrieval\nexport const createPathMap = (rows: unknown): Record<string, Record<string, unknown>[]> => {\n  let rowsByPath = {}\n\n  if (Array.isArray(rows)) {\n    rowsByPath = rows.reduce((res, row) => {\n      const formattedRow = {\n        ...row,\n      }\n\n      delete formattedRow.path\n\n      if (!res[row.path]) {\n        res[row.path] = []\n      }\n      res[row.path].push(row)\n\n      return res\n    }, {})\n  }\n\n  return rowsByPath\n}\n"],"names":["createPathMap","rows","rowsByPath","Array","isArray","reduce","res","row","formattedRow","path","push"],"mappings":"AAAA,wCAAwC;AACxC,uBAAuB;;;;AAChB,MAAMA,gBAAgB,CAACC;IAC5B,IAAIC,aAAa,CAAC;IAElB,IAAIC,MAAMC,OAAO,CAACH,OAAO;QACvBC,aAAaD,KAAKI,MAAM,CAAC,CAACC,KAAKC;YAC7B,MAAMC,eAAe;gBACnB,GAAGD,GAAG;YACR;YAEA,OAAOC,aAAaC,IAAI;YAExB,IAAI,CAACH,GAAG,CAACC,IAAIE,IAAI,CAAC,EAAE;gBAClBH,GAAG,CAACC,IAAIE,IAAI,CAAC,GAAG,EAAE;YACpB;YACAH,GAAG,CAACC,IAAIE,IAAI,CAAC,CAACC,IAAI,CAACH;YAEnB,OAAOD;QACT,GAAG,CAAC;IACN;IAEA,OAAOJ;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2128, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2134, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/read/hasManyNumber.ts"],"sourcesContent":["import type { NumberField } from 'payload'\n\ntype Args = {\n  field: NumberField\n  locale?: string\n  numberRows: Record<string, unknown>[]\n  ref: Record<string, unknown>\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformHasManyNumber = ({\n  field,\n  locale,\n  numberRows,\n  ref,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let result: unknown[]\n\n  if (withinArrayOrBlockLocale) {\n    result = numberRows.reduce((acc, { locale, number }) => {\n      if (locale === withinArrayOrBlockLocale) {\n        acc.push(number)\n      }\n\n      return acc\n    }, [])\n  } else {\n    result = numberRows.map(({ number }) => number)\n  }\n\n  if (locale) {\n    ref[field.name][locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n"],"names":["transformHasManyNumber","field","locale","numberRows","ref","withinArrayOrBlockLocale","result","reduce","acc","number","push","map","name"],"mappings":";;;AAUO,MAAMA,yBAAyB,CAAC,EACrCC,KAAK,EACLC,MAAM,EACNC,UAAU,EACVC,GAAG,EACHC,wBAAwB,EACnB;IACL,IAAIC;IAEJ,IAAID,0BAA0B;QAC5BC,SAASH,WAAWI,MAAM,CAAC,CAACC,KAAK,EAAEN,MAAM,EAAEO,MAAM,EAAE;YACjD,IAAIP,WAAWG,0BAA0B;gBACvCG,IAAIE,IAAI,CAACD;YACX;YAEA,OAAOD;QACT,GAAG,EAAE;IACP,OAAO;QACLF,SAASH,WAAWQ,GAAG,CAAC,CAAC,EAAEF,MAAM,EAAE,GAAKA;IAC1C;IAEA,IAAIP,QAAQ;QACVE,GAAG,CAACH,MAAMW,IAAI,CAAC,CAACV,OAAO,GAAGI;IAC5B,OAAO;QACLF,GAAG,CAACH,MAAMW,IAAI,CAAC,GAAGN;IACpB;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2155, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2161, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/read/hasManyText.ts"],"sourcesContent":["import type { TextField } from 'payload'\n\ntype Args = {\n  field: TextField\n  locale?: string\n  ref: Record<string, unknown>\n  textRows: Record<string, unknown>[]\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformHasManyText = ({\n  field,\n  locale,\n  ref,\n  textRows,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let result: unknown[]\n\n  if (withinArrayOrBlockLocale) {\n    result = textRows.reduce((acc, { locale, text }) => {\n      if (locale === withinArrayOrBlockLocale) {\n        acc.push(text)\n      }\n\n      return acc\n    }, [])\n  } else {\n    result = textRows.map(({ text }) => text)\n  }\n\n  if (locale) {\n    ref[field.name][locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n"],"names":["transformHasManyText","field","locale","ref","textRows","withinArrayOrBlockLocale","result","reduce","acc","text","push","map","name"],"mappings":";;;AAUO,MAAMA,uBAAuB,CAAC,EACnCC,KAAK,EACLC,MAAM,EACNC,GAAG,EACHC,QAAQ,EACRC,wBAAwB,EACnB;IACL,IAAIC;IAEJ,IAAID,0BAA0B;QAC5BC,SAASF,SAASG,MAAM,CAAC,CAACC,KAAK,EAAEN,MAAM,EAAEO,IAAI,EAAE;YAC7C,IAAIP,WAAWG,0BAA0B;gBACvCG,IAAIE,IAAI,CAACD;YACX;YAEA,OAAOD;QACT,GAAG,EAAE;IACP,OAAO;QACLF,SAASF,SAASO,GAAG,CAAC,CAAC,EAAEF,IAAI,EAAE,GAAKA;IACtC;IAEA,IAAIP,QAAQ;QACVC,GAAG,CAACF,MAAMW,IAAI,CAAC,CAACV,OAAO,GAAGI;IAC5B,OAAO;QACLH,GAAG,CAACF,MAAMW,IAAI,CAAC,GAAGN;IACpB;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2182, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2188, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/read/relationship.ts"],"sourcesContent":["import type { RelationshipField, UploadField } from 'payload'\n\ntype Args = {\n  field: RelationshipField | UploadField\n  locale?: string\n  ref: Record<string, unknown>\n  relations: Record<string, unknown>[]\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformRelationship = ({\n  field,\n  locale,\n  ref,\n  relations,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let result: unknown\n\n  if (!('hasMany' in field) || field.hasMany === false) {\n    let relation = relations[0]\n\n    if (withinArrayOrBlockLocale) {\n      relation = relations.find((rel) => rel.locale === withinArrayOrBlockLocale)\n    }\n\n    if (relation) {\n      // Handle hasOne Poly\n      if (Array.isArray(field.relationTo)) {\n        const matchedRelation = Object.entries(relation).find(([key, val]) => {\n          return val !== null && !['id', 'locale', 'order', 'parent', 'path'].includes(key)\n        })\n\n        if (matchedRelation) {\n          const relationTo = matchedRelation[0].replace('ID', '')\n\n          result = {\n            relationTo,\n            value: matchedRelation[1],\n          }\n        }\n      }\n    }\n  } else {\n    const transformedRelations = []\n\n    relations.forEach((relation) => {\n      let matchedLocale = true\n\n      if (withinArrayOrBlockLocale) {\n        matchedLocale = relation.locale === withinArrayOrBlockLocale\n      }\n\n      // Handle hasMany\n      if (!Array.isArray(field.relationTo)) {\n        const relatedData = relation[`${field.relationTo}ID`]\n\n        if (relatedData && matchedLocale) {\n          transformedRelations.push(relatedData)\n        }\n      } else {\n        // Handle hasMany Poly\n        const matchedRelation = Object.entries(relation).find(\n          ([key, val]) =>\n            val !== null &&\n            !['id', 'locale', 'order', 'parent', 'path'].includes(key) &&\n            matchedLocale,\n        )\n\n        if (matchedRelation) {\n          const relationTo = matchedRelation[0].replace('ID', '')\n\n          transformedRelations.push({\n            relationTo,\n            value: matchedRelation[1],\n          })\n        }\n      }\n    })\n\n    result = transformedRelations\n  }\n\n  if (locale) {\n    ref[field.name][locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n"],"names":["transformRelationship","field","locale","ref","relations","withinArrayOrBlockLocale","result","hasMany","relation","find","rel","Array","isArray","relationTo","matchedRelation","Object","entries","key","val","includes","replace","value","transformedRelations","forEach","matchedLocale","relatedData","push","name"],"mappings":";;;AAUO,MAAMA,wBAAwB,CAAC,EACpCC,KAAK,EACLC,MAAM,EACNC,GAAG,EACHC,SAAS,EACTC,wBAAwB,EACnB;IACL,IAAIC;IAEJ,IAAI,CAAE,CAAA,aAAaL,KAAI,KAAMA,MAAMM,OAAO,KAAK,OAAO;QACpD,IAAIC,WAAWJ,SAAS,CAAC,EAAE;QAE3B,IAAIC,0BAA0B;YAC5BG,WAAWJ,UAAUK,IAAI,CAAC,CAACC,MAAQA,IAAIR,MAAM,KAAKG;QACpD;QAEA,IAAIG,UAAU;YACZ,qBAAqB;YACrB,IAAIG,MAAMC,OAAO,CAACX,MAAMY,UAAU,GAAG;gBACnC,MAAMC,kBAAkBC,OAAOC,OAAO,CAACR,UAAUC,IAAI,CAAC,CAAC,CAACQ,KAAKC,IAAI;oBAC/D,OAAOA,QAAQ,QAAQ,CAAC;wBAAC;wBAAM;wBAAU;wBAAS;wBAAU;qBAAO,CAACC,QAAQ,CAACF;gBAC/E;gBAEA,IAAIH,iBAAiB;oBACnB,MAAMD,aAAaC,eAAe,CAAC,EAAE,CAACM,OAAO,CAAC,MAAM;oBAEpDd,SAAS;wBACPO;wBACAQ,OAAOP,eAAe,CAAC,EAAE;oBAC3B;gBACF;YACF;QACF;IACF,OAAO;QACL,MAAMQ,uBAAuB,EAAE;QAE/BlB,UAAUmB,OAAO,CAAC,CAACf;YACjB,IAAIgB,gBAAgB;YAEpB,IAAInB,0BAA0B;gBAC5BmB,gBAAgBhB,SAASN,MAAM,KAAKG;YACtC;YAEA,iBAAiB;YACjB,IAAI,CAACM,MAAMC,OAAO,CAACX,MAAMY,UAAU,GAAG;gBACpC,MAAMY,cAAcjB,QAAQ,CAAC,GAAGP,MAAMY,UAAU,CAAC,EAAE,CAAC,CAAC;gBAErD,IAAIY,eAAeD,eAAe;oBAChCF,qBAAqBI,IAAI,CAACD;gBAC5B;YACF,OAAO;gBACL,sBAAsB;gBACtB,MAAMX,kBAAkBC,OAAOC,OAAO,CAACR,UAAUC,IAAI,CACnD,CAAC,CAACQ,KAAKC,IAAI,GACTA,QAAQ,QACR,CAAC;wBAAC;wBAAM;wBAAU;wBAAS;wBAAU;qBAAO,CAACC,QAAQ,CAACF,QACtDO;gBAGJ,IAAIV,iBAAiB;oBACnB,MAAMD,aAAaC,eAAe,CAAC,EAAE,CAACM,OAAO,CAAC,MAAM;oBAEpDE,qBAAqBI,IAAI,CAAC;wBACxBb;wBACAQ,OAAOP,eAAe,CAAC,EAAE;oBAC3B;gBACF;YACF;QACF;QAEAR,SAASgB;IACX;IAEA,IAAIpB,QAAQ;QACVC,GAAG,CAACF,MAAM0B,IAAI,CAAC,CAACzB,OAAO,GAAGI;IAC5B,OAAO;QACLH,GAAG,CAACF,MAAM0B,IAAI,CAAC,GAAGrB;IACpB;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2258, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2264, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/read/traverseFields.ts"],"sourcesContent":["import type { FlattenedField, JoinQuery, SanitizedConfig } from 'payload'\n\nimport { fieldAffectsData, fieldIsVirtual } from 'payload/shared'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { BlocksMap } from '../../utilities/createBlocksMap.js'\n\nimport { transformHasManyNumber } from './hasManyNumber.js'\nimport { transformHasManyText } from './hasManyText.js'\nimport { transformRelationship } from './relationship.js'\n\ntype TraverseFieldsArgs = {\n  /**\n   * The DB adapter\n   */\n  adapter: DrizzleAdapter\n  /**\n   * Pre-formatted blocks map\n   */\n  blocks: BlocksMap\n  /**\n   * The full Payload config\n   */\n  config: SanitizedConfig\n  /**\n   * The data reference to be mutated within this recursive function\n   */\n  dataRef: Record<string, unknown>\n  /**\n   * Data that needs to be removed from the result after all fields have populated\n   */\n  deletions: (() => void)[]\n  /**\n   * Column prefix can be built up by group and named tab fields\n   */\n  fieldPrefix: string\n  /**\n   * An array of Payload fields to traverse\n   */\n  fields: FlattenedField[]\n  /**\n   *\n   */\n  joinQuery?: JoinQuery\n  /**\n   * All hasMany number fields, as returned by Drizzle, keyed on an object by field path\n   */\n  numbers: Record<string, Record<string, unknown>[]>\n  /**\n   * The current field path (in dot notation), used to merge in relationships\n   */\n  path: string\n  /**\n   * All related documents, as returned by Drizzle, keyed on an object by field path\n   */\n  relationships: Record<string, Record<string, unknown>[]>\n  /**\n   * Data structure representing the nearest table from db\n   */\n  table: Record<string, unknown>\n  /**\n   * All hasMany text fields, as returned by Drizzle, keyed on an object by field path\n   */\n  texts: Record<string, Record<string, unknown>[]>\n  /**\n   * Set to a locale if this group of fields is within a localized array or block.\n   */\n  withinArrayOrBlockLocale?: string\n}\n\n// Traverse fields recursively, transforming data\n// for each field type into required Payload shape\nexport const traverseFields = <T extends Record<string, unknown>>({\n  adapter,\n  blocks,\n  config,\n  dataRef,\n  deletions,\n  fieldPrefix,\n  fields,\n  joinQuery,\n  numbers,\n  path,\n  relationships,\n  table,\n  texts,\n  withinArrayOrBlockLocale,\n}: TraverseFieldsArgs): T => {\n  const sanitizedPath = path ? `${path}.` : path\n\n  const formatted = fields.reduce((result, field) => {\n    if (fieldIsVirtual(field)) {\n      return result\n    }\n\n    const fieldName = `${fieldPrefix || ''}${field.name}`\n    let fieldData = table[fieldName]\n    const localizedFieldData = {}\n    const valuesToTransform: {\n      ref: Record<string, unknown>\n      table: Record<string, unknown>\n    }[] = []\n\n    if (fieldPrefix) {\n      deletions.push(() => delete table[fieldName])\n    }\n\n    if (field.type === 'array') {\n      if (Array.isArray(fieldData)) {\n        if (field.localized) {\n          result[field.name] = fieldData.reduce((arrayResult, row) => {\n            if (typeof row._locale === 'string') {\n              if (!arrayResult[row._locale]) {\n                arrayResult[row._locale] = []\n              }\n              const locale = row._locale\n              const data = {}\n              delete row._locale\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n\n              const rowResult = traverseFields<T>({\n                adapter,\n                blocks,\n                config,\n                dataRef: data,\n                deletions,\n                fieldPrefix: '',\n                fields: field.flattenedFields,\n                numbers,\n                path: `${sanitizedPath}${field.name}.${row._order - 1}`,\n                relationships,\n                table: row,\n                texts,\n                withinArrayOrBlockLocale: locale,\n              })\n\n              if ('_order' in rowResult) {\n                delete rowResult._order\n              }\n\n              arrayResult[locale].push(rowResult)\n            }\n\n            return arrayResult\n          }, {})\n        } else {\n          result[field.name] = fieldData.reduce((acc, row, i) => {\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n\n            if ('_order' in row) {\n              delete row._order\n            }\n\n            if (\n              !withinArrayOrBlockLocale ||\n              (withinArrayOrBlockLocale && withinArrayOrBlockLocale === row._locale)\n            ) {\n              if (row._locale) {\n                delete row._locale\n              }\n\n              acc.push(\n                traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  dataRef: row,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: field.flattenedFields,\n                  numbers,\n                  path: `${sanitizedPath}${field.name}.${i}`,\n                  relationships,\n                  table: row,\n                  texts,\n                  withinArrayOrBlockLocale,\n                }),\n              )\n            }\n\n            return acc\n          }, [])\n        }\n      }\n\n      return result\n    }\n\n    if (field.type === 'blocks') {\n      const blockFieldPath = `${sanitizedPath}${field.name}`\n      const blocksByPath = blocks[blockFieldPath]\n\n      if (Array.isArray(blocksByPath)) {\n        if (field.localized) {\n          result[field.name] = {}\n\n          blocksByPath.forEach((row) => {\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n            if (typeof row._locale === 'string') {\n              if (!result[field.name][row._locale]) {\n                result[field.name][row._locale] = []\n              }\n              result[field.name][row._locale].push(row)\n              delete row._locale\n            }\n          })\n\n          Object.entries(result[field.name]).forEach(([locale, localizedBlocks]) => {\n            result[field.name][locale] = localizedBlocks.map((row) => {\n              const block = field.blocks.find(({ slug }) => slug === row.blockType)\n\n              if (block) {\n                const blockResult = traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  dataRef: row,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: block.flattenedFields,\n                  numbers,\n                  path: `${blockFieldPath}.${row._order - 1}`,\n                  relationships,\n                  table: row,\n                  texts,\n                  withinArrayOrBlockLocale: locale,\n                })\n\n                delete blockResult._order\n                return blockResult\n              }\n\n              return {}\n            })\n          })\n        } else {\n          // Add locale-specific index to have a proper blockFieldPath for current locale\n          // because blocks can be in the same array for different locales!\n          if (withinArrayOrBlockLocale && config.localization) {\n            for (const locale of config.localization.localeCodes) {\n              let localeIndex = 0\n\n              for (let i = 0; i < blocksByPath.length; i++) {\n                const row = blocksByPath[i]\n                if (row._locale === locale) {\n                  row._index = localeIndex\n                  localeIndex++\n                }\n              }\n            }\n          }\n\n          result[field.name] = blocksByPath.reduce((acc, row, i) => {\n            delete row._order\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n            const block = field.blocks.find(({ slug }) => slug === row.blockType)\n\n            if (block) {\n              if (\n                !withinArrayOrBlockLocale ||\n                (withinArrayOrBlockLocale && withinArrayOrBlockLocale === row._locale)\n              ) {\n                if (row._locale) {\n                  delete row._locale\n                }\n                if (typeof row._index === 'number') {\n                  i = row._index\n                  delete row._index\n                }\n\n                acc.push(\n                  traverseFields<T>({\n                    adapter,\n                    blocks,\n                    config,\n                    dataRef: row,\n                    deletions,\n                    fieldPrefix: '',\n                    fields: block.flattenedFields,\n                    numbers,\n                    path: `${blockFieldPath}.${i}`,\n                    relationships,\n                    table: row,\n                    texts,\n                    withinArrayOrBlockLocale,\n                  }),\n                )\n\n                return acc\n              }\n            } else {\n              acc.push({})\n            }\n\n            return acc\n          }, [])\n        }\n      }\n\n      return result\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (typeof field.relationTo === 'string' && !('hasMany' in field && field.hasMany)) {\n        if (\n          field.localized &&\n          config.localization &&\n          config.localization.locales &&\n          Array.isArray(table?._locales)\n        ) {\n          table._locales.forEach((localeRow) => {\n            result[field.name] = { [localeRow._locale]: localeRow[fieldName] }\n          })\n        } else {\n          valuesToTransform.push({ ref: result, table })\n        }\n      } else {\n        const relationPathMatch = relationships[`${sanitizedPath}${field.name}`]\n\n        if (!relationPathMatch) {\n          if ('hasMany' in field && field.hasMany) {\n            if (field.localized && config.localization && config.localization.locales) {\n              result[field.name] = {\n                [config.localization.defaultLocale]: [],\n              }\n            } else {\n              result[field.name] = []\n            }\n          }\n\n          return result\n        }\n\n        if (field.localized) {\n          result[field.name] = {}\n          const relationsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n          relationPathMatch.forEach((row) => {\n            if (typeof row.locale === 'string') {\n              if (!relationsByLocale[row.locale]) {\n                relationsByLocale[row.locale] = []\n              }\n              relationsByLocale[row.locale].push(row)\n            }\n          })\n\n          Object.entries(relationsByLocale).forEach(([locale, relations]) => {\n            transformRelationship({\n              field,\n              locale,\n              ref: result,\n              relations,\n            })\n          })\n        } else {\n          transformRelationship({\n            field,\n            ref: result,\n            relations: relationPathMatch,\n            withinArrayOrBlockLocale,\n          })\n        }\n        return result\n      }\n    }\n\n    if (field.type === 'join') {\n      const { limit = field.defaultLimit ?? 10 } =\n        joinQuery?.[`${fieldPrefix.replaceAll('_', '.')}${field.name}`] || {}\n\n      // raw hasMany results from SQLite\n      if (typeof fieldData === 'string') {\n        fieldData = JSON.parse(fieldData)\n      }\n\n      let fieldResult:\n        | { docs: unknown[]; hasNextPage: boolean }\n        | Record<string, { docs: unknown[]; hasNextPage: boolean }>\n      if (Array.isArray(fieldData)) {\n        if (field.localized && adapter.payload.config.localization) {\n          fieldResult = fieldData.reduce(\n            (joinResult, row) => {\n              if (typeof row.locale === 'string') {\n                joinResult[row.locale].docs.push(row.id)\n              }\n\n              return joinResult\n            },\n\n            // initialize with defaults so empty won't be undefined\n            adapter.payload.config.localization.localeCodes.reduce((acc, code) => {\n              acc[code] = {\n                docs: [],\n                hasNextPage: false,\n              }\n              return acc\n            }, {}),\n          )\n          Object.keys(fieldResult).forEach((locale) => {\n            fieldResult[locale].hasNextPage = fieldResult[locale].docs.length > limit\n            fieldResult[locale].docs = fieldResult[locale].docs.slice(0, limit)\n          })\n        } else {\n          const hasNextPage = limit !== 0 && fieldData.length > limit\n          fieldResult = {\n            docs: (hasNextPage ? fieldData.slice(0, limit) : fieldData).map(({ id }) => ({\n              id,\n            })),\n            hasNextPage,\n          }\n        }\n      }\n\n      result[field.name] = fieldResult\n      return result\n    }\n\n    if (field.type === 'text' && field?.hasMany) {\n      const textPathMatch = texts[`${sanitizedPath}${field.name}`]\n      if (!textPathMatch) {\n        return result\n      }\n\n      if (field.localized) {\n        result[field.name] = {}\n        const textsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n        textPathMatch.forEach((row) => {\n          if (typeof row.locale === 'string') {\n            if (!textsByLocale[row.locale]) {\n              textsByLocale[row.locale] = []\n            }\n            textsByLocale[row.locale].push(row)\n          }\n        })\n\n        Object.entries(textsByLocale).forEach(([locale, texts]) => {\n          transformHasManyText({\n            field,\n            locale,\n            ref: result,\n            textRows: texts,\n          })\n        })\n      } else {\n        transformHasManyText({\n          field,\n          ref: result,\n          textRows: textPathMatch,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return result\n    }\n\n    if (field.type === 'number' && field.hasMany) {\n      const numberPathMatch = numbers[`${sanitizedPath}${field.name}`]\n      if (!numberPathMatch) {\n        return result\n      }\n\n      if (field.localized) {\n        result[field.name] = {}\n        const numbersByLocale: Record<string, Record<string, unknown>[]> = {}\n\n        numberPathMatch.forEach((row) => {\n          if (typeof row.locale === 'string') {\n            if (!numbersByLocale[row.locale]) {\n              numbersByLocale[row.locale] = []\n            }\n            numbersByLocale[row.locale].push(row)\n          }\n        })\n\n        Object.entries(numbersByLocale).forEach(([locale, numbers]) => {\n          transformHasManyNumber({\n            field,\n            locale,\n            numberRows: numbers,\n            ref: result,\n          })\n        })\n      } else {\n        transformHasManyNumber({\n          field,\n          numberRows: numberPathMatch,\n          ref: result,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return result\n    }\n\n    if (field.type === 'select' && field.hasMany) {\n      if (Array.isArray(fieldData)) {\n        if (field.localized) {\n          result[field.name] = fieldData.reduce((selectResult, row) => {\n            if (typeof row.locale === 'string') {\n              if (!selectResult[row.locale]) {\n                selectResult[row.locale] = []\n              }\n              selectResult[row.locale].push(row.value)\n            }\n\n            return selectResult\n          }, {})\n        } else {\n          let selectData = fieldData\n          if (withinArrayOrBlockLocale) {\n            selectData = selectData.filter(({ locale }) => locale === withinArrayOrBlockLocale)\n          }\n          result[field.name] = selectData.map(({ value }) => value)\n        }\n      }\n      return result\n    }\n\n    if (field.localized && Array.isArray(table._locales)) {\n      if (!table._locales.length && adapter.payload.config.localization) {\n        adapter.payload.config.localization.localeCodes.forEach((_locale) =>\n          (table._locales as unknown[]).push({ _locale }),\n        )\n      }\n\n      table._locales.forEach((localeRow) => {\n        valuesToTransform.push({\n          ref: localizedFieldData,\n          table: {\n            ...table,\n            ...localeRow,\n          },\n        })\n      })\n    } else {\n      valuesToTransform.push({ ref: result, table })\n    }\n\n    valuesToTransform.forEach(({ ref, table }) => {\n      const fieldData = table[`${fieldPrefix || ''}${field.name}`]\n      const locale = table?._locale\n      let val = fieldData\n\n      switch (field.type) {\n        case 'date': {\n          if (typeof fieldData === 'string') {\n            val = new Date(fieldData).toISOString()\n          }\n\n          break\n        }\n\n        case 'group':\n        case 'tab': {\n          const groupFieldPrefix = `${fieldPrefix || ''}${field.name}_`\n          const groupData = {}\n          const locale = table._locale as string\n          const refKey = field.localized && locale ? locale : field.name\n\n          if (field.localized && locale) {\n            delete table._locale\n          }\n          ref[refKey] = traverseFields<Record<string, unknown>>({\n            adapter,\n            blocks,\n            config,\n            dataRef: groupData as Record<string, unknown>,\n            deletions,\n            fieldPrefix: groupFieldPrefix,\n            fields: field.flattenedFields,\n            numbers,\n            path: `${sanitizedPath}${field.name}`,\n            relationships,\n            table,\n            texts,\n            withinArrayOrBlockLocale: locale || withinArrayOrBlockLocale,\n          })\n\n          if ('_order' in ref) {\n            delete ref._order\n          }\n\n          return\n        }\n\n        case 'number': {\n          if (typeof fieldData === 'string') {\n            val = Number.parseFloat(fieldData)\n          }\n\n          break\n        }\n\n        case 'point': {\n          if (typeof fieldData === 'string') {\n            val = JSON.parse(fieldData)\n          }\n\n          break\n        }\n\n        case 'relationship':\n        case 'upload': {\n          if (\n            val &&\n            typeof field.relationTo === 'string' &&\n            adapter.payload.collections[field.relationTo].customIDType === 'number'\n          ) {\n            val = Number(val)\n          }\n\n          break\n        }\n        case 'text': {\n          if (typeof fieldData === 'string') {\n            val = String(fieldData)\n          }\n\n          break\n        }\n\n        default: {\n          break\n        }\n      }\n      if (typeof locale === 'string') {\n        ref[locale] = val\n      } else {\n        result[field.name] = val\n      }\n    })\n\n    if (Object.keys(localizedFieldData).length > 0) {\n      result[field.name] = localizedFieldData\n    }\n\n    return result\n\n    return result\n  }, dataRef)\n\n  if (Array.isArray(table._locales)) {\n    deletions.push(() => delete table._locales)\n  }\n\n  return formatted as T\n}\n"],"names":["fieldIsVirtual","transformHasManyNumber","transformHasManyText","transformRelationship","traverseFields","adapter","blocks","config","dataRef","deletions","fieldPrefix","fields","joinQuery","numbers","path","relationships","table","texts","withinArrayOrBlockLocale","sanitizedPath","formatted","reduce","result","field","fieldName","name","fieldData","localizedFieldData","valuesToTransform","push","type","Array","isArray","localized","arrayResult","row","_locale","locale","data","_uuid","id","rowResult","flattenedFields","_order","acc","i","blockFieldPath","blocksByPath","forEach","Object","entries","localizedBlocks","map","block","find","slug","blockType","blockResult","localization","localeCodes","localeIndex","length","_index","relationTo","hasMany","locales","_locales","localeRow","ref","relationPathMatch","defaultLocale","relationsByLocale","relations","limit","defaultLimit","replaceAll","JSON","parse","fieldResult","payload","joinResult","docs","code","hasNextPage","keys","slice","textPathMatch","textsByLocale","textRows","numberPathMatch","numbersByLocale","numberRows","selectResult","value","selectData","filter","val","Date","toISOString","groupFieldPrefix","groupData","refKey","Number","parseFloat","collections","customIDType","String"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2761, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2767, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/read/index.ts"],"sourcesContent":["import type { FlattenedField, JoinQuery, SanitizedConfig, TypeWithID } from 'payload'\n\nimport type { DrizzleAdapter } from '../../types.js'\n\nimport { createBlocksMap } from '../../utilities/createBlocksMap.js'\nimport { createPathMap } from '../../utilities/createRelationshipMap.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype TransformArgs = {\n  adapter: DrizzleAdapter\n  config: SanitizedConfig\n  data: Record<string, unknown>\n  fallbackLocale?: false | string\n  fields: FlattenedField[]\n  joinQuery?: JoinQuery\n  locale?: string\n}\n\n// This is the entry point to transform Drizzle output data\n// into the shape Payload expects based on field schema\nexport const transform = <T extends Record<string, unknown> | TypeWithID>({\n  adapter,\n  config,\n  data,\n  fields,\n  joinQuery,\n}: TransformArgs): T => {\n  let relationships: Record<string, Record<string, unknown>[]> = {}\n  let texts: Record<string, Record<string, unknown>[]> = {}\n  let numbers: Record<string, Record<string, unknown>[]> = {}\n\n  if ('_rels' in data) {\n    relationships = createPathMap(data._rels)\n    delete data._rels\n  }\n\n  if ('_texts' in data) {\n    texts = createPathMap(data._texts)\n    delete data._texts\n  }\n\n  if ('_numbers' in data) {\n    numbers = createPathMap(data._numbers)\n    delete data._numbers\n  }\n\n  const blocks = createBlocksMap(data)\n  const deletions = []\n\n  const result = traverseFields<T>({\n    adapter,\n    blocks,\n    config,\n    dataRef: {\n      id: data.id,\n    },\n    deletions,\n    fieldPrefix: '',\n    fields,\n    joinQuery,\n    numbers,\n    path: '',\n    relationships,\n    table: data,\n    texts,\n  })\n\n  deletions.forEach((deletion) => deletion())\n\n  return result\n}\n"],"names":["createBlocksMap","createPathMap","traverseFields","transform","adapter","config","data","fields","joinQuery","relationships","texts","numbers","_rels","_texts","_numbers","blocks","deletions","result","dataRef","id","fieldPrefix","path","table","forEach","deletion"],"mappings":";;;AAIA,SAASA,eAAe,QAAQ,qCAAoC;AACpE,SAASC,aAAa,QAAQ,2CAA0C;AACxE,SAASC,cAAc,QAAQ,sBAAqB;;;;AAc7C,MAAMC,YAAY,CAAiD,EACxEC,OAAO,EACPC,MAAM,EACNC,IAAI,EACJC,MAAM,EACNC,SAAS,EACK;IACd,IAAIC,gBAA2D,CAAC;IAChE,IAAIC,QAAmD,CAAC;IACxD,IAAIC,UAAqD,CAAC;IAE1D,IAAI,WAAWL,MAAM;QACnBG,6ZAAgBR,gBAAAA,EAAcK,KAAKM,KAAK;QACxC,OAAON,KAAKM,KAAK;IACnB;IAEA,IAAI,YAAYN,MAAM;QACpBI,qZAAQT,gBAAAA,EAAcK,KAAKO,MAAM;QACjC,OAAOP,KAAKO,MAAM;IACpB;IAEA,IAAI,cAAcP,MAAM;QACtBK,uZAAUV,gBAAAA,EAAcK,KAAKQ,QAAQ;QACrC,OAAOR,KAAKQ,QAAQ;IACtB;IAEA,MAAMC,gZAASf,kBAAAA,EAAgBM;IAC/B,MAAMU,YAAY,EAAE;IAEpB,MAAMC,uZAASf,iBAAAA,EAAkB;QAC/BE;QACAW;QACAV;QACAa,SAAS;YACPC,IAAIb,KAAKa,EAAE;QACb;QACAH;QACAI,aAAa;QACbb;QACAC;QACAG;QACAU,MAAM;QACNZ;QACAa,OAAOhB;QACPI;IACF;IAEAM,UAAUO,OAAO,CAAC,CAACC,WAAaA;IAEhC,OAAOP;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2814, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2820, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/isArrayOfRows.ts"],"sourcesContent":["export function isArrayOfRows(data: unknown): data is Record<string, unknown>[] {\n  return Array.isArray(data)\n}\n"],"names":["isArrayOfRows","data","Array","isArray"],"mappings":";;;AAAO,SAASA,cAAcC,IAAa;IACzC,OAAOC,MAAMC,OAAO,CAACF;AACvB","ignoreList":[0]}},
    {"offset": {"line": 2826, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2832, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/write/array.ts"],"sourcesContent":["import type { FlattenedArrayField } from 'payload'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { ArrayRowToInsert, BlockRowToInsert, RelationshipToDelete } from './types.js'\n\nimport { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  arrayTableName: string\n  baseTableName: string\n  blocks: {\n    [blockType: string]: BlockRowToInsert[]\n  }\n  blocksToDelete: Set<string>\n  data: unknown\n  field: FlattenedArrayField\n  locale?: string\n  numbers: Record<string, unknown>[]\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToDelete: RelationshipToDelete[]\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformArray = ({\n  adapter,\n  arrayTableName,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  data,\n  field,\n  locale,\n  numbers,\n  path,\n  relationships,\n  relationshipsToDelete,\n  selects,\n  texts,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  const newRows: ArrayRowToInsert[] = []\n\n  const hasUUID = adapter.tables[arrayTableName]._uuid\n\n  if (isArrayOfRows(data)) {\n    data.forEach((arrayRow, i) => {\n      const newRow: ArrayRowToInsert = {\n        arrays: {},\n        locales: {},\n        row: {\n          _order: i + 1,\n        },\n      }\n\n      // If we have declared a _uuid field on arrays,\n      // that means the ID has to be unique,\n      // and our ids within arrays are not unique.\n      // So move the ID to a uuid field for storage\n      // and allow the database to generate a serial id automatically\n      if (hasUUID) {\n        newRow.row._uuid = arrayRow.id\n        delete arrayRow.id\n      }\n\n      if (locale) {\n        newRow.locales[locale] = {\n          _locale: locale,\n        }\n      }\n\n      if (field.localized) {\n        newRow.row._locale = locale\n      }\n\n      if (withinArrayOrBlockLocale) {\n        newRow.row._locale = withinArrayOrBlockLocale\n      }\n\n      traverseFields({\n        adapter,\n        arrays: newRow.arrays,\n        baseTableName,\n        blocks,\n        blocksToDelete,\n        columnPrefix: '',\n        data: arrayRow,\n        fieldPrefix: '',\n        fields: field.flattenedFields,\n        insideArrayOrBlock: true,\n        locales: newRow.locales,\n        numbers,\n        parentTableName: arrayTableName,\n        path: `${path || ''}${field.name}.${i}.`,\n        relationships,\n        relationshipsToDelete,\n        row: newRow.row,\n        selects,\n        texts,\n        withinArrayOrBlockLocale,\n      })\n\n      newRows.push(newRow)\n    })\n  }\n\n  return newRows\n}\n"],"names":["isArrayOfRows","traverseFields","transformArray","adapter","arrayTableName","baseTableName","blocks","blocksToDelete","data","field","locale","numbers","path","relationships","relationshipsToDelete","selects","texts","withinArrayOrBlockLocale","newRows","hasUUID","tables","_uuid","forEach","arrayRow","i","newRow","arrays","locales","row","_order","id","_locale","localized","columnPrefix","fieldPrefix","fields","flattenedFields","insideArrayOrBlock","parentTableName","name","push"],"mappings":";;;AAKA,SAASA,aAAa,QAAQ,mCAAkC;AAChE,SAASC,cAAc,QAAQ,sBAAqB;;;AA4B7C,MAAMC,iBAAiB,CAAC,EAC7BC,OAAO,EACPC,cAAc,EACdC,aAAa,EACbC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,KAAK,EACLC,MAAM,EACNC,OAAO,EACPC,IAAI,EACJC,aAAa,EACbC,qBAAqB,EACrBC,OAAO,EACPC,KAAK,EACLC,wBAAwB,EACnB;IACL,MAAMC,UAA8B,EAAE;IAEtC,MAAMC,UAAUhB,QAAQiB,MAAM,CAAChB,eAAe,CAACiB,KAAK;IAEpD,yYAAIrB,gBAAAA,EAAcQ,OAAO;QACvBA,KAAKc,OAAO,CAAC,CAACC,UAAUC;YACtB,MAAMC,SAA2B;gBAC/BC,QAAQ,CAAC;gBACTC,SAAS,CAAC;gBACVC,KAAK;oBACHC,QAAQL,IAAI;gBACd;YACF;YAEA,+CAA+C;YAC/C,sCAAsC;YACtC,4CAA4C;YAC5C,6CAA6C;YAC7C,+DAA+D;YAC/D,IAAIL,SAAS;gBACXM,OAAOG,GAAG,CAACP,KAAK,GAAGE,SAASO,EAAE;gBAC9B,OAAOP,SAASO,EAAE;YACpB;YAEA,IAAIpB,QAAQ;gBACVe,OAAOE,OAAO,CAACjB,OAAO,GAAG;oBACvBqB,SAASrB;gBACX;YACF;YAEA,IAAID,MAAMuB,SAAS,EAAE;gBACnBP,OAAOG,GAAG,CAACG,OAAO,GAAGrB;YACvB;YAEA,IAAIO,0BAA0B;gBAC5BQ,OAAOG,GAAG,CAACG,OAAO,GAAGd;YACvB;YAEAhB,gaAAAA,EAAe;gBACbE;gBACAuB,QAAQD,OAAOC,MAAM;gBACrBrB;gBACAC;gBACAC;gBACA0B,cAAc;gBACdzB,MAAMe;gBACNW,aAAa;gBACbC,QAAQ1B,MAAM2B,eAAe;gBAC7BC,oBAAoB;gBACpBV,SAASF,OAAOE,OAAO;gBACvBhB;gBACA2B,iBAAiBlC;gBACjBQ,MAAM,GAAGA,QAAQ,KAAKH,MAAM8B,IAAI,CAAC,CAAC,EAAEf,EAAE,CAAC,CAAC;gBACxCX;gBACAC;gBACAc,KAAKH,OAAOG,GAAG;gBACfb;gBACAC;gBACAC;YACF;YAEAC,QAAQsB,IAAI,CAACf;QACf;IACF;IAEA,OAAOP;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2898, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2904, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/write/blocks.ts"],"sourcesContent":["import type { FlattenedBlocksField } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { BlockRowToInsert, RelationshipToDelete } from './types.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  baseTableName: string\n  blocks: {\n    [blockType: string]: BlockRowToInsert[]\n  }\n  blocksToDelete: Set<string>\n  data: Record<string, unknown>[]\n  field: FlattenedBlocksField\n  locale?: string\n  numbers: Record<string, unknown>[]\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToDelete: RelationshipToDelete[]\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\nexport const transformBlocks = ({\n  adapter,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  data,\n  field,\n  locale,\n  numbers,\n  path,\n  relationships,\n  relationshipsToDelete,\n  selects,\n  texts,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  data.forEach((blockRow, i) => {\n    if (typeof blockRow.blockType !== 'string') {\n      return\n    }\n    const matchedBlock = field.blocks.find(({ slug }) => slug === blockRow.blockType)\n    if (!matchedBlock) {\n      return\n    }\n    const blockType = toSnakeCase(blockRow.blockType)\n\n    if (!blocks[blockType]) {\n      blocks[blockType] = []\n    }\n\n    const newRow: BlockRowToInsert = {\n      arrays: {},\n      locales: {},\n      row: {\n        _order: i + 1,\n        _path: `${path}${field.name}`,\n      },\n    }\n\n    if (field.localized && locale) {\n      newRow.row._locale = locale\n    }\n    if (withinArrayOrBlockLocale) {\n      newRow.row._locale = withinArrayOrBlockLocale\n    }\n\n    const blockTableName = adapter.tableNameMap.get(`${baseTableName}_blocks_${blockType}`)\n\n    const hasUUID = adapter.tables[blockTableName]._uuid\n\n    // If we have declared a _uuid field on arrays,\n    // that means the ID has to be unique,\n    // and our ids within arrays are not unique.\n    // So move the ID to a uuid field for storage\n    // and allow the database to generate a serial id automatically\n    if (hasUUID) {\n      newRow.row._uuid = blockRow.id\n      delete blockRow.id\n    }\n\n    traverseFields({\n      adapter,\n      arrays: newRow.arrays,\n      baseTableName,\n      blocks,\n      blocksToDelete,\n      columnPrefix: '',\n      data: blockRow,\n      fieldPrefix: '',\n      fields: matchedBlock.flattenedFields,\n      insideArrayOrBlock: true,\n      locales: newRow.locales,\n      numbers,\n      parentTableName: blockTableName,\n      path: `${path || ''}${field.name}.${i}.`,\n      relationships,\n      relationshipsToDelete,\n      row: newRow.row,\n      selects,\n      texts,\n      withinArrayOrBlockLocale,\n    })\n\n    blocks[blockType].push(newRow)\n  })\n}\n"],"names":["toSnakeCase","traverseFields","transformBlocks","adapter","baseTableName","blocks","blocksToDelete","data","field","locale","numbers","path","relationships","relationshipsToDelete","selects","texts","withinArrayOrBlockLocale","forEach","blockRow","i","blockType","matchedBlock","find","slug","newRow","arrays","locales","row","_order","_path","name","localized","_locale","blockTableName","tableNameMap","get","hasUUID","tables","_uuid","id","columnPrefix","fieldPrefix","fields","flattenedFields","insideArrayOrBlock","parentTableName","push"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAKvC,SAASC,cAAc,QAAQ,sBAAqB;;;AA0B7C,MAAMC,kBAAkB,CAAC,EAC9BC,OAAO,EACPC,aAAa,EACbC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,KAAK,EACLC,MAAM,EACNC,OAAO,EACPC,IAAI,EACJC,aAAa,EACbC,qBAAqB,EACrBC,OAAO,EACPC,KAAK,EACLC,wBAAwB,EACnB;IACLT,KAAKU,OAAO,CAAC,CAACC,UAAUC;QACtB,IAAI,OAAOD,SAASE,SAAS,KAAK,UAAU;YAC1C;QACF;QACA,MAAMC,eAAeb,MAAMH,MAAM,CAACiB,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASL,SAASE,SAAS;QAChF,IAAI,CAACC,cAAc;YACjB;QACF;QACA,MAAMD,6NAAYpB,UAAAA,EAAYkB,SAASE,SAAS;QAEhD,IAAI,CAACf,MAAM,CAACe,UAAU,EAAE;YACtBf,MAAM,CAACe,UAAU,GAAG,EAAE;QACxB;QAEA,MAAMI,SAA2B;YAC/BC,QAAQ,CAAC;YACTC,SAAS,CAAC;YACVC,KAAK;gBACHC,QAAQT,IAAI;gBACZU,OAAO,GAAGlB,OAAOH,MAAMsB,IAAI,EAAE;YAC/B;QACF;QAEA,IAAItB,MAAMuB,SAAS,IAAItB,QAAQ;YAC7Be,OAAOG,GAAG,CAACK,OAAO,GAAGvB;QACvB;QACA,IAAIO,0BAA0B;YAC5BQ,OAAOG,GAAG,CAACK,OAAO,GAAGhB;QACvB;QAEA,MAAMiB,iBAAiB9B,QAAQ+B,YAAY,CAACC,GAAG,CAAC,GAAG/B,cAAc,QAAQ,EAAEgB,WAAW;QAEtF,MAAMgB,UAAUjC,QAAQkC,MAAM,CAACJ,eAAe,CAACK,KAAK;QAEpD,+CAA+C;QAC/C,sCAAsC;QACtC,4CAA4C;QAC5C,6CAA6C;QAC7C,+DAA+D;QAC/D,IAAIF,SAAS;YACXZ,OAAOG,GAAG,CAACW,KAAK,GAAGpB,SAASqB,EAAE;YAC9B,OAAOrB,SAASqB,EAAE;QACpB;uZAEAtC,iBAAAA,EAAe;YACbE;YACAsB,QAAQD,OAAOC,MAAM;YACrBrB;YACAC;YACAC;YACAkC,cAAc;YACdjC,MAAMW;YACNuB,aAAa;YACbC,QAAQrB,aAAasB,eAAe;YACpCC,oBAAoB;YACpBlB,SAASF,OAAOE,OAAO;YACvBhB;YACAmC,iBAAiBZ;YACjBtB,MAAM,GAAGA,QAAQ,KAAKH,MAAMsB,IAAI,CAAC,CAAC,EAAEX,EAAE,CAAC,CAAC;YACxCP;YACAC;YACAc,KAAKH,OAAOG,GAAG;YACfb;YACAC;YACAC;QACF;QAEAX,MAAM,CAACe,UAAU,CAAC0B,IAAI,CAACtB;IACzB;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2974, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2980, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/write/numbers.ts"],"sourcesContent":["type Args = {\n  baseRow: Record<string, unknown>\n  data: unknown[]\n  numbers: Record<string, unknown>[]\n}\n\nexport const transformNumbers = ({ baseRow, data, numbers }: Args) => {\n  data.forEach((val, i) => {\n    numbers.push({\n      ...baseRow,\n      number: val,\n      order: i + 1,\n    })\n  })\n}\n"],"names":["transformNumbers","baseRow","data","numbers","forEach","val","i","push","number","order"],"mappings":";;;AAMO,MAAMA,mBAAmB,CAAC,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,EAAQ;IAC/DD,KAAKE,OAAO,CAAC,CAACC,KAAKC;QACjBH,QAAQI,IAAI,CAAC;YACX,GAAGN,OAAO;YACVO,QAAQH;YACRI,OAAOH,IAAI;QACb;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2992, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2998, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/write/relationships.ts"],"sourcesContent":["import type { RelationshipField, UploadField } from 'payload'\n\nimport { valueIsValueWithRelation } from 'payload/shared'\n\ntype Args = {\n  baseRow: Record<string, unknown>\n  data: unknown\n  field: RelationshipField | UploadField\n  relationships: Record<string, unknown>[]\n}\n\nexport const transformRelationship = ({ baseRow, data, field, relationships }: Args) => {\n  const relations = Array.isArray(data) ? data : [data]\n\n  relations.forEach((relation, i) => {\n    if (relation) {\n      const relationRow = { ...baseRow }\n      if ('hasMany' in field && field.hasMany) {\n        relationRow.order = i + 1\n      }\n\n      if (Array.isArray(field.relationTo) && valueIsValueWithRelation(relation)) {\n        relationRow[`${relation.relationTo}ID`] = relation.value\n        relationships.push(relationRow)\n      } else {\n        relationRow[`${field.relationTo}ID`] = relation\n        if (relation) {\n          relationships.push(relationRow)\n        }\n      }\n    }\n  })\n}\n"],"names":["valueIsValueWithRelation","transformRelationship","baseRow","data","field","relationships","relations","Array","isArray","forEach","relation","i","relationRow","hasMany","order","relationTo","value","push"],"mappings":";;;AAEA,SAASA,wBAAwB,QAAQ,iBAAgB;;AASlD,MAAMC,wBAAwB,CAAC,EAAEC,OAAO,EAAEC,IAAI,EAAEC,KAAK,EAAEC,aAAa,EAAQ;IACjF,MAAMC,YAAYC,MAAMC,OAAO,CAACL,QAAQA,OAAO;QAACA;KAAK;IAErDG,UAAUG,OAAO,CAAC,CAACC,UAAUC;QAC3B,IAAID,UAAU;YACZ,MAAME,cAAc;gBAAE,GAAGV,OAAO;YAAC;YACjC,IAAI,aAAaE,SAASA,MAAMS,OAAO,EAAE;gBACvCD,YAAYE,KAAK,GAAGH,IAAI;YAC1B;YAEA,IAAIJ,MAAMC,OAAO,CAACJ,MAAMW,UAAU,MAAKf,iZAAAA,EAAyBU,WAAW;gBACzEE,WAAW,CAAC,GAAGF,SAASK,UAAU,CAAC,EAAE,CAAC,CAAC,GAAGL,SAASM,KAAK;gBACxDX,cAAcY,IAAI,CAACL;YACrB,OAAO;gBACLA,WAAW,CAAC,GAAGR,MAAMW,UAAU,CAAC,EAAE,CAAC,CAAC,GAAGL;gBACvC,IAAIA,UAAU;oBACZL,cAAcY,IAAI,CAACL;gBACrB;YACF;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3027, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3033, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/write/selects.ts"],"sourcesContent":["import { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\n\ntype Args = {\n  data: unknown\n  id?: unknown\n  locale?: string\n}\n\nexport const transformSelects = ({ id, data, locale }: Args) => {\n  const newRows: Record<string, unknown>[] = []\n\n  if (isArrayOfRows(data)) {\n    data.forEach((value, i) => {\n      const newRow: Record<string, unknown> = {\n        order: i + 1,\n        parent: id,\n        value,\n      }\n\n      if (locale) {\n        newRow.locale = locale\n      }\n\n      newRows.push(newRow)\n    })\n  }\n\n  return newRows\n}\n"],"names":["isArrayOfRows","transformSelects","id","data","locale","newRows","forEach","value","i","newRow","order","parent","push"],"mappings":";;;AAAA,SAASA,aAAa,QAAQ,mCAAkC;;AAQzD,MAAMC,mBAAmB,CAAC,EAAEC,EAAE,EAAEC,IAAI,EAAEC,MAAM,EAAQ;IACzD,MAAMC,UAAqC,EAAE;IAE7C,yYAAIL,gBAAAA,EAAcG,OAAO;QACvBA,KAAKG,OAAO,CAAC,CAACC,OAAOC;YACnB,MAAMC,SAAkC;gBACtCC,OAAOF,IAAI;gBACXG,QAAQT;gBACRK;YACF;YAEA,IAAIH,QAAQ;gBACVK,OAAOL,MAAM,GAAGA;YAClB;YAEAC,QAAQO,IAAI,CAACH;QACf;IACF;IAEA,OAAOJ;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3055, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3061, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/write/texts.ts"],"sourcesContent":["type Args = {\n  baseRow: Record<string, unknown>\n  data: unknown[]\n  texts: Record<string, unknown>[]\n}\n\nexport const transformTexts = ({ baseRow, data, texts }: Args) => {\n  data.forEach((val, i) => {\n    texts.push({\n      ...baseRow,\n      order: i + 1,\n      text: val,\n    })\n  })\n}\n"],"names":["transformTexts","baseRow","data","texts","forEach","val","i","push","order","text"],"mappings":";;;AAMO,MAAMA,iBAAiB,CAAC,EAAEC,OAAO,EAAEC,IAAI,EAAEC,KAAK,EAAQ;IAC3DD,KAAKE,OAAO,CAAC,CAACC,KAAKC;QACjBH,MAAMI,IAAI,CAAC;YACT,GAAGN,OAAO;YACVO,OAAOF,IAAI;YACXG,MAAMJ;QACR;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3073, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3079, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/write/traverseFields.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\nimport { sql } from 'drizzle-orm'\nimport { fieldIsVirtual } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { ArrayRowToInsert, BlockRowToInsert, RelationshipToDelete } from './types.js'\n\nimport { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\nimport { transformArray } from './array.js'\nimport { transformBlocks } from './blocks.js'\nimport { transformNumbers } from './numbers.js'\nimport { transformRelationship } from './relationships.js'\nimport { transformSelects } from './selects.js'\nimport { transformTexts } from './texts.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  arrays: {\n    [tableName: string]: ArrayRowToInsert[]\n  }\n  /**\n   * This is the name of the base table\n   */\n  baseTableName: string\n  blocks: {\n    [blockType: string]: BlockRowToInsert[]\n  }\n  blocksToDelete: Set<string>\n  /**\n   * A snake-case field prefix, representing prior fields\n   * Ex: my_group_my_named_tab_\n   */\n  columnPrefix: string\n  data: Record<string, unknown>\n  existingLocales?: Record<string, unknown>[]\n  /**\n   * A prefix that will retain camel-case formatting, representing prior fields\n   * Ex: myGroup_myNamedTab_\n   */\n  fieldPrefix: string\n  fields: FlattenedField[]\n  forcedLocale?: string\n  /**\n   * Tracks whether the current traversion context is from array or block.\n   */\n  insideArrayOrBlock?: boolean\n  locales: {\n    [locale: string]: Record<string, unknown>\n  }\n  numbers: Record<string, unknown>[]\n  /**\n   * This is the name of the parent table\n   */\n  parentTableName: string\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToDelete: RelationshipToDelete[]\n  row: Record<string, unknown>\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\n\nexport const traverseFields = ({\n  adapter,\n  arrays,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  columnPrefix,\n  data,\n  existingLocales,\n  fieldPrefix,\n  fields,\n  forcedLocale,\n  insideArrayOrBlock = false,\n  locales,\n  numbers,\n  parentTableName,\n  path,\n  relationships,\n  relationshipsToDelete,\n  row,\n  selects,\n  texts,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  if (row._uuid) {\n    data._uuid = row._uuid\n  }\n\n  fields.forEach((field) => {\n    let columnName = ''\n    let fieldName = ''\n    let fieldData: unknown\n\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    columnName = `${columnPrefix || ''}${toSnakeCase(field.name)}`\n    fieldName = `${fieldPrefix || ''}${field.name}`\n    fieldData = data[field.name]\n\n    if (field.type === 'array') {\n      const arrayTableName = adapter.tableNameMap.get(`${parentTableName}_${columnName}`)\n\n      if (!arrays[arrayTableName]) {\n        arrays[arrayTableName] = []\n      }\n\n      if (field.localized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              const newRows = transformArray({\n                adapter,\n                arrayTableName,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                data: localeData,\n                field,\n                locale: localeKey,\n                numbers,\n                path,\n                relationships,\n                relationshipsToDelete,\n                selects,\n                texts,\n                withinArrayOrBlockLocale: localeKey,\n              })\n\n              arrays[arrayTableName] = arrays[arrayTableName].concat(newRows)\n            }\n          })\n        }\n      } else {\n        const newRows = transformArray({\n          adapter,\n          arrayTableName,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          data: data[field.name],\n          field,\n          numbers,\n          path,\n          relationships,\n          relationshipsToDelete,\n          selects,\n          texts,\n          withinArrayOrBlockLocale,\n        })\n\n        arrays[arrayTableName] = arrays[arrayTableName].concat(newRows)\n      }\n\n      return\n    }\n\n    if (field.type === 'blocks') {\n      field.blocks.forEach(({ slug }) => {\n        blocksToDelete.add(toSnakeCase(slug))\n      })\n\n      if (field.localized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              transformBlocks({\n                adapter,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                data: localeData,\n                field,\n                locale: localeKey,\n                numbers,\n                path,\n                relationships,\n                relationshipsToDelete,\n                selects,\n                texts,\n                withinArrayOrBlockLocale: localeKey,\n              })\n            }\n          })\n        }\n      } else if (isArrayOfRows(fieldData)) {\n        transformBlocks({\n          adapter,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          data: fieldData,\n          field,\n          numbers,\n          path,\n          relationships,\n          relationshipsToDelete,\n          selects,\n          texts,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'group' || field.type === 'tab') {\n      if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n        if (field.localized) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            // preserve array ID if there is\n            localeData._uuid = data.id || data._uuid\n\n            traverseFields({\n              adapter,\n              arrays,\n              baseTableName,\n              blocks,\n              blocksToDelete,\n              columnPrefix: `${columnName}_`,\n              data: localeData as Record<string, unknown>,\n              existingLocales,\n              fieldPrefix: `${fieldName}_`,\n              fields: field.flattenedFields,\n              forcedLocale: localeKey,\n              insideArrayOrBlock,\n              locales,\n              numbers,\n              parentTableName,\n              path: `${path || ''}${field.name}.`,\n              relationships,\n              relationshipsToDelete,\n              row,\n              selects,\n              texts,\n              withinArrayOrBlockLocale: localeKey,\n            })\n          })\n        } else {\n          // preserve array ID if there is\n          const groupData = data[field.name] as Record<string, unknown>\n          groupData._uuid = data.id || data._uuid\n\n          traverseFields({\n            adapter,\n            arrays,\n            baseTableName,\n            blocks,\n            blocksToDelete,\n            columnPrefix: `${columnName}_`,\n            data: groupData,\n            existingLocales,\n            fieldPrefix: `${fieldName}_`,\n            fields: field.flattenedFields,\n            insideArrayOrBlock,\n            locales,\n            numbers,\n            parentTableName,\n            path: `${path || ''}${field.name}.`,\n            relationships,\n            relationshipsToDelete,\n            row,\n            selects,\n            texts,\n            withinArrayOrBlockLocale,\n          })\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      const relationshipPath = `${path || ''}${field.name}`\n\n      if (\n        field.localized &&\n        (Array.isArray(field.relationTo) || ('hasMany' in field && field.hasMany))\n      ) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (localeData === null) {\n              relationshipsToDelete.push({\n                locale: localeKey,\n                path: relationshipPath,\n              })\n              return\n            }\n\n            transformRelationship({\n              baseRow: {\n                locale: localeKey,\n                path: relationshipPath,\n              },\n              data: localeData,\n              field,\n              relationships,\n            })\n          })\n        }\n        return\n      } else if (Array.isArray(field.relationTo) || ('hasMany' in field && field.hasMany)) {\n        if (fieldData === null || (Array.isArray(fieldData) && fieldData.length === 0)) {\n          relationshipsToDelete.push({ path: relationshipPath })\n          return\n        }\n\n        transformRelationship({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: relationshipPath,\n          },\n          data: fieldData,\n          field,\n          relationships,\n        })\n        return\n      } else {\n        if (\n          !field.localized &&\n          fieldData &&\n          typeof fieldData === 'object' &&\n          'id' in fieldData &&\n          fieldData?.id\n        ) {\n          fieldData = fieldData.id\n        } else if (field.localized) {\n          if (typeof fieldData === 'object') {\n            Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n              if (typeof localeData === 'object') {\n                if (localeData && 'id' in localeData && localeData?.id) {\n                  fieldData[localeKey] = localeData.id\n                }\n              } else {\n                fieldData[localeKey] = localeData\n              }\n            })\n          }\n        }\n      }\n    }\n\n    if (field.type === 'text' && field.hasMany) {\n      const textPath = `${path || ''}${field.name}`\n\n      if (field.localized) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              transformTexts({\n                baseRow: {\n                  locale: localeKey,\n                  path: textPath,\n                },\n                data: localeData,\n                texts,\n              })\n            }\n          })\n        }\n      } else if (Array.isArray(fieldData)) {\n        transformTexts({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: textPath,\n          },\n          data: fieldData,\n          texts,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'number' && field.hasMany) {\n      const numberPath = `${path || ''}${field.name}`\n\n      if (field.localized) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              transformNumbers({\n                baseRow: {\n                  locale: localeKey,\n                  path: numberPath,\n                },\n                data: localeData,\n                numbers,\n              })\n            }\n          })\n        }\n      } else if (Array.isArray(fieldData)) {\n        transformNumbers({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: numberPath,\n          },\n          data: fieldData,\n          numbers,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'select' && field.hasMany) {\n      const selectTableName = adapter.tableNameMap.get(`${parentTableName}_${columnName}`)\n      if (!selects[selectTableName]) {\n        selects[selectTableName] = []\n      }\n\n      if (field.localized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              const newRows = transformSelects({\n                id: insideArrayOrBlock ? data._uuid || data.id : undefined,\n                data: localeData,\n                locale: localeKey,\n              })\n\n              selects[selectTableName] = selects[selectTableName].concat(newRows)\n            }\n          })\n        }\n      } else if (Array.isArray(data[field.name])) {\n        const newRows = transformSelects({\n          id: insideArrayOrBlock ? data._uuid || data.id : undefined,\n          data: data[field.name],\n          locale: withinArrayOrBlockLocale,\n        })\n\n        selects[selectTableName] = selects[selectTableName].concat(newRows)\n      }\n\n      return\n    }\n\n    const valuesToTransform: { localeKey?: string; ref: unknown; value: unknown }[] = []\n\n    if (field.localized) {\n      if (typeof fieldData === 'object' && fieldData !== null) {\n        Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n          if (!locales[localeKey]) {\n            locales[localeKey] = {}\n          }\n\n          valuesToTransform.push({\n            localeKey,\n            ref: locales,\n            value: localeData,\n          })\n        })\n      }\n    } else {\n      let ref = row\n\n      if (forcedLocale) {\n        if (!locales[forcedLocale]) {\n          locales[forcedLocale] = {}\n        }\n        ref = locales[forcedLocale]\n      }\n\n      valuesToTransform.push({ ref, value: fieldData })\n    }\n\n    valuesToTransform.forEach(({ localeKey, ref, value }) => {\n      let formattedValue = value\n\n      if (typeof value !== 'undefined') {\n        if (value && field.type === 'point' && adapter.name !== 'sqlite') {\n          formattedValue = sql`ST_GeomFromGeoJSON(${JSON.stringify(value)})`\n        }\n\n        if (field.type === 'date') {\n          if (typeof value === 'number' && !Number.isNaN(value)) {\n            formattedValue = new Date(value).toISOString()\n          } else if (value instanceof Date) {\n            formattedValue = value.toISOString()\n          }\n        }\n      }\n\n      if (field.type === 'date' && fieldName === 'updatedAt') {\n        // let the db handle this\n        formattedValue = new Date().toISOString()\n      }\n\n      if (typeof formattedValue !== 'undefined') {\n        if (localeKey) {\n          ref[localeKey][fieldName] = formattedValue\n        } else {\n          ref[fieldName] = formattedValue\n        }\n      }\n    })\n  })\n}\n"],"names":["sql","fieldIsVirtual","toSnakeCase","isArrayOfRows","transformArray","transformBlocks","transformNumbers","transformRelationship","transformSelects","transformTexts","traverseFields","adapter","arrays","baseTableName","blocks","blocksToDelete","columnPrefix","data","existingLocales","fieldPrefix","fields","forcedLocale","insideArrayOrBlock","locales","numbers","parentTableName","path","relationships","relationshipsToDelete","row","selects","texts","withinArrayOrBlockLocale","_uuid","forEach","field","columnName","fieldName","fieldData","name","type","arrayTableName","tableNameMap","get","localized","Object","entries","localeKey","localeData","Array","isArray","newRows","locale","concat","slug","add","id","flattenedFields","groupData","relationshipPath","relationTo","hasMany","push","baseRow","length","textPath","numberPath","selectTableName","undefined","valuesToTransform","ref","value","formattedValue","JSON","stringify","Number","isNaN","Date","toISOString"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3475, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3481, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transform/write/index.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { RowToInsert } from './types.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  data: Record<string, unknown>\n  fields: FlattenedField[]\n  path?: string\n  tableName: string\n}\n\nexport const transformForWrite = ({\n  adapter,\n  data,\n  fields,\n  path = '',\n  tableName,\n}: Args): RowToInsert => {\n  // Split out the incoming data into rows to insert / delete\n  const rowToInsert: RowToInsert = {\n    arrays: {},\n    blocks: {},\n    blocksToDelete: new Set(),\n    locales: {},\n    numbers: [],\n    relationships: [],\n    relationshipsToDelete: [],\n    row: {},\n    selects: {},\n    texts: [],\n  }\n\n  // This function is responsible for building up the\n  // above rowToInsert\n  traverseFields({\n    adapter,\n    arrays: rowToInsert.arrays,\n    baseTableName: tableName,\n    blocks: rowToInsert.blocks,\n    blocksToDelete: rowToInsert.blocksToDelete,\n    columnPrefix: '',\n    data,\n    fieldPrefix: '',\n    fields,\n    locales: rowToInsert.locales,\n    numbers: rowToInsert.numbers,\n    parentTableName: tableName,\n    path,\n    relationships: rowToInsert.relationships,\n    relationshipsToDelete: rowToInsert.relationshipsToDelete,\n    row: rowToInsert.row,\n    selects: rowToInsert.selects,\n    texts: rowToInsert.texts,\n  })\n\n  return rowToInsert\n}\n"],"names":["traverseFields","transformForWrite","adapter","data","fields","path","tableName","rowToInsert","arrays","blocks","blocksToDelete","Set","locales","numbers","relationships","relationshipsToDelete","row","selects","texts","baseTableName","columnPrefix","fieldPrefix","parentTableName"],"mappings":";;;AAKA,SAASA,cAAc,QAAQ,sBAAqB;;AAU7C,MAAMC,oBAAoB,CAAC,EAChCC,OAAO,EACPC,IAAI,EACJC,MAAM,EACNC,OAAO,EAAE,EACTC,SAAS,EACJ;IACL,2DAA2D;IAC3D,MAAMC,cAA2B;QAC/BC,QAAQ,CAAC;QACTC,QAAQ,CAAC;QACTC,gBAAgB,IAAIC;QACpBC,SAAS,CAAC;QACVC,SAAS,EAAE;QACXC,eAAe,EAAE;QACjBC,uBAAuB,EAAE;QACzBC,KAAK,CAAC;QACNC,SAAS,CAAC;QACVC,OAAO,EAAE;IACX;IAEA,mDAAmD;IACnD,oBAAoB;mZACpBlB,iBAAAA,EAAe;QACbE;QACAM,QAAQD,YAAYC,MAAM;QAC1BW,eAAeb;QACfG,QAAQF,YAAYE,MAAM;QAC1BC,gBAAgBH,YAAYG,cAAc;QAC1CU,cAAc;QACdjB;QACAkB,aAAa;QACbjB;QACAQ,SAASL,YAAYK,OAAO;QAC5BC,SAASN,YAAYM,OAAO;QAC5BS,iBAAiBhB;QACjBD;QACAS,eAAeP,YAAYO,aAAa;QACxCC,uBAAuBR,YAAYQ,qBAAqB;QACxDC,KAAKT,YAAYS,GAAG;QACpBC,SAASV,YAAYU,OAAO;QAC5BC,OAAOX,YAAYW,KAAK;IAC1B;IAEA,OAAOX;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3524, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3530, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/upsertRow/deleteExistingArrayRows.ts"],"sourcesContent":["import { and, eq } from 'drizzle-orm'\n\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  parentID: unknown\n  tableName: string\n}\n\nexport const deleteExistingArrayRows = async ({\n  adapter,\n  db,\n  parentID,\n  tableName,\n}: Args): Promise<void> => {\n  const table = adapter.tables[tableName]\n\n  const whereConstraints = [eq(table._parentID, parentID)]\n\n  await adapter.deleteWhere({\n    db,\n    tableName,\n    where: and(...whereConstraints),\n  })\n}\n"],"names":["and","eq","deleteExistingArrayRows","adapter","db","parentID","tableName","table","tables","whereConstraints","_parentID","deleteWhere","where"],"mappings":";;;AAAA,SAASA,GAAG,EAAEC,EAAE,QAAQ,cAAa;;AAW9B,MAAMC,0BAA0B,OAAO,EAC5CC,OAAO,EACPC,EAAE,EACFC,QAAQ,EACRC,SAAS,EACJ;IACL,MAAMC,QAAQJ,QAAQK,MAAM,CAACF,UAAU;IAEvC,MAAMG,mBAAmB;QAACR,oVAAAA,EAAGM,MAAMG,SAAS,EAAEL;KAAU;IAExD,MAAMF,QAAQQ,WAAW,CAAC;QACxBP;QACAE;QACAM,sVAAOZ,MAAAA,KAAOS;IAChB;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3546, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3552, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/upsertRow/deleteExistingRowsByPath.ts"],"sourcesContent":["import { and, eq, inArray } from 'drizzle-orm'\n\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  localeColumnName?: string\n  parentColumnName?: string\n  parentID: unknown\n  pathColumnName?: string\n  rows: Record<string, unknown>[]\n  tableName: string\n}\n\nexport const deleteExistingRowsByPath = async ({\n  adapter,\n  db,\n  localeColumnName = '_locale',\n  parentColumnName = '_parentID',\n  parentID,\n  pathColumnName = '_path',\n  rows,\n  tableName,\n}: Args): Promise<void> => {\n  const localizedPathsToDelete = new Set<string>()\n  const pathsToDelete = new Set<string>()\n  const table = adapter.tables[tableName]\n\n  rows.forEach((row) => {\n    const path = row[pathColumnName]\n    const localeData = row[localeColumnName]\n    if (typeof path === 'string') {\n      if (typeof localeData === 'string') {\n        localizedPathsToDelete.add(path)\n      } else {\n        pathsToDelete.add(path)\n      }\n    }\n  })\n\n  if (localizedPathsToDelete.size > 0) {\n    const whereConstraints = [eq(table[parentColumnName], parentID)]\n\n    if (pathColumnName) {\n      whereConstraints.push(inArray(table[pathColumnName], Array.from(localizedPathsToDelete)))\n    }\n\n    await adapter.deleteWhere({\n      db,\n      tableName,\n      where: and(...whereConstraints),\n    })\n  }\n\n  if (pathsToDelete.size > 0) {\n    const whereConstraints = [eq(table[parentColumnName], parentID)]\n\n    if (pathColumnName) {\n      whereConstraints.push(inArray(table[pathColumnName], Array.from(pathsToDelete)))\n    }\n\n    await adapter.deleteWhere({\n      db,\n      tableName,\n      where: and(...whereConstraints),\n    })\n  }\n}\n"],"names":["and","eq","inArray","deleteExistingRowsByPath","adapter","db","localeColumnName","parentColumnName","parentID","pathColumnName","rows","tableName","localizedPathsToDelete","Set","pathsToDelete","table","tables","forEach","row","path","localeData","add","size","whereConstraints","push","Array","from","deleteWhere","where"],"mappings":";;;AAAA,SAASA,GAAG,EAAEC,EAAE,EAAEC,OAAO,QAAQ,cAAa;;AAevC,MAAMC,2BAA2B,OAAO,EAC7CC,OAAO,EACPC,EAAE,EACFC,mBAAmB,SAAS,EAC5BC,mBAAmB,WAAW,EAC9BC,QAAQ,EACRC,iBAAiB,OAAO,EACxBC,IAAI,EACJC,SAAS,EACJ;IACL,MAAMC,yBAAyB,IAAIC;IACnC,MAAMC,gBAAgB,IAAID;IAC1B,MAAME,QAAQX,QAAQY,MAAM,CAACL,UAAU;IAEvCD,KAAKO,OAAO,CAAC,CAACC;QACZ,MAAMC,OAAOD,GAAG,CAACT,eAAe;QAChC,MAAMW,aAAaF,GAAG,CAACZ,iBAAiB;QACxC,IAAI,OAAOa,SAAS,UAAU;YAC5B,IAAI,OAAOC,eAAe,UAAU;gBAClCR,uBAAuBS,GAAG,CAACF;YAC7B,OAAO;gBACLL,cAAcO,GAAG,CAACF;YACpB;QACF;IACF;IAEA,IAAIP,uBAAuBU,IAAI,GAAG,GAAG;QACnC,MAAMC,mBAAmB;2VAACtB,KAAAA,EAAGc,KAAK,CAACR,iBAAiB,EAAEC;SAAU;QAEhE,IAAIC,gBAAgB;YAClBc,iBAAiBC,IAAI,EAACtB,wVAAAA,EAAQa,KAAK,CAACN,eAAe,EAAEgB,MAAMC,IAAI,CAACd;QAClE;QAEA,MAAMR,QAAQuB,WAAW,CAAC;YACxBtB;YACAM;YACAiB,QAAO5B,oVAAAA,KAAOuB;QAChB;IACF;IAEA,IAAIT,cAAcQ,IAAI,GAAG,GAAG;QAC1B,MAAMC,mBAAmB;2VAACtB,KAAAA,EAAGc,KAAK,CAACR,iBAAiB,EAAEC;SAAU;QAEhE,IAAIC,gBAAgB;YAClBc,iBAAiBC,IAAI,gVAACtB,UAAAA,EAAQa,KAAK,CAACN,eAAe,EAAEgB,MAAMC,IAAI,CAACZ;QAClE;QAEA,MAAMV,QAAQuB,WAAW,CAAC;YACxBtB;YACAM;YACAiB,sVAAO5B,MAAAA,KAAOuB;QAChB;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3599, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3605, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/upsertRow/insertArrays.ts"],"sourcesContent":["import type { ArrayRowToInsert } from '../transform/write/types.js'\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  arrays: {\n    [tableName: string]: ArrayRowToInsert[]\n  }[]\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  parentRows: Record<string, unknown>[]\n  uuidMap?: Record<string, number | string>\n}\n\ntype RowsByTable = {\n  [tableName: string]: {\n    arrays: {\n      [tableName: string]: ArrayRowToInsert[]\n    }[]\n    locales: Record<string, unknown>[]\n    rows: Record<string, unknown>[]\n  }\n}\n\nexport const insertArrays = async ({\n  adapter,\n  arrays,\n  db,\n  parentRows,\n  uuidMap = {},\n}: Args): Promise<void> => {\n  // Maintain a map of flattened rows by table\n  const rowsByTable: RowsByTable = {}\n\n  arrays.forEach((arraysByTable, parentRowIndex) => {\n    Object.entries(arraysByTable).forEach(([tableName, arrayRows]) => {\n      // If the table doesn't exist in map, initialize it\n      if (!rowsByTable[tableName]) {\n        rowsByTable[tableName] = {\n          arrays: [],\n          locales: [],\n          rows: [],\n        }\n      }\n\n      const parentID = parentRows[parentRowIndex].id\n\n      // Add any sub arrays that need to be created\n      // We will call this recursively below\n      arrayRows.forEach((arrayRow, i) => {\n        if (Object.keys(arrayRow.arrays).length > 0) {\n          rowsByTable[tableName].arrays.push(arrayRow.arrays)\n        }\n\n        // Set up parent IDs for both row and locale row\n        arrayRow.row._parentID = parentID\n        rowsByTable[tableName].rows.push(arrayRow.row)\n\n        Object.entries(arrayRow.locales).forEach(([arrayRowLocale, arrayRowLocaleData]) => {\n          arrayRowLocaleData._parentID = arrayRow.row.id\n          arrayRowLocaleData._locale = arrayRowLocale\n          rowsByTable[tableName].locales.push(arrayRowLocaleData)\n          if (!arrayRow.row.id) {\n            arrayRowLocaleData._getParentID = (rows: { _uuid: string; id: number }[]) => {\n              const { id } = rows.find((each) => each._uuid === arrayRow.row._uuid)\n              return id\n            }\n          }\n        })\n      })\n    })\n  })\n\n  // Insert all corresponding arrays\n  // (one insert per array table)\n  for (const [tableName, row] of Object.entries(rowsByTable)) {\n    // the nested arrays need the ID for the parentID foreign key\n    let insertedRows: Args['parentRows']\n    if (row.rows.length > 0) {\n      insertedRows = await adapter.insert({\n        db,\n        tableName,\n        values: row.rows,\n      })\n\n      insertedRows.forEach((row) => {\n        if (\n          typeof row._uuid === 'string' &&\n          (typeof row.id === 'string' || typeof row.id === 'number')\n        ) {\n          uuidMap[row._uuid] = row.id\n        }\n      })\n    }\n\n    // Insert locale rows\n    if (adapter.tables[`${tableName}${adapter.localesSuffix}`] && row.locales.length > 0) {\n      if (!row.locales[0]._parentID) {\n        row.locales = row.locales.map((localeRow) => {\n          if (typeof localeRow._getParentID === 'function') {\n            localeRow._parentID = localeRow._getParentID(insertedRows)\n            delete localeRow._getParentID\n          }\n          return localeRow\n        })\n      }\n      await adapter.insert({\n        db,\n        tableName: `${tableName}${adapter.localesSuffix}`,\n        values: row.locales,\n      })\n    }\n\n    // If there are sub arrays, call this function recursively\n    if (row.arrays.length > 0) {\n      await insertArrays({\n        adapter,\n        arrays: row.arrays,\n        db,\n        parentRows: insertedRows,\n      })\n    }\n  }\n}\n"],"names":["insertArrays","adapter","arrays","db","parentRows","uuidMap","rowsByTable","forEach","arraysByTable","parentRowIndex","Object","entries","tableName","arrayRows","locales","rows","parentID","id","arrayRow","i","keys","length","push","row","_parentID","arrayRowLocale","arrayRowLocaleData","_locale","_getParentID","find","each","_uuid","insertedRows","insert","values","tables","localesSuffix","map","localeRow"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3690, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3696, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/upsertRow/index.ts"],"sourcesContent":["import type { TypeWithID } from 'payload'\n\nimport { eq } from 'drizzle-orm'\nimport { ValidationError } from 'payload'\n\nimport type { BlockRowToInsert } from '../transform/write/types.js'\nimport type { Args } from './types.js'\n\nimport { buildFindManyArgs } from '../find/buildFindManyArgs.js'\nimport { transform } from '../transform/read/index.js'\nimport { transformForWrite } from '../transform/write/index.js'\nimport { deleteExistingArrayRows } from './deleteExistingArrayRows.js'\nimport { deleteExistingRowsByPath } from './deleteExistingRowsByPath.js'\nimport { insertArrays } from './insertArrays.js'\n\nexport const upsertRow = async <T extends Record<string, unknown> | TypeWithID>({\n  id,\n  adapter,\n  data,\n  db,\n  fields,\n  ignoreResult,\n  // TODO:\n  // When we support joins for write operations (create/update) - pass collectionSlug to the buildFindManyArgs\n  // Make a new argument in upsertRow.ts and pass the slug from every operation.\n  joinQuery: _joinQuery,\n  operation,\n  path = '',\n  req,\n  select,\n  tableName,\n  upsertTarget,\n  where,\n}: Args): Promise<T> => {\n  // Split out the incoming data into the corresponding:\n  // base row, locales, relationships, blocks, and arrays\n  const rowToInsert = transformForWrite({\n    adapter,\n    data,\n    fields,\n    path,\n    tableName,\n  })\n\n  // First, we insert the main row\n  let insertedRow: Record<string, unknown>\n\n  try {\n    if (operation === 'update') {\n      const target = upsertTarget || adapter.tables[tableName].id\n\n      if (id) {\n        rowToInsert.row.id = id\n        ;[insertedRow] = await adapter.insert({\n          db,\n          onConflictDoUpdate: { set: rowToInsert.row, target },\n          tableName,\n          values: rowToInsert.row,\n        })\n      } else {\n        ;[insertedRow] = await adapter.insert({\n          db,\n          onConflictDoUpdate: { set: rowToInsert.row, target, where },\n          tableName,\n          values: rowToInsert.row,\n        })\n      }\n    } else {\n      ;[insertedRow] = await adapter.insert({\n        db,\n        tableName,\n        values: rowToInsert.row,\n      })\n    }\n\n    const localesToInsert: Record<string, unknown>[] = []\n    const relationsToInsert: Record<string, unknown>[] = []\n    const textsToInsert: Record<string, unknown>[] = []\n    const numbersToInsert: Record<string, unknown>[] = []\n    const blocksToInsert: { [blockType: string]: BlockRowToInsert[] } = {}\n    const selectsToInsert: { [selectTableName: string]: Record<string, unknown>[] } = {}\n\n    // If there are locale rows with data, add the parent and locale to each\n    if (Object.keys(rowToInsert.locales).length > 0) {\n      Object.entries(rowToInsert.locales).forEach(([locale, localeRow]) => {\n        localeRow._parentID = insertedRow.id\n        localeRow._locale = locale\n        localesToInsert.push(localeRow)\n      })\n    }\n\n    // If there are relationships, add parent to each\n    if (rowToInsert.relationships.length > 0) {\n      rowToInsert.relationships.forEach((relation) => {\n        relation.parent = insertedRow.id\n        relationsToInsert.push(relation)\n      })\n    }\n\n    // If there are texts, add parent to each\n    if (rowToInsert.texts.length > 0) {\n      rowToInsert.texts.forEach((textRow) => {\n        textRow.parent = insertedRow.id\n        textsToInsert.push(textRow)\n      })\n    }\n\n    // If there are numbers, add parent to each\n    if (rowToInsert.numbers.length > 0) {\n      rowToInsert.numbers.forEach((numberRow) => {\n        numberRow.parent = insertedRow.id\n        numbersToInsert.push(numberRow)\n      })\n    }\n\n    // If there are selects, add parent to each, and then\n    // store by table name and rows\n    if (Object.keys(rowToInsert.selects).length > 0) {\n      Object.entries(rowToInsert.selects).forEach(([selectTableName, selectRows]) => {\n        selectsToInsert[selectTableName] = []\n\n        selectRows.forEach((row) => {\n          if (typeof row.parent === 'undefined') {\n            row.parent = insertedRow.id\n          }\n\n          selectsToInsert[selectTableName].push(row)\n        })\n      })\n    }\n\n    // If there are blocks, add parent to each, and then\n    // store by table name and rows\n    Object.keys(rowToInsert.blocks).forEach((blockName) => {\n      rowToInsert.blocks[blockName].forEach((blockRow) => {\n        blockRow.row._parentID = insertedRow.id\n        if (!blocksToInsert[blockName]) {\n          blocksToInsert[blockName] = []\n        }\n        if (blockRow.row.uuid) {\n          delete blockRow.row.uuid\n        }\n        blocksToInsert[blockName].push(blockRow)\n      })\n    })\n\n    // //////////////////////////////////\n    // INSERT LOCALES\n    // //////////////////////////////////\n\n    if (localesToInsert.length > 0) {\n      const localeTableName = `${tableName}${adapter.localesSuffix}`\n      const localeTable = adapter.tables[`${tableName}${adapter.localesSuffix}`]\n\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: localeTableName,\n          where: eq(localeTable._parentID, insertedRow.id),\n        })\n      }\n\n      await adapter.insert({\n        db,\n        tableName: localeTableName,\n        values: localesToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT RELATIONSHIPS\n    // //////////////////////////////////\n\n    const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...relationsToInsert, ...rowToInsert.relationshipsToDelete],\n        tableName: relationshipsTableName,\n      })\n    }\n\n    if (relationsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: relationshipsTableName,\n        values: relationsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany TEXTS\n    // //////////////////////////////////\n\n    const textsTableName = `${tableName}_texts`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: textsToInsert,\n        tableName: textsTableName,\n      })\n    }\n\n    if (textsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: textsTableName,\n        values: textsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany NUMBERS\n    // //////////////////////////////////\n\n    const numbersTableName = `${tableName}_numbers`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: numbersToInsert,\n        tableName: numbersTableName,\n      })\n    }\n\n    if (numbersToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: numbersTableName,\n        values: numbersToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT BLOCKS\n    // //////////////////////////////////\n\n    const insertedBlockRows: Record<string, Record<string, unknown>[]> = {}\n\n    if (operation === 'update') {\n      for (const blockName of rowToInsert.blocksToDelete) {\n        const blockTableName = adapter.tableNameMap.get(`${tableName}_blocks_${blockName}`)\n        const blockTable = adapter.tables[blockTableName]\n        await adapter.deleteWhere({\n          db,\n          tableName: blockTableName,\n          where: eq(blockTable._parentID, insertedRow.id),\n        })\n      }\n    }\n\n    // When versions are enabled, this is used to track mapping between blocks/arrays ObjectID to their numeric generated representation, then we use it for nested to arrays/blocks select hasMany in versions.\n    const arraysBlocksUUIDMap: Record<string, number | string> = {}\n\n    for (const [blockName, blockRows] of Object.entries(blocksToInsert)) {\n      const blockTableName = adapter.tableNameMap.get(`${tableName}_blocks_${blockName}`)\n      insertedBlockRows[blockName] = await adapter.insert({\n        db,\n        tableName: blockTableName,\n        values: blockRows.map(({ row }) => row),\n      })\n\n      insertedBlockRows[blockName].forEach((row, i) => {\n        blockRows[i].row = row\n        if (\n          typeof row._uuid === 'string' &&\n          (typeof row.id === 'string' || typeof row.id === 'number')\n        ) {\n          arraysBlocksUUIDMap[row._uuid] = row.id\n        }\n      })\n\n      const blockLocaleIndexMap: number[] = []\n\n      const blockLocaleRowsToInsert = blockRows.reduce((acc, blockRow, i) => {\n        if (Object.entries(blockRow.locales).length > 0) {\n          Object.entries(blockRow.locales).forEach(([blockLocale, blockLocaleData]) => {\n            if (Object.keys(blockLocaleData).length > 0) {\n              blockLocaleData._parentID = blockRow.row.id\n              blockLocaleData._locale = blockLocale\n              acc.push(blockLocaleData)\n              blockLocaleIndexMap.push(i)\n            }\n          })\n        }\n\n        return acc\n      }, [])\n\n      if (blockLocaleRowsToInsert.length > 0) {\n        await adapter.insert({\n          db,\n          tableName: `${blockTableName}${adapter.localesSuffix}`,\n          values: blockLocaleRowsToInsert,\n        })\n      }\n\n      await insertArrays({\n        adapter,\n        arrays: blockRows.map(({ arrays }) => arrays),\n        db,\n        parentRows: insertedBlockRows[blockName],\n        uuidMap: arraysBlocksUUIDMap,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT ARRAYS RECURSIVELY\n    // //////////////////////////////////\n\n    if (operation === 'update') {\n      for (const arrayTableName of Object.keys(rowToInsert.arrays)) {\n        await deleteExistingArrayRows({\n          adapter,\n          db,\n          parentID: insertedRow.id,\n          tableName: arrayTableName,\n        })\n      }\n    }\n\n    await insertArrays({\n      adapter,\n      arrays: [rowToInsert.arrays],\n      db,\n      parentRows: [insertedRow],\n      uuidMap: arraysBlocksUUIDMap,\n    })\n\n    // //////////////////////////////////\n    // INSERT hasMany SELECTS\n    // //////////////////////////////////\n\n    for (const [selectTableName, tableRows] of Object.entries(selectsToInsert)) {\n      const selectTable = adapter.tables[selectTableName]\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: selectTableName,\n          where: eq(selectTable.parent, insertedRow.id),\n        })\n      }\n\n      if (Object.keys(arraysBlocksUUIDMap).length > 0) {\n        tableRows.forEach((row: any) => {\n          if (row.parent in arraysBlocksUUIDMap) {\n            row.parent = arraysBlocksUUIDMap[row.parent]\n          }\n        })\n      }\n\n      if (tableRows.length) {\n        await adapter.insert({\n          db,\n          tableName: selectTableName,\n          values: tableRows,\n        })\n      }\n    }\n\n    // //////////////////////////////////\n    // Error Handling\n    // //////////////////////////////////\n  } catch (error) {\n    if (error.code === '23505') {\n      let fieldName: null | string = null\n      // We need to try and find the right constraint for the field but if we can't we fallback to a generic message\n      if (adapter.fieldConstraints?.[tableName]) {\n        if (adapter.fieldConstraints[tableName]?.[error.constraint]) {\n          fieldName = adapter.fieldConstraints[tableName]?.[error.constraint]\n        } else {\n          const replacement = `${tableName}_`\n\n          if (error.constraint.includes(replacement)) {\n            const replacedConstraint = error.constraint.replace(replacement, '')\n\n            if (replacedConstraint && adapter.fieldConstraints[tableName]?.[replacedConstraint]) {\n              fieldName = adapter.fieldConstraints[tableName][replacedConstraint]\n            }\n          }\n        }\n      }\n\n      if (!fieldName) {\n        // Last case scenario we extract the key and value from the detail on the error\n        const detail = error.detail\n        const regex = /Key \\(([^)]+)\\)=\\(([^)]+)\\)/\n        const match = detail.match(regex)\n\n        if (match) {\n          const key = match[1]\n\n          fieldName = key\n        }\n      }\n\n      throw new ValidationError(\n        {\n          id,\n          errors: [\n            {\n              message: req?.t ? req.t('error:valueMustBeUnique') : 'Value must be unique',\n              path: fieldName,\n            },\n          ],\n        },\n        req?.t,\n      )\n    } else {\n      throw error\n    }\n  }\n\n  if (ignoreResult) {\n    return data as T\n  }\n\n  // //////////////////////////////////\n  // RETRIEVE NEWLY UPDATED ROW\n  // //////////////////////////////////\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    depth: 0,\n    fields,\n    joinQuery: false,\n    select,\n    tableName,\n  })\n\n  findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n  const doc = await db.query[tableName].findFirst(findManyArgs)\n\n  // //////////////////////////////////\n  // TRANSFORM DATA\n  // //////////////////////////////////\n\n  const result = transform<T>({\n    adapter,\n    config: adapter.payload.config,\n    data: doc,\n    fields,\n    joinQuery: false,\n  })\n\n  return result\n}\n"],"names":["eq","ValidationError","buildFindManyArgs","transform","transformForWrite","deleteExistingArrayRows","deleteExistingRowsByPath","insertArrays","upsertRow","id","adapter","data","db","fields","ignoreResult","joinQuery","_joinQuery","operation","path","req","select","tableName","upsertTarget","where","rowToInsert","insertedRow","target","tables","row","insert","onConflictDoUpdate","set","values","localesToInsert","relationsToInsert","textsToInsert","numbersToInsert","blocksToInsert","selectsToInsert","Object","keys","locales","length","entries","forEach","locale","localeRow","_parentID","_locale","push","relationships","relation","parent","texts","textRow","numbers","numberRow","selects","selectTableName","selectRows","blocks","blockName","blockRow","uuid","localeTableName","localesSuffix","localeTable","deleteWhere","relationshipsTableName","relationshipsSuffix","localeColumnName","parentColumnName","parentID","pathColumnName","rows","relationshipsToDelete","textsTableName","numbersTableName","insertedBlockRows","blocksToDelete","blockTableName","tableNameMap","get","blockTable","arraysBlocksUUIDMap","blockRows","map","i","_uuid","blockLocaleIndexMap","blockLocaleRowsToInsert","reduce","acc","blockLocale","blockLocaleData","arrays","parentRows","uuidMap","arrayTableName","tableRows","selectTable","error","code","fieldName","fieldConstraints","constraint","replacement","includes","replacedConstraint","replace","detail","regex","match","key","errors","message","t","findManyArgs","depth","doc","query","findFirst","result","config","payload"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4098, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4104, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/create.ts"],"sourcesContent":["import type { Create } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const create: Create = async function create(\n  this: DrizzleAdapter,\n  { collection: collectionSlug, data, req, select },\n) {\n  const db = await getTransaction(this, req)\n  const collection = this.payload.collections[collectionSlug].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n\n  const result = await upsertRow({\n    adapter: this,\n    data,\n    db,\n    fields: collection.flattenedFields,\n    operation: 'create',\n    req,\n    select,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["toSnakeCase","upsertRow","getTransaction","create","collection","collectionSlug","data","req","select","db","payload","collections","config","tableName","tableNameMap","get","slug","result","adapter","fields","flattenedFields","operation"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;AAEvD,MAAMC,SAAiB,eAAeA,OAE3C,EAAEC,YAAYC,cAAc,EAAEC,IAAI,EAAEC,GAAG,EAAEC,MAAM,EAAE;IAEjD,MAAMC,KAAK,OAAMP,sZAAAA,EAAe,IAAI,EAAEK;IACtC,MAAMH,aAAa,IAAI,CAACM,OAAO,CAACC,WAAW,CAACN,eAAe,CAACO,MAAM;IAElE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kNAACf,UAAAA,EAAYI,WAAWY,IAAI;IAEnE,MAAMC,SAAS,mYAAMhB,YAAAA,EAAU;QAC7BiB,SAAS,IAAI;QACbZ;QACAG;QACAU,QAAQf,WAAWgB,eAAe;QAClCC,WAAW;QACXd;QACAC;QACAK;IACF;IAEA,OAAOI;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4129, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4135, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/createGlobal.ts"],"sourcesContent":["import type { CreateGlobalArgs } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function createGlobal<T extends Record<string, unknown>>(\n  this: DrizzleAdapter,\n  { slug, data, req }: CreateGlobalArgs,\n): Promise<T> {\n  const db = await getTransaction(this, req)\n  const globalConfig = this.payload.globals.config.find((config) => config.slug === slug)\n\n  const tableName = this.tableNameMap.get(toSnakeCase(globalConfig.slug))\n\n  data.createdAt = new Date().toISOString()\n\n  const result = await upsertRow<{ globalType: string } & T>({\n    adapter: this,\n    data,\n    db,\n    fields: globalConfig.flattenedFields,\n    operation: 'create',\n    req,\n    tableName,\n  })\n\n  result.globalType = slug\n\n  return result\n}\n"],"names":["toSnakeCase","upsertRow","getTransaction","createGlobal","slug","data","req","db","globalConfig","payload","globals","config","find","tableName","tableNameMap","get","createdAt","Date","toISOString","result","adapter","fields","flattenedFields","operation","globalType"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;AAEvD,eAAeC,aAEpB,EAAEC,IAAI,EAAEC,IAAI,EAAEC,GAAG,EAAoB;IAErC,MAAMC,KAAK,4YAAML,iBAAAA,EAAe,IAAI,EAAEI;IACtC,MAAME,eAAe,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOP,IAAI,KAAKA;IAElF,MAAMS,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,EAACf,0NAAAA,EAAYQ,aAAaJ,IAAI;IAErEC,KAAKW,SAAS,GAAG,IAAIC,OAAOC,WAAW;IAEvC,MAAMC,SAAS,mYAAMlB,YAAAA,EAAsC;QACzDmB,SAAS,IAAI;QACbf;QACAE;QACAc,QAAQb,aAAac,eAAe;QACpCC,WAAW;QACXjB;QACAO;IACF;IAEAM,OAAOK,UAAU,GAAGpB;IAEpB,OAAOe;AACT","ignoreList":[0]}},
    {"offset": {"line": 4161, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4167, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/createGlobalVersion.ts"],"sourcesContent":["import type { CreateGlobalVersionArgs, TypeWithID, TypeWithVersion } from 'payload'\n\nimport { sql } from 'drizzle-orm'\nimport { buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function createGlobalVersion<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  {\n    autosave,\n    createdAt,\n    globalSlug,\n    publishedLocale,\n    req,\n    select,\n    snapshot,\n    updatedAt,\n    versionData,\n  }: CreateGlobalVersionArgs,\n) {\n  const db = await getTransaction(this, req)\n  const global = this.payload.globals.config.find(({ slug }) => slug === globalSlug)\n\n  const tableName = this.tableNameMap.get(`_${toSnakeCase(global.slug)}${this.versionsSuffix}`)\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    adapter: this,\n    data: {\n      autosave,\n      createdAt,\n      latest: true,\n      publishedLocale,\n      snapshot,\n      updatedAt,\n      version: versionData,\n    },\n    db,\n    fields: buildVersionGlobalFields(this.payload.config, global, true),\n    operation: 'create',\n    req,\n    select,\n    tableName,\n  })\n\n  const table = this.tables[tableName]\n  if (global.versions.drafts) {\n    await this.execute({\n      db,\n      sql: sql`\n          UPDATE ${table}\n          SET latest = false\n          WHERE ${table.id} != ${result.id};\n        `,\n    })\n  }\n\n  return result\n}\n"],"names":["sql","buildVersionGlobalFields","toSnakeCase","upsertRow","getTransaction","createGlobalVersion","autosave","createdAt","globalSlug","publishedLocale","req","select","snapshot","updatedAt","versionData","db","global","payload","globals","config","find","slug","tableName","tableNameMap","get","versionsSuffix","result","adapter","data","latest","version","fields","operation","table","tables","versions","drafts","execute","id"],"mappings":";;;AAIA,OAAOE,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;AAN9D,SAASH,wBAAwB,QAAQ,UAAS;AADlD,SAASD,GAAG,QAAQ,cAAa;;;;;;AAS1B,eAAeK,oBAEpB,EACEC,QAAQ,EACRC,SAAS,EACTC,UAAU,EACVC,eAAe,EACfC,GAAG,EACHC,MAAM,EACNC,QAAQ,EACRC,SAAS,EACTC,WAAW,EACa;IAE1B,MAAMC,KAAK,4YAAMX,iBAAAA,EAAe,IAAI,EAAEM;IACtC,MAAMM,SAAS,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASb;IAEvE,MAAMc,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CAAC,CAAC,CAAC,mNAAEtB,UAAAA,EAAYc,OAAOK,IAAI,IAAI,IAAI,CAACI,cAAc,EAAE;IAE5F,MAAMC,SAAS,mYAAMvB,YAAAA,EAA8B;QACjDwB,SAAS,IAAI;QACbC,MAAM;YACJtB;YACAC;YACAsB,QAAQ;YACRpB;YACAG;YACAC;YACAiB,SAAShB;QACX;QACAC;QACAgB,mYAAQ9B,2BAAAA,EAAyB,IAAI,CAACgB,OAAO,CAACE,MAAM,EAAEH,QAAQ;QAC9DgB,WAAW;QACXtB;QACAC;QACAW;IACF;IAEA,MAAMW,QAAQ,IAAI,CAACC,MAAM,CAACZ,UAAU;IACpC,IAAIN,OAAOmB,QAAQ,CAACC,MAAM,EAAE;QAC1B,MAAM,IAAI,CAACC,OAAO,CAAC;YACjBtB;YACAf,0TAAKA,MAAG,CAAC;iBACE,EAAEiC,MAAM;;gBAET,EAAEA,MAAMK,EAAE,CAAC,IAAI,EAAEZ,OAAOY,EAAE,CAAC;QACnC,CAAC;QACL;IACF;IAEA,OAAOZ;AACT","ignoreList":[0]}},
    {"offset": {"line": 4215, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4221, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/createTableName.ts"],"sourcesContent":["import type { DBIdentifierName } from 'payload'\n\nimport { APIError } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\ntype Args = {\n  adapter: Pick<DrizzleAdapter, 'tableNameMap' | 'versionsSuffix'>\n  /** The collection, global or field config **/\n  config: {\n    dbName?: DBIdentifierName\n    enumName?: DBIdentifierName\n    name?: string\n    slug?: string\n  }\n  /** For nested tables passed for the user custom dbName functions to handle their own iterations */\n  parentTableName?: string\n  /** For sub tables (array for example) this needs to include the parentTableName */\n  prefix?: string\n  /** For tables based on fields that could have both enumName and dbName (ie: select with hasMany), default: 'dbName' */\n  target?: 'dbName' | 'enumName'\n  /** Throws error if true for postgres when table and enum names exceed 63 characters */\n  throwValidationError?: boolean\n  /** Adds the versions suffix to the default table name - should only be used on the base collection to avoid duplicate suffixing */\n  versions?: boolean\n  /** Adds the versions suffix to custom dbName only - this is used while creating blocks / selects / arrays / etc */\n  versionsCustomName?: boolean\n}\n\n/**\n * Used to name database enums and tables\n * Returns the table or enum name for a given entity\n */\nexport const createTableName = ({\n  adapter,\n  config: { name, slug },\n  config,\n  parentTableName,\n  prefix = '',\n  target = 'dbName',\n  throwValidationError = false,\n  versions = false,\n  versionsCustomName = false,\n}: Args): string => {\n  let customNameDefinition = config[target]\n\n  let defaultTableName = `${prefix}${toSnakeCase(name ?? slug)}`\n\n  if (versions) {\n    defaultTableName = `_${defaultTableName}${adapter.versionsSuffix}`\n  }\n\n  let customTableNameResult: string\n\n  if (!customNameDefinition && target === 'enumName') {\n    customNameDefinition = config['dbName']\n  }\n\n  if (customNameDefinition) {\n    customTableNameResult =\n      typeof customNameDefinition === 'function'\n        ? customNameDefinition({ tableName: parentTableName })\n        : customNameDefinition\n\n    if (versionsCustomName) {\n      customTableNameResult = `_${customTableNameResult}${adapter.versionsSuffix}`\n    }\n  }\n\n  const result = customTableNameResult || defaultTableName\n\n  adapter.tableNameMap.set(defaultTableName, result)\n\n  if (!throwValidationError) {\n    return result\n  }\n\n  if (result.length > 63) {\n    throw new APIError(\n      `Exceeded max identifier length for table or enum name of 63 characters. Invalid name: ${result}`,\n    )\n  }\n\n  return result\n}\n"],"names":["APIError","toSnakeCase","createTableName","adapter","config","name","slug","parentTableName","prefix","target","throwValidationError","versions","versionsCustomName","customNameDefinition","defaultTableName","versionsSuffix","customTableNameResult","tableName","result","tableNameMap","set","length"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AADvC,SAASD,QAAQ,QAAQ,UAAS;;;AAgC3B,MAAME,kBAAkB,CAAC,EAC9BC,OAAO,EACPC,QAAQ,EAAEC,IAAI,EAAEC,IAAI,EAAE,EACtBF,MAAM,EACNG,eAAe,EACfC,SAAS,EAAE,EACXC,SAAS,QAAQ,EACjBC,uBAAuB,KAAK,EAC5BC,WAAW,KAAK,EAChBC,qBAAqB,KAAK,EACrB;IACL,IAAIC,uBAAuBT,MAAM,CAACK,OAAO;IAEzC,IAAIK,mBAAmB,GAAGN,UAASP,0NAAAA,EAAYI,QAAQC,OAAO;IAE9D,IAAIK,UAAU;QACZG,mBAAmB,CAAC,CAAC,EAAEA,mBAAmBX,QAAQY,cAAc,EAAE;IACpE;IAEA,IAAIC;IAEJ,IAAI,CAACH,wBAAwBJ,WAAW,YAAY;QAClDI,uBAAuBT,MAAM,CAAC,SAAS;IACzC;IAEA,IAAIS,sBAAsB;QACxBG,wBACE,OAAOH,yBAAyB,aAC5BA,qBAAqB;YAAEI,WAAWV;QAAgB,KAClDM;QAEN,IAAID,oBAAoB;YACtBI,wBAAwB,CAAC,CAAC,EAAEA,wBAAwBb,QAAQY,cAAc,EAAE;QAC9E;IACF;IAEA,MAAMG,SAASF,yBAAyBF;IAExCX,QAAQgB,YAAY,CAACC,GAAG,CAACN,kBAAkBI;IAE3C,IAAI,CAACR,sBAAsB;QACzB,OAAOQ;IACT;IAEA,IAAIA,OAAOG,MAAM,GAAG,IAAI;QACtB,MAAM,gXAAIrB,WAAAA,CACR,CAAC,sFAAsF,EAAEkB,QAAQ;IAErG;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4256, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4262, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/createVersion.ts"],"sourcesContent":["import type { CreateVersionArgs, TypeWithID, TypeWithVersion } from 'payload'\n\nimport { sql } from 'drizzle-orm'\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function createVersion<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  {\n    autosave,\n    collectionSlug,\n    createdAt,\n    parent,\n    publishedLocale,\n    req,\n    select,\n    snapshot,\n    updatedAt,\n    versionData,\n  }: CreateVersionArgs<T>,\n) {\n  const db = await getTransaction(this, req)\n  const collection = this.payload.collections[collectionSlug].config\n  const defaultTableName = toSnakeCase(collection.slug)\n\n  const tableName = this.tableNameMap.get(`_${defaultTableName}${this.versionsSuffix}`)\n\n  const version = { ...versionData }\n  if (version.id) {\n    delete version.id\n  }\n\n  const data: Record<string, unknown> = {\n    autosave,\n    createdAt,\n    latest: true,\n    parent,\n    publishedLocale,\n    snapshot,\n    updatedAt,\n    version,\n  }\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    adapter: this,\n    data,\n    db,\n    fields: buildVersionCollectionFields(this.payload.config, collection, true),\n    operation: 'create',\n    req,\n    select,\n    tableName,\n  })\n\n  const table = this.tables[tableName]\n\n  if (collection.versions.drafts) {\n    await this.execute({\n      db,\n      sql: sql`\n        UPDATE ${table}\n        SET latest = false\n        WHERE ${table.id} != ${result.id}\n          AND ${table.parent} = ${parent}\n          AND ${table.updatedAt} < ${result.updatedAt}\n      `,\n    })\n  }\n\n  return result\n}\n"],"names":["sql","buildVersionCollectionFields","toSnakeCase","upsertRow","getTransaction","createVersion","autosave","collectionSlug","createdAt","parent","publishedLocale","req","select","snapshot","updatedAt","versionData","db","collection","payload","collections","config","defaultTableName","slug","tableName","tableNameMap","get","versionsSuffix","version","id","data","latest","result","adapter","fields","operation","table","tables","versions","drafts","execute"],"mappings":";;;AAIA,OAAOE,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;AAN9D,SAASH,4BAA4B,QAAQ,UAAS;AADtD,SAASD,GAAG,QAAQ,cAAa;;;;;;AAS1B,eAAeK,cAEpB,EACEC,QAAQ,EACRC,cAAc,EACdC,SAAS,EACTC,MAAM,EACNC,eAAe,EACfC,GAAG,EACHC,MAAM,EACNC,QAAQ,EACRC,SAAS,EACTC,WAAW,EACU;IAEvB,MAAMC,KAAK,MAAMZ,uZAAAA,EAAe,IAAI,EAAEO;IACtC,MAAMM,aAAa,IAAI,CAACC,OAAO,CAACC,WAAW,CAACZ,eAAe,CAACa,MAAM;IAClE,MAAMC,oOAAmBnB,UAAAA,EAAYe,WAAWK,IAAI;IAEpD,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CAAC,CAAC,CAAC,EAAEJ,mBAAmB,IAAI,CAACK,cAAc,EAAE;IAEpF,MAAMC,UAAU;QAAE,GAAGZ,WAAW;IAAC;IACjC,IAAIY,QAAQC,EAAE,EAAE;QACd,OAAOD,QAAQC,EAAE;IACnB;IAEA,MAAMC,OAAgC;QACpCvB;QACAE;QACAsB,QAAQ;QACRrB;QACAC;QACAG;QACAC;QACAa;IACF;IAEA,MAAMI,SAAS,OAAM5B,wYAAAA,EAA8B;QACjD6B,SAAS,IAAI;QACbH;QACAb;QACAiB,uYAAQhC,+BAAAA,EAA6B,IAAI,CAACiB,OAAO,CAACE,MAAM,EAAEH,YAAY;QACtEiB,WAAW;QACXvB;QACAC;QACAW;IACF;IAEA,MAAMY,QAAQ,IAAI,CAACC,MAAM,CAACb,UAAU;IAEpC,IAAIN,WAAWoB,QAAQ,CAACC,MAAM,EAAE;QAC9B,MAAM,IAAI,CAACC,OAAO,CAAC;YACjBvB;YACAhB,0TAAKA,MAAG,CAAC;eACA,EAAEmC,MAAM;;cAET,EAAEA,MAAMP,EAAE,CAAC,IAAI,EAAEG,OAAOH,EAAE,CAAC;cAC3B,EAAEO,MAAM1B,MAAM,CAAC,GAAG,EAAEA,OAAO;cAC3B,EAAE0B,MAAMrB,SAAS,CAAC,GAAG,EAAEiB,OAAOjB,SAAS,CAAC;MAChD,CAAC;QACH;IACF;IAEA,OAAOiB;AACT","ignoreList":[0]}},
    {"offset": {"line": 4321, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4327, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queries/selectDistinct.ts"],"sourcesContent":["import type { QueryPromise, SQL } from 'drizzle-orm'\nimport type { SQLiteColumn } from 'drizzle-orm/sqlite-core'\n\nimport type { ChainedMethods } from '../find/chainMethods.js'\nimport type {\n  DrizzleAdapter,\n  DrizzleTransaction,\n  GenericColumn,\n  GenericPgColumn,\n  TransactionPg,\n  TransactionSQLite,\n} from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { chainMethods } from '../find/chainMethods.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  chainedMethods?: ChainedMethods\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  joins: BuildQueryJoinAliases\n  selectFields: Record<string, GenericColumn>\n  tableName: string\n  where: SQL\n}\n\n/**\n * Selects distinct records from a table only if there are joins that need to be used, otherwise return null\n */\nexport const selectDistinct = ({\n  adapter,\n  chainedMethods = [],\n  db,\n  joins,\n  selectFields,\n  tableName,\n  where,\n}: Args): QueryPromise<{ id: number | string }[] & Record<string, GenericColumn>> => {\n  if (Object.keys(joins).length > 0) {\n    if (where) {\n      chainedMethods.push({ args: [where], method: 'where' })\n    }\n\n    joins.forEach(({ condition, table }) => {\n      chainedMethods.push({\n        args: [table, condition],\n        method: 'leftJoin',\n      })\n    })\n\n    let query\n    const table = adapter.tables[tableName]\n\n    if (adapter.name === 'postgres') {\n      query = (db as TransactionPg)\n        .selectDistinct(selectFields as Record<string, GenericPgColumn>)\n        .from(table)\n    }\n    if (adapter.name === 'sqlite') {\n      query = (db as TransactionSQLite)\n        .selectDistinct(selectFields as Record<string, SQLiteColumn>)\n        .from(table)\n    }\n\n    return chainMethods({\n      methods: chainedMethods,\n      query,\n    })\n  }\n}\n"],"names":["chainMethods","selectDistinct","adapter","chainedMethods","db","joins","selectFields","tableName","where","Object","keys","length","push","args","method","forEach","condition","table","query","tables","name","from","methods"],"mappings":";;;AAcA,SAASA,YAAY,QAAQ,0BAAyB;;AAe/C,MAAMC,iBAAiB,CAAC,EAC7BC,OAAO,EACPC,iBAAiB,EAAE,EACnBC,EAAE,EACFC,KAAK,EACLC,YAAY,EACZC,SAAS,EACTC,KAAK,EACA;IACL,IAAIC,OAAOC,IAAI,CAACL,OAAOM,MAAM,GAAG,GAAG;QACjC,IAAIH,OAAO;YACTL,eAAeS,IAAI,CAAC;gBAAEC,MAAM;oBAACL;iBAAM;gBAAEM,QAAQ;YAAQ;QACvD;QAEAT,MAAMU,OAAO,CAAC,CAAC,EAAEC,SAAS,EAAEC,KAAK,EAAE;YACjCd,eAAeS,IAAI,CAAC;gBAClBC,MAAM;oBAACI;oBAAOD;iBAAU;gBACxBF,QAAQ;YACV;QACF;QAEA,IAAII;QACJ,MAAMD,QAAQf,QAAQiB,MAAM,CAACZ,UAAU;QAEvC,IAAIL,QAAQkB,IAAI,KAAK,YAAY;YAC/BF,QAASd,GACNH,cAAc,CAACK,cACfe,IAAI,CAACJ;QACV;QACA,IAAIf,QAAQkB,IAAI,KAAK,UAAU;YAC7BF,QAASd,GACNH,cAAc,CAACK,cACfe,IAAI,CAACJ;QACV;QAEA,sYAAOjB,eAAAA,EAAa;YAClBsB,SAASnB;YACTe;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4365, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4371, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/find/findMany.ts"],"sourcesContent":["import type { FindArgs, FlattenedField, TypeWithID } from 'payload'\n\nimport { inArray } from 'drizzle-orm'\n\nimport type { DrizzleAdapter } from '../types.js'\nimport type { ChainedMethods } from './chainMethods.js'\n\nimport buildQuery from '../queries/buildQuery.js'\nimport { selectDistinct } from '../queries/selectDistinct.js'\nimport { transform } from '../transform/read/index.js'\nimport { getTransaction } from '../utilities/getTransaction.js'\nimport { buildFindManyArgs } from './buildFindManyArgs.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  collectionSlug?: string\n  fields: FlattenedField[]\n  tableName: string\n  versions?: boolean\n} & Omit<FindArgs, 'collection'>\n\nexport const findMany = async function find({\n  adapter,\n  collectionSlug,\n  fields,\n  joins: joinQuery,\n  limit: limitArg,\n  locale,\n  page = 1,\n  pagination,\n  req,\n  select,\n  skip,\n  sort,\n  tableName,\n  versions,\n  where: whereArg,\n}: Args) {\n  const db = await getTransaction(adapter, req)\n  let limit = limitArg\n  let totalDocs: number\n  let totalPages: number\n  let hasPrevPage: boolean\n  let hasNextPage: boolean\n  let pagingCounter: number\n  const offset = skip || (page - 1) * limit\n\n  if (limit === 0) {\n    limit = undefined\n  }\n\n  const { joins, orderBy, selectFields, where } = buildQuery({\n    adapter,\n    fields,\n    locale,\n    sort,\n    tableName,\n    where: whereArg,\n  })\n\n  const orderedIDMap: Record<number | string, number> = {}\n  let orderedIDs: (number | string)[]\n\n  const selectDistinctMethods: ChainedMethods = []\n\n  if (orderBy) {\n    selectDistinctMethods.push({\n      args: [() => orderBy.map(({ column, order }) => order(column))],\n      method: 'orderBy',\n    })\n  }\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    collectionSlug,\n    depth: 0,\n    fields,\n    joinQuery,\n    joins,\n    locale,\n    select,\n    tableName,\n    versions,\n  })\n\n  selectDistinctMethods.push({ args: [offset], method: 'offset' })\n  selectDistinctMethods.push({ args: [limit], method: 'limit' })\n\n  const selectDistinctResult = await selectDistinct({\n    adapter,\n    chainedMethods: selectDistinctMethods,\n    db,\n    joins,\n    selectFields,\n    tableName,\n    where,\n  })\n\n  if (selectDistinctResult) {\n    if (selectDistinctResult.length === 0) {\n      return {\n        docs: [],\n        hasNextPage: false,\n        hasPrevPage: false,\n        limit,\n        nextPage: null,\n        page: 1,\n        pagingCounter: 0,\n        prevPage: null,\n        totalDocs: 0,\n        totalPages: 0,\n      }\n    } else {\n      // set the id in an object for sorting later\n      selectDistinctResult.forEach(({ id }, i) => {\n        orderedIDMap[id] = i\n      })\n      orderedIDs = Object.keys(orderedIDMap)\n      findManyArgs.where = inArray(adapter.tables[tableName].id, orderedIDs)\n    }\n  } else {\n    findManyArgs.limit = limit\n    findManyArgs.offset = offset\n    findManyArgs.orderBy = () => orderBy.map(({ column, order }) => order(column))\n\n    if (where) {\n      findManyArgs.where = where\n    }\n  }\n\n  const findPromise = db.query[tableName].findMany(findManyArgs)\n\n  if (pagination !== false && (orderedIDs ? orderedIDs?.length <= limit : true)) {\n    totalDocs = await adapter.countDistinct({\n      db,\n      joins,\n      tableName,\n      where,\n    })\n\n    totalPages = typeof limit === 'number' && limit !== 0 ? Math.ceil(totalDocs / limit) : 1\n    hasPrevPage = page > 1\n    hasNextPage = totalPages > page\n    pagingCounter = (page - 1) * limit + 1\n  }\n\n  const rawDocs = await findPromise\n  // sort rawDocs from selectQuery\n  if (Object.keys(orderedIDMap).length > 0) {\n    rawDocs.sort((a, b) => orderedIDMap[a.id] - orderedIDMap[b.id])\n  }\n\n  if (pagination === false || !totalDocs) {\n    totalDocs = rawDocs.length\n    totalPages = 1\n    pagingCounter = 1\n    hasPrevPage = false\n    hasNextPage = false\n  }\n\n  const docs = rawDocs.map((data: TypeWithID) => {\n    return transform({\n      adapter,\n      config: adapter.payload.config,\n      data,\n      fields,\n      joinQuery,\n    })\n  })\n\n  return {\n    docs,\n    hasNextPage,\n    hasPrevPage,\n    limit: limitArg,\n    nextPage: hasNextPage ? page + 1 : null,\n    page,\n    pagingCounter,\n    prevPage: hasPrevPage ? page - 1 : null,\n    totalDocs,\n    totalPages,\n  }\n}\n"],"names":["inArray","buildQuery","selectDistinct","transform","getTransaction","buildFindManyArgs","findMany","find","adapter","collectionSlug","fields","joins","joinQuery","limit","limitArg","locale","page","pagination","req","select","skip","sort","tableName","versions","where","whereArg","db","totalDocs","totalPages","hasPrevPage","hasNextPage","pagingCounter","offset","undefined","orderBy","selectFields","orderedIDMap","orderedIDs","selectDistinctMethods","push","args","map","column","order","method","findManyArgs","depth","selectDistinctResult","chainedMethods","length","docs","nextPage","prevPage","forEach","id","i","Object","keys","tables","findPromise","query","countDistinct","Math","ceil","rawDocs","a","b","data","config","payload"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4527, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4533, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/deleteMany.ts"],"sourcesContent":["import type { DeleteMany } from 'payload'\n\nimport { inArray } from 'drizzle-orm'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const deleteMany: DeleteMany = async function deleteMany(\n  this: DrizzleAdapter,\n  { collection, req, where },\n) {\n  const db = await getTransaction(this, req)\n  const collectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  const result = await findMany({\n    adapter: this,\n    fields: collectionConfig.flattenedFields,\n    joins: false,\n    limit: 0,\n    locale: req?.locale,\n    page: 1,\n    pagination: false,\n    req,\n    tableName,\n    where,\n  })\n\n  const ids = []\n\n  result.docs.forEach((data) => {\n    ids.push(data.id)\n  })\n\n  if (ids.length > 0) {\n    await this.deleteWhere({\n      db,\n      tableName,\n      where: inArray(this.tables[tableName].id, ids),\n    })\n  }\n}\n"],"names":["inArray","toSnakeCase","findMany","getTransaction","deleteMany","collection","req","where","db","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","result","adapter","fields","flattenedFields","joins","limit","locale","page","pagination","ids","docs","forEach","data","push","id","length","deleteWhere","tables"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAC7C,SAASC,cAAc,QAAQ,gCAA+B;AAN9D,SAASH,OAAO,QAAQ,cAAa;;;;;AAQ9B,MAAMI,aAAyB,eAAeA,WAEnD,EAAEC,UAAU,EAAEC,GAAG,EAAEC,KAAK,EAAE;IAE1B,MAAMC,KAAK,UAAML,mZAAAA,EAAe,IAAI,EAAEG;IACtC,MAAMG,mBAAmB,IAAI,CAACC,OAAO,CAACC,WAAW,CAACN,WAAW,CAACO,MAAM;IAEpE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kNAACd,UAAAA,EAAYQ,iBAAiBO,IAAI;IAEzE,MAAMC,SAAS,MAAMf,sYAAAA,EAAS;QAC5BgB,SAAS,IAAI;QACbC,QAAQV,iBAAiBW,eAAe;QACxCC,OAAO;QACPC,OAAO;QACPC,QAAQjB,KAAKiB;QACbC,MAAM;QACNC,YAAY;QACZnB;QACAO;QACAN;IACF;IAEA,MAAMmB,MAAM,EAAE;IAEdT,OAAOU,IAAI,CAACC,OAAO,CAAC,CAACC;QACnBH,IAAII,IAAI,CAACD,KAAKE,EAAE;IAClB;IAEA,IAAIL,IAAIM,MAAM,GAAG,GAAG;QAClB,MAAM,IAAI,CAACC,WAAW,CAAC;YACrBzB;YACAK;YACAN,sVAAOP,UAAAA,EAAQ,IAAI,CAACkC,MAAM,CAACrB,UAAU,CAACkB,EAAE,EAAEL;QAC5C;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4572, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4578, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/deleteOne.ts"],"sourcesContent":["import type { DeleteOne } from 'payload'\n\nimport { eq } from 'drizzle-orm'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildFindManyArgs } from './find/buildFindManyArgs.js'\nimport buildQuery from './queries/buildQuery.js'\nimport { selectDistinct } from './queries/selectDistinct.js'\nimport { transform } from './transform/read/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const deleteOne: DeleteOne = async function deleteOne(\n  this: DrizzleAdapter,\n  { collection: collectionSlug, req, select, where: whereArg },\n) {\n  const db = await getTransaction(this, req)\n  const collection = this.payload.collections[collectionSlug].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n\n  let docToDelete: Record<string, unknown>\n\n  const { joins, selectFields, where } = buildQuery({\n    adapter: this,\n    fields: collection.flattenedFields,\n    locale: req?.locale,\n    tableName,\n    where: whereArg,\n  })\n\n  const selectDistinctResult = await selectDistinct({\n    adapter: this,\n    chainedMethods: [{ args: [1], method: 'limit' }],\n    db,\n    joins,\n    selectFields,\n    tableName,\n    where,\n  })\n\n  if (selectDistinctResult?.[0]?.id) {\n    docToDelete = await db.query[tableName].findFirst({\n      where: eq(this.tables[tableName].id, selectDistinctResult[0].id),\n    })\n  } else {\n    const findManyArgs = buildFindManyArgs({\n      adapter: this,\n      depth: 0,\n      fields: collection.flattenedFields,\n      joinQuery: false,\n      select,\n      tableName,\n    })\n\n    findManyArgs.where = where\n\n    docToDelete = await db.query[tableName].findFirst(findManyArgs)\n  }\n\n  const result = transform({\n    adapter: this,\n    config: this.payload.config,\n    data: docToDelete,\n    fields: collection.flattenedFields,\n    joinQuery: false,\n  })\n\n  await this.deleteWhere({\n    db,\n    tableName,\n    where: eq(this.tables[tableName].id, docToDelete.id),\n  })\n\n  return result\n}\n"],"names":["eq","toSnakeCase","buildFindManyArgs","buildQuery","selectDistinct","transform","getTransaction","deleteOne","collection","collectionSlug","req","select","where","whereArg","db","payload","collections","config","tableName","tableNameMap","get","slug","docToDelete","joins","selectFields","adapter","fields","flattenedFields","locale","selectDistinctResult","chainedMethods","args","method","id","query","findFirst","tables","findManyArgs","depth","joinQuery","result","data","deleteWhere"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,iBAAiB,QAAQ,8BAA6B;AAC/D,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,cAAc,QAAQ,8BAA6B;AAC5D,SAASC,SAAS,QAAQ,4BAA2B;AACrD,SAASC,cAAc,QAAQ,gCAA+B;AAT9D,SAASN,EAAE,QAAQ,cAAa;;;;;;;;AAWzB,MAAMO,YAAuB,eAAeA,UAEjD,EAAEC,YAAYC,cAAc,EAAEC,GAAG,EAAEC,MAAM,EAAEC,OAAOC,QAAQ,EAAE;IAE5D,MAAMC,KAAK,MAAMR,uZAAAA,EAAe,IAAI,EAAEI;IACtC,MAAMF,aAAa,IAAI,CAACO,OAAO,CAACC,WAAW,CAACP,eAAe,CAACQ,MAAM;IAElE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kNAACnB,UAAAA,EAAYO,WAAWa,IAAI;IAEnE,IAAIC;IAEJ,MAAM,EAAEC,KAAK,EAAEC,YAAY,EAAEZ,KAAK,EAAE,IAAGT,yYAAAA,EAAW;QAChDsB,SAAS,IAAI;QACbC,QAAQlB,WAAWmB,eAAe;QAClCC,QAAQlB,KAAKkB;QACbV;QACAN,OAAOC;IACT;IAEA,MAAMgB,uBAAuB,0YAAMzB,iBAAAA,EAAe;QAChDqB,SAAS,IAAI;QACbK,gBAAgB;YAAC;gBAAEC,MAAM;oBAAC;iBAAE;gBAAEC,QAAQ;YAAQ;SAAE;QAChDlB;QACAS;QACAC;QACAN;QACAN;IACF;IAEA,IAAIiB,sBAAsB,CAAC,EAAE,EAAEI,IAAI;QACjCX,cAAc,MAAMR,GAAGoB,KAAK,CAAChB,UAAU,CAACiB,SAAS,CAAC;YAChDvB,QAAOZ,mVAAAA,EAAG,IAAI,CAACoC,MAAM,CAAClB,UAAU,CAACe,EAAE,EAAEJ,oBAAoB,CAAC,EAAE,CAACI,EAAE;QACjE;IACF,OAAO;QACL,MAAMI,mZAAenC,oBAAAA,EAAkB;YACrCuB,SAAS,IAAI;YACba,OAAO;YACPZ,QAAQlB,WAAWmB,eAAe;YAClCY,WAAW;YACX5B;YACAO;QACF;QAEAmB,aAAazB,KAAK,GAAGA;QAErBU,cAAc,MAAMR,GAAGoB,KAAK,CAAChB,UAAU,CAACiB,SAAS,CAACE;IACpD;IAEA,MAAMG,UAASnC,gZAAAA,EAAU;QACvBoB,SAAS,IAAI;QACbR,QAAQ,IAAI,CAACF,OAAO,CAACE,MAAM;QAC3BwB,MAAMnB;QACNI,QAAQlB,WAAWmB,eAAe;QAClCY,WAAW;IACb;IAEA,MAAM,IAAI,CAACG,WAAW,CAAC;QACrB5B;QACAI;QACAN,sVAAOZ,KAAAA,EAAG,IAAI,CAACoC,MAAM,CAAClB,UAAU,CAACe,EAAE,EAAEX,YAAYW,EAAE;IACrD;IAEA,OAAOO;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4653, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4659, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/deleteVersions.ts"],"sourcesContent":["import type { DeleteVersions, SanitizedCollectionConfig } from 'payload'\n\nimport { inArray } from 'drizzle-orm'\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const deleteVersions: DeleteVersions = async function deleteVersion(\n  this: DrizzleAdapter,\n  { collection, locale, req, where: where },\n) {\n  const db = await getTransaction(this, req)\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n\n  const { docs } = await findMany({\n    adapter: this,\n    fields,\n    joins: false,\n    limit: 0,\n    locale,\n    page: 1,\n    pagination: false,\n    req,\n    tableName,\n    where,\n  })\n\n  const ids = []\n\n  docs.forEach((doc) => {\n    ids.push(doc.id)\n  })\n\n  if (ids.length > 0) {\n    await this.deleteWhere({\n      db,\n      tableName,\n      where: inArray(this.tables[tableName].id, ids),\n    })\n  }\n\n  return docs\n}\n"],"names":["inArray","buildVersionCollectionFields","toSnakeCase","findMany","getTransaction","deleteVersions","deleteVersion","collection","locale","req","where","db","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","versionsSuffix","fields","docs","adapter","joins","limit","page","pagination","ids","forEach","doc","push","id","length","deleteWhere","tables"],"mappings":";;;AAIA,OAAOE,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAC7C,SAASC,cAAc,QAAQ,gCAA+B;AAN9D,SAASH,4BAA4B,QAAQ,UAAS;AADtD,SAASD,OAAO,QAAQ,cAAa;;;;;;AAS9B,MAAMK,iBAAiC,eAAeC,cAE3D,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAOA,KAAK,EAAE;IAEzC,MAAMC,KAAK,UAAMP,mZAAAA,EAAe,IAAI,EAAEK;IACtC,MAAMG,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACP,WAAW,CAACQ,MAAM;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mNAAEhB,UAAAA,EAAYU,iBAAiBO,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE;IAGhE,MAAMC,wYAASpB,+BAAAA,EAA6B,IAAI,CAACY,OAAO,CAACE,MAAM,EAAEH,kBAAkB;IAEnF,MAAM,EAAEU,IAAI,EAAE,GAAG,MAAMnB,sYAAAA,EAAS;QAC9BoB,SAAS,IAAI;QACbF;QACAG,OAAO;QACPC,OAAO;QACPjB;QACAkB,MAAM;QACNC,YAAY;QACZlB;QACAO;QACAN;IACF;IAEA,MAAMkB,MAAM,EAAE;IAEdN,KAAKO,OAAO,CAAC,CAACC;QACZF,IAAIG,IAAI,CAACD,IAAIE,EAAE;IACjB;IAEA,IAAIJ,IAAIK,MAAM,GAAG,GAAG;QAClB,MAAM,IAAI,CAACC,WAAW,CAAC;YACrBvB;YACAK;YACAN,OAAOV,yVAAAA,EAAQ,IAAI,CAACmC,MAAM,CAACnB,UAAU,CAACgB,EAAE,EAAEJ;QAC5C;IACF;IAEA,OAAON;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4702, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4708, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/destroy.ts"],"sourcesContent":["import type { Destroy } from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const destroy: Destroy = async function destroy(this: DrizzleAdapter) {\n  if (this.enums) {\n    this.enums = {}\n  }\n  this.schema = {}\n  this.tables = {}\n  this.relations = {}\n  this.fieldConstraints = {}\n  this.drizzle = undefined\n  this.initializing = new Promise((res, rej) => {\n    this.resolveInitializing = res\n    this.rejectInitializing = rej\n  })\n}\n"],"names":["destroy","enums","schema","tables","relations","fieldConstraints","drizzle","undefined","initializing","Promise","res","rej","resolveInitializing","rejectInitializing"],"mappings":"AAIA,4DAA4D;;;;AACrD,MAAMA,UAAmB,eAAeA;IAC7C,IAAI,IAAI,CAACC,KAAK,EAAE;QACd,IAAI,CAACA,KAAK,GAAG,CAAC;IAChB;IACA,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,gBAAgB,GAAG,CAAC;IACzB,IAAI,CAACC,OAAO,GAAGC;IACf,IAAI,CAACC,YAAY,GAAG,IAAIC,QAAQ,CAACC,KAAKC;QACpC,IAAI,CAACC,mBAAmB,GAAGF;QAC3B,IAAI,CAACG,kBAAkB,GAAGF;IAC5B;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4726, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4732, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/find.ts"],"sourcesContent":["import type { Find, SanitizedCollectionConfig } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const find: Find = async function find(\n  this: DrizzleAdapter,\n  { collection, joins, limit, locale, page = 1, pagination, req, select, sort: sortArg, where },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : collectionConfig.defaultSort\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  return findMany({\n    adapter: this,\n    collectionSlug: collectionConfig.slug,\n    fields: collectionConfig.flattenedFields,\n    joins,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    select,\n    sort,\n    tableName,\n    where,\n  })\n}\n"],"names":["toSnakeCase","findMany","find","collection","joins","limit","locale","page","pagination","req","select","sort","sortArg","where","collectionConfig","payload","collections","config","undefined","defaultSort","tableName","tableNameMap","get","slug","adapter","collectionSlug","fields","flattenedFields"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;AAEtC,MAAMC,OAAa,eAAeA,KAEvC,EAAEC,UAAU,EAAEC,KAAK,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,CAAC,EAAEC,UAAU,EAAEC,GAAG,EAAEC,MAAM,EAAEC,MAAMC,OAAO,EAAEC,KAAK,EAAE;IAE7F,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACb,WAAW,CAACc,MAAM;IAC/F,MAAMN,OAAOC,YAAYM,aAAaN,YAAY,OAAOA,UAAUE,iBAAiBK,WAAW;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kNAACtB,UAAAA,EAAYc,iBAAiBS,IAAI;IAEzE,kYAAOtB,WAAAA,EAAS;QACduB,SAAS,IAAI;QACbC,gBAAgBX,iBAAiBS,IAAI;QACrCG,QAAQZ,iBAAiBa,eAAe;QACxCvB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAS;QACAP;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4759, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4765, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/findGlobal.ts"],"sourcesContent":["import type { FindGlobal } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const findGlobal: FindGlobal = async function findGlobal(\n  this: DrizzleAdapter,\n  { slug, locale, req, select, where },\n) {\n  const globalConfig = this.payload.globals.config.find((config) => config.slug === slug)\n\n  const tableName = this.tableNameMap.get(toSnakeCase(globalConfig.slug))\n\n  const {\n    docs: [doc],\n  } = await findMany({\n    adapter: this,\n    fields: globalConfig.flattenedFields,\n    limit: 1,\n    locale,\n    pagination: false,\n    req,\n    select,\n    tableName,\n    where,\n  })\n\n  if (doc) {\n    doc.globalType = slug\n    return doc\n  }\n\n  return {}\n}\n"],"names":["toSnakeCase","findMany","findGlobal","slug","locale","req","select","where","globalConfig","payload","globals","config","find","tableName","tableNameMap","get","docs","doc","adapter","fields","flattenedFields","limit","pagination","globalType"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;AAEtC,MAAMC,aAAyB,eAAeA,WAEnD,EAAEC,IAAI,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,KAAK,EAAE;IAEpC,MAAMC,eAAe,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOR,IAAI,KAAKA;IAElF,MAAMU,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kNAACf,UAAAA,EAAYQ,aAAaL,IAAI;IAErE,MAAM,EACJa,MAAM,CAACC,IAAI,EACZ,GAAG,iYAAMhB,WAAAA,EAAS;QACjBiB,SAAS,IAAI;QACbC,QAAQX,aAAaY,eAAe;QACpCC,OAAO;QACPjB;QACAkB,YAAY;QACZjB;QACAC;QACAO;QACAN;IACF;IAEA,IAAIU,KAAK;QACPA,IAAIM,UAAU,GAAGpB;QACjB,OAAOc;IACT;IAEA,OAAO,CAAC;AACV,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4792, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4798, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/findGlobalVersions.ts"],"sourcesContent":["import type { FindGlobalVersions, SanitizedGlobalConfig } from 'payload'\n\nimport { buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const findGlobalVersions: FindGlobalVersions = async function findGlobalVersions(\n  this: DrizzleAdapter,\n  { global, limit, locale, page, pagination, req, select, skip, sort: sortArg, where },\n) {\n  const globalConfig: SanitizedGlobalConfig = this.payload.globals.config.find(\n    ({ slug }) => slug === global,\n  )\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : '-createdAt'\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(globalConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionGlobalFields(this.payload.config, globalConfig, true)\n\n  return findMany({\n    adapter: this,\n    fields,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    select,\n    skip,\n    sort,\n    tableName,\n    where,\n  })\n}\n"],"names":["buildVersionGlobalFields","toSnakeCase","findMany","findGlobalVersions","global","limit","locale","page","pagination","req","select","skip","sort","sortArg","where","globalConfig","payload","globals","config","find","slug","undefined","tableName","tableNameMap","get","versionsSuffix","fields","adapter"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAL7C,SAASF,wBAAwB,QAAQ,UAAS;;;;AAO3C,MAAMG,qBAAyC,eAAeA,mBAEnE,EAAEC,MAAM,EAAEC,KAAK,EAAEC,MAAM,EAAEC,IAAI,EAAEC,UAAU,EAAEC,GAAG,EAAEC,MAAM,EAAEC,IAAI,EAAEC,MAAMC,OAAO,EAAEC,KAAK,EAAE;IAEpF,MAAMC,eAAsC,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAC1E,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAAShB;IAEzB,MAAMQ,OAAOC,YAAYQ,aAAaR,YAAY,OAAOA,UAAU;IAEnE,MAAMS,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mNAAEvB,UAAAA,EAAYc,aAAaK,IAAI,IAAI,IAAI,CAACK,cAAc,EAAE;IAG5D,MAAMC,oYAAS1B,2BAAAA,EAAyB,IAAI,CAACgB,OAAO,CAACE,MAAM,EAAEH,cAAc;IAE3E,kYAAOb,WAAAA,EAAS;QACdyB,SAAS,IAAI;QACbD;QACArB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAU;QACAR;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4827, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4833, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/findMigrationDir.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\n/**\n * Attempt to find migrations directory.\n *\n * Checks for the following directories in order:\n * - `migrationDir` argument from Payload config\n * - `src/migrations`\n * - `dist/migrations`\n * - `migrations`\n *\n * Defaults to `src/migrations`\n *\n * @param migrationDir\n * @returns\n */\nexport function findMigrationDir(migrationDir?: string): string {\n  const cwd = process.cwd()\n  const srcDir = path.resolve(cwd, 'src/migrations')\n  const distDir = path.resolve(cwd, 'dist/migrations')\n  const relativeMigrations = path.resolve(cwd, 'migrations')\n\n  // Use arg if provided\n  if (migrationDir) {\n    return migrationDir\n  }\n\n  // Check other common locations\n  if (fs.existsSync(srcDir)) {\n    return srcDir\n  }\n\n  if (fs.existsSync(distDir)) {\n    return distDir\n  }\n\n  if (fs.existsSync(relativeMigrations)) {\n    return relativeMigrations\n  }\n\n  return srcDir\n}\n"],"names":["fs","path","findMigrationDir","migrationDir","cwd","process","srcDir","resolve","distDir","relativeMigrations","existsSync"],"mappings":";;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;;;AAgBhB,SAASC,iBAAiBC,YAAqB;IACpD,MAAMC,MAAMC,QAAQD,GAAG;IACvB,MAAME,2GAASL,UAAAA,CAAKM,OAAO,CAACH,KAAK;IACjC,MAAMI,4GAAUP,UAAAA,CAAKM,OAAO,CAACH,KAAK;IAClC,MAAMK,uHAAqBR,UAAAA,CAAKM,OAAO,CAACH,KAAK;IAE7C,sBAAsB;IACtB,IAAID,cAAc;QAChB,OAAOA;IACT;IAEA,+BAA+B;IAC/B,kGAAIH,UAAAA,CAAGU,UAAU,CAACJ,SAAS;QACzB,OAAOA;IACT;IAEA,kGAAIN,UAAAA,CAAGU,UAAU,CAACF,UAAU;QAC1B,OAAOA;IACT;IAEA,kGAAIR,UAAAA,CAAGU,UAAU,CAACD,qBAAqB;QACrC,OAAOA;IACT;IAEA,OAAOH;AACT","ignoreList":[0]}},
    {"offset": {"line": 4861, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4867, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/findOne.ts"],"sourcesContent":["import type { FindOneArgs, SanitizedCollectionConfig, TypeWithID } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport async function findOne<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  { collection, joins, locale, req, select, where }: FindOneArgs,\n): Promise<T> {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  const { docs } = await findMany({\n    adapter: this,\n    collectionSlug: collection,\n    fields: collectionConfig.flattenedFields,\n    joins,\n    limit: 1,\n    locale,\n    page: 1,\n    pagination: false,\n    req,\n    select,\n    sort: undefined,\n    tableName,\n    where,\n  })\n\n  return docs?.[0] || null\n}\n"],"names":["toSnakeCase","findMany","findOne","collection","joins","locale","req","select","where","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","docs","adapter","collectionSlug","fields","flattenedFields","limit","page","pagination","sort","undefined"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;AAEtC,eAAeC,QAEpB,EAAEC,UAAU,EAAEC,KAAK,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,KAAK,EAAe;IAE9D,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACR,WAAW,CAACS,MAAM;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kNAACf,UAAAA,EAAYS,iBAAiBO,IAAI;IAEzE,MAAM,EAAEC,IAAI,EAAE,GAAG,iYAAMhB,WAAAA,EAAS;QAC9BiB,SAAS,IAAI;QACbC,gBAAgBhB;QAChBiB,QAAQX,iBAAiBY,eAAe;QACxCjB;QACAkB,OAAO;QACPjB;QACAkB,MAAM;QACNC,YAAY;QACZlB;QACAC;QACAkB,MAAMC;QACNb;QACAL;IACF;IAEA,OAAOS,MAAM,CAAC,EAAE,IAAI;AACtB","ignoreList":[0]}},
    {"offset": {"line": 4894, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4900, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/findVersions.ts"],"sourcesContent":["import type { FindVersions, SanitizedCollectionConfig } from 'payload'\n\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const findVersions: FindVersions = async function findVersions(\n  this: DrizzleAdapter,\n  { collection, limit, locale, page, pagination, req, select, skip, sort: sortArg, where },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : collectionConfig.defaultSort\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n\n  return findMany({\n    adapter: this,\n    fields,\n    joins: false,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    select,\n    skip,\n    sort,\n    tableName,\n    where,\n  })\n}\n"],"names":["buildVersionCollectionFields","toSnakeCase","findMany","findVersions","collection","limit","locale","page","pagination","req","select","skip","sort","sortArg","where","collectionConfig","payload","collections","config","undefined","defaultSort","tableName","tableNameMap","get","slug","versionsSuffix","fields","adapter","joins"],"mappings":";;;AAGA,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAL7C,SAASF,4BAA4B,QAAQ,UAAS;;;;AAO/C,MAAMG,eAA6B,eAAeA,aAEvD,EAAEC,UAAU,EAAEC,KAAK,EAAEC,MAAM,EAAEC,IAAI,EAAEC,UAAU,EAAEC,GAAG,EAAEC,MAAM,EAAEC,IAAI,EAAEC,MAAMC,OAAO,EAAEC,KAAK,EAAE;IAExF,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACb,WAAW,CAACc,MAAM;IAC/F,MAAMN,OAAOC,YAAYM,aAAaN,YAAY,OAAOA,UAAUE,iBAAiBK,WAAW;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,GAAEtB,0NAAAA,EAAYc,iBAAiBS,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE;IAGhE,MAAMC,wYAAS1B,+BAAAA,EAA6B,IAAI,CAACgB,OAAO,CAACE,MAAM,EAAEH,kBAAkB;IAEnF,kYAAOb,WAAAA,EAAS;QACdyB,SAAS,IAAI;QACbD;QACAE,OAAO;QACPvB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAS;QACAP;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4930, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4936, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/migrationTableExists.ts"],"sourcesContent":["import type { DrizzleAdapter } from '../types.js'\n\nexport const migrationTableExists = async (adapter: DrizzleAdapter): Promise<boolean> => {\n  let statement\n\n  if (adapter.name === 'postgres') {\n    const prependSchema = adapter.schemaName ? `\"${adapter.schemaName}\".` : ''\n    statement = `SELECT to_regclass('${prependSchema}\"payload_migrations\"') AS exists;`\n  }\n\n  if (adapter.name === 'sqlite') {\n    statement = `\n      SELECT CASE\n               WHEN COUNT(*) > 0 THEN 1\n               ELSE 0\n               END AS 'exists'\n      FROM sqlite_master\n      WHERE type = 'table'\n        AND name = 'payload_migrations';`\n  }\n\n  const result = await adapter.execute({\n    drizzle: adapter.drizzle,\n    raw: statement,\n  })\n\n  const [row] = result.rows\n\n  return row && typeof row === 'object' && 'exists' in row && !!row.exists\n}\n"],"names":["migrationTableExists","adapter","statement","name","prependSchema","schemaName","result","execute","drizzle","raw","row","rows","exists"],"mappings":";;;AAEO,MAAMA,uBAAuB,OAAOC;IACzC,IAAIC;IAEJ,IAAID,QAAQE,IAAI,KAAK,YAAY;QAC/B,MAAMC,gBAAgBH,QAAQI,UAAU,GAAG,CAAC,CAAC,EAAEJ,QAAQI,UAAU,CAAC,EAAE,CAAC,GAAG;QACxEH,YAAY,CAAC,oBAAoB,EAAEE,cAAc,iCAAiC,CAAC;IACrF;IAEA,IAAIH,QAAQE,IAAI,KAAK,UAAU;QAC7BD,YAAY,CAAC;;;;;;;wCAOuB,CAAC;IACvC;IAEA,MAAMI,SAAS,MAAML,QAAQM,OAAO,CAAC;QACnCC,SAASP,QAAQO,OAAO;QACxBC,KAAKP;IACP;IAEA,MAAM,CAACQ,IAAI,GAAGJ,OAAOK,IAAI;IAEzB,OAAOD,OAAO,OAAOA,QAAQ,YAAY,YAAYA,OAAO,CAAC,CAACA,IAAIE,MAAM;AAC1E,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4962, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4968, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/parseError.ts"],"sourcesContent":["/**\n * Format error message with hint if available\n */\nexport const parseError = (err: unknown, msg: string): string => {\n  let formattedMsg = `${msg}`\n  if (err instanceof Error) {\n    formattedMsg += ` ${err.message}.`\n    // Check if the error has a hint property\n    if ('hint' in err && typeof err.hint === 'string') {\n      formattedMsg += ` ${err.hint}.`\n    }\n  }\n  return formattedMsg\n}\n"],"names":["parseError","err","msg","formattedMsg","Error","message","hint"],"mappings":"AAAA;;CAEC,GACD;;;AAAO,MAAMA,aAAa,CAACC,KAAcC;IACvC,IAAIC,eAAe,GAAGD,KAAK;IAC3B,IAAID,eAAeG,OAAO;QACxBD,gBAAgB,CAAC,CAAC,EAAEF,IAAII,OAAO,CAAC,CAAC,CAAC;QAClC,yCAAyC;QACzC,IAAI,UAAUJ,OAAO,OAAOA,IAAIK,IAAI,KAAK,UAAU;YACjDH,gBAAgB,CAAC,CAAC,EAAEF,IAAIK,IAAI,CAAC,CAAC,CAAC;QACjC;IACF;IACA,OAAOH;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4984, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4990, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/migrate.ts"],"sourcesContent":["import type { Payload } from 'payload'\n\nimport {\n  commitTransaction,\n  createLocalReq,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\nimport prompts from 'prompts'\n\nimport type { DrizzleAdapter, Migration } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\nexport const migrate: DrizzleAdapter['migrate'] = async function migrate(\n  this: DrizzleAdapter,\n  args,\n): Promise<void> {\n  const { payload } = this\n  const migrationFiles = args?.migrations || (await readMigrationFiles({ payload }))\n\n  if (!migrationFiles.length) {\n    payload.logger.info({ msg: 'No migrations to run.' })\n    return\n  }\n\n  if ('createExtensions' in this && typeof this.createExtensions === 'function') {\n    await this.createExtensions()\n  }\n\n  let latestBatch = 0\n  let migrationsInDB = []\n\n  const hasMigrationTable = await migrationTableExists(this)\n\n  if (hasMigrationTable) {\n    ;({ docs: migrationsInDB } = await payload.find({\n      collection: 'payload-migrations',\n      limit: 0,\n      sort: '-name',\n    }))\n    if (Number(migrationsInDB?.[0]?.batch) > 0) {\n      latestBatch = Number(migrationsInDB[0]?.batch)\n    }\n  }\n\n  if (migrationsInDB.find((m) => m.batch === -1)) {\n    const { confirm: runMigrations } = await prompts(\n      {\n        name: 'confirm',\n        type: 'confirm',\n        initial: false,\n        message:\n          \"It looks like you've run Payload in dev mode, meaning you've dynamically pushed changes to your database.\\n\\n\" +\n          \"If you'd like to run migrations, data loss will occur. Would you like to proceed?\",\n      },\n      {\n        onCancel: () => {\n          process.exit(0)\n        },\n      },\n    )\n\n    if (!runMigrations) {\n      process.exit(0)\n    }\n  }\n\n  const newBatch = latestBatch + 1\n\n  // Execute 'up' function for each migration sequentially\n  for (const migration of migrationFiles) {\n    const alreadyRan = migrationsInDB.find((existing) => existing.name === migration.name)\n\n    // If already ran, skip\n    if (alreadyRan) {\n      continue\n    }\n\n    await runMigrationFile(payload, migration, newBatch)\n  }\n}\n\nasync function runMigrationFile(payload: Payload, migration: Migration, batch: number) {\n  const start = Date.now()\n  const req = await createLocalReq({}, payload)\n\n  payload.logger.info({ msg: `Migrating: ${migration.name}` })\n\n  try {\n    await initTransaction(req)\n    const db = await getTransaction(payload.db as DrizzleAdapter, req)\n    await migration.up({ db, payload, req })\n    payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    await payload.create({\n      collection: 'payload-migrations',\n      data: {\n        name: migration.name,\n        batch,\n      },\n      req,\n    })\n    await commitTransaction(req)\n  } catch (err: unknown) {\n    await killTransaction(req)\n    payload.logger.error({\n      err,\n      msg: parseError(err, `Error running migration ${migration.name}`),\n    })\n    process.exit(1)\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","readMigrationFiles","prompts","getTransaction","migrationTableExists","parseError","migrate","args","payload","migrationFiles","migrations","length","logger","info","msg","createExtensions","latestBatch","migrationsInDB","hasMigrationTable","docs","find","collection","limit","sort","Number","batch","m","confirm","runMigrations","name","type","initial","message","onCancel","process","exit","newBatch","migration","alreadyRan","existing","runMigrationFile","start","Date","now","req","db","up","create","data","err","error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5096, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5102, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/migrateDown.ts"],"sourcesContent":["import {\n  commitTransaction,\n  createLocalReq,\n  getMigrations,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\nexport async function migrateDown(this: DrizzleAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const latestBatchMigrations = existingMigrations.filter(({ batch }) => batch === latestBatch)\n\n  for (const migration of latestBatchMigrations) {\n    const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n    if (!migrationFile) {\n      throw new Error(`Migration ${migration.name} not found locally.`)\n    }\n\n    const start = Date.now()\n    const req = await createLocalReq({}, payload)\n\n    try {\n      payload.logger.info({ msg: `Migrating down: ${migrationFile.name}` })\n      await initTransaction(req)\n      const db = await getTransaction(this, req)\n      await migrationFile.down({ db, payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migrationFile.name} (${Date.now() - start}ms)`,\n      })\n\n      const tableExists = await migrationTableExists(this)\n      if (tableExists) {\n        await payload.delete({\n          id: migration.id,\n          collection: 'payload-migrations',\n          req,\n        })\n      }\n\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error migrating down ${migrationFile.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","getMigrations","initTransaction","killTransaction","readMigrationFiles","getTransaction","migrationTableExists","parseError","migrateDown","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","latestBatchMigrations","filter","batch","migration","migrationFile","find","m","name","Error","start","Date","now","req","db","down","tableExists","delete","id","collection","err","error","process","exit"],"mappings":";;;AAWA,SAASM,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,UAAU,QAAQ,4BAA2B;AAbtD,SACER,iBAAiB,EACjBC,cAAc,EACdC,aAAa,EACbC,eAAe,EACfC,eAAe,EACfC,kBAAkB,QACb,UAAS;;;;;;;;;;AAQT,eAAeI;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,gZAAMN,qBAAAA,EAAmB;QAAEK;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAEC,WAAW,EAAE,GAAG,2YAAMX,gBAAAA,EAAc;QAC9DQ;IACF;IAEA,IAAI,CAACE,oBAAoBE,QAAQ;QAC/BJ,QAAQK,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA6B;QACxD;IACF;IAEAP,QAAQK,MAAM,CAACC,IAAI,CAAC;QAClBC,KAAK,CAAC,mBAAmB,EAAEJ,YAAY,eAAe,EAAED,mBAAmBE,MAAM,CAAC,cAAc,CAAC;IACnG;IAEA,MAAMI,wBAAwBN,mBAAmBO,MAAM,CAAC,CAAC,EAAEC,KAAK,EAAE,GAAKA,UAAUP;IAEjF,KAAK,MAAMQ,aAAaH,sBAAuB;QAC7C,MAAMI,gBAAgBX,eAAeY,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAC1E,IAAI,CAACH,eAAe;YAClB,MAAM,IAAII,MAAM,CAAC,UAAU,EAAEL,UAAUI,IAAI,CAAC,mBAAmB,CAAC;QAClE;QAEA,MAAME,QAAQC,KAAKC,GAAG;QACtB,MAAMC,MAAM,+XAAM7B,iBAAAA,EAAe,CAAC,GAAGS;QAErC,IAAI;YACFA,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,EAAE;YAAC;YACnE,OAAMtB,2YAAAA,EAAgB2B;YACtB,MAAMC,KAAK,4YAAMzB,iBAAAA,EAAe,IAAI,EAAEwB;YACtC,MAAMR,cAAcU,IAAI,CAAC;gBAAED;gBAAIrB;gBAASoB;YAAI;YAC5CpB,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAClBC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,CAAC,EAAE,EAAEG,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YACxE;YAEA,MAAMM,cAAc,OAAM1B,kaAAAA,EAAqB,IAAI;YACnD,IAAI0B,aAAa;gBACf,MAAMvB,QAAQwB,MAAM,CAAC;oBACnBC,IAAId,UAAUc,EAAE;oBAChBC,YAAY;oBACZN;gBACF;YACF;YAEA,kYAAM9B,oBAAAA,EAAkB8B;QAC1B,EAAE,OAAOO,KAAc;YACrB,gYAAMjC,kBAAAA,EAAgB0B;YAEtBpB,QAAQK,MAAM,CAACuB,KAAK,CAAC;gBACnBD;gBACApB,uYAAKT,aAAAA,EAAW6B,KAAK,CAAC,qBAAqB,EAAEf,cAAcG,IAAI,CAAC,eAAe,CAAC;YAClF;YACAc,QAAQC,IAAI,CAAC;QACf;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 5176, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5182, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/migrateFresh.ts"],"sourcesContent":["import {\n  commitTransaction,\n  createLocalReq,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\nimport prompts from 'prompts'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { parseError } from './utilities/parseError.js'\n\n/**\n * Drop the current database and run all migrate up functions\n */\nexport async function migrateFresh(\n  this: DrizzleAdapter,\n  { forceAcceptWarning = false },\n): Promise<void> {\n  const { payload } = this\n\n  if (forceAcceptWarning === false) {\n    const { confirm: acceptWarning } = await prompts(\n      {\n        name: 'confirm',\n        type: 'confirm',\n        initial: false,\n        message: `WARNING: This will drop your database and run all migrations. Are you sure you want to proceed?`,\n      },\n      {\n        onCancel: () => {\n          process.exit(0)\n        },\n      },\n    )\n\n    if (!acceptWarning) {\n      process.exit(0)\n    }\n  }\n\n  payload.logger.info({\n    msg: `Dropping database.`,\n  })\n\n  await this.dropDatabase({ adapter: this })\n\n  const migrationFiles = await readMigrationFiles({ payload })\n  payload.logger.debug({\n    msg: `Found ${migrationFiles.length} migration files.`,\n  })\n\n  const req = await createLocalReq({}, payload)\n\n  if ('createExtensions' in this && typeof this.createExtensions === 'function') {\n    await this.createExtensions()\n  }\n\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      const db = await getTransaction(this, req)\n      await migration.up({ db, payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          batch: 1,\n        },\n        req,\n      })\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back`),\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","readMigrationFiles","prompts","getTransaction","parseError","migrateFresh","forceAcceptWarning","payload","confirm","acceptWarning","name","type","initial","message","onCancel","process","exit","logger","info","msg","dropDatabase","adapter","migrationFiles","debug","length","req","createExtensions","migration","start","Date","now","db","up","create","collection","data","batch","err","error"],"mappings":";;;AAOA,OAAOK,aAAa,UAAS;AAI7B,SAASC,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,UAAU,QAAQ,4BAA2B;AAZtD,SACEP,iBAAiB,EACjBC,cAAc,EACdC,eAAe,EACfC,eAAe,EACfC,kBAAkB,QACb,UAAS;;;;;;;;;AAWT,eAAeI,aAEpB,EAAEC,qBAAqB,KAAK,EAAE;IAE9B,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IAExB,IAAID,uBAAuB,OAAO;QAChC,MAAM,EAAEE,SAASC,aAAa,EAAE,GAAG,+LAAMP,UAAAA,EACvC;YACEQ,MAAM;YACNC,MAAM;YACNC,SAAS;YACTC,SAAS,CAAC,+FAA+F,CAAC;QAC5G,GACA;YACEC,UAAU;gBACRC,QAAQC,IAAI,CAAC;YACf;QACF;QAGF,IAAI,CAACP,eAAe;YAClBM,QAAQC,IAAI,CAAC;QACf;IACF;IAEAT,QAAQU,MAAM,CAACC,IAAI,CAAC;QAClBC,KAAK,CAAC,kBAAkB,CAAC;IAC3B;IAEA,MAAM,IAAI,CAACC,YAAY,CAAC;QAAEC,SAAS,IAAI;IAAC;IAExC,MAAMC,iBAAiB,gZAAMrB,qBAAAA,EAAmB;QAAEM;IAAQ;IAC1DA,QAAQU,MAAM,CAACM,KAAK,CAAC;QACnBJ,KAAK,CAAC,MAAM,EAAEG,eAAeE,MAAM,CAAC,iBAAiB,CAAC;IACxD;IAEA,MAAMC,MAAM,+XAAM3B,iBAAAA,EAAe,CAAC,GAAGS;IAErC,IAAI,sBAAsB,IAAI,IAAI,OAAO,IAAI,CAACmB,gBAAgB,KAAK,YAAY;QAC7E,MAAM,IAAI,CAACA,gBAAgB;IAC7B;IAEA,qBAAqB;IACrB,KAAK,MAAMC,aAAaL,eAAgB;QACtCf,QAAQU,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK,CAAC,WAAW,EAAEQ,UAAUjB,IAAI,EAAE;QAAC;QAC1D,IAAI;YACF,MAAMkB,QAAQC,KAAKC,GAAG;YACtB,gYAAM/B,kBAAAA,EAAgB0B;YACtB,MAAMM,KAAK,UAAM5B,mZAAAA,EAAe,IAAI,EAAEsB;YACtC,MAAME,UAAUK,EAAE,CAAC;gBAAED;gBAAIxB;gBAASkB;YAAI;YACtC,MAAMlB,QAAQ0B,MAAM,CAAC;gBACnBC,YAAY;gBACZC,MAAM;oBACJzB,MAAMiB,UAAUjB,IAAI;oBACpB0B,OAAO;gBACT;gBACAX;YACF;YACA,MAAM5B,gZAAAA,EAAkB4B;YAExBlB,QAAQU,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,WAAW,EAAEQ,UAAUjB,IAAI,CAAC,EAAE,EAAEmB,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YAAC;QACtF,EAAE,OAAOS,KAAc;YACrB,gYAAMrC,kBAAAA,EAAgByB;YACtBlB,QAAQU,MAAM,CAACqB,KAAK,CAAC;gBACnBD;gBACAlB,uYAAKf,aAAAA,EAAWiC,KAAK,CAAC,wBAAwB,EAAEV,UAAUjB,IAAI,CAAC,cAAc,CAAC;YAChF;YACAK,QAAQC,IAAI,CAAC;QACf;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 5266, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5272, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/migrateRefresh.ts"],"sourcesContent":["import {\n  commitTransaction,\n  createLocalReq,\n  getMigrations,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\n/**\n * Run all migration down functions before running up\n */\nexport async function migrateRefresh(this: DrizzleAdapter) {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const req = await createLocalReq({}, payload)\n\n  // Reverse order of migrations to rollback\n  existingMigrations.reverse()\n\n  for (const migration of existingMigrations) {\n    try {\n      const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n      if (!migrationFile) {\n        throw new Error(`Migration ${migration.name} not found locally.`)\n      }\n\n      payload.logger.info({ msg: `Migrating down: ${migration.name}` })\n      const start = Date.now()\n      await initTransaction(req)\n      const db = await getTransaction(this, req)\n      await migrationFile.down({ db, payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)`,\n      })\n\n      const tableExists = await migrationTableExists(this)\n      if (tableExists) {\n        await payload.delete({\n          collection: 'payload-migrations',\n          req,\n          where: {\n            name: {\n              equals: migration.name,\n            },\n          },\n        })\n      }\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      await migration.up({ payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          executed: true,\n        },\n        req,\n      })\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","getMigrations","initTransaction","killTransaction","readMigrationFiles","getTransaction","migrationTableExists","parseError","migrateRefresh","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","req","reverse","migration","migrationFile","find","m","name","Error","start","Date","now","db","down","tableExists","delete","collection","where","equals","err","error","process","exit","up","create","data","executed"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5384, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5390, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/migrateReset.ts"],"sourcesContent":["import {\n  commitTransaction,\n  createLocalReq,\n  getMigrations,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\n\n/**\n * Run all migrate down functions\n */\nexport async function migrateReset(this: DrizzleAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations } = await getMigrations({ payload })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to reset.' })\n    return\n  }\n\n  const req = await createLocalReq({}, payload)\n\n  // Rollback all migrations in order\n  for (const migration of existingMigrations) {\n    const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n    try {\n      if (!migrationFile) {\n        throw new Error(`Migration ${migration.name} not found locally.`)\n      }\n\n      const start = Date.now()\n      payload.logger.info({ msg: `Migrating down: ${migrationFile.name}` })\n      await initTransaction(req)\n      const db = await getTransaction(this, req)\n      await migrationFile.down({ db, payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migrationFile.name} (${Date.now() - start}ms)`,\n      })\n\n      const tableExists = await migrationTableExists(this)\n      if (tableExists) {\n        await payload.delete({\n          id: migration.id,\n          collection: 'payload-migrations',\n          req,\n        })\n      }\n\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      let msg = `Error running migration ${migrationFile.name}.`\n\n      if (err instanceof Error) {\n        msg += ` ${err.message}`\n      }\n\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg,\n      })\n      process.exit(1)\n    }\n  }\n\n  // Delete dev migration\n\n  const tableExists = await migrationTableExists(this)\n  if (tableExists) {\n    try {\n      await payload.delete({\n        collection: 'payload-migrations',\n        where: {\n          batch: {\n            equals: -1,\n          },\n        },\n      })\n    } catch (err: unknown) {\n      payload.logger.error({ err, msg: 'Error deleting dev migration' })\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","getMigrations","initTransaction","killTransaction","readMigrationFiles","getTransaction","migrationTableExists","migrateReset","payload","migrationFiles","existingMigrations","length","logger","info","msg","req","migration","migrationFile","find","m","name","Error","start","Date","now","db","down","tableExists","delete","id","collection","err","message","error","process","exit","where","batch","equals"],"mappings":";;;AAWA,SAASM,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,oBAAoB,QAAQ,sCAAqC;AAZ1E,SACEP,iBAAiB,EACjBC,cAAc,EACdC,aAAa,EACbC,eAAe,EACfC,eAAe,EACfC,kBAAkB,QACb,UAAS;;;;;;;;;AAUT,eAAeG;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,gZAAML,qBAAAA,EAAmB;QAAEI;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAE,GAAG,2YAAMT,gBAAAA,EAAc;QAAEO;IAAQ;IAE7D,IAAI,CAACE,oBAAoBC,QAAQ;QAC/BH,QAAQI,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA0B;QACrD;IACF;IAEA,MAAMC,MAAM,+XAAMf,iBAAAA,EAAe,CAAC,GAAGQ;IAErC,mCAAmC;IACnC,KAAK,MAAMQ,aAAaN,mBAAoB;QAC1C,MAAMO,gBAAgBR,eAAeS,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAC1E,IAAI;YACF,IAAI,CAACH,eAAe;gBAClB,MAAM,IAAII,MAAM,CAAC,UAAU,EAAEL,UAAUI,IAAI,CAAC,mBAAmB,CAAC;YAClE;YAEA,MAAME,QAAQC,KAAKC,GAAG;YACtBhB,QAAQI,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEG,cAAcG,IAAI,EAAE;YAAC;YACnE,gYAAMlB,kBAAAA,EAAgBa;YACtB,MAAMU,KAAK,OAAMpB,sZAAAA,EAAe,IAAI,EAAEU;YACtC,MAAME,cAAcS,IAAI,CAAC;gBAAED;gBAAIjB;gBAASO;YAAI;YAC5CP,QAAQI,MAAM,CAACC,IAAI,CAAC;gBAClBC,KAAK,CAAC,gBAAgB,EAAEG,cAAcG,IAAI,CAAC,EAAE,EAAEG,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YACxE;YAEA,MAAMK,cAAc,kZAAMrB,uBAAAA,EAAqB,IAAI;YACnD,IAAIqB,aAAa;gBACf,MAAMnB,QAAQoB,MAAM,CAAC;oBACnBC,IAAIb,UAAUa,EAAE;oBAChBC,YAAY;oBACZf;gBACF;YACF;YAEA,kYAAMhB,oBAAAA,EAAkBgB;QAC1B,EAAE,OAAOgB,KAAc;YACrB,IAAIjB,MAAM,CAAC,wBAAwB,EAAEG,cAAcG,IAAI,CAAC,CAAC,CAAC;YAE1D,IAAIW,eAAeV,OAAO;gBACxBP,OAAO,CAAC,CAAC,EAAEiB,IAAIC,OAAO,EAAE;YAC1B;YAEA,gYAAM7B,kBAAAA,EAAgBY;YACtBP,QAAQI,MAAM,CAACqB,KAAK,CAAC;gBACnBF;gBACAjB;YACF;YACAoB,QAAQC,IAAI,CAAC;QACf;IACF;IAEA,uBAAuB;IAEvB,MAAMR,cAAc,OAAMrB,kaAAAA,EAAqB,IAAI;IACnD,IAAIqB,aAAa;QACf,IAAI;YACF,MAAMnB,QAAQoB,MAAM,CAAC;gBACnBE,YAAY;gBACZM,OAAO;oBACLC,OAAO;wBACLC,QAAQ,CAAC;oBACX;gBACF;YACF;QACF,EAAE,OAAOP,KAAc;YACrBvB,QAAQI,MAAM,CAACqB,KAAK,CAAC;gBAAEF;gBAAKjB,KAAK;YAA+B;QAClE;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 5482, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5488, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/migrateStatus.ts"],"sourcesContent":["import { Table } from 'console-table-printer'\nimport { getMigrations, readMigrationFiles } from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\n\nexport async function migrateStatus(this: DrizzleAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  payload.logger.debug({\n    msg: `Found ${migrationFiles.length} migration files.`,\n  })\n\n  let existingMigrations = []\n  const hasMigrationTable = await migrationTableExists(this)\n\n  if (hasMigrationTable) {\n    ;({ existingMigrations } = await getMigrations({ payload }))\n  }\n\n  if (!migrationFiles.length) {\n    payload.logger.info({ msg: 'No migrations found.' })\n    return\n  }\n\n  // Compare migration files to existing migrations\n  const statuses = migrationFiles.map((migration) => {\n    const existingMigration = existingMigrations.find((m) => m.name === migration.name)\n    return {\n      Name: migration.name,\n\n      Batch: existingMigration?.batch,\n      Ran: existingMigration ? 'Yes' : 'No',\n    }\n  })\n\n  const p = new Table()\n\n  statuses.forEach((s) => {\n    p.addRow(s, {\n      color: s.Ran === 'Yes' ? 'green' : 'red',\n    })\n  })\n  p.printTable()\n}\n"],"names":["Table","getMigrations","readMigrationFiles","migrationTableExists","migrateStatus","payload","migrationFiles","logger","debug","msg","length","existingMigrations","hasMigrationTable","info","statuses","map","migration","existingMigration","find","m","name","Name","Batch","batch","Ran","p","forEach","s","addRow","color","printTable"],"mappings":";;;AAAA,SAASA,KAAK,QAAQ,wBAAuB;AAK7C,SAASG,oBAAoB,QAAQ,sCAAqC;AAJ1E,SAASF,aAAa,EAAEC,kBAAkB,QAAQ,UAAS;;;;;AAMpD,eAAeE;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,gZAAMJ,qBAAAA,EAAmB;QAAEG;IAAQ;IAE1DA,QAAQE,MAAM,CAACC,KAAK,CAAC;QACnBC,KAAK,CAAC,MAAM,EAAEH,eAAeI,MAAM,CAAC,iBAAiB,CAAC;IACxD;IAEA,IAAIC,qBAAqB,EAAE;IAC3B,MAAMC,oBAAoB,MAAMT,maAAAA,EAAqB,IAAI;IAEzD,IAAIS,mBAAmB;;QACnB,CAAA,EAAED,kBAAkB,EAAE,GAAG,MAAMV,qZAAAA,EAAc;YAAEI;QAAQ,EAAC;IAC5D;IAEA,IAAI,CAACC,eAAeI,MAAM,EAAE;QAC1BL,QAAQE,MAAM,CAACM,IAAI,CAAC;YAAEJ,KAAK;QAAuB;QAClD;IACF;IAEA,iDAAiD;IACjD,MAAMK,WAAWR,eAAeS,GAAG,CAAC,CAACC;QACnC,MAAMC,oBAAoBN,mBAAmBO,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAClF,OAAO;YACLC,MAAML,UAAUI,IAAI;YAEpBE,OAAOL,mBAAmBM;YAC1BC,KAAKP,oBAAoB,QAAQ;QACnC;IACF;IAEA,MAAMQ,IAAI,0OAAIzB,QAAAA;IAEdc,SAASY,OAAO,CAAC,CAACC;QAChBF,EAAEG,MAAM,CAACD,GAAG;YACVE,OAAOF,EAAEH,GAAG,KAAK,QAAQ,UAAU;QACrC;IACF;IACAC,EAAEK,UAAU;AACd","ignoreList":[0]}},
    {"offset": {"line": 5537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5543, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queries/operatorMap.ts"],"sourcesContent":["import {\n  and,\n  type Column,\n  eq,\n  gt,\n  gte,\n  ilike,\n  inArray,\n  isNotNull,\n  isNull,\n  lt,\n  lte,\n  ne,\n  notInArray,\n  or,\n  type SQL,\n  type SQLWrapper,\n} from 'drizzle-orm'\n\ntype OperatorKeys =\n  | 'and'\n  | 'contains'\n  | 'equals'\n  | 'exists'\n  | 'greater_than'\n  | 'greater_than_equal'\n  | 'in'\n  | 'isNull'\n  | 'less_than'\n  | 'less_than_equal'\n  | 'like'\n  | 'not_equals'\n  | 'not_in'\n  | 'or'\n\nexport type Operators = Record<OperatorKeys, (column: Column, value: SQLWrapper | unknown) => SQL>\n\nexport const operatorMap: Operators = {\n  and,\n  contains: ilike,\n  equals: eq,\n  exists: isNotNull,\n  greater_than: gt,\n  greater_than_equal: gte,\n  in: inArray,\n  isNull, // handles exists: false\n  less_than: lt,\n  less_than_equal: lte,\n  like: ilike,\n  not_equals: ne,\n  // TODO: support this\n  // all: all,\n  not_in: notInArray,\n  or,\n}\n"],"names":["and","eq","gt","gte","ilike","inArray","isNotNull","isNull","lt","lte","ne","notInArray","or","operatorMap","contains","equals","exists","greater_than","greater_than_equal","in","less_than","less_than_equal","like","not_equals","not_in"],"mappings":";;;AAAA,SACEA,GAAG,EAEHC,EAAE,EACFC,EAAE,EACFC,GAAG,EACHC,KAAK,EACLC,OAAO,EACPC,SAAS,EACTC,MAAM,EACNC,EAAE,EACFC,GAAG,EACHC,EAAE,EACFC,UAAU,EACVC,EAAE,QAGG,cAAa;;AAoBb,MAAMC,cAAyB;oVACpCb,MAAAA;IACAc,qVAAUV,QAAAA;IACVW,mVAAQd,KAAAA;IACRe,mVAAQV,YAAAA;IACRW,yVAAcf,KAAAA;IACdgB,+VAAoBf,MAAAA;IACpBgB,+UAAId,UAAAA;uVACJE,SAAAA;IACAa,sVAAWZ,KAAAA;IACXa,4VAAiBZ,MAAAA;IACjBa,iVAAMlB,QAAAA;IACNmB,uVAAYb,KAAAA;IACZ,qBAAqB;IACrB,YAAY;IACZc,mVAAQb,aAAAA;mVACRC,KAAAA;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 5566, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5572, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/queryDrafts.ts"],"sourcesContent":["import type { QueryDrafts, SanitizedCollectionConfig } from 'payload'\n\nimport { buildVersionCollectionFields, combineQueries } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const queryDrafts: QueryDrafts = async function queryDrafts(\n  this: DrizzleAdapter,\n  { collection, joins, limit, locale, page = 1, pagination, req, select, sort, where },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n\n  const combinedWhere = combineQueries({ latest: { equals: true } }, where)\n\n  const result = await findMany({\n    adapter: this,\n    collectionSlug: collection,\n    fields,\n    joins,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    select,\n    sort,\n    tableName,\n    versions: true,\n    where: combinedWhere,\n  })\n\n  return {\n    ...result,\n    docs: result.docs.map((doc) => {\n      doc = {\n        id: doc.parent,\n        ...doc.version,\n      }\n\n      return doc\n    }),\n  }\n}\n"],"names":["buildVersionCollectionFields","combineQueries","toSnakeCase","findMany","queryDrafts","collection","joins","limit","locale","page","pagination","req","select","sort","where","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","versionsSuffix","fields","combinedWhere","latest","equals","result","adapter","collectionSlug","versions","docs","map","doc","id","parent","version"],"mappings":";;;AAGA,OAAOE,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAL7C,SAASH,4BAA4B,EAAEC,cAAc,QAAQ,UAAS;;;;;AAO/D,MAAMG,cAA2B,eAAeA,YAErD,EAAEC,UAAU,EAAEC,KAAK,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,CAAC,EAAEC,UAAU,EAAEC,GAAG,EAAEC,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAE;IAEpF,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACZ,WAAW,CAACa,MAAM;IAC/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mNAAEnB,UAAAA,EAAYa,iBAAiBO,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE;IAEhE,MAAMC,wYAASxB,+BAAAA,EAA6B,IAAI,CAACgB,OAAO,CAACE,MAAM,EAAEH,kBAAkB;IAEnF,MAAMU,iBAAgBxB,wYAAAA,EAAe;QAAEyB,QAAQ;YAAEC,QAAQ;QAAK;IAAE,GAAGb;IAEnE,MAAMc,SAAS,OAAMzB,qYAAAA,EAAS;QAC5B0B,SAAS,IAAI;QACbC,gBAAgBzB;QAChBmB;QACAlB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAM;QACAY,UAAU;QACVjB,OAAOW;IACT;IAEA,OAAO;QACL,GAAGG,MAAM;QACTI,MAAMJ,OAAOI,IAAI,CAACC,GAAG,CAAC,CAACC;YACrBA,MAAM;gBACJC,IAAID,IAAIE,MAAM;gBACd,GAAGF,IAAIG,OAAO;YAChB;YAEA,OAAOH;QACT;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 5618, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5624, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/schema/buildDrizzleRelations.ts"],"sourcesContent":["import type { Relation } from 'drizzle-orm'\n\nimport { relations } from 'drizzle-orm'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nexport const buildDrizzleRelations = ({ adapter }: { adapter: DrizzleAdapter }) => {\n  for (const tableName in adapter.rawRelations) {\n    const rawRelations = adapter.rawRelations[tableName]\n\n    adapter.relations[`relations_${tableName}`] = relations(\n      adapter.tables[tableName],\n      ({ many, one }) => {\n        const result: Record<string, Relation<string>> = {}\n\n        for (const key in rawRelations) {\n          const relation = rawRelations[key]\n\n          if (relation.type === 'one') {\n            result[key] = one(adapter.tables[relation.to], {\n              fields: relation.fields.map(\n                (field) => adapter.tables[field.table][field.name],\n              ) as any,\n              references: relation.references.map(\n                (reference) => adapter.tables[relation.to][reference],\n              ),\n              relationName: relation.relationName,\n            })\n          } else {\n            result[key] = many(adapter.tables[relation.to], {\n              relationName: relation.relationName,\n            })\n          }\n        }\n\n        return result\n      },\n    )\n  }\n}\n"],"names":["relations","buildDrizzleRelations","adapter","tableName","rawRelations","tables","many","one","result","key","relation","type","to","fields","map","field","table","name","references","reference","relationName"],"mappings":";;;AAEA,SAASA,SAAS,QAAQ,cAAa;;AAIhC,MAAMC,wBAAwB,CAAC,EAAEC,OAAO,EAA+B;IAC5E,IAAK,MAAMC,aAAaD,QAAQE,YAAY,CAAE;QAC5C,MAAMA,eAAeF,QAAQE,YAAY,CAACD,UAAU;QAEpDD,QAAQF,SAAS,CAAC,CAAC,UAAU,EAAEG,WAAW,CAAC,2TAAGH,YAAAA,EAC5CE,QAAQG,MAAM,CAACF,UAAU,EACzB,CAAC,EAAEG,IAAI,EAAEC,GAAG,EAAE;YACZ,MAAMC,SAA2C,CAAC;YAElD,IAAK,MAAMC,OAAOL,aAAc;gBAC9B,MAAMM,WAAWN,YAAY,CAACK,IAAI;gBAElC,IAAIC,SAASC,IAAI,KAAK,OAAO;oBAC3BH,MAAM,CAACC,IAAI,GAAGF,IAAIL,QAAQG,MAAM,CAACK,SAASE,EAAE,CAAC,EAAE;wBAC7CC,QAAQH,SAASG,MAAM,CAACC,GAAG,CACzB,CAACC,QAAUb,QAAQG,MAAM,CAACU,MAAMC,KAAK,CAAC,CAACD,MAAME,IAAI,CAAC;wBAEpDC,YAAYR,SAASQ,UAAU,CAACJ,GAAG,CACjC,CAACK,YAAcjB,QAAQG,MAAM,CAACK,SAASE,EAAE,CAAC,CAACO,UAAU;wBAEvDC,cAAcV,SAASU,YAAY;oBACrC;gBACF,OAAO;oBACLZ,MAAM,CAACC,IAAI,GAAGH,KAAKJ,QAAQG,MAAM,CAACK,SAASE,EAAE,CAAC,EAAE;wBAC9CQ,cAAcV,SAASU,YAAY;oBACrC;gBACF;YACF;YAEA,OAAOZ;QACT;IAEJ;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 5652, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5658, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/buildIndexName.ts"],"sourcesContent":["import type { DrizzleAdapter } from '../types.js'\n\nexport const buildIndexName = ({\n  name,\n  adapter,\n  number = 0,\n}: {\n  adapter: DrizzleAdapter\n  name: string\n  number?: number\n}): string => {\n  const indexName = `${name}${number ? `_${number}` : ''}_idx`\n\n  if (!adapter.indexes.has(indexName)) {\n    adapter.indexes.add(indexName)\n    return indexName\n  }\n\n  return buildIndexName({\n    name,\n    adapter,\n    number: number + 1,\n  })\n}\n"],"names":["buildIndexName","name","adapter","number","indexName","indexes","has","add"],"mappings":";;;AAEO,MAAMA,iBAAiB,CAAC,EAC7BC,IAAI,EACJC,OAAO,EACPC,SAAS,CAAC,EAKX;IACC,MAAMC,YAAY,GAAGH,OAAOE,SAAS,CAAC,CAAC,EAAEA,QAAQ,GAAG,GAAG,IAAI,CAAC;IAE5D,IAAI,CAACD,QAAQG,OAAO,CAACC,GAAG,CAACF,YAAY;QACnCF,QAAQG,OAAO,CAACE,GAAG,CAACH;QACpB,OAAOA;IACT;IAEA,OAAOJ,eAAe;QACpBC;QACAC;QACAC,QAAQA,SAAS;IACnB;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 5673, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5679, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/hasLocalesTable.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nimport { fieldAffectsData, fieldHasSubFields } from 'payload/shared'\n\nexport const hasLocalesTable = (fields: Field[]): boolean => {\n  return fields.some((field) => {\n    // arrays always get a separate table\n    if (field.type === 'array') {\n      return false\n    }\n    if (fieldAffectsData(field) && field.localized) {\n      return true\n    }\n    if (fieldHasSubFields(field)) {\n      return hasLocalesTable(field.fields)\n    }\n    if (field.type === 'tabs') {\n      return field.tabs.some((tab) => hasLocalesTable(tab.fields))\n    }\n    return false\n  })\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","hasLocalesTable","fields","some","field","type","localized","tabs","tab"],"mappings":";;;AAEA,SAASA,gBAAgB,EAAEC,iBAAiB,QAAQ,iBAAgB;;AAE7D,MAAMC,kBAAkB,CAACC;IAC9B,OAAOA,OAAOC,IAAI,CAAC,CAACC;QAClB,qCAAqC;QACrC,IAAIA,MAAMC,IAAI,KAAK,SAAS;YAC1B,OAAO;QACT;QACA,2XAAIN,mBAAAA,EAAiBK,UAAUA,MAAME,SAAS,EAAE;YAC9C,OAAO;QACT;QACA,KAAIN,0YAAAA,EAAkBI,QAAQ;YAC5B,OAAOH,gBAAgBG,MAAMF,MAAM;QACrC;QACA,IAAIE,MAAMC,IAAI,KAAK,QAAQ;YACzB,OAAOD,MAAMG,IAAI,CAACJ,IAAI,CAAC,CAACK,MAAQP,gBAAgBO,IAAIN,MAAM;QAC5D;QACA,OAAO;IACT;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 5702, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5708, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/validateExistingBlockIsIdentical.ts"],"sourcesContent":["import type { Block, Field } from 'payload'\n\nimport { InvalidConfiguration } from 'payload'\nimport { fieldAffectsData, fieldHasSubFields, tabHasName } from 'payload/shared'\n\nimport type { RawTable } from '../types.js'\n\ntype Args = {\n  block: Block\n  localized: boolean\n  rootTableName: string\n  table: RawTable\n  tableLocales?: RawTable\n}\n\nconst getFlattenedFieldNames = (\n  fields: Field[],\n  prefix: string = '',\n): { localized?: boolean; name: string }[] => {\n  return fields.reduce((fieldsToUse, field) => {\n    let fieldPrefix = prefix\n\n    if (\n      ['array', 'blocks', 'relationship', 'upload'].includes(field.type) ||\n      ('hasMany' in field && field.hasMany === true)\n    ) {\n      return fieldsToUse\n    }\n\n    if (fieldHasSubFields(field)) {\n      fieldPrefix = 'name' in field ? `${prefix}${field.name}_` : prefix\n      return [...fieldsToUse, ...getFlattenedFieldNames(field.fields, fieldPrefix)]\n    }\n\n    if (field.type === 'tabs') {\n      return [\n        ...fieldsToUse,\n        ...field.tabs.reduce((tabFields, tab) => {\n          fieldPrefix = 'name' in tab ? `${prefix}_${tab.name}` : prefix\n          return [\n            ...tabFields,\n            ...(tabHasName(tab)\n              ? [{ ...tab, type: 'tab' }]\n              : getFlattenedFieldNames(tab.fields, fieldPrefix)),\n          ]\n        }, []),\n      ]\n    }\n\n    if (fieldAffectsData(field)) {\n      return [\n        ...fieldsToUse,\n        {\n          name: `${fieldPrefix}${field.name}`,\n          localized: field.localized,\n        },\n      ]\n    }\n\n    return fieldsToUse\n  }, [])\n}\n\nexport const validateExistingBlockIsIdentical = ({\n  block,\n  localized,\n  rootTableName,\n  table,\n  tableLocales,\n}: Args): void => {\n  const fieldNames = getFlattenedFieldNames(block.fields)\n\n  const missingField =\n    // ensure every field from the config is in the matching table\n    fieldNames.find(({ name, localized }) => {\n      const fieldTable = localized && tableLocales ? tableLocales : table\n      return Object.keys(fieldTable.columns).indexOf(name) === -1\n    }) ||\n    // ensure every table column is matched for every field from the config\n    Object.keys(table).find((fieldName) => {\n      if (!['_locale', '_order', '_parentID', '_path', '_uuid'].includes(fieldName)) {\n        return fieldNames.findIndex((field) => field.name) === -1\n      }\n    })\n\n  if (missingField) {\n    throw new InvalidConfiguration(\n      `The table ${rootTableName} has multiple blocks with slug ${\n        block.slug\n      }, but the schemas do not match. One block includes the field ${\n        typeof missingField === 'string' ? missingField : missingField.name\n      }, while the other block does not.`,\n    )\n  }\n\n  if (Boolean(localized) !== Boolean(table.columns._locale)) {\n    throw new InvalidConfiguration(\n      `The table ${rootTableName} has multiple blocks with slug ${block.slug}, but the schemas do not match. One is localized, but another is not. Block schemas of the same name must match exactly.`,\n    )\n  }\n}\n"],"names":["InvalidConfiguration","fieldAffectsData","fieldHasSubFields","tabHasName","getFlattenedFieldNames","fields","prefix","reduce","fieldsToUse","field","fieldPrefix","includes","type","hasMany","name","tabs","tabFields","tab","localized","validateExistingBlockIsIdentical","block","rootTableName","table","tableLocales","fieldNames","missingField","find","fieldTable","Object","keys","columns","indexOf","fieldName","findIndex","slug","Boolean","_locale"],"mappings":";;;AAGA,SAASC,gBAAgB,EAAEC,iBAAiB,EAAEC,UAAU,QAAQ,iBAAgB;AADhF,SAASH,oBAAoB,QAAQ,UAAS;;;AAa9C,MAAMI,yBAAyB,CAC7BC,QACAC,SAAiB,EAAE;IAEnB,OAAOD,OAAOE,MAAM,CAAC,CAACC,aAAaC;QACjC,IAAIC,cAAcJ;QAElB,IACE;YAAC;YAAS;YAAU;YAAgB;SAAS,CAACK,QAAQ,CAACF,MAAMG,IAAI,KAChE,aAAaH,SAASA,MAAMI,OAAO,KAAK,MACzC;YACA,OAAOL;QACT;QAEA,2XAAIN,oBAAAA,EAAkBO,QAAQ;YAC5BC,cAAc,UAAUD,QAAQ,GAAGH,SAASG,MAAMK,IAAI,CAAC,CAAC,CAAC,GAAGR;YAC5D,OAAO;mBAAIE;mBAAgBJ,uBAAuBK,MAAMJ,MAAM,EAAEK;aAAa;QAC/E;QAEA,IAAID,MAAMG,IAAI,KAAK,QAAQ;YACzB,OAAO;mBACFJ;mBACAC,MAAMM,IAAI,CAACR,MAAM,CAAC,CAACS,WAAWC;oBAC/BP,cAAc,UAAUO,MAAM,GAAGX,OAAO,CAAC,EAAEW,IAAIH,IAAI,EAAE,GAAGR;oBACxD,OAAO;2BACFU;kZACCb,aAAAA,EAAWc,OACX;4BAAC;gCAAE,GAAGA,GAAG;gCAAEL,MAAM;4BAAM;yBAAE,GACzBR,uBAAuBa,IAAIZ,MAAM,EAAEK;qBACxC;gBACH,GAAG,EAAE;aACN;QACH;QAEA,KAAIT,yYAAAA,EAAiBQ,QAAQ;YAC3B,OAAO;mBACFD;gBACH;oBACEM,MAAM,GAAGJ,cAAcD,MAAMK,IAAI,EAAE;oBACnCI,WAAWT,MAAMS,SAAS;gBAC5B;aACD;QACH;QAEA,OAAOV;IACT,GAAG,EAAE;AACP;AAEO,MAAMW,mCAAmC,CAAC,EAC/CC,KAAK,EACLF,SAAS,EACTG,aAAa,EACbC,KAAK,EACLC,YAAY,EACP;IACL,MAAMC,aAAapB,uBAAuBgB,MAAMf,MAAM;IAEtD,MAAMoB,eACJ,AACAD,WAAWE,IAAI,CAAC,CAAC,EAAEZ,IAAI,EAAEI,SAAS,EAAE,0BAD0B;QAE5D,MAAMS,aAAaT,aAAaK,eAAeA,eAAeD;QAC9D,OAAOM,OAAOC,IAAI,CAACF,WAAWG,OAAO,EAAEC,OAAO,CAACjB,UAAU,CAAC;IAC5D,MACA,uEAAuE;IACvEc,OAAOC,IAAI,CAACP,OAAOI,IAAI,CAAC,CAACM;QACvB,IAAI,CAAC;YAAC;YAAW;YAAU;YAAa;YAAS;SAAQ,CAACrB,QAAQ,CAACqB,YAAY;YAC7E,OAAOR,WAAWS,SAAS,CAAC,CAACxB,QAAUA,MAAMK,IAAI,MAAM,CAAC;QAC1D;IACF;IAEF,IAAIW,cAAc;QAChB,MAAM,4XAAIzB,uBAAAA,CACR,CAAC,UAAU,EAAEqB,cAAc,+BAA+B,EACxDD,MAAMc,IAAI,CACX,6DAA6D,EAC5D,OAAOT,iBAAiB,WAAWA,eAAeA,aAAaX,IAAI,CACpE,iCAAiC,CAAC;IAEvC;IAEA,IAAIqB,QAAQjB,eAAeiB,QAAQb,MAAMQ,OAAO,CAACM,OAAO,GAAG;QACzD,MAAM,4XAAIpC,uBAAAA,CACR,CAAC,UAAU,EAAEqB,cAAc,+BAA+B,EAAED,MAAMc,IAAI,CAAC,wHAAwH,CAAC;IAEpM;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 5786, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5792, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/schema/idToUUID.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\nexport const idToUUID = (fields: FlattenedField[]): FlattenedField[] =>\n  fields.map((field) => {\n    if ('name' in field && field.name === 'id') {\n      return {\n        ...field,\n        name: '_uuid',\n      }\n    }\n\n    return field\n  })\n"],"names":["idToUUID","fields","map","field","name"],"mappings":";;;AAEO,MAAMA,WAAW,CAACC,SACvBA,OAAOC,GAAG,CAAC,CAACC;QACV,IAAI,UAAUA,SAASA,MAAMC,IAAI,KAAK,MAAM;YAC1C,OAAO;gBACL,GAAGD,KAAK;gBACRC,MAAM;YACR;QACF;QAEA,OAAOD;IACT,GAAE","ignoreList":[0]}},
    {"offset": {"line": 5804, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5810, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/schema/withDefault.ts"],"sourcesContent":["import type { FieldAffectingData } from 'payload'\n\nimport type { RawColumn } from '../types.js'\n\nexport const withDefault = (column: RawColumn, field: FieldAffectingData): RawColumn => {\n  if (typeof field.defaultValue === 'undefined' || typeof field.defaultValue === 'function') {\n    return column\n  }\n\n  if (typeof field.defaultValue === 'string' && field.defaultValue.includes(\"'\")) {\n    const escapedString = field.defaultValue.replaceAll(\"'\", \"''\")\n    return {\n      ...column,\n      default: escapedString,\n    }\n  }\n\n  return {\n    ...column,\n    default: field.defaultValue,\n  }\n}\n"],"names":["withDefault","column","field","defaultValue","includes","escapedString","replaceAll","default"],"mappings":";;;AAIO,MAAMA,cAAc,CAACC,QAAmBC;IAC7C,IAAI,OAAOA,MAAMC,YAAY,KAAK,eAAe,OAAOD,MAAMC,YAAY,KAAK,YAAY;QACzF,OAAOF;IACT;IAEA,IAAI,OAAOC,MAAMC,YAAY,KAAK,YAAYD,MAAMC,YAAY,CAACC,QAAQ,CAAC,MAAM;QAC9E,MAAMC,gBAAgBH,MAAMC,YAAY,CAACG,UAAU,CAAC,KAAK;QACzD,OAAO;YACL,GAAGL,MAAM;YACTM,SAASF;QACX;IACF;IAEA,OAAO;QACL,GAAGJ,MAAM;QACTM,SAASL,MAAMC,YAAY;IAC7B;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 5829, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5835, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/schema/traverseFields.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\nimport { InvalidConfiguration } from 'payload'\nimport { fieldAffectsData, fieldIsVirtual, optionIsObject } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type {\n  DrizzleAdapter,\n  IDType,\n  RawColumn,\n  RawForeignKey,\n  RawIndex,\n  RawRelation,\n  RelationMap,\n  SetColumnID,\n} from '../types.js'\n\nimport { createTableName } from '../createTableName.js'\nimport { buildIndexName } from '../utilities/buildIndexName.js'\nimport { hasLocalesTable } from '../utilities/hasLocalesTable.js'\nimport { validateExistingBlockIsIdentical } from '../utilities/validateExistingBlockIsIdentical.js'\nimport { buildTable } from './build.js'\nimport { idToUUID } from './idToUUID.js'\nimport { withDefault } from './withDefault.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  columnPrefix?: string\n  columns: Record<string, RawColumn>\n  disableNotNull: boolean\n  disableRelsTableUnique?: boolean\n  disableUnique?: boolean\n  fieldPrefix?: string\n  fields: FlattenedField[]\n  forceLocalized?: boolean\n  indexes: Record<string, RawIndex>\n  localesColumns: Record<string, RawColumn>\n  localesIndexes: Record<string, RawIndex>\n  newTableName: string\n  parentTableName: string\n  relationships: Set<string>\n  relationsToBuild: RelationMap\n  rootRelationsToBuild?: RelationMap\n  rootTableIDColType: IDType\n  rootTableName: string\n  setColumnID: SetColumnID\n  uniqueRelationships: Set<string>\n  versions: boolean\n  /**\n   * Tracks whether or not this table is built\n   * from the result of a localized array or block field at some point\n   */\n  withinLocalizedArrayOrBlock?: boolean\n}\n\ntype Result = {\n  hasLocalizedField: boolean\n  hasLocalizedManyNumberField: boolean\n  hasLocalizedManyTextField: boolean\n  hasLocalizedRelationshipField: boolean\n  hasManyNumberField: 'index' | boolean\n  hasManyTextField: 'index' | boolean\n}\n\nexport const traverseFields = ({\n  adapter,\n  columnPrefix,\n  columns,\n  disableNotNull,\n  disableRelsTableUnique,\n  disableUnique = false,\n  fieldPrefix,\n  fields,\n  forceLocalized,\n  indexes,\n  localesColumns,\n  localesIndexes,\n  newTableName,\n  parentTableName,\n  relationships,\n  relationsToBuild,\n  rootRelationsToBuild,\n  rootTableIDColType,\n  rootTableName,\n  setColumnID,\n  uniqueRelationships,\n  versions,\n  withinLocalizedArrayOrBlock,\n}: Args): Result => {\n  const throwValidationError = true\n  let hasLocalizedField = false\n  let hasLocalizedRelationshipField = false\n  let hasManyTextField: 'index' | boolean = false\n  let hasLocalizedManyTextField = false\n  let hasManyNumberField: 'index' | boolean = false\n  let hasLocalizedManyNumberField = false\n\n  let parentIDColType: IDType = 'integer'\n\n  const idColumn = columns.id\n\n  if (idColumn && ['numeric', 'text', 'uuid', 'varchar'].includes(idColumn.type)) {\n    parentIDColType = idColumn.type as IDType\n  }\n\n  fields.forEach((field) => {\n    if ('name' in field && field.name === 'id') {\n      return\n    }\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    let targetTable = columns\n    let targetIndexes = indexes\n\n    const columnName = `${columnPrefix || ''}${field.name[0] === '_' ? '_' : ''}${toSnakeCase(\n      field.name,\n    )}`\n    const fieldName = `${fieldPrefix?.replace('.', '_') || ''}${field.name}`\n\n    // If field is localized,\n    // add the column to the locale table instead of main table\n    if (\n      adapter.payload.config.localization &&\n      (field.localized || forceLocalized) &&\n      field.type !== 'array' &&\n      field.type !== 'blocks' &&\n      (('hasMany' in field && field.hasMany !== true) || !('hasMany' in field))\n    ) {\n      hasLocalizedField = true\n      targetTable = localesColumns\n      targetIndexes = localesIndexes\n    }\n\n    if (\n      (field.unique || field.index || ['relationship', 'upload'].includes(field.type)) &&\n      !['array', 'blocks', 'group'].includes(field.type) &&\n      !('hasMany' in field && field.hasMany === true) &&\n      !('relationTo' in field && Array.isArray(field.relationTo))\n    ) {\n      const unique = disableUnique !== true && field.unique\n      if (unique) {\n        const constraintValue = `${fieldPrefix || ''}${field.name}`\n        if (!adapter.fieldConstraints?.[rootTableName]) {\n          adapter.fieldConstraints[rootTableName] = {}\n        }\n        adapter.fieldConstraints[rootTableName][`${columnName}_idx`] = constraintValue\n      }\n\n      const indexName = buildIndexName({ name: `${newTableName}_${columnName}`, adapter })\n\n      targetIndexes[indexName] = {\n        name: indexName,\n        on: field.localized ? [fieldName, '_locale'] : fieldName,\n        unique,\n      }\n    }\n\n    switch (field.type) {\n      case 'array': {\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n\n        const arrayTableName = createTableName({\n          adapter,\n          config: field,\n          parentTableName: newTableName,\n          prefix: `${newTableName}_`,\n          throwValidationError,\n          versionsCustomName: versions,\n        })\n\n        const baseColumns: Record<string, RawColumn> = {\n          _order: {\n            name: '_order',\n            type: 'integer',\n            notNull: true,\n          },\n          _parentID: {\n            name: '_parent_id',\n            type: parentIDColType,\n            notNull: true,\n          },\n        }\n\n        const baseIndexes: Record<string, RawIndex> = {\n          _orderIdx: {\n            name: `${arrayTableName}_order_idx`,\n            on: ['_order'],\n          },\n          _parentIDIdx: {\n            name: `${arrayTableName}_parent_id_idx`,\n            on: '_parentID',\n          },\n        }\n\n        const baseForeignKeys: Record<string, RawForeignKey> = {\n          _parentIDFk: {\n            name: `${arrayTableName}_parent_id_fk`,\n            columns: ['_parentID'],\n            foreignColumns: [\n              {\n                name: 'id',\n                table: parentTableName,\n              },\n            ],\n            onDelete: 'cascade',\n          },\n        }\n\n        const isLocalized =\n          Boolean(field.localized && adapter.payload.config.localization) ||\n          withinLocalizedArrayOrBlock ||\n          forceLocalized\n\n        if (isLocalized) {\n          baseColumns._locale = {\n            name: '_locale',\n            type: 'enum',\n            locale: true,\n            notNull: true,\n          }\n\n          baseIndexes._localeIdx = {\n            name: `${arrayTableName}_locale_idx`,\n            on: '_locale',\n          }\n        }\n\n        const {\n          hasLocalizedManyNumberField: subHasLocalizedManyNumberField,\n          hasLocalizedManyTextField: subHasLocalizedManyTextField,\n          hasLocalizedRelationshipField: subHasLocalizedRelationshipField,\n          hasManyNumberField: subHasManyNumberField,\n          hasManyTextField: subHasManyTextField,\n          relationsToBuild: subRelationsToBuild,\n        } = buildTable({\n          adapter,\n          baseColumns,\n          baseForeignKeys,\n          baseIndexes,\n          disableNotNull: disableNotNullFromHere,\n          disableRelsTableUnique: true,\n          disableUnique,\n          fields: disableUnique ? idToUUID(field.flattenedFields) : field.flattenedFields,\n          rootRelationships: relationships,\n          rootRelationsToBuild,\n          rootTableIDColType,\n          rootTableName,\n          rootUniqueRelationships: uniqueRelationships,\n          setColumnID,\n          tableName: arrayTableName,\n          versions,\n          withinLocalizedArrayOrBlock: isLocalized,\n        })\n\n        if (subHasLocalizedManyNumberField) {\n          hasLocalizedManyNumberField = subHasLocalizedManyNumberField\n        }\n\n        if (subHasLocalizedRelationshipField) {\n          hasLocalizedRelationshipField = subHasLocalizedRelationshipField\n        }\n\n        if (subHasLocalizedManyTextField) {\n          hasLocalizedManyTextField = subHasLocalizedManyTextField\n        }\n\n        if (subHasManyTextField) {\n          if (!hasManyTextField || subHasManyTextField === 'index') {\n            hasManyTextField = subHasManyTextField\n          }\n        }\n        if (subHasManyNumberField) {\n          if (!hasManyNumberField || subHasManyNumberField === 'index') {\n            hasManyNumberField = subHasManyNumberField\n          }\n        }\n\n        relationsToBuild.set(fieldName, {\n          type: 'many',\n          // arrays have their own localized table, independent of the base table.\n          localized: false,\n          target: arrayTableName,\n        })\n\n        const arrayRelations: Record<string, RawRelation> = {\n          _parentID: {\n            type: 'one',\n            fields: [\n              {\n                name: '_parentID',\n                table: arrayTableName,\n              },\n            ],\n            references: ['id'],\n            relationName: fieldName,\n            to: parentTableName,\n          },\n        }\n\n        if (hasLocalesTable(field.fields)) {\n          arrayRelations._locales = {\n            type: 'many',\n            relationName: '_locales',\n            to: `${arrayTableName}${adapter.localesSuffix}`,\n          }\n        }\n\n        subRelationsToBuild.forEach(({ type, localized, target }, key) => {\n          if (type === 'one') {\n            const arrayWithLocalized = localized\n              ? `${arrayTableName}${adapter.localesSuffix}`\n              : arrayTableName\n\n            arrayRelations[key] = {\n              type: 'one',\n              fields: [\n                {\n                  name: key,\n                  table: arrayWithLocalized,\n                },\n              ],\n              references: ['id'],\n              relationName: key,\n              to: target,\n            }\n          }\n\n          if (type === 'many') {\n            arrayRelations[key] = {\n              type: 'many',\n              relationName: key,\n              to: target,\n            }\n          }\n        })\n\n        adapter.rawRelations[arrayTableName] = arrayRelations\n\n        break\n      }\n      case 'blocks': {\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n\n        field.blocks.forEach((block) => {\n          const blockTableName = createTableName({\n            adapter,\n            config: block,\n            parentTableName: rootTableName,\n            prefix: `${rootTableName}_blocks_`,\n            throwValidationError,\n            versionsCustomName: versions,\n          })\n          if (!adapter.rawTables[blockTableName]) {\n            const baseColumns: Record<string, RawColumn> = {\n              _order: {\n                name: '_order',\n                type: 'integer',\n                notNull: true,\n              },\n              _parentID: {\n                name: '_parent_id',\n                type: rootTableIDColType,\n                notNull: true,\n              },\n              _path: {\n                name: '_path',\n                type: 'text',\n                notNull: true,\n              },\n            }\n\n            const baseIndexes: Record<string, RawIndex> = {\n              _orderIdx: {\n                name: `${blockTableName}_order_idx`,\n                on: '_order',\n              },\n              _parentIDIdx: {\n                name: `${blockTableName}_parent_id_idx`,\n                on: ['_parentID'],\n              },\n              _pathIdx: {\n                name: `${blockTableName}_path_idx`,\n                on: '_path',\n              },\n            }\n\n            const baseForeignKeys: Record<string, RawForeignKey> = {\n              _parentIdFk: {\n                name: `${blockTableName}_parent_id_fk`,\n                columns: ['_parentID'],\n                foreignColumns: [\n                  {\n                    name: 'id',\n                    table: rootTableName,\n                  },\n                ],\n                onDelete: 'cascade',\n              },\n            }\n\n            const isLocalized =\n              Boolean(field.localized && adapter.payload.config.localization) ||\n              withinLocalizedArrayOrBlock ||\n              forceLocalized\n\n            if (isLocalized) {\n              baseColumns._locale = {\n                name: '_locale',\n                type: 'enum',\n                locale: true,\n                notNull: true,\n              }\n\n              baseIndexes._localeIdx = {\n                name: `${blockTableName}_locale_idx`,\n                on: '_locale',\n              }\n            }\n\n            const {\n              hasLocalizedManyNumberField: subHasLocalizedManyNumberField,\n              hasLocalizedManyTextField: subHasLocalizedManyTextField,\n              hasLocalizedRelationshipField: subHasLocalizedRelationshipField,\n              hasManyNumberField: subHasManyNumberField,\n              hasManyTextField: subHasManyTextField,\n              relationsToBuild: subRelationsToBuild,\n            } = buildTable({\n              adapter,\n              baseColumns,\n              baseForeignKeys,\n              baseIndexes,\n              disableNotNull: disableNotNullFromHere,\n              disableRelsTableUnique: true,\n              disableUnique,\n              fields: disableUnique ? idToUUID(block.flattenedFields) : block.flattenedFields,\n              rootRelationships: relationships,\n              rootRelationsToBuild,\n              rootTableIDColType,\n              rootTableName,\n              rootUniqueRelationships: uniqueRelationships,\n              setColumnID,\n              tableName: blockTableName,\n              versions,\n              withinLocalizedArrayOrBlock: isLocalized,\n            })\n\n            if (subHasLocalizedManyNumberField) {\n              hasLocalizedManyNumberField = subHasLocalizedManyNumberField\n            }\n\n            if (subHasLocalizedRelationshipField) {\n              hasLocalizedRelationshipField = subHasLocalizedRelationshipField\n            }\n\n            if (subHasLocalizedManyTextField) {\n              hasLocalizedManyTextField = subHasLocalizedManyTextField\n            }\n\n            if (subHasManyTextField) {\n              if (!hasManyTextField || subHasManyTextField === 'index') {\n                hasManyTextField = subHasManyTextField\n              }\n            }\n\n            if (subHasManyNumberField) {\n              if (!hasManyNumberField || subHasManyNumberField === 'index') {\n                hasManyNumberField = subHasManyNumberField\n              }\n            }\n\n            const blockRelations: Record<string, RawRelation> = {\n              _parentID: {\n                type: 'one',\n                fields: [\n                  {\n                    name: '_parentID',\n                    table: blockTableName,\n                  },\n                ],\n                references: ['id'],\n                relationName: `_blocks_${block.slug}`,\n                to: rootTableName,\n              },\n            }\n\n            if (hasLocalesTable(block.fields)) {\n              blockRelations._locales = {\n                type: 'many',\n                relationName: '_locales',\n                to: `${blockTableName}${adapter.localesSuffix}`,\n              }\n            }\n\n            subRelationsToBuild.forEach(({ type, localized, target }, key) => {\n              if (type === 'one') {\n                const blockWithLocalized = localized\n                  ? `${blockTableName}${adapter.localesSuffix}`\n                  : blockTableName\n\n                blockRelations[key] = {\n                  type: 'one',\n                  fields: [\n                    {\n                      name: key,\n                      table: blockWithLocalized,\n                    },\n                  ],\n                  references: ['id'],\n                  relationName: key,\n                  to: target,\n                }\n              }\n\n              if (type === 'many') {\n                blockRelations[key] = {\n                  type: 'many',\n                  relationName: key,\n                  to: target,\n                }\n              }\n            })\n\n            adapter.rawRelations[blockTableName] = blockRelations\n          } else if (process.env.NODE_ENV !== 'production' && !versions) {\n            validateExistingBlockIsIdentical({\n              block,\n              localized: field.localized,\n              rootTableName,\n              table: adapter.rawTables[blockTableName],\n              tableLocales: adapter.rawTables[`${blockTableName}${adapter.localesSuffix}`],\n            })\n          }\n          // blocks relationships are defined from the collection or globals table down to the block, bypassing any subBlocks\n          rootRelationsToBuild.set(`_blocks_${block.slug}`, {\n            type: 'many',\n            // blocks are not localized on the parent table\n            localized: false,\n            target: blockTableName,\n          })\n        })\n\n        break\n      }\n      case 'checkbox': {\n        targetTable[fieldName] = withDefault(\n          {\n            name: columnName,\n            type: 'boolean',\n          },\n          field,\n        )\n\n        break\n      }\n\n      case 'code':\n      case 'email':\n      case 'textarea': {\n        targetTable[fieldName] = withDefault(\n          {\n            name: columnName,\n            type: 'varchar',\n          },\n          field,\n        )\n\n        break\n      }\n\n      case 'date': {\n        targetTable[fieldName] = withDefault(\n          {\n            name: columnName,\n            type: 'timestamp',\n            mode: 'string',\n            precision: 3,\n            withTimezone: true,\n          },\n          field,\n        )\n\n        break\n      }\n\n      case 'group':\n      case 'tab': {\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n\n        const {\n          hasLocalizedField: groupHasLocalizedField,\n          hasLocalizedManyNumberField: groupHasLocalizedManyNumberField,\n          hasLocalizedManyTextField: groupHasLocalizedManyTextField,\n          hasLocalizedRelationshipField: groupHasLocalizedRelationshipField,\n          hasManyNumberField: groupHasManyNumberField,\n          hasManyTextField: groupHasManyTextField,\n        } = traverseFields({\n          adapter,\n          columnPrefix: `${columnName}_`,\n          columns,\n          disableNotNull: disableNotNullFromHere,\n          disableUnique,\n          fieldPrefix: `${fieldName}.`,\n          fields: field.flattenedFields,\n          forceLocalized: field.localized,\n          indexes,\n          localesColumns,\n          localesIndexes,\n          newTableName: `${parentTableName}_${columnName}`,\n          parentTableName,\n          relationships,\n          relationsToBuild,\n          rootRelationsToBuild,\n          rootTableIDColType,\n          rootTableName,\n          setColumnID,\n          uniqueRelationships,\n          versions,\n          withinLocalizedArrayOrBlock: withinLocalizedArrayOrBlock || field.localized,\n        })\n\n        if (groupHasLocalizedField) {\n          hasLocalizedField = true\n        }\n        if (groupHasLocalizedRelationshipField) {\n          hasLocalizedRelationshipField = true\n        }\n        if (groupHasManyTextField) {\n          hasManyTextField = true\n        }\n        if (groupHasLocalizedManyTextField) {\n          hasLocalizedManyTextField = true\n        }\n        if (groupHasManyNumberField) {\n          hasManyNumberField = true\n        }\n        if (groupHasLocalizedManyNumberField) {\n          hasLocalizedManyNumberField = true\n        }\n        break\n      }\n\n      case 'json':\n      case 'richText': {\n        targetTable[fieldName] = withDefault(\n          {\n            name: columnName,\n            type: 'jsonb',\n          },\n          field,\n        )\n\n        break\n      }\n\n      case 'number': {\n        if (field.hasMany) {\n          const isLocalized =\n            Boolean(field.localized && adapter.payload.config.localization) ||\n            withinLocalizedArrayOrBlock ||\n            forceLocalized\n\n          if (isLocalized) {\n            hasLocalizedManyNumberField = true\n          }\n\n          if (field.index) {\n            hasManyNumberField = 'index'\n          } else if (!hasManyNumberField) {\n            hasManyNumberField = true\n          }\n\n          if (field.unique) {\n            throw new InvalidConfiguration(\n              'Unique is not supported in Postgres for hasMany number fields.',\n            )\n          }\n        } else {\n          targetTable[fieldName] = withDefault(\n            {\n              name: columnName,\n              type: 'numeric',\n            },\n            field,\n          )\n        }\n\n        break\n      }\n\n      case 'point': {\n        targetTable[fieldName] = withDefault(\n          {\n            name: columnName,\n            type: 'geometry',\n          },\n          field,\n        )\n\n        break\n      }\n\n      case 'radio':\n      case 'select': {\n        const enumName = createTableName({\n          adapter,\n          config: field,\n          parentTableName: newTableName,\n          prefix: `enum_${newTableName}_`,\n          target: 'enumName',\n          throwValidationError,\n        })\n\n        const options = field.options.map((option) => {\n          if (optionIsObject(option)) {\n            return option.value\n          }\n\n          return option\n        })\n\n        if (field.type === 'select' && field.hasMany) {\n          const selectTableName = createTableName({\n            adapter,\n            config: field,\n            parentTableName: newTableName,\n            prefix: `${newTableName}_`,\n            throwValidationError,\n            versionsCustomName: versions,\n          })\n\n          const baseColumns: Record<string, RawColumn> = {\n            order: {\n              name: 'order',\n              type: 'integer',\n              notNull: true,\n            },\n            parent: {\n              name: 'parent_id',\n              type: parentIDColType,\n              notNull: true,\n            },\n            value: {\n              name: 'value',\n              type: 'enum',\n              enumName: createTableName({\n                adapter,\n                config: field,\n                parentTableName: newTableName,\n                prefix: `enum_${newTableName}_`,\n                target: 'enumName',\n                throwValidationError,\n              }),\n              options,\n            },\n          }\n\n          const baseIndexes: Record<string, RawIndex> = {\n            orderIdx: {\n              name: `${selectTableName}_order_idx`,\n              on: 'order',\n            },\n            parentIdx: {\n              name: `${selectTableName}_parent_idx`,\n              on: 'parent',\n            },\n          }\n\n          const baseForeignKeys: Record<string, RawForeignKey> = {\n            parentFk: {\n              name: `${selectTableName}_parent_fk`,\n              columns: ['parent'],\n              foreignColumns: [\n                {\n                  name: 'id',\n                  table: parentTableName,\n                },\n              ],\n              onDelete: 'cascade',\n            },\n          }\n\n          const isLocalized =\n            Boolean(field.localized && adapter.payload.config.localization) ||\n            withinLocalizedArrayOrBlock ||\n            forceLocalized\n\n          if (isLocalized) {\n            baseColumns.locale = {\n              name: 'locale',\n              type: 'enum',\n              locale: true,\n              notNull: true,\n            }\n\n            baseIndexes.localeIdx = {\n              name: `${selectTableName}_locale_idx`,\n              on: 'locale',\n            }\n          }\n\n          if (field.index) {\n            baseIndexes.value = {\n              name: `${selectTableName}_value_idx`,\n              on: 'value',\n            }\n          }\n\n          buildTable({\n            adapter,\n            baseColumns,\n            baseForeignKeys,\n            baseIndexes,\n            disableNotNull,\n            disableUnique,\n            fields: [],\n            rootTableName,\n            setColumnID,\n            tableName: selectTableName,\n            versions,\n          })\n\n          relationsToBuild.set(fieldName, {\n            type: 'many',\n            // selects have their own localized table, independent of the base table.\n            localized: false,\n            target: selectTableName,\n          })\n\n          adapter.rawRelations[selectTableName] = {\n            parent: {\n              type: 'one',\n              fields: [\n                {\n                  name: 'parent',\n                  table: selectTableName,\n                },\n              ],\n              references: ['id'],\n              relationName: fieldName,\n              to: parentTableName,\n            },\n          }\n        } else {\n          targetTable[fieldName] = withDefault(\n            {\n              name: columnName,\n              type: 'enum',\n              enumName,\n              options,\n            },\n            field,\n          )\n        }\n        break\n      }\n\n      case 'relationship':\n      case 'upload':\n        if (Array.isArray(field.relationTo)) {\n          field.relationTo.forEach((relation) => {\n            relationships.add(relation)\n            if (field.unique && !disableUnique && !disableRelsTableUnique) {\n              uniqueRelationships.add(relation)\n            }\n          })\n        } else if (field.hasMany) {\n          relationships.add(field.relationTo)\n          if (field.unique && !disableUnique && !disableRelsTableUnique) {\n            uniqueRelationships.add(field.relationTo)\n          }\n        } else {\n          // simple relationships get a column on the targetTable with a foreign key to the relationTo table\n          const relationshipConfig = adapter.payload.collections[field.relationTo].config\n\n          const tableName = adapter.tableNameMap.get(toSnakeCase(field.relationTo))\n\n          // get the id type of the related collection\n          let colType: IDType = adapter.idType === 'uuid' ? 'uuid' : 'integer'\n          const relatedCollectionCustomID = relationshipConfig.fields.find(\n            (field) => fieldAffectsData(field) && field.name === 'id',\n          )\n          if (relatedCollectionCustomID?.type === 'number') {\n            colType = 'numeric'\n          }\n          if (relatedCollectionCustomID?.type === 'text') {\n            colType = 'varchar'\n          }\n\n          // make the foreign key column for relationship using the correct id column type\n          targetTable[fieldName] = {\n            name: `${columnName}_id`,\n            type: colType,\n            reference: {\n              name: 'id',\n              onDelete: 'set null',\n              table: tableName,\n            },\n          }\n\n          // add relationship to table\n          relationsToBuild.set(fieldName, {\n            type: 'one',\n            localized: adapter.payload.config.localization && (field.localized || forceLocalized),\n            target: tableName,\n          })\n\n          // add notNull when not required\n          if (!disableNotNull && field.required && !field.admin?.condition) {\n            targetTable[fieldName].notNull = true\n          }\n          break\n        }\n\n        if (\n          Boolean(field.localized && adapter.payload.config.localization) ||\n          withinLocalizedArrayOrBlock\n        ) {\n          hasLocalizedRelationshipField = true\n        }\n\n        break\n\n      case 'text': {\n        if (field.hasMany) {\n          const isLocalized =\n            Boolean(field.localized && adapter.payload.config.localization) ||\n            withinLocalizedArrayOrBlock ||\n            forceLocalized\n\n          if (isLocalized) {\n            hasLocalizedManyTextField = true\n          }\n\n          if (field.index) {\n            hasManyTextField = 'index'\n          } else if (!hasManyTextField) {\n            hasManyTextField = true\n          }\n\n          if (field.unique) {\n            throw new InvalidConfiguration(\n              'Unique is not supported in Postgres for hasMany text fields.',\n            )\n          }\n        } else {\n          targetTable[fieldName] = withDefault(\n            {\n              name: columnName,\n              type: 'varchar',\n            },\n            field,\n          )\n        }\n        break\n      }\n\n      default:\n        break\n    }\n\n    const condition = field.admin && field.admin.condition\n\n    if (\n      !disableNotNull &&\n      targetTable[fieldName] &&\n      'required' in field &&\n      field.required &&\n      !condition\n    ) {\n      targetTable[fieldName].notNull = true\n    }\n  })\n\n  return {\n    hasLocalizedField,\n    hasLocalizedManyNumberField,\n    hasLocalizedManyTextField,\n    hasLocalizedRelationshipField,\n    hasManyNumberField,\n    hasManyTextField,\n  }\n}\n"],"names":["InvalidConfiguration","fieldAffectsData","fieldIsVirtual","optionIsObject","toSnakeCase","createTableName","buildIndexName","hasLocalesTable","validateExistingBlockIsIdentical","buildTable","idToUUID","withDefault","traverseFields","adapter","columnPrefix","columns","disableNotNull","disableRelsTableUnique","disableUnique","fieldPrefix","fields","forceLocalized","indexes","localesColumns","localesIndexes","newTableName","parentTableName","relationships","relationsToBuild","rootRelationsToBuild","rootTableIDColType","rootTableName","setColumnID","uniqueRelationships","versions","withinLocalizedArrayOrBlock","throwValidationError","hasLocalizedField","hasLocalizedRelationshipField","hasManyTextField","hasLocalizedManyTextField","hasManyNumberField","hasLocalizedManyNumberField","parentIDColType","idColumn","id","includes","type","forEach","field","name","targetTable","targetIndexes","columnName","fieldName","replace","payload","config","localization","localized","hasMany","unique","index","Array","isArray","relationTo","constraintValue","fieldConstraints","indexName","on","disableNotNullFromHere","Boolean","admin","condition","arrayTableName","prefix","versionsCustomName","baseColumns","_order","notNull","_parentID","baseIndexes","_orderIdx","_parentIDIdx","baseForeignKeys","_parentIDFk","foreignColumns","table","onDelete","isLocalized","_locale","locale","_localeIdx","subHasLocalizedManyNumberField","subHasLocalizedManyTextField","subHasLocalizedRelationshipField","subHasManyNumberField","subHasManyTextField","subRelationsToBuild","flattenedFields","rootRelationships","rootUniqueRelationships","tableName","set","target","arrayRelations","references","relationName","to","_locales","localesSuffix","key","arrayWithLocalized","rawRelations","blocks","block","blockTableName","rawTables","_path","_pathIdx","_parentIdFk","blockRelations","slug","blockWithLocalized","process","env","NODE_ENV","tableLocales","mode","precision","withTimezone","groupHasLocalizedField","groupHasLocalizedManyNumberField","groupHasLocalizedManyTextField","groupHasLocalizedRelationshipField","groupHasManyNumberField","groupHasManyTextField","enumName","options","map","option","value","selectTableName","order","parent","orderIdx","parentIdx","parentFk","localeIdx","relation","add","relationshipConfig","collections","tableNameMap","get","colType","idType","relatedCollectionCustomID","find","reference","required"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6614, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6620, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/schema/build.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type {\n  DrizzleAdapter,\n  IDType,\n  RawColumn,\n  RawForeignKey,\n  RawIndex,\n  RawRelation,\n  RawTable,\n  RelationMap,\n  SetColumnID,\n} from '../types.js'\n\nimport { createTableName } from '../createTableName.js'\nimport { buildIndexName } from '../utilities/buildIndexName.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  baseColumns?: Record<string, RawColumn>\n  /**\n   * After table is created, run these functions to add extra config to the table\n   * ie. indexes, multiple columns, etc\n   */\n  baseForeignKeys?: Record<string, RawForeignKey>\n  /**\n   * After table is created, run these functions to add extra config to the table\n   * ie. indexes, multiple columns, etc\n   */\n  baseIndexes?: Record<string, RawIndex>\n  buildNumbers?: boolean\n  buildRelationships?: boolean\n  disableNotNull: boolean\n  disableRelsTableUnique?: boolean\n  disableUnique: boolean\n  fields: FlattenedField[]\n  rootRelationships?: Set<string>\n  rootRelationsToBuild?: RelationMap\n  rootTableIDColType?: IDType\n  rootTableName?: string\n  rootUniqueRelationships?: Set<string>\n  setColumnID: SetColumnID\n  tableName: string\n  timestamps?: boolean\n  versions: boolean\n  /**\n   * Tracks whether or not this table is built\n   * from the result of a localized array or block field at some point\n   */\n  withinLocalizedArrayOrBlock?: boolean\n}\n\ntype Result = {\n  hasLocalizedManyNumberField: boolean\n  hasLocalizedManyTextField: boolean\n  hasLocalizedRelationshipField: boolean\n  hasManyNumberField: 'index' | boolean\n  hasManyTextField: 'index' | boolean\n  relationsToBuild: RelationMap\n}\n\nexport const buildTable = ({\n  adapter,\n  baseColumns = {},\n  baseForeignKeys = {},\n  baseIndexes = {},\n  disableNotNull,\n  disableRelsTableUnique = false,\n  disableUnique = false,\n  fields,\n  rootRelationships,\n  rootRelationsToBuild,\n  rootTableIDColType,\n  rootTableName: incomingRootTableName,\n  rootUniqueRelationships,\n  setColumnID,\n  tableName,\n  timestamps,\n  versions,\n  withinLocalizedArrayOrBlock,\n}: Args): Result => {\n  const isRoot = !incomingRootTableName\n  const rootTableName = incomingRootTableName || tableName\n  const columns: Record<string, RawColumn> = baseColumns\n  const indexes: Record<string, RawIndex> = baseIndexes\n\n  const localesColumns: Record<string, RawColumn> = {}\n  const localesIndexes: Record<string, RawIndex> = {}\n  let localesTable: RawTable\n  let textsTable: RawTable\n  let numbersTable: RawTable\n\n  // Relationships to the base collection\n  const relationships: Set<string> = rootRelationships || new Set()\n\n  // Unique relationships to the base collection\n  const uniqueRelationships: Set<string> = rootUniqueRelationships || new Set()\n\n  let relationshipsTable: RawTable\n\n  // Drizzle relations\n  const relationsToBuild: RelationMap = new Map()\n\n  const idColType: IDType = setColumnID({ adapter, columns, fields })\n\n  const {\n    hasLocalizedField,\n    hasLocalizedManyNumberField,\n    hasLocalizedManyTextField,\n    hasLocalizedRelationshipField,\n    hasManyNumberField,\n    hasManyTextField,\n  } = traverseFields({\n    adapter,\n    columns,\n    disableNotNull,\n    disableRelsTableUnique,\n    disableUnique,\n    fields,\n    indexes,\n    localesColumns,\n    localesIndexes,\n    newTableName: tableName,\n    parentTableName: tableName,\n    relationships,\n    relationsToBuild,\n    rootRelationsToBuild: rootRelationsToBuild || relationsToBuild,\n    rootTableIDColType: rootTableIDColType || idColType,\n    rootTableName,\n    setColumnID,\n    uniqueRelationships,\n    versions,\n    withinLocalizedArrayOrBlock,\n  })\n\n  // split the relationsToBuild by localized and non-localized\n  const localizedRelations = new Map()\n  const nonLocalizedRelations = new Map()\n\n  relationsToBuild.forEach(({ type, localized, relationName, target }, key) => {\n    const map = localized ? localizedRelations : nonLocalizedRelations\n    map.set(key, { type, relationName, target })\n  })\n\n  if (timestamps) {\n    columns.createdAt = {\n      name: 'created_at',\n      type: 'timestamp',\n      defaultNow: true,\n      mode: 'string',\n      notNull: true,\n      precision: 3,\n      withTimezone: true,\n    }\n\n    columns.updatedAt = {\n      name: 'updated_at',\n      type: 'timestamp',\n      defaultNow: true,\n      mode: 'string',\n      notNull: true,\n      precision: 3,\n      withTimezone: true,\n    }\n  }\n\n  const table: RawTable = {\n    name: tableName,\n    columns,\n    foreignKeys: baseForeignKeys,\n    indexes,\n  }\n\n  adapter.rawTables[tableName] = table\n\n  if (hasLocalizedField || localizedRelations.size) {\n    const localeTableName = `${tableName}${adapter.localesSuffix}`\n    localesColumns.id = {\n      name: 'id',\n      type: 'serial',\n      primaryKey: true,\n    }\n\n    localesColumns._locale = {\n      name: '_locale',\n      type: 'enum',\n      locale: true,\n      notNull: true,\n    }\n\n    localesColumns._parentID = {\n      name: '_parent_id',\n      type: idColType,\n      notNull: true,\n    }\n\n    localesIndexes._localeParent = {\n      name: `${localeTableName}_locale_parent_id_unique`,\n      on: ['_locale', '_parentID'],\n      unique: true,\n    }\n\n    localesTable = {\n      name: localeTableName,\n      columns: localesColumns,\n      foreignKeys: {\n        _parentIdFk: {\n          name: `${localeTableName}_parent_id_fk`,\n          columns: ['_parentID'],\n          foreignColumns: [\n            {\n              name: 'id',\n              table: tableName,\n            },\n          ],\n          onDelete: 'cascade',\n        },\n      },\n      indexes: localesIndexes,\n    }\n\n    adapter.rawTables[localeTableName] = localesTable\n\n    const localeRelations: Record<string, RawRelation> = {\n      _parentID: {\n        type: 'one',\n        fields: [\n          {\n            name: '_parentID',\n            table: localeTableName,\n          },\n        ],\n        references: ['id'],\n        relationName: '_locales',\n        to: tableName,\n      },\n    }\n\n    localizedRelations.forEach(({ type, target }, key) => {\n      if (type === 'one') {\n        localeRelations[key] = {\n          type: 'one',\n          fields: [\n            {\n              name: key,\n              table: localeTableName,\n            },\n          ],\n          references: ['id'],\n          relationName: key,\n          to: target,\n        }\n      }\n      if (type === 'many') {\n        localeRelations[key] = {\n          type: 'many',\n          relationName: key,\n          to: target,\n        }\n      }\n    })\n    adapter.rawRelations[localeTableName] = localeRelations\n  }\n\n  if (isRoot) {\n    if (hasManyTextField) {\n      const textsTableName = `${rootTableName}_texts`\n\n      const columns: Record<string, RawColumn> = {\n        id: {\n          name: 'id',\n          type: 'serial',\n          primaryKey: true,\n        },\n        order: {\n          name: 'order',\n          type: 'integer',\n          notNull: true,\n        },\n        parent: {\n          name: 'parent_id',\n          type: idColType,\n          notNull: true,\n        },\n        path: {\n          name: 'path',\n          type: 'varchar',\n\n          notNull: true,\n        },\n        text: {\n          name: 'text',\n          type: 'varchar',\n        },\n      }\n\n      if (hasLocalizedManyTextField) {\n        columns.locale = {\n          name: 'locale',\n          type: 'enum',\n          locale: true,\n        }\n      }\n\n      const textsTableIndexes: Record<string, RawIndex> = {\n        orderParentIdx: {\n          name: `${textsTableName}_order_parent_idx`,\n          on: ['order', 'parent'],\n        },\n      }\n\n      if (hasManyTextField === 'index') {\n        textsTableIndexes.text_idx = {\n          name: `${textsTableName}_text_idx`,\n          on: 'text',\n        }\n      }\n\n      if (hasLocalizedManyTextField) {\n        textsTableIndexes.localeParent = {\n          name: `${textsTableName}_locale_parent`,\n          on: ['locale', 'parent'],\n        }\n      }\n\n      textsTable = {\n        name: textsTableName,\n        columns,\n        foreignKeys: {\n          parentFk: {\n            name: `${textsTableName}_parent_fk`,\n            columns: ['parent'],\n            foreignColumns: [\n              {\n                name: 'id',\n                table: tableName,\n              },\n            ],\n            onDelete: 'cascade',\n          },\n        },\n        indexes: textsTableIndexes,\n      }\n\n      adapter.rawTables[textsTableName] = textsTable\n\n      adapter.rawRelations[textsTableName] = {\n        parent: {\n          type: 'one',\n          fields: [\n            {\n              name: 'parent',\n              table: textsTableName,\n            },\n          ],\n          references: ['id'],\n          relationName: '_texts',\n          to: tableName,\n        },\n      }\n    }\n\n    if (hasManyNumberField) {\n      const numbersTableName = `${rootTableName}_numbers`\n      const columns: Record<string, RawColumn> = {\n        id: {\n          name: 'id',\n          type: 'serial',\n          primaryKey: true,\n        },\n        number: {\n          name: 'number',\n          type: 'numeric',\n        },\n        order: {\n          name: 'order',\n          type: 'integer',\n          notNull: true,\n        },\n        parent: {\n          name: 'parent_id',\n          type: idColType,\n          notNull: true,\n        },\n        path: {\n          name: 'path',\n          type: 'varchar',\n          notNull: true,\n        },\n      }\n\n      if (hasLocalizedManyNumberField) {\n        columns.locale = {\n          name: 'locale',\n          type: 'enum',\n          locale: true,\n        }\n      }\n\n      const numbersTableIndexes: Record<string, RawIndex> = {\n        orderParentIdx: { name: `${numbersTableName}_order_parent_idx`, on: ['order', 'parent'] },\n      }\n\n      if (hasManyNumberField === 'index') {\n        numbersTableIndexes.numberIdx = {\n          name: `${numbersTableName}_number_idx`,\n          on: 'number',\n        }\n      }\n\n      if (hasLocalizedManyNumberField) {\n        numbersTableIndexes.localeParent = {\n          name: `${numbersTableName}_locale_parent`,\n          on: ['locale', 'parent'],\n        }\n      }\n\n      numbersTable = {\n        name: numbersTableName,\n        columns,\n        foreignKeys: {\n          parentFk: {\n            name: `${numbersTableName}_parent_fk`,\n            columns: ['parent'],\n            foreignColumns: [\n              {\n                name: 'id',\n                table: tableName,\n              },\n            ],\n            onDelete: 'cascade',\n          },\n        },\n        indexes: numbersTableIndexes,\n      }\n\n      adapter.rawTables[numbersTableName] = numbersTable\n\n      adapter.rawRelations[numbersTableName] = {\n        parent: {\n          type: 'one',\n          fields: [\n            {\n              name: 'parent',\n              table: numbersTableName,\n            },\n          ],\n          references: ['id'],\n          relationName: '_numbers',\n          to: tableName,\n        },\n      }\n    }\n\n    if (relationships.size) {\n      const relationshipColumns: Record<string, RawColumn> = {\n        id: {\n          name: 'id',\n          type: 'serial',\n          primaryKey: true,\n        },\n        order: {\n          name: 'order',\n          type: 'integer',\n        },\n        parent: {\n          name: 'parent_id',\n          type: idColType,\n          notNull: true,\n        },\n        path: {\n          name: 'path',\n          type: 'varchar',\n          notNull: true,\n        },\n      }\n\n      if (hasLocalizedRelationshipField) {\n        relationshipColumns.locale = {\n          name: 'locale',\n          type: 'enum',\n          locale: true,\n        }\n      }\n\n      const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n      const relationshipIndexes: Record<string, RawIndex> = {\n        order: {\n          name: `${relationshipsTableName}_order_idx`,\n          on: 'order',\n        },\n        parentIdx: {\n          name: `${relationshipsTableName}_parent_idx`,\n          on: 'parent',\n        },\n        pathIdx: {\n          name: `${relationshipsTableName}_path_idx`,\n          on: 'path',\n        },\n      }\n\n      if (hasLocalizedRelationshipField) {\n        relationshipIndexes.localeIdx = {\n          name: `${relationshipsTableName}_locale_idx`,\n          on: 'locale',\n        }\n      }\n\n      const relationshipForeignKeys: Record<string, RawForeignKey> = {\n        parentFk: {\n          name: `${relationshipsTableName}_parent_fk`,\n          columns: ['parent'],\n          foreignColumns: [\n            {\n              name: 'id',\n              table: tableName,\n            },\n          ],\n          onDelete: 'cascade',\n        },\n      }\n\n      relationships.forEach((relationTo) => {\n        const relationshipConfig = adapter.payload.collections[relationTo].config\n        const formattedRelationTo = createTableName({\n          adapter,\n          config: relationshipConfig,\n          throwValidationError: true,\n        })\n        let colType: 'integer' | 'numeric' | 'uuid' | 'varchar' =\n          adapter.idType === 'uuid' ? 'uuid' : 'integer'\n        const relatedCollectionCustomIDType =\n          adapter.payload.collections[relationshipConfig.slug]?.customIDType\n\n        if (relatedCollectionCustomIDType === 'number') {\n          colType = 'numeric'\n        }\n        if (relatedCollectionCustomIDType === 'text') {\n          colType = 'varchar'\n        }\n\n        const colName = `${relationTo}ID`\n\n        relationshipColumns[colName] = {\n          name: `${formattedRelationTo}_id`,\n          type: colType,\n        }\n\n        relationshipForeignKeys[`${relationTo}IdFk`] = {\n          name: `${relationshipsTableName}_${toSnakeCase(relationTo)}_fk`,\n          columns: [colName],\n          foreignColumns: [\n            {\n              name: 'id',\n              table: formattedRelationTo,\n            },\n          ],\n          onDelete: 'cascade',\n        }\n\n        const indexColumns = [colName]\n\n        const unique = !disableUnique && uniqueRelationships.has(relationTo)\n\n        if (unique) {\n          indexColumns.push('path')\n        }\n        if (hasLocalizedRelationshipField) {\n          indexColumns.push('locale')\n        }\n\n        const indexName = buildIndexName({\n          name: `${relationshipsTableName}_${formattedRelationTo}_id`,\n          adapter,\n        })\n\n        relationshipIndexes[indexName] = {\n          name: indexName,\n          on: indexColumns,\n          unique,\n        }\n      })\n\n      relationshipsTable = {\n        name: relationshipsTableName,\n        columns: relationshipColumns,\n        foreignKeys: relationshipForeignKeys,\n        indexes: relationshipIndexes,\n      }\n\n      adapter.rawTables[relationshipsTableName] = relationshipsTable\n\n      const relationshipsTableRelations: Record<string, RawRelation> = {\n        parent: {\n          type: 'one',\n          fields: [\n            {\n              name: 'parent',\n              table: relationshipsTableName,\n            },\n          ],\n          references: ['id'],\n          relationName: '_rels',\n          to: tableName,\n        },\n      }\n\n      relationships.forEach((relationTo) => {\n        const relatedTableName = createTableName({\n          adapter,\n          config: adapter.payload.collections[relationTo].config,\n          throwValidationError: true,\n        })\n        const idColumnName = `${relationTo}ID`\n\n        relationshipsTableRelations[idColumnName] = {\n          type: 'one',\n          fields: [\n            {\n              name: idColumnName,\n              table: relationshipsTableName,\n            },\n          ],\n          references: ['id'],\n          relationName: relationTo,\n          to: relatedTableName,\n        }\n      })\n      adapter.rawRelations[relationshipsTableName] = relationshipsTableRelations\n    }\n  }\n\n  const tableRelations: Record<string, RawRelation> = {}\n\n  nonLocalizedRelations.forEach(({ type, relationName, target }, key) => {\n    if (type === 'one') {\n      tableRelations[key] = {\n        type: 'one',\n        fields: [\n          {\n            name: key,\n            table: tableName,\n          },\n        ],\n        references: ['id'],\n        relationName: key,\n        to: target,\n      }\n    }\n    if (type === 'many') {\n      tableRelations[key] = {\n        type: 'many',\n        relationName: relationName || key,\n        to: target,\n      }\n    }\n  })\n\n  if (hasLocalizedField) {\n    tableRelations._locales = {\n      type: 'many',\n      relationName: '_locales',\n      to: localesTable.name,\n    }\n  }\n\n  if (isRoot && textsTable) {\n    tableRelations._texts = {\n      type: 'many',\n      relationName: '_texts',\n      to: textsTable.name,\n    }\n  }\n\n  if (isRoot && numbersTable) {\n    tableRelations._numbers = {\n      type: 'many',\n      relationName: '_numbers',\n      to: numbersTable.name,\n    }\n  }\n\n  if (relationships.size && relationshipsTable) {\n    tableRelations._rels = {\n      type: 'many',\n      relationName: '_rels',\n      to: relationshipsTable.name,\n    }\n  }\n\n  adapter.rawRelations[tableName] = tableRelations\n\n  return {\n    hasLocalizedManyNumberField,\n    hasLocalizedManyTextField,\n    hasLocalizedRelationshipField,\n    hasManyNumberField,\n    hasManyTextField,\n    relationsToBuild,\n  }\n}\n"],"names":["toSnakeCase","createTableName","buildIndexName","traverseFields","buildTable","adapter","baseColumns","baseForeignKeys","baseIndexes","disableNotNull","disableRelsTableUnique","disableUnique","fields","rootRelationships","rootRelationsToBuild","rootTableIDColType","rootTableName","incomingRootTableName","rootUniqueRelationships","setColumnID","tableName","timestamps","versions","withinLocalizedArrayOrBlock","isRoot","columns","indexes","localesColumns","localesIndexes","localesTable","textsTable","numbersTable","relationships","Set","uniqueRelationships","relationshipsTable","relationsToBuild","Map","idColType","hasLocalizedField","hasLocalizedManyNumberField","hasLocalizedManyTextField","hasLocalizedRelationshipField","hasManyNumberField","hasManyTextField","newTableName","parentTableName","localizedRelations","nonLocalizedRelations","forEach","type","localized","relationName","target","key","map","set","createdAt","name","defaultNow","mode","notNull","precision","withTimezone","updatedAt","table","foreignKeys","rawTables","size","localeTableName","localesSuffix","id","primaryKey","_locale","locale","_parentID","_localeParent","on","unique","_parentIdFk","foreignColumns","onDelete","localeRelations","references","to","rawRelations","textsTableName","order","parent","path","text","textsTableIndexes","orderParentIdx","text_idx","localeParent","parentFk","numbersTableName","number","numbersTableIndexes","numberIdx","relationshipColumns","relationshipsTableName","relationshipsSuffix","relationshipIndexes","parentIdx","pathIdx","localeIdx","relationshipForeignKeys","relationTo","relationshipConfig","payload","collections","config","formattedRelationTo","throwValidationError","colType","idType","relatedCollectionCustomIDType","slug","customIDType","colName","indexColumns","has","push","indexName","relationshipsTableRelations","relatedTableName","idColumnName","tableRelations","_locales","_texts","_numbers","_rels"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7228, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7234, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/schema/buildRawSchema.ts"],"sourcesContent":["import { buildVersionCollectionFields, buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter, RawIndex, SetColumnID } from '../types.js'\n\nimport { createTableName } from '../createTableName.js'\nimport { buildTable } from './build.js'\n\n/**\n * Builds abstract Payload SQL schema\n */\nexport const buildRawSchema = ({\n  adapter,\n  setColumnID,\n}: {\n  adapter: DrizzleAdapter\n  setColumnID: SetColumnID\n}) => {\n  adapter.indexes = new Set()\n\n  adapter.payload.config.collections.forEach((collection) => {\n    createTableName({\n      adapter,\n      config: collection,\n    })\n\n    if (collection.versions) {\n      createTableName({\n        adapter,\n        config: collection,\n        versions: true,\n        versionsCustomName: true,\n      })\n    }\n  })\n\n  adapter.payload.config.collections.forEach((collection) => {\n    const tableName = adapter.tableNameMap.get(toSnakeCase(collection.slug))\n    const config = adapter.payload.config\n\n    const baseIndexes: Record<string, RawIndex> = {}\n\n    if (collection.upload.filenameCompoundIndex) {\n      const indexName = `${tableName}_filename_compound_idx`\n\n      baseIndexes.filename_compound_index = {\n        name: indexName,\n        on: collection.upload.filenameCompoundIndex.map((f) => f),\n        unique: true,\n      }\n    }\n\n    buildTable({\n      adapter,\n      disableNotNull: !!collection?.versions?.drafts,\n      disableUnique: false,\n      fields: collection.flattenedFields,\n      setColumnID,\n      tableName,\n      timestamps: collection.timestamps,\n      versions: false,\n    })\n\n    if (collection.versions) {\n      const versionsTableName = adapter.tableNameMap.get(\n        `_${toSnakeCase(collection.slug)}${adapter.versionsSuffix}`,\n      )\n      const versionFields = buildVersionCollectionFields(config, collection, true)\n\n      buildTable({\n        adapter,\n        disableNotNull: !!collection.versions?.drafts,\n        disableUnique: true,\n        fields: versionFields,\n        setColumnID,\n        tableName: versionsTableName,\n        timestamps: true,\n        versions: true,\n      })\n    }\n  })\n\n  adapter.payload.config.globals.forEach((global) => {\n    const tableName = createTableName({\n      adapter,\n      config: global,\n    })\n\n    buildTable({\n      adapter,\n      disableNotNull: !!global?.versions?.drafts,\n      disableUnique: false,\n      fields: global.flattenedFields,\n      setColumnID,\n      tableName,\n      timestamps: false,\n      versions: false,\n    })\n\n    if (global.versions) {\n      const versionsTableName = createTableName({\n        adapter,\n        config: global,\n        versions: true,\n        versionsCustomName: true,\n      })\n      const config = adapter.payload.config\n      const versionFields = buildVersionGlobalFields(config, global, true)\n\n      buildTable({\n        adapter,\n        disableNotNull: !!global.versions?.drafts,\n        disableUnique: true,\n        fields: versionFields,\n        setColumnID,\n        tableName: versionsTableName,\n        timestamps: true,\n        versions: true,\n      })\n    }\n  })\n}\n"],"names":["buildVersionCollectionFields","buildVersionGlobalFields","toSnakeCase","createTableName","buildTable","buildRawSchema","adapter","setColumnID","indexes","Set","payload","config","collections","forEach","collection","versions","versionsCustomName","tableName","tableNameMap","get","slug","baseIndexes","upload","filenameCompoundIndex","indexName","filename_compound_index","name","on","map","f","unique","disableNotNull","drafts","disableUnique","fields","flattenedFields","timestamps","versionsTableName","versionsSuffix","versionFields","globals","global"],"mappings":";;;AACA,OAAOE,iBAAiB,gBAAe;AAIvC,SAASC,eAAe,QAAQ,wBAAuB;AACvD,SAASC,UAAU,QAAQ,aAAY;AANvC,SAASJ,4BAA4B,EAAEC,wBAAwB,QAAQ,UAAS;;;;;;AAWzE,MAAMI,iBAAiB,CAAC,EAC7BC,OAAO,EACPC,WAAW,EAIZ;IACCD,QAAQE,OAAO,GAAG,IAAIC;IAEtBH,QAAQI,OAAO,CAACC,MAAM,CAACC,WAAW,CAACC,OAAO,CAAC,CAACC;iYAC1CX,mBAAAA,EAAgB;YACdG;YACAK,QAAQG;QACV;QAEA,IAAIA,WAAWC,QAAQ,EAAE;sYACvBZ,kBAAAA,EAAgB;gBACdG;gBACAK,QAAQG;gBACRC,UAAU;gBACVC,oBAAoB;YACtB;QACF;IACF;IAEAV,QAAQI,OAAO,CAACC,MAAM,CAACC,WAAW,CAACC,OAAO,CAAC,CAACC;QAC1C,MAAMG,YAAYX,QAAQY,YAAY,CAACC,GAAG,kNAACjB,UAAAA,EAAYY,WAAWM,IAAI;QACtE,MAAMT,SAASL,QAAQI,OAAO,CAACC,MAAM;QAErC,MAAMU,cAAwC,CAAC;QAE/C,IAAIP,WAAWQ,MAAM,CAACC,qBAAqB,EAAE;YAC3C,MAAMC,YAAY,GAAGP,UAAU,sBAAsB,CAAC;YAEtDI,YAAYI,uBAAuB,GAAG;gBACpCC,MAAMF;gBACNG,IAAIb,WAAWQ,MAAM,CAACC,qBAAqB,CAACK,GAAG,CAAC,CAACC,IAAMA;gBACvDC,QAAQ;YACV;QACF;kYAEA1B,aAAAA,EAAW;YACTE;YACAyB,gBAAgB,CAAC,CAACjB,YAAYC,UAAUiB;YACxCC,eAAe;YACfC,QAAQpB,WAAWqB,eAAe;YAClC5B;YACAU;YACAmB,YAAYtB,WAAWsB,UAAU;YACjCrB,UAAU;QACZ;QAEA,IAAID,WAAWC,QAAQ,EAAE;YACvB,MAAMsB,oBAAoB/B,QAAQY,YAAY,CAACC,GAAG,CAChD,CAAC,CAAC,mNAAEjB,UAAAA,EAAYY,WAAWM,IAAI,IAAId,QAAQgC,cAAc,EAAE;YAE7D,MAAMC,iBAAgBvC,6ZAAAA,EAA6BW,QAAQG,YAAY;sYAEvEV,aAAAA,EAAW;gBACTE;gBACAyB,gBAAgB,CAAC,CAACjB,WAAWC,QAAQ,EAAEiB;gBACvCC,eAAe;gBACfC,QAAQK;gBACRhC;gBACAU,WAAWoB;gBACXD,YAAY;gBACZrB,UAAU;YACZ;QACF;IACF;IAEAT,QAAQI,OAAO,CAACC,MAAM,CAAC6B,OAAO,CAAC3B,OAAO,CAAC,CAAC4B;QACtC,MAAMxB,sYAAYd,kBAAAA,EAAgB;YAChCG;YACAK,QAAQ8B;QACV;SAEArC,sYAAAA,EAAW;YACTE;YACAyB,gBAAgB,CAAC,CAACU,QAAQ1B,UAAUiB;YACpCC,eAAe;YACfC,QAAQO,OAAON,eAAe;YAC9B5B;YACAU;YACAmB,YAAY;YACZrB,UAAU;QACZ;QAEA,IAAI0B,OAAO1B,QAAQ,EAAE;YACnB,MAAMsB,8YAAoBlC,kBAAAA,EAAgB;gBACxCG;gBACAK,QAAQ8B;gBACR1B,UAAU;gBACVC,oBAAoB;YACtB;YACA,MAAML,SAASL,QAAQI,OAAO,CAACC,MAAM;YACrC,MAAM4B,2YAAgBtC,2BAAAA,EAAyBU,QAAQ8B,QAAQ;sYAE/DrC,aAAAA,EAAW;gBACTE;gBACAyB,gBAAgB,CAAC,CAACU,OAAO1B,QAAQ,EAAEiB;gBACnCC,eAAe;gBACfC,QAAQK;gBACRhC;gBACAU,WAAWoB;gBACXD,YAAY;gBACZrB,UAAU;YACZ;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 7336, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7342, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transactions/beginTransaction.ts"],"sourcesContent":["import type { BeginTransaction } from 'payload'\n\nimport { v4 as uuid } from 'uuid'\n\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\nexport const beginTransaction: BeginTransaction = async function beginTransaction(\n  this: DrizzleAdapter,\n  options: DrizzleAdapter['transactionOptions'],\n) {\n  let id\n  try {\n    id = uuid()\n\n    let reject: () => Promise<void>\n    let resolve: () => Promise<void>\n    let transaction: DrizzleTransaction\n\n    let transactionReady: () => void\n\n    // Await initialization here\n    // Prevent race conditions where the adapter may be\n    // re-initializing, and `this.drizzle` is potentially undefined\n    await this.initializing\n\n    // Drizzle only exposes a transactions API that is sufficient if you\n    // can directly pass around the `tx` argument. But our operations are spread\n    // over many files and we don't want to pass the `tx` around like that,\n    // so instead, we \"lift\" up the `resolve` and `reject` methods\n    // and will call them in our respective transaction methods\n    const done = this.drizzle\n      .transaction(async (tx) => {\n        transaction = tx\n        await new Promise<void>((res, rej) => {\n          resolve = () => {\n            res()\n            return done\n          }\n          reject = () => {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            rej()\n            return done\n          }\n          transactionReady()\n        })\n      }, options || this.transactionOptions)\n      .catch(() => {\n        // swallow\n      })\n\n    // Need to wait until the transaction is ready\n    // before binding its `resolve` and `reject` methods below\n    await new Promise<void>((resolve) => (transactionReady = resolve))\n\n    this.sessions[id] = {\n      db: transaction,\n      reject,\n      resolve,\n    }\n  } catch (err) {\n    this.payload.logger.error({ err, msg: `Error: cannot begin transaction: ${err.message}` })\n    process.exit(1)\n  }\n\n  return id\n}\n"],"names":["v4","uuid","beginTransaction","options","id","reject","resolve","transaction","transactionReady","initializing","done","drizzle","tx","Promise","res","rej","transactionOptions","catch","sessions","db","err","payload","logger","error","msg","message","process","exit"],"mappings":";;;AAEA,SAASA,MAAMC,IAAI,QAAQ,OAAM;;AAI1B,MAAMC,mBAAqC,eAAeA,iBAE/DC,OAA6C;IAE7C,IAAIC;IACJ,IAAI;QACFA,6OAAKH,KAAAA;QAEL,IAAII;QACJ,IAAIC;QACJ,IAAIC;QAEJ,IAAIC;QAEJ,4BAA4B;QAC5B,mDAAmD;QACnD,+DAA+D;QAC/D,MAAM,IAAI,CAACC,YAAY;QAEvB,oEAAoE;QACpE,4EAA4E;QAC5E,uEAAuE;QACvE,8DAA8D;QAC9D,2DAA2D;QAC3D,MAAMC,OAAO,IAAI,CAACC,OAAO,CACtBJ,WAAW,CAAC,OAAOK;YAClBL,cAAcK;YACd,MAAM,IAAIC,QAAc,CAACC,KAAKC;gBAC5BT,UAAU;oBACRQ;oBACA,OAAOJ;gBACT;gBACAL,SAAS;oBACP,2EAA2E;oBAC3EU;oBACA,OAAOL;gBACT;gBACAF;YACF;QACF,GAAGL,WAAW,IAAI,CAACa,kBAAkB,EACpCC,KAAK,CAAC;QACL,UAAU;QACZ;QAEF,8CAA8C;QAC9C,0DAA0D;QAC1D,MAAM,IAAIJ,QAAc,CAACP,UAAaE,mBAAmBF;QAEzD,IAAI,CAACY,QAAQ,CAACd,GAAG,GAAG;YAClBe,IAAIZ;YACJF;YACAC;QACF;IACF,EAAE,OAAOc,KAAK;QACZ,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,KAAK,CAAC;YAAEH;YAAKI,KAAK,CAAC,iCAAiC,EAAEJ,IAAIK,OAAO,EAAE;QAAC;QACxFC,QAAQC,IAAI,CAAC;IACf;IAEA,OAAOvB;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 7398, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7404, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transactions/commitTransaction.ts"],"sourcesContent":["import type { CommitTransaction } from 'payload'\n\nexport const commitTransaction: CommitTransaction = async function commitTransaction(id) {\n  if (id instanceof Promise) {\n    return\n  }\n\n  // if the session was deleted it has already been aborted\n  if (!this.sessions[id]) {\n    return\n  }\n\n  try {\n    await this.sessions[id].resolve()\n  } catch (err: unknown) {\n    await this.sessions[id].reject()\n  }\n\n  delete this.sessions[id]\n}\n"],"names":["commitTransaction","id","Promise","sessions","resolve","err","reject"],"mappings":";;;AAEO,MAAMA,oBAAuC,eAAeA,kBAAkBC,EAAE;IACrF,IAAIA,cAAcC,SAAS;QACzB;IACF;IAEA,yDAAyD;IACzD,IAAI,CAAC,IAAI,CAACC,QAAQ,CAACF,GAAG,EAAE;QACtB;IACF;IAEA,IAAI;QACF,MAAM,IAAI,CAACE,QAAQ,CAACF,GAAG,CAACG,OAAO;IACjC,EAAE,OAAOC,KAAc;QACrB,MAAM,IAAI,CAACF,QAAQ,CAACF,GAAG,CAACK,MAAM;IAChC;IAEA,OAAO,IAAI,CAACH,QAAQ,CAACF,GAAG;AAC1B,EAAC","ignoreList":[0]}},
    {"offset": {"line": 7422, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7428, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/transactions/rollbackTransaction.ts"],"sourcesContent":["import type { RollbackTransaction } from 'payload'\n\nexport const rollbackTransaction: RollbackTransaction = async function rollbackTransaction(\n  incomingID = '',\n) {\n  const transactionID = incomingID instanceof Promise ? await incomingID : incomingID\n\n  // if multiple operations are using the same transaction, the first will flow through and delete the session.\n  // subsequent calls should be ignored.\n  if (!this.sessions[transactionID]) {\n    return\n  }\n\n  // end the session promise in failure by calling reject\n  await this.sessions[transactionID].reject()\n\n  // delete the session causing any other operations with the same transaction to fail\n  delete this.sessions[transactionID]\n}\n"],"names":["rollbackTransaction","incomingID","transactionID","Promise","sessions","reject"],"mappings":";;;AAEO,MAAMA,sBAA2C,eAAeA,oBACrEC,aAAa,EAAE;IAEf,MAAMC,gBAAgBD,sBAAsBE,UAAU,MAAMF,aAAaA;IAEzE,6GAA6G;IAC7G,sCAAsC;IACtC,IAAI,CAAC,IAAI,CAACG,QAAQ,CAACF,cAAc,EAAE;QACjC;IACF;IAEA,uDAAuD;IACvD,MAAM,IAAI,CAACE,QAAQ,CAACF,cAAc,CAACG,MAAM;IAEzC,oFAAoF;IACpF,OAAO,IAAI,CAACD,QAAQ,CAACF,cAAc;AACrC,EAAC","ignoreList":[0]}},
    {"offset": {"line": 7443, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7449, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/update.ts"],"sourcesContent":["import type { UpdateOne } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildFindManyArgs } from './find/buildFindManyArgs.js'\nimport buildQuery from './queries/buildQuery.js'\nimport { selectDistinct } from './queries/selectDistinct.js'\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const updateOne: UpdateOne = async function updateOne(\n  this: DrizzleAdapter,\n  { id, collection: collectionSlug, data, joins: joinQuery, locale, req, select, where: whereArg },\n) {\n  const db = await getTransaction(this, req)\n  const collection = this.payload.collections[collectionSlug].config\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n  const whereToUse = whereArg || { id: { equals: id } }\n  let idToUpdate = id\n\n  const { joins, selectFields, where } = buildQuery({\n    adapter: this,\n    fields: collection.flattenedFields,\n    locale,\n    tableName,\n    where: whereToUse,\n  })\n\n  const selectDistinctResult = await selectDistinct({\n    adapter: this,\n    chainedMethods: [{ args: [1], method: 'limit' }],\n    db,\n    joins,\n    selectFields,\n    tableName,\n    where,\n  })\n\n  if (selectDistinctResult?.[0]?.id) {\n    idToUpdate = selectDistinctResult?.[0]?.id\n\n    // If id wasn't passed but `where` without any joins, retrieve it with findFirst\n  } else if (whereArg && !joins.length) {\n    const findManyArgs = buildFindManyArgs({\n      adapter: this,\n      depth: 0,\n      fields: collection.flattenedFields,\n      joinQuery: false,\n      select: {},\n      tableName,\n    })\n\n    findManyArgs.where = where\n\n    const docToUpdate = await db.query[tableName].findFirst(findManyArgs)\n    idToUpdate = docToUpdate?.id\n  }\n\n  const result = await upsertRow({\n    id: idToUpdate,\n    adapter: this,\n    data,\n    db,\n    fields: collection.flattenedFields,\n    joinQuery,\n    operation: 'update',\n    req,\n    select,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["toSnakeCase","buildFindManyArgs","buildQuery","selectDistinct","upsertRow","getTransaction","updateOne","id","collection","collectionSlug","data","joins","joinQuery","locale","req","select","where","whereArg","db","payload","collections","config","tableName","tableNameMap","get","slug","whereToUse","equals","idToUpdate","selectFields","adapter","fields","flattenedFields","selectDistinctResult","chainedMethods","args","method","length","findManyArgs","depth","docToUpdate","query","findFirst","result","operation"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,iBAAiB,QAAQ,8BAA6B;AAC/D,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,cAAc,QAAQ,8BAA6B;AAC5D,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;;;;AAEvD,MAAMC,YAAuB,eAAeA,UAEjD,EAAEC,EAAE,EAAEC,YAAYC,cAAc,EAAEC,IAAI,EAAEC,OAAOC,SAAS,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,OAAOC,QAAQ,EAAE;IAEhG,MAAMC,KAAK,4YAAMb,iBAAAA,EAAe,IAAI,EAAES;IACtC,MAAMN,aAAa,IAAI,CAACW,OAAO,CAACC,WAAW,CAACX,eAAe,CAACY,MAAM;IAClE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kNAACxB,UAAAA,EAAYQ,WAAWiB,IAAI;IACnE,MAAMC,aAAaT,YAAY;QAAEV,IAAI;YAAEoB,QAAQpB;QAAG;IAAE;IACpD,IAAIqB,aAAarB;IAEjB,MAAM,EAAEI,KAAK,EAAEkB,YAAY,EAAEb,KAAK,EAAE,mYAAGd,UAAAA,EAAW;QAChD4B,SAAS,IAAI;QACbC,QAAQvB,WAAWwB,eAAe;QAClCnB;QACAS;QACAN,OAAOU;IACT;IAEA,MAAMO,uBAAuB,0YAAM9B,iBAAAA,EAAe;QAChD2B,SAAS,IAAI;QACbI,gBAAgB;YAAC;gBAAEC,MAAM;oBAAC;iBAAE;gBAAEC,QAAQ;YAAQ;SAAE;QAChDlB;QACAP;QACAkB;QACAP;QACAN;IACF;IAEA,IAAIiB,sBAAsB,CAAC,EAAE,EAAE1B,IAAI;QACjCqB,aAAaK,sBAAsB,CAAC,EAAE,EAAE1B;IAExC,gFAAgF;IAClF,OAAO,IAAIU,YAAY,CAACN,MAAM0B,MAAM,EAAE;QACpC,MAAMC,mZAAerC,oBAAAA,EAAkB;YACrC6B,SAAS,IAAI;YACbS,OAAO;YACPR,QAAQvB,WAAWwB,eAAe;YAClCpB,WAAW;YACXG,QAAQ,CAAC;YACTO;QACF;QAEAgB,aAAatB,KAAK,GAAGA;QAErB,MAAMwB,cAAc,MAAMtB,GAAGuB,KAAK,CAACnB,UAAU,CAACoB,SAAS,CAACJ;QACxDV,aAAaY,aAAajC;IAC5B;IAEA,MAAMoC,SAAS,MAAMvC,yYAAAA,EAAU;QAC7BG,IAAIqB;QACJE,SAAS,IAAI;QACbpB;QACAQ;QACAa,QAAQvB,WAAWwB,eAAe;QAClCpB;QACAgC,WAAW;QACX9B;QACAC;QACAO;IACF;IAEA,OAAOqB;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 7527, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7533, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/updateGlobal.ts"],"sourcesContent":["import type { UpdateGlobalArgs } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function updateGlobal<T extends Record<string, unknown>>(\n  this: DrizzleAdapter,\n  { slug, data, req, select }: UpdateGlobalArgs,\n): Promise<T> {\n  const db = await getTransaction(this, req)\n  const globalConfig = this.payload.globals.config.find((config) => config.slug === slug)\n  const tableName = this.tableNameMap.get(toSnakeCase(globalConfig.slug))\n\n  const existingGlobal = await db.query[tableName].findFirst({})\n\n  const result = await upsertRow<{ globalType: string } & T>({\n    ...(existingGlobal ? { id: existingGlobal.id, operation: 'update' } : { operation: 'create' }),\n    adapter: this,\n    data,\n    db,\n    fields: globalConfig.flattenedFields,\n    req,\n    select,\n    tableName,\n  })\n\n  result.globalType = slug\n\n  return result\n}\n"],"names":["toSnakeCase","upsertRow","getTransaction","updateGlobal","slug","data","req","select","db","globalConfig","payload","globals","config","find","tableName","tableNameMap","get","existingGlobal","query","findFirst","result","id","operation","adapter","fields","flattenedFields","globalType"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;AAEvD,eAAeC,aAEpB,EAAEC,IAAI,EAAEC,IAAI,EAAEC,GAAG,EAAEC,MAAM,EAAoB;IAE7C,MAAMC,KAAK,UAAMN,mZAAAA,EAAe,IAAI,EAAEI;IACtC,MAAMG,eAAe,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOR,IAAI,KAAKA;IAClF,MAAMU,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,kNAAChB,UAAAA,EAAYS,aAAaL,IAAI;IAErE,MAAMa,iBAAiB,MAAMT,GAAGU,KAAK,CAACJ,UAAU,CAACK,SAAS,CAAC,CAAC;IAE5D,MAAMC,SAAS,mYAAMnB,YAAAA,EAAsC;QACzD,GAAIgB,iBAAiB;YAAEI,IAAIJ,eAAeI,EAAE;YAAEC,WAAW;QAAS,IAAI;YAAEA,WAAW;QAAS,CAAC;QAC7FC,SAAS,IAAI;QACblB;QACAG;QACAgB,QAAQf,aAAagB,eAAe;QACpCnB;QACAC;QACAO;IACF;IAEAM,OAAOM,UAAU,GAAGtB;IAEpB,OAAOgB;AACT","ignoreList":[0]}},
    {"offset": {"line": 7565, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7571, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/updateGlobalVersion.ts"],"sourcesContent":["import type {\n  SanitizedGlobalConfig,\n  TypeWithID,\n  TypeWithVersion,\n  UpdateGlobalVersionArgs,\n} from 'payload'\n\nimport { buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport buildQuery from './queries/buildQuery.js'\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function updateGlobalVersion<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  { id, global, locale, req, select, versionData, where: whereArg }: UpdateGlobalVersionArgs<T>,\n) {\n  const db = await getTransaction(this, req)\n  const globalConfig: SanitizedGlobalConfig = this.payload.globals.config.find(\n    ({ slug }) => slug === global,\n  )\n  const whereToUse = whereArg || { id: { equals: id } }\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(globalConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionGlobalFields(this.payload.config, globalConfig, true)\n\n  const { where } = buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    tableName,\n    where: whereToUse,\n  })\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    id,\n    adapter: this,\n    data: versionData,\n    db,\n    fields,\n    operation: 'update',\n    req,\n    select,\n    tableName,\n    where,\n  })\n\n  return result\n}\n"],"names":["buildVersionGlobalFields","toSnakeCase","buildQuery","upsertRow","getTransaction","updateGlobalVersion","id","global","locale","req","select","versionData","where","whereArg","db","globalConfig","payload","globals","config","find","slug","whereToUse","equals","tableName","tableNameMap","get","versionsSuffix","fields","adapter","result","data","operation"],"mappings":";;;AAQA,OAAOC,iBAAiB,gBAAe;AAIvC,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;AAP9D,SAASJ,wBAAwB,QAAQ,UAAS;;;;;;AAS3C,eAAeK,oBAEpB,EAAEC,EAAE,EAAEC,MAAM,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,WAAW,EAAEC,OAAOC,QAAQ,EAA8B;IAE7F,MAAMC,KAAK,OAAMV,sZAAAA,EAAe,IAAI,EAAEK;IACtC,MAAMM,eAAsC,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAC1E,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASb;IAEzB,MAAMc,aAAaR,YAAY;QAAEP,IAAI;YAAEgB,QAAQhB;QAAG;IAAE;IAEpD,MAAMiB,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mNAAExB,UAAAA,EAAYc,aAAaK,IAAI,IAAI,IAAI,CAACM,cAAc,EAAE;IAG5D,MAAMC,oYAAS3B,2BAAAA,EAAyB,IAAI,CAACgB,OAAO,CAACE,MAAM,EAAEH,cAAc;IAE3E,MAAM,EAAEH,KAAK,EAAE,mYAAGV,UAAAA,EAAW;QAC3B0B,SAAS,IAAI;QACbD;QACAnB;QACAe;QACAX,OAAOS;IACT;IAEA,MAAMQ,SAAS,mYAAM1B,YAAAA,EAA8B;QACjDG;QACAsB,SAAS,IAAI;QACbE,MAAMnB;QACNG;QACAa;QACAI,WAAW;QACXtB;QACAC;QACAa;QACAX;IACF;IAEA,OAAOiB;AACT","ignoreList":[0]}},
    {"offset": {"line": 7615, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7621, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/updateVersion.ts"],"sourcesContent":["import type {\n  SanitizedCollectionConfig,\n  TypeWithID,\n  TypeWithVersion,\n  UpdateVersionArgs,\n} from 'payload'\n\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport buildQuery from './queries/buildQuery.js'\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function updateVersion<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  { id, collection, locale, req, select, versionData, where: whereArg }: UpdateVersionArgs<T>,\n) {\n  const db = await getTransaction(this, req)\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const whereToUse = whereArg || { id: { equals: id } }\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n\n  const { where } = buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    tableName,\n    where: whereToUse,\n  })\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    id,\n    adapter: this,\n    data: versionData,\n    db,\n    fields,\n    joinQuery: false,\n    operation: 'update',\n    req,\n    select,\n    tableName,\n    where,\n  })\n\n  return result\n}\n"],"names":["buildVersionCollectionFields","toSnakeCase","buildQuery","upsertRow","getTransaction","updateVersion","id","collection","locale","req","select","versionData","where","whereArg","db","collectionConfig","payload","collections","config","whereToUse","equals","tableName","tableNameMap","get","slug","versionsSuffix","fields","adapter","result","data","joinQuery","operation"],"mappings":";;;AAQA,OAAOC,iBAAiB,gBAAe;AAIvC,OAAOC,gBAAgB,0BAAyB;AAChD,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;AAP9D,SAASJ,4BAA4B,QAAQ,UAAS;;;;;;AAS/C,eAAeK,cAEpB,EAAEC,EAAE,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,WAAW,EAAEC,OAAOC,QAAQ,EAAwB;IAE3F,MAAMC,KAAK,4YAAMV,iBAAAA,EAAe,IAAI,EAAEK;IACtC,MAAMM,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACV,WAAW,CAACW,MAAM;IAC/F,MAAMC,aAAaN,YAAY;QAAEP,IAAI;YAAEc,QAAQd;QAAG;IAAE;IACpD,MAAMe,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,mNAAEtB,UAAAA,EAAYc,iBAAiBS,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE;IAGhE,MAAMC,wYAAS1B,+BAAAA,EAA6B,IAAI,CAACgB,OAAO,CAACE,MAAM,EAAEH,kBAAkB;IAEnF,MAAM,EAAEH,KAAK,EAAE,GAAGV,0YAAAA,EAAW;QAC3ByB,SAAS,IAAI;QACbD;QACAlB;QACAa;QACAT,OAAOO;IACT;IAEA,MAAMS,SAAS,mYAAMzB,YAAAA,EAA8B;QACjDG;QACAqB,SAAS,IAAI;QACbE,MAAMlB;QACNG;QACAY;QACAI,WAAW;QACXC,WAAW;QACXtB;QACAC;QACAW;QACAT;IACF;IAEA,OAAOgB;AACT","ignoreList":[0]}},
    {"offset": {"line": 7666, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7672, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/getMigrationTemplate.ts"],"sourcesContent":["import type { MigrationTemplateArgs } from 'payload'\n\nexport const indent = (text: string) =>\n  text\n    .split('\\n')\n    .map((line) => `  ${line}`)\n    .join('\\n')\n\nexport const getMigrationTemplate = ({\n  downSQL,\n  imports,\n  packageName,\n  upSQL,\n}: MigrationTemplateArgs): string => `import { MigrateUpArgs, MigrateDownArgs, sql } from '${packageName}'\n${imports ? `${imports}\\n` : ''}\nexport async function up({ db, payload, req }: MigrateUpArgs): Promise<void> {\n${indent(upSQL)}\n}\n\nexport async function down({ db, payload, req }: MigrateDownArgs): Promise<void> {\n${indent(downSQL)}\n}\n`\n"],"names":["indent","text","split","map","line","join","getMigrationTemplate","downSQL","imports","packageName","upSQL"],"mappings":";;;;AAEO,MAAMA,SAAS,CAACC,OACrBA,KACGC,KAAK,CAAC,MACNC,GAAG,CAAC,CAACC,OAAS,CAAC,EAAE,EAAEA,MAAM,EACzBC,IAAI,CAAC,MAAK;AAER,MAAMC,uBAAuB,CAAC,EACnCC,OAAO,EACPC,OAAO,EACPC,WAAW,EACXC,KAAK,EACiB,GAAa,CAAC,qDAAqD,EAAED,YAAY;AACzG,EAAED,UAAU,GAAGA,QAAQ,EAAE,CAAC,GAAG,GAAG;;AAEhC,EAAER,OAAOU,OAAO;;;;AAIhB,EAAEV,OAAOO,SAAS;;AAElB,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 7687, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7693, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/buildCreateMigration.ts"],"sourcesContent":["import type { DrizzleSnapshotJSON } from 'drizzle-kit/api'\nimport type { CreateMigration } from 'payload'\n\nimport fs from 'fs'\nimport path from 'path'\nimport { getPredefinedMigration, writeMigrationIndex } from 'payload'\nimport prompts from 'prompts'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nimport { getMigrationTemplate } from './getMigrationTemplate.js'\n\nexport const buildCreateMigration = ({\n  executeMethod,\n  filename,\n  sanitizeStatements,\n}: {\n  executeMethod: string\n  filename: string\n  sanitizeStatements: (args: { sqlExecute: string; statements: string[] }) => string\n}): CreateMigration => {\n  const dirname = path.dirname(filename)\n  return async function createMigration(\n    this: DrizzleAdapter,\n    { file, forceAcceptWarning, migrationName, payload, skipEmpty },\n  ) {\n    const dir = payload.db.migrationDir\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir)\n    }\n\n    const { generateDrizzleJson, generateMigration, upSnapshot } = this.requireDrizzleKit()\n\n    const drizzleJsonAfter = await generateDrizzleJson(this.schema)\n\n    const [yyymmdd, hhmmss] = new Date().toISOString().split('T')\n    const formattedDate = yyymmdd.replace(/\\D/g, '')\n    const formattedTime = hhmmss.split('.')[0].replace(/\\D/g, '')\n    let imports: string = ''\n    let downSQL: string\n    let upSQL: string\n    ;({ downSQL, imports, upSQL } = await getPredefinedMigration({\n      dirname,\n      file,\n      migrationName,\n      payload,\n    }))\n\n    const timestamp = `${formattedDate}_${formattedTime}`\n\n    const name = migrationName || file?.split('/').slice(2).join('/')\n    const fileName = `${timestamp}${name ? `_${name.replace(/\\W/g, '_')}` : ''}`\n\n    const filePath = `${dir}/${fileName}`\n\n    let drizzleJsonBefore = this.defaultDrizzleSnapshot as DrizzleSnapshotJSON\n\n    if (this.schemaName) {\n      drizzleJsonBefore.schemas = {\n        [this.schemaName]: this.schemaName,\n      }\n    }\n\n    if (!upSQL) {\n      // Get latest migration snapshot\n      const latestSnapshot = fs\n        .readdirSync(dir)\n        .filter((file) => file.endsWith('.json'))\n        .sort()\n        .reverse()?.[0]\n\n      if (latestSnapshot) {\n        drizzleJsonBefore = JSON.parse(fs.readFileSync(`${dir}/${latestSnapshot}`, 'utf8'))\n\n        if (upSnapshot && drizzleJsonBefore.version < drizzleJsonAfter.version) {\n          drizzleJsonBefore = upSnapshot(drizzleJsonBefore)\n        }\n      }\n\n      const sqlStatementsUp = await generateMigration(drizzleJsonBefore, drizzleJsonAfter)\n      const sqlStatementsDown = await generateMigration(drizzleJsonAfter, drizzleJsonBefore)\n      const sqlExecute = `await db.${executeMethod}(` + 'sql`'\n\n      if (sqlStatementsUp?.length) {\n        upSQL = sanitizeStatements({ sqlExecute, statements: sqlStatementsUp })\n      }\n      if (sqlStatementsDown?.length) {\n        downSQL = sanitizeStatements({ sqlExecute, statements: sqlStatementsDown })\n      }\n\n      if (!upSQL?.length && !downSQL?.length && !forceAcceptWarning) {\n        if (skipEmpty) {\n          process.exit(0)\n        }\n\n        const { confirm: shouldCreateBlankMigration } = await prompts(\n          {\n            name: 'confirm',\n            type: 'confirm',\n            initial: false,\n            message: 'No schema changes detected. Would you like to create a blank migration file?',\n          },\n          {\n            onCancel: () => {\n              process.exit(0)\n            },\n          },\n        )\n\n        if (!shouldCreateBlankMigration) {\n          process.exit(0)\n        }\n      }\n\n      // write schema\n      fs.writeFileSync(`${filePath}.json`, JSON.stringify(drizzleJsonAfter, null, 2))\n    }\n\n    // write migration\n    fs.writeFileSync(\n      `${filePath}.ts`,\n      getMigrationTemplate({\n        downSQL: downSQL || `  // Migration code`,\n        imports,\n        packageName: payload.db.packageName,\n        upSQL: upSQL || `  // Migration code`,\n      }),\n    )\n\n    writeMigrationIndex({ migrationsDir: payload.db.migrationDir })\n\n    payload.logger.info({ msg: `Migration created at ${filePath}.ts` })\n  }\n}\n"],"names":["fs","path","getPredefinedMigration","writeMigrationIndex","prompts","getMigrationTemplate","buildCreateMigration","executeMethod","filename","sanitizeStatements","dirname","createMigration","file","forceAcceptWarning","migrationName","payload","skipEmpty","dir","db","migrationDir","existsSync","mkdirSync","generateDrizzleJson","generateMigration","upSnapshot","requireDrizzleKit","drizzleJsonAfter","schema","yyymmdd","hhmmss","Date","toISOString","split","formattedDate","replace","formattedTime","imports","downSQL","upSQL","timestamp","name","slice","join","fileName","filePath","drizzleJsonBefore","defaultDrizzleSnapshot","schemaName","schemas","latestSnapshot","readdirSync","filter","endsWith","sort","reverse","JSON","parse","readFileSync","version","sqlStatementsUp","sqlStatementsDown","sqlExecute","length","statements","process","exit","confirm","shouldCreateBlankMigration","type","initial","message","onCancel","writeFileSync","stringify","packageName","migrationsDir","logger","info","msg"],"mappings":";;;AAGA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;AAEvB,OAAOG,aAAa,UAAS;AAI7B,SAASC,oBAAoB,QAAQ,4BAA2B;AALhE,SAASH,sBAAsB,EAAEC,mBAAmB,QAAQ,UAAS;;;;;;;AAO9D,MAAMG,uBAAuB,CAAC,EACnCC,aAAa,EACbC,QAAQ,EACRC,kBAAkB,EAKnB;IACC,MAAMC,4GAAUT,UAAAA,CAAKS,OAAO,CAACF;IAC7B,OAAO,eAAeG,gBAEpB,EAAEC,IAAI,EAAEC,kBAAkB,EAAEC,aAAa,EAAEC,OAAO,EAAEC,SAAS,EAAE;QAE/D,MAAMC,MAAMF,QAAQG,EAAE,CAACC,YAAY;QACnC,IAAI,CAACnB,wGAAAA,CAAGoB,UAAU,CAACH,MAAM;0GACvBjB,UAAAA,CAAGqB,SAAS,CAACJ;QACf;QAEA,MAAM,EAAEK,mBAAmB,EAAEC,iBAAiB,EAAEC,UAAU,EAAE,GAAG,IAAI,CAACC,iBAAiB;QAErF,MAAMC,mBAAmB,MAAMJ,oBAAoB,IAAI,CAACK,MAAM;QAE9D,MAAM,CAACC,SAASC,OAAO,GAAG,IAAIC,OAAOC,WAAW,GAAGC,KAAK,CAAC;QACzD,MAAMC,gBAAgBL,QAAQM,OAAO,CAAC,OAAO;QAC7C,MAAMC,gBAAgBN,OAAOG,KAAK,CAAC,IAAI,CAAC,EAAE,CAACE,OAAO,CAAC,OAAO;QAC1D,IAAIE,UAAkB;QACtB,IAAIC;QACJ,IAAIC;QACF,CAAA,EAAED,OAAO,EAAED,OAAO,EAAEE,KAAK,EAAE,GAAG,oZAAMpC,yBAAAA,EAAuB;YAC3DQ;YACAE;YACAE;YACAC;QACF,EAAC;QAED,MAAMwB,YAAY,GAAGN,cAAc,CAAC,EAAEE,eAAe;QAErD,MAAMK,OAAO1B,iBAAiBF,MAAMoB,MAAM,KAAKS,MAAM,GAAGC,KAAK;QAC7D,MAAMC,WAAW,GAAGJ,YAAYC,OAAO,CAAC,CAAC,EAAEA,KAAKN,OAAO,CAAC,OAAO,MAAM,GAAG,IAAI;QAE5E,MAAMU,WAAW,GAAG3B,IAAI,CAAC,EAAE0B,UAAU;QAErC,IAAIE,oBAAoB,IAAI,CAACC,sBAAsB;QAEnD,IAAI,IAAI,CAACC,UAAU,EAAE;YACnBF,kBAAkBG,OAAO,GAAG;gBAC1B,CAAC,IAAI,CAACD,UAAU,CAAC,EAAE,IAAI,CAACA,UAAU;YACpC;QACF;QAEA,IAAI,CAACT,OAAO;YACV,gCAAgC;YAChC,MAAMW,+GAAiBjD,UAAAA,CACpBkD,WAAW,CAACjC,KACZkC,MAAM,CAAC,CAACvC,OAASA,KAAKwC,QAAQ,CAAC,UAC/BC,IAAI,GACJC,OAAO,IAAI,CAAC,EAAE;YAEjB,IAAIL,gBAAgB;gBAClBJ,oBAAoBU,KAAKC,KAAK,+FAACxD,UAAAA,CAAGyD,YAAY,CAAC,GAAGxC,IAAI,CAAC,EAAEgC,gBAAgB,EAAE;gBAE3E,IAAIzB,cAAcqB,kBAAkBa,OAAO,GAAGhC,iBAAiBgC,OAAO,EAAE;oBACtEb,oBAAoBrB,WAAWqB;gBACjC;YACF;YAEA,MAAMc,kBAAkB,MAAMpC,kBAAkBsB,mBAAmBnB;YACnE,MAAMkC,oBAAoB,MAAMrC,kBAAkBG,kBAAkBmB;YACpE,MAAMgB,aAAa,CAAC,SAAS,EAAEtD,cAAc,CAAC,CAAC,GAAG;YAElD,IAAIoD,iBAAiBG,QAAQ;gBAC3BxB,QAAQ7B,mBAAmB;oBAAEoD;oBAAYE,YAAYJ;gBAAgB;YACvE;YACA,IAAIC,mBAAmBE,QAAQ;gBAC7BzB,UAAU5B,mBAAmB;oBAAEoD;oBAAYE,YAAYH;gBAAkB;YAC3E;YAEA,IAAI,CAACtB,OAAOwB,UAAU,CAACzB,SAASyB,UAAU,CAACjD,oBAAoB;gBAC7D,IAAIG,WAAW;oBACbgD,QAAQC,IAAI,CAAC;gBACf;gBAEA,MAAM,EAAEC,SAASC,0BAA0B,EAAE,GAAG,+LAAM/D,UAAAA,EACpD;oBACEoC,MAAM;oBACN4B,MAAM;oBACNC,SAAS;oBACTC,SAAS;gBACX,GACA;oBACEC,UAAU;wBACRP,QAAQC,IAAI,CAAC;oBACf;gBACF;gBAGF,IAAI,CAACE,4BAA4B;oBAC/BH,QAAQC,IAAI,CAAC;gBACf;YACF;YAEA,eAAe;0GACfjE,UAAAA,CAAGwE,aAAa,CAAC,GAAG5B,SAAS,KAAK,CAAC,EAAEW,KAAKkB,SAAS,CAAC/C,kBAAkB,MAAM;QAC9E;QAEA,kBAAkB;qGAClB1B,WAAAA,CAAGwE,aAAa,CACd,GAAG5B,SAAS,GAAG,CAAC,8YAChBvC,uBAAAA,EAAqB;YACnBgC,SAASA,WAAW,CAAC,mBAAmB,CAAC;YACzCD;YACAsC,aAAa3D,QAAQG,EAAE,CAACwD,WAAW;YACnCpC,OAAOA,SAAS,CAAC,mBAAmB,CAAC;QACvC;mZAGFnC,sBAAAA,EAAoB;YAAEwE,eAAe5D,QAAQG,EAAE,CAACC,YAAY;QAAC;QAE7DJ,QAAQ6D,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK,CAAC,qBAAqB,EAAElC,SAAS,GAAG,CAAC;QAAC;IACnE;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 7798, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7804, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/createSchemaGenerator.ts"],"sourcesContent":["import type { GenerateSchema } from 'payload'\n\nimport { existsSync } from 'fs'\nimport { writeFile } from 'fs/promises'\nimport path from 'path'\n\nimport type { ColumnToCodeConverter, DrizzleAdapter } from '../types.js'\n\n/**\n * @example\n * console.log(sanitizeObjectKey(\"oneTwo\"));   // oneTwo\n * console.log(sanitizeObjectKey(\"one-two\"));  // 'one-two'\n * console.log(sanitizeObjectKey(\"_one$Two3\")); // _one$Two3\n * console.log(sanitizeObjectKey(\"3invalid\")); // '3invalid'\n */\nconst sanitizeObjectKey = (key: string) => {\n  // Regular expression for a valid identifier\n  const identifierRegex = /^[a-z_$][\\w$]*$/i\n  if (identifierRegex.test(key)) {\n    return key\n  }\n\n  return `'${key}'`\n}\n\n/**\n * @example\n * (columns default-valuesID) -> columns['default-valuesID']\n * (columns defaultValues) -> columns.defaultValues\n */\nconst accessProperty = (objName: string, key: string) => {\n  const sanitized = sanitizeObjectKey(key)\n\n  if (sanitized.startsWith(\"'\")) {\n    return `${objName}[${sanitized}]`\n  }\n\n  return `${objName}.${key}`\n}\n\nexport const createSchemaGenerator = ({\n  columnToCodeConverter,\n  corePackageSuffix,\n  defaultOutputFile,\n  enumImport,\n  schemaImport,\n  tableImport,\n}: {\n  columnToCodeConverter: ColumnToCodeConverter\n  corePackageSuffix: string\n  defaultOutputFile?: string\n  enumImport?: string\n  schemaImport?: string\n  tableImport: string\n}): GenerateSchema => {\n  return async function generateSchema(\n    this: DrizzleAdapter,\n    { log = true, outputFile = defaultOutputFile, prettify = true } = {},\n  ) {\n    const importDeclarations: Record<string, Set<string>> = {}\n\n    const tableDeclarations: string[] = []\n    const enumDeclarations: string[] = []\n    const relationsDeclarations: string[] = []\n\n    const addImport = (from: string, name: string) => {\n      if (!importDeclarations[from]) {\n        importDeclarations[from] = new Set()\n      }\n\n      importDeclarations[from].add(name)\n    }\n\n    const corePackage = `${this.packageName}/drizzle/${corePackageSuffix}`\n\n    let schemaDeclaration: null | string = null\n\n    if (this.schemaName) {\n      addImport(corePackage, schemaImport)\n      schemaDeclaration = `export const db_schema = ${schemaImport}('${this.schemaName}')`\n    }\n\n    const enumFn = this.schemaName ? `db_schema.enum` : enumImport\n\n    const enumsList: string[] = []\n    const addEnum = (name: string, options: string[]) => {\n      if (enumsList.some((each) => each === name)) {\n        return\n      }\n      enumsList.push(name)\n      enumDeclarations.push(\n        `export const ${name} = ${enumFn}('${name}', [${options.map((option) => `'${option}'`).join(', ')}])`,\n      )\n    }\n\n    if (this.payload.config.localization && enumImport) {\n      addEnum('enum__locales', this.payload.config.localization.localeCodes)\n    }\n\n    const tableFn = this.schemaName ? `db_schema.table` : tableImport\n\n    if (!this.schemaName) {\n      addImport(corePackage, tableImport)\n    }\n\n    addImport(corePackage, 'index')\n    addImport(corePackage, 'uniqueIndex')\n    addImport(corePackage, 'foreignKey')\n\n    addImport(`${this.packageName}/drizzle`, 'sql')\n    addImport(`${this.packageName}/drizzle`, 'relations')\n\n    for (const tableName in this.rawTables) {\n      const table = this.rawTables[tableName]\n\n      const extrasDeclarations: string[] = []\n\n      if (table.indexes) {\n        for (const key in table.indexes) {\n          const index = table.indexes[key]\n          let indexDeclaration = `${sanitizeObjectKey(key)}: ${index.unique ? 'uniqueIndex' : 'index'}('${index.name}')`\n          indexDeclaration += `.on(${typeof index.on === 'string' ? `${accessProperty('columns', index.on)}` : `${index.on.map((on) => `${accessProperty('columns', on)}`).join(', ')}`}),`\n          extrasDeclarations.push(indexDeclaration)\n        }\n      }\n\n      if (table.foreignKeys) {\n        for (const key in table.foreignKeys) {\n          const foreignKey = table.foreignKeys[key]\n\n          let foreignKeyDeclaration = `${sanitizeObjectKey(key)}: foreignKey({\n      columns: [${foreignKey.columns.map((col) => `columns['${col}']`).join(', ')}],\n      foreignColumns: [${foreignKey.foreignColumns.map((col) => `${accessProperty(col.table, col.name)}`).join(', ')}],\n      name: '${foreignKey.name}' \n    })`\n\n          if (foreignKey.onDelete) {\n            foreignKeyDeclaration += `.onDelete('${foreignKey.onDelete}')`\n          }\n          if (foreignKey.onUpdate) {\n            foreignKeyDeclaration += `.onUpdate('${foreignKey.onDelete}')`\n          }\n\n          foreignKeyDeclaration += ','\n\n          extrasDeclarations.push(foreignKeyDeclaration)\n        }\n      }\n\n      const tableCode = `\nexport const ${tableName} = ${tableFn}('${tableName}', {\n${Object.entries(table.columns)\n  .map(\n    ([key, column]) =>\n      `  ${sanitizeObjectKey(key)}: ${columnToCodeConverter({\n        adapter: this,\n        addEnum,\n        addImport,\n        column,\n        locales: this.payload.config.localization\n          ? this.payload.config.localization.localeCodes\n          : undefined,\n        tableKey: tableName,\n      })},`,\n  )\n  .join('\\n')}\n}${\n        extrasDeclarations.length\n          ? `, (columns) => ({\n    ${extrasDeclarations.join('\\n    ')}  \n  })`\n          : ''\n      }\n) \n`\n\n      tableDeclarations.push(tableCode)\n    }\n\n    for (const tableName in this.rawRelations) {\n      const relations = this.rawRelations[tableName]\n      const properties: string[] = []\n\n      for (const key in relations) {\n        const relation = relations[key]\n        let declaration: string\n\n        if (relation.type === 'one') {\n          declaration = `${sanitizeObjectKey(key)}: one(${relation.to}, {\n    ${relation.fields.some((field) => field.table !== tableName) ? '// @ts-expect-error Drizzle TypeScript bug for ONE relationships with a field in different table' : ''}\n    fields: [${relation.fields.map((field) => `${accessProperty(field.table, field.name)}`).join(', ')}],\n    references: [${relation.references.map((col) => `${accessProperty(relation.to, col)}`).join(', ')}],\n    ${relation.relationName ? `relationName: '${relation.relationName}',` : ''}\n    }),`\n        } else {\n          declaration = `${sanitizeObjectKey(key)}: many(${relation.to}, {\n            ${relation.relationName ? `relationName: '${relation.relationName}',` : ''}\n    }),`\n        }\n\n        properties.push(declaration)\n      }\n\n      // beautify / lintify relations callback output, when no many for example, don't add it\n      const args = []\n\n      if (Object.values(relations).some((rel) => rel.type === 'one')) {\n        args.push('one')\n      }\n\n      if (Object.values(relations).some((rel) => rel.type === 'many')) {\n        args.push('many')\n      }\n\n      const arg = args.length ? `{ ${args.join(', ')} }` : ''\n\n      const declaration = `export const relations_${tableName} = relations(${tableName}, (${arg}) => ({\n  ${properties.join('\\n    ')}\n      }))`\n\n      relationsDeclarations.push(declaration)\n    }\n\n    if (enumDeclarations.length && !this.schemaName) {\n      addImport(corePackage, enumImport)\n    }\n\n    const importDeclarationsSanitized: string[] = []\n\n    for (const moduleName in importDeclarations) {\n      const moduleImports = importDeclarations[moduleName]\n\n      importDeclarationsSanitized.push(\n        `import { ${Array.from(moduleImports).join(', ')} } from '${moduleName}'`,\n      )\n    }\n\n    const schemaType = `\ntype DatabaseSchema = {\n  ${[\n    this.schemaName ? 'db_schema' : null,\n    ...enumsList,\n    ...Object.keys(this.rawTables),\n    ...Object.keys(this.rawRelations).map((table) => `relations_${table}`),\n  ]\n    .filter(Boolean)\n    .map((name) => `${name}: typeof ${name}`)\n    .join('\\n  ')}\n}\n    `\n\n    const finalDeclaration = `\ndeclare module '${this.packageName}/types' {\n  export interface GeneratedDatabaseSchema {\n    schema: DatabaseSchema\n  }\n}\n    `\n\n    const warning = `\n/* tslint:disable */\n/* eslint-disable */\n/**\n * This file was automatically generated by Payload.\n * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,\n * and re-run \\`payload generate:db-schema\\` to regenerate this file.\n */\n`\n\n    let code = [\n      warning,\n      ...importDeclarationsSanitized,\n      schemaDeclaration,\n      ...enumDeclarations,\n      ...tableDeclarations,\n      ...relationsDeclarations,\n      schemaType,\n      finalDeclaration,\n    ]\n      .filter(Boolean)\n      .join('\\n')\n\n    if (!outputFile) {\n      const cwd = process.cwd()\n      const srcDir = path.resolve(cwd, 'src')\n\n      if (existsSync(srcDir)) {\n        outputFile = path.resolve(srcDir, 'payload-generated-schema.ts')\n      } else {\n        outputFile = path.resolve(cwd, 'payload-generated-schema.ts')\n      }\n    }\n\n    if (prettify) {\n      try {\n        const prettier = await import('prettier')\n        const configPath = await prettier.resolveConfigFile()\n        const config = configPath ? await prettier.resolveConfig(configPath) : {}\n        code = await prettier.format(code, { ...config, parser: 'typescript' })\n        // eslint-disable-next-line no-empty\n      } catch {}\n    }\n\n    await writeFile(outputFile, code, 'utf-8')\n\n    if (log) {\n      this.payload.logger.info(`Written ${outputFile}`)\n    }\n  }\n}\n"],"names":["existsSync","writeFile","path","sanitizeObjectKey","key","identifierRegex","test","accessProperty","objName","sanitized","startsWith","createSchemaGenerator","columnToCodeConverter","corePackageSuffix","defaultOutputFile","enumImport","schemaImport","tableImport","generateSchema","log","outputFile","prettify","importDeclarations","tableDeclarations","enumDeclarations","relationsDeclarations","addImport","from","name","Set","add","corePackage","packageName","schemaDeclaration","schemaName","enumFn","enumsList","addEnum","options","some","each","push","map","option","join","payload","config","localization","localeCodes","tableFn","tableName","rawTables","table","extrasDeclarations","indexes","index","indexDeclaration","unique","on","foreignKeys","foreignKey","foreignKeyDeclaration","columns","col","foreignColumns","onDelete","onUpdate","tableCode","Object","entries","column","adapter","locales","undefined","tableKey","length","rawRelations","relations","properties","relation","declaration","type","to","fields","field","references","relationName","args","values","rel","arg","importDeclarationsSanitized","moduleName","moduleImports","Array","schemaType","keys","filter","Boolean","finalDeclaration","warning","code","cwd","process","srcDir","resolve","prettier","configPath","resolveConfigFile","resolveConfig","format","parser","logger","info"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8028, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8034, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/extendDrizzleTable.ts"],"sourcesContent":["/**\n * Implemented from:\n * https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/pg-core/table.ts#L73\n * Drizzle uses @internal JSDoc to remove their internal methods from types, for example\n * Table.Symbol, columnBuilder.build - but they actually exist.\n */\nimport type { ColumnBuilderBase } from 'drizzle-orm'\n\nimport { Table } from 'drizzle-orm'\nimport { APIError } from 'payload'\n\nconst { Symbol: DrizzleSymbol } = Table as unknown as {\n  Symbol: {\n    Columns: symbol\n    ExtraConfigBuilder: symbol\n    ExtraConfigColumns: symbol\n  }\n}\n\ntype Args = {\n  columns?: Record<string, ColumnBuilderBase<any>>\n  extraConfig?: (self: Record<string, any>) => object\n  table: Table\n}\n\n/**\n * Extends the passed table with additional columns / extra config\n */\nexport const extendDrizzleTable = ({ columns, extraConfig, table }: Args): void => {\n  const InlineForeignKeys = Object.getOwnPropertySymbols(table).find((symbol) => {\n    return symbol.description?.includes('InlineForeignKeys')\n  })\n\n  if (!InlineForeignKeys) {\n    throw new APIError(`Error when finding InlineForeignKeys Symbol`, 500)\n  }\n\n  if (columns) {\n    for (const [name, columnBuilder] of Object.entries(columns) as [string, any][]) {\n      const column = columnBuilder.build(table)\n\n      table[name] = column\n      table[InlineForeignKeys].push(...columnBuilder.buildForeignKeys(column, table))\n      table[DrizzleSymbol.Columns][name] = column\n\n      table[DrizzleSymbol.ExtraConfigColumns][name] =\n        'buildExtraConfigColumn' in columnBuilder\n          ? columnBuilder.buildExtraConfigColumn(table)\n          : column\n    }\n  }\n\n  if (extraConfig) {\n    const originalExtraConfigBuilder = table[DrizzleSymbol.ExtraConfigBuilder]\n\n    table[DrizzleSymbol.ExtraConfigBuilder] = (t) => {\n      return {\n        ...originalExtraConfigBuilder(t),\n        ...extraConfig(t),\n      }\n    }\n  }\n}\n"],"names":["Table","APIError","Symbol","DrizzleSymbol","extendDrizzleTable","columns","extraConfig","table","InlineForeignKeys","Object","getOwnPropertySymbols","find","symbol","description","includes","name","columnBuilder","entries","column","build","push","buildForeignKeys","Columns","ExtraConfigColumns","buildExtraConfigColumn","originalExtraConfigBuilder","ExtraConfigBuilder","t"],"mappings":"AAAA;;;;;CAKC;;;AAGD,SAASA,KAAK,QAAQ,cAAa;AACnC,SAASC,QAAQ,QAAQ,UAAS;;;AAElC,MAAM,EAAEC,QAAQC,aAAa,EAAE,mTAAGH,QAAAA;AAiB3B,MAAMI,qBAAqB,CAAC,EAAEC,OAAO,EAAEC,WAAW,EAAEC,KAAK,EAAQ;IACtE,MAAMC,oBAAoBC,OAAOC,qBAAqB,CAACH,OAAOI,IAAI,CAAC,CAACC;QAClE,OAAOA,OAAOC,WAAW,EAAEC,SAAS;IACtC;IAEA,IAAI,CAACN,mBAAmB;QACtB,MAAM,gXAAIP,WAAAA,CAAS,CAAC,2CAA2C,CAAC,EAAE;IACpE;IAEA,IAAII,SAAS;QACX,KAAK,MAAM,CAACU,MAAMC,cAAc,IAAIP,OAAOQ,OAAO,CAACZ,SAA6B;YAC9E,MAAMa,SAASF,cAAcG,KAAK,CAACZ;YAEnCA,KAAK,CAACQ,KAAK,GAAGG;YACdX,KAAK,CAACC,kBAAkB,CAACY,IAAI,IAAIJ,cAAcK,gBAAgB,CAACH,QAAQX;YACxEA,KAAK,CAACJ,cAAcmB,OAAO,CAAC,CAACP,KAAK,GAAGG;YAErCX,KAAK,CAACJ,cAAcoB,kBAAkB,CAAC,CAACR,KAAK,GAC3C,4BAA4BC,gBACxBA,cAAcQ,sBAAsB,CAACjB,SACrCW;QACR;IACF;IAEA,IAAIZ,aAAa;QACf,MAAMmB,6BAA6BlB,KAAK,CAACJ,cAAcuB,kBAAkB,CAAC;QAE1EnB,KAAK,CAACJ,cAAcuB,kBAAkB,CAAC,GAAG,CAACC;YACzC,OAAO;gBACL,GAAGF,2BAA2BE,EAAE;gBAChC,GAAGrB,YAAYqB,EAAE;YACnB;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8073, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8079, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/executeSchemaHooks.ts"],"sourcesContent":["import type { DrizzleAdapter } from '../types.js'\n\nimport { extendDrizzleTable } from './extendDrizzleTable.js'\n\ntype DatabaseSchema = {\n  enums?: DrizzleAdapter['enums']\n  relations: Record<string, any>\n  tables: DrizzleAdapter['tables']\n}\n\ntype Adapter = {\n  afterSchemaInit: DatabaseSchemaHook[]\n  beforeSchemaInit: DatabaseSchemaHook[]\n} & DatabaseSchema\n\ntype DatabaseSchemaHookArgs = {\n  adapter: Record<string, unknown>\n  extendTable: typeof extendDrizzleTable\n  schema: DatabaseSchema\n}\n\ntype DatabaseSchemaHook = (args: DatabaseSchemaHookArgs) => DatabaseSchema | Promise<DatabaseSchema>\n\ntype Args = {\n  adapter: Adapter\n  type: 'afterSchemaInit' | 'beforeSchemaInit'\n}\n\nexport const executeSchemaHooks = async ({ type, adapter }: Args): Promise<void> => {\n  for (const hook of (adapter as unknown as Adapter)[type]) {\n    const result = await hook({\n      adapter: adapter as unknown as Adapter,\n      extendTable: extendDrizzleTable,\n      schema: {\n        enums: adapter.enums,\n        relations: adapter.relations,\n        tables: adapter.tables,\n      },\n    })\n    if (result.enums) {\n      adapter.enums = result.enums\n    }\n\n    adapter.tables = result.tables\n    adapter.relations = result.relations\n  }\n}\n"],"names":["extendDrizzleTable","executeSchemaHooks","type","adapter","hook","result","extendTable","schema","enums","relations","tables"],"mappings":";;;AAEA,SAASA,kBAAkB,QAAQ,0BAAyB;;AA0BrD,MAAMC,qBAAqB,OAAO,EAAEC,IAAI,EAAEC,OAAO,EAAQ;IAC9D,KAAK,MAAMC,QAASD,OAA8B,CAACD,KAAK,CAAE;QACxD,MAAMG,SAAS,MAAMD,KAAK;YACxBD,SAASA;YACTG,mZAAaN,qBAAAA;YACbO,QAAQ;gBACNC,OAAOL,QAAQK,KAAK;gBACpBC,WAAWN,QAAQM,SAAS;gBAC5BC,QAAQP,QAAQO,MAAM;YACxB;QACF;QACA,IAAIL,OAAOG,KAAK,EAAE;YAChBL,QAAQK,KAAK,GAAGH,OAAOG,KAAK;QAC9B;QAEAL,QAAQO,MAAM,GAAGL,OAAOK,MAAM;QAC9BP,QAAQM,SAAS,GAAGJ,OAAOI,SAAS;IACtC;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8102, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8108, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/utilities/pushDevSchema.ts"],"sourcesContent":["import { deepStrictEqual } from 'assert'\nimport prompts from 'prompts'\n\nimport type { BasePostgresAdapter } from '../postgres/types.js'\nimport type { DrizzleAdapter, PostgresDB, RawTable } from '../types.js'\n\nconst previousSchema: {\n  localeCodes: null | string[]\n  rawTables: null | Record<string, RawTable>\n} = {\n  localeCodes: null,\n  rawTables: null,\n}\n\n/**\n * Pushes the development schema to the database using Drizzle.\n *\n * @param {DrizzleAdapter} adapter - The PostgresAdapter instance connected to the database.\n * @returns {Promise<void>} - A promise that resolves once the schema push is complete.\n */\nexport const pushDevSchema = async (adapter: DrizzleAdapter) => {\n  if (process.env.PAYLOAD_FORCE_DRIZZLE_PUSH !== 'true') {\n    const localeCodes =\n      adapter.payload.config.localization && adapter.payload.config.localization.localeCodes\n\n    try {\n      deepStrictEqual(previousSchema, {\n        localeCodes,\n        rawTables: adapter.rawTables,\n      })\n\n      if (adapter.logger) {\n        adapter.payload.logger.info('No changes detected in schema, skipping schema push.')\n      }\n\n      return\n    } catch {\n      previousSchema.localeCodes = localeCodes\n      previousSchema.rawTables = adapter.rawTables\n    }\n  }\n\n  const { pushSchema } = adapter.requireDrizzleKit()\n\n  const { extensions = {}, tablesFilter } = adapter as BasePostgresAdapter\n\n  // This will prompt if clarifications are needed for Drizzle to push new schema\n  const { apply, hasDataLoss, warnings } = await pushSchema(\n    adapter.schema,\n    adapter.drizzle,\n    adapter.schemaName ? [adapter.schemaName] : undefined,\n    tablesFilter,\n    // Drizzle extensionsFilter supports only postgis for now\n    // https://github.com/drizzle-team/drizzle-orm/blob/83daf2d5cf023112de878bc2249ee2c41a2a5b1b/drizzle-kit/src/cli/validations/cli.ts#L26\n    extensions.postgis ? ['postgis'] : undefined,\n  )\n\n  if (warnings.length) {\n    let message = `Warnings detected during schema push: \\n\\n${warnings.join('\\n')}\\n\\n`\n\n    if (hasDataLoss) {\n      message += `DATA LOSS WARNING: Possible data loss detected if schema is pushed.\\n\\n`\n    }\n\n    message += `Accept warnings and push schema to database?`\n\n    const { confirm: acceptWarnings } = await prompts(\n      {\n        name: 'confirm',\n        type: 'confirm',\n        initial: false,\n        message,\n      },\n      {\n        onCancel: () => {\n          process.exit(0)\n        },\n      },\n    )\n\n    // Exit if user does not accept warnings.\n    // Q: Is this the right type of exit for this interaction?\n    if (!acceptWarnings) {\n      process.exit(0)\n    }\n  }\n\n  await apply()\n  const migrationsTable = adapter.schemaName\n    ? `\"${adapter.schemaName}\".\"payload_migrations\"`\n    : '\"payload_migrations\"'\n\n  const drizzle = adapter.drizzle as PostgresDB\n\n  const result = await adapter.execute({\n    drizzle,\n    raw: `SELECT * FROM ${migrationsTable} WHERE batch = '-1'`,\n  })\n\n  const devPush = result.rows\n\n  if (!devPush.length) {\n    // Use drizzle for insert so $defaultFn's are called\n    await drizzle.insert(adapter.tables.payload_migrations).values({\n      name: 'dev',\n      batch: -1,\n    })\n  } else {\n    await adapter.execute({\n      drizzle,\n      raw: `UPDATE ${migrationsTable} SET updated_at = CURRENT_TIMESTAMP WHERE batch = '-1'`,\n    })\n  }\n}\n"],"names":["deepStrictEqual","prompts","previousSchema","localeCodes","rawTables","pushDevSchema","adapter","process","env","PAYLOAD_FORCE_DRIZZLE_PUSH","payload","config","localization","logger","info","pushSchema","requireDrizzleKit","extensions","tablesFilter","apply","hasDataLoss","warnings","schema","drizzle","schemaName","undefined","postgis","length","message","join","confirm","acceptWarnings","name","type","initial","onCancel","exit","migrationsTable","result","execute","raw","devPush","rows","insert","tables","payload_migrations","values","batch"],"mappings":";;;AAAA,SAASA,eAAe,QAAQ,SAAQ;AACxC,OAAOC,aAAa,UAAS;;;AAK7B,MAAMC,iBAGF;IACFC,aAAa;IACbC,WAAW;AACb;AAQO,MAAMC,gBAAgB,OAAOC;IAClC,IAAIC,QAAQC,GAAG,CAACC,0BAA0B,KAAK,QAAQ;QACrD,MAAMN,cACJG,QAAQI,OAAO,CAACC,MAAM,CAACC,YAAY,IAAIN,QAAQI,OAAO,CAACC,MAAM,CAACC,YAAY,CAACT,WAAW;QAExF,IAAI;sHACFH,kBAAAA,EAAgBE,gBAAgB;gBAC9BC;gBACAC,WAAWE,QAAQF,SAAS;YAC9B;YAEA,IAAIE,QAAQO,MAAM,EAAE;gBAClBP,QAAQI,OAAO,CAACG,MAAM,CAACC,IAAI,CAAC;YAC9B;YAEA;QACF,EAAE,OAAM;YACNZ,eAAeC,WAAW,GAAGA;YAC7BD,eAAeE,SAAS,GAAGE,QAAQF,SAAS;QAC9C;IACF;IAEA,MAAM,EAAEW,UAAU,EAAE,GAAGT,QAAQU,iBAAiB;IAEhD,MAAM,EAAEC,aAAa,CAAC,CAAC,EAAEC,YAAY,EAAE,GAAGZ;IAE1C,+EAA+E;IAC/E,MAAM,EAAEa,KAAK,EAAEC,WAAW,EAAEC,QAAQ,EAAE,GAAG,MAAMN,WAC7CT,QAAQgB,MAAM,EACdhB,QAAQiB,OAAO,EACfjB,QAAQkB,UAAU,GAAG;QAAClB,QAAQkB,UAAU;KAAC,GAAGC,WAC5CP,cACA,AACA,yDADyD,8EAC8E;IACvID,WAAWS,OAAO,GAAG;QAAC;KAAU,GAAGD;IAGrC,IAAIJ,SAASM,MAAM,EAAE;QACnB,IAAIC,UAAU,CAAC,0CAA0C,EAAEP,SAASQ,IAAI,CAAC,MAAM,IAAI,CAAC;QAEpF,IAAIT,aAAa;YACfQ,WAAW,CAAC,uEAAuE,CAAC;QACtF;QAEAA,WAAW,CAAC,4CAA4C,CAAC;QAEzD,MAAM,EAAEE,SAASC,cAAc,EAAE,GAAG,+LAAM9B,UAAAA,EACxC;YACE+B,MAAM;YACNC,MAAM;YACNC,SAAS;YACTN;QACF,GACA;YACEO,UAAU;gBACR5B,QAAQ6B,IAAI,CAAC;YACf;QACF;QAGF,yCAAyC;QACzC,0DAA0D;QAC1D,IAAI,CAACL,gBAAgB;YACnBxB,QAAQ6B,IAAI,CAAC;QACf;IACF;IAEA,MAAMjB;IACN,MAAMkB,kBAAkB/B,QAAQkB,UAAU,GACtC,CAAC,CAAC,EAAElB,QAAQkB,UAAU,CAAC,sBAAsB,CAAC,GAC9C;IAEJ,MAAMD,UAAUjB,QAAQiB,OAAO;IAE/B,MAAMe,SAAS,MAAMhC,QAAQiC,OAAO,CAAC;QACnChB;QACAiB,KAAK,CAAC,cAAc,EAAEH,gBAAgB,mBAAmB,CAAC;IAC5D;IAEA,MAAMI,UAAUH,OAAOI,IAAI;IAE3B,IAAI,CAACD,QAAQd,MAAM,EAAE;QACnB,oDAAoD;QACpD,MAAMJ,QAAQoB,MAAM,CAACrC,QAAQsC,MAAM,CAACC,kBAAkB,EAAEC,MAAM,CAAC;YAC7Dd,MAAM;YACNe,OAAO,CAAC;QACV;IACF,OAAO;QACL,MAAMzC,QAAQiC,OAAO,CAAC;YACpBhB;YACAiB,KAAK,CAAC,OAAO,EAAEH,gBAAgB,sDAAsD,CAAC;QACxF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8188, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8194, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/index.ts"],"sourcesContent":["export { count } from './count.js'\nexport { countGlobalVersions } from './countGlobalVersions.js'\nexport { countVersions } from './countVersions.js'\nexport { create } from './create.js'\nexport { createGlobal } from './createGlobal.js'\nexport { createGlobalVersion } from './createGlobalVersion.js'\nexport { createTableName } from './createTableName.js'\nexport { createVersion } from './createVersion.js'\nexport { deleteMany } from './deleteMany.js'\nexport { deleteOne } from './deleteOne.js'\nexport { deleteVersions } from './deleteVersions.js'\nexport { destroy } from './destroy.js'\nexport { find } from './find.js'\nexport { chainMethods } from './find/chainMethods.js'\nexport { findGlobal } from './findGlobal.js'\nexport { findGlobalVersions } from './findGlobalVersions.js'\nexport { findMigrationDir } from './findMigrationDir.js'\nexport { findOne } from './findOne.js'\nexport { findVersions } from './findVersions.js'\nexport { migrate } from './migrate.js'\nexport { migrateDown } from './migrateDown.js'\nexport { migrateFresh } from './migrateFresh.js'\nexport { migrateRefresh } from './migrateRefresh.js'\nexport { migrateReset } from './migrateReset.js'\nexport { migrateStatus } from './migrateStatus.js'\nexport { operatorMap } from './queries/operatorMap.js'\nexport type { Operators } from './queries/operatorMap.js'\nexport { queryDrafts } from './queryDrafts.js'\nexport { buildDrizzleRelations } from './schema/buildDrizzleRelations.js'\nexport { buildRawSchema } from './schema/buildRawSchema.js'\nexport { beginTransaction } from './transactions/beginTransaction.js'\nexport { commitTransaction } from './transactions/commitTransaction.js'\nexport { rollbackTransaction } from './transactions/rollbackTransaction.js'\nexport { updateOne } from './update.js'\nexport { updateGlobal } from './updateGlobal.js'\nexport { updateGlobalVersion } from './updateGlobalVersion.js'\nexport { updateVersion } from './updateVersion.js'\nexport { upsertRow } from './upsertRow/index.js'\nexport { buildCreateMigration } from './utilities/buildCreateMigration.js'\nexport { buildIndexName } from './utilities/buildIndexName.js'\nexport { createSchemaGenerator } from './utilities/createSchemaGenerator.js'\nexport { executeSchemaHooks } from './utilities/executeSchemaHooks.js'\nexport { extendDrizzleTable } from './utilities/extendDrizzleTable.js'\nexport { hasLocalesTable } from './utilities/hasLocalesTable.js'\nexport { pushDevSchema } from './utilities/pushDevSchema.js'\nexport { validateExistingBlockIsIdentical } from './utilities/validateExistingBlockIsIdentical.js'\n"],"names":["count","countGlobalVersions","countVersions","create","createGlobal","createGlobalVersion","createTableName","createVersion","deleteMany","deleteOne","deleteVersions","destroy","find","chainMethods","findGlobal","findGlobalVersions","findMigrationDir","findOne","findVersions","migrate","migrateDown","migrateFresh","migrateRefresh","migrateReset","migrateStatus","operatorMap","queryDrafts","buildDrizzleRelations","buildRawSchema","beginTransaction","commitTransaction","rollbackTransaction","updateOne","updateGlobal","updateGlobalVersion","updateVersion","upsertRow","buildCreateMigration","buildIndexName","createSchemaGenerator","executeSchemaHooks","extendDrizzleTable","hasLocalesTable","pushDevSchema","validateExistingBlockIsIdentical"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 8241, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8300, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/columnToCodeConverter.ts"],"sourcesContent":["import type { ColumnToCodeConverter } from '../types.js'\nexport const columnToCodeConverter: ColumnToCodeConverter = ({\n  adapter,\n  addEnum,\n  addImport,\n  column,\n  tableKey,\n}) => {\n  let columnBuilderFn: string = column.type\n\n  if (column.type === 'geometry') {\n    columnBuilderFn = 'geometryColumn'\n    addImport(adapter.packageName, columnBuilderFn)\n  } else if (column.type === 'enum') {\n    if ('locale' in column) {\n      columnBuilderFn = `enum__locales`\n    } else {\n      addEnum(column.enumName, column.options)\n      columnBuilderFn = column.enumName\n    }\n  } else {\n    addImport(`${adapter.packageName}/drizzle/pg-core`, columnBuilderFn)\n  }\n\n  const columnBuilderArgsArray: string[] = []\n\n  if (column.type === 'timestamp') {\n    columnBuilderArgsArray.push(`mode: '${column.mode}'`)\n    if (column.withTimezone) {\n      columnBuilderArgsArray.push('withTimezone: true')\n    }\n\n    if (typeof column.precision === 'number') {\n      columnBuilderArgsArray.push(`precision: ${column.precision}`)\n    }\n  }\n\n  let columnBuilderArgs = ''\n\n  if (columnBuilderArgsArray.length) {\n    columnBuilderArgs = `, {${columnBuilderArgsArray.join(',')}}`\n  }\n\n  let code = `${columnBuilderFn}('${column.name}'${columnBuilderArgs})`\n\n  if (column.type === 'timestamp' && column.defaultNow) {\n    code = `${code}.defaultNow()`\n  }\n\n  if (column.type === 'uuid' && column.defaultRandom) {\n    code = `${code}.defaultRandom()`\n  }\n\n  if (column.notNull) {\n    code = `${code}.notNull()`\n  }\n\n  if (column.primaryKey) {\n    code = `${code}.primaryKey()`\n  }\n\n  if (typeof column.default !== 'undefined') {\n    let sanitizedDefault = column.default\n\n    if (column.type === 'geometry') {\n      sanitizedDefault = `sql\\`${column.default}\\``\n    } else if (column.type === 'jsonb') {\n      sanitizedDefault = `sql\\`'${JSON.stringify(column.default)}'::jsonb\\``\n    } else if (column.type === 'numeric') {\n      sanitizedDefault = `'${column.default}'`\n    } else if (typeof column.default === 'string') {\n      sanitizedDefault = `${JSON.stringify(column.default)}`\n    }\n\n    code = `${code}.default(${sanitizedDefault})`\n  }\n\n  if (column.reference) {\n    let callback = `()`\n\n    if (column.reference.table === tableKey) {\n      addImport(`${adapter.packageName}/drizzle/pg-core`, 'type AnyPgColumn')\n      callback = `${callback}: AnyPgColumn`\n    }\n\n    callback = `${callback} => ${column.reference.table}.${column.reference.name}`\n\n    code = `${code}.references(${callback}, {\n      ${column.reference.onDelete ? `onDelete: '${column.reference.onDelete}'` : ''}\n  })`\n  }\n\n  return code\n}\n"],"names":["columnToCodeConverter","adapter","addEnum","addImport","column","tableKey","columnBuilderFn","type","packageName","enumName","options","columnBuilderArgsArray","push","mode","withTimezone","precision","columnBuilderArgs","length","join","code","name","defaultNow","defaultRandom","notNull","primaryKey","default","sanitizedDefault","JSON","stringify","reference","callback","table","onDelete"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8371, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8377, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/countDistinct.ts"],"sourcesContent":["import { count, sql } from 'drizzle-orm'\n\nimport type { ChainedMethods, TransactionPg } from '../types.js'\nimport type { BasePostgresAdapter, CountDistinct } from './types.js'\n\nimport { chainMethods } from '../find/chainMethods.js'\n\nexport const countDistinct: CountDistinct = async function countDistinct(\n  this: BasePostgresAdapter,\n  { db, joins, tableName, where },\n) {\n  const chainedMethods: ChainedMethods = []\n\n  // COUNT(DISTINCT id)  is slow on large tables, so we only use DISTINCT if we have to\n  const visitedPaths = new Set([])\n  let useDistinct = false\n  joins.forEach(({ condition, queryPath, table }) => {\n    if (!useDistinct && queryPath) {\n      if (visitedPaths.has(queryPath)) {\n        useDistinct = true\n      } else {\n        visitedPaths.add(queryPath)\n      }\n    }\n    chainedMethods.push({\n      args: [table, condition],\n      method: 'leftJoin',\n    })\n  })\n\n  const countResult = await chainMethods({\n    methods: chainedMethods,\n    query: (db as TransactionPg)\n      .select({\n        count: useDistinct ? sql`COUNT(DISTINCT ${this.tables[tableName].id})` : count(),\n      })\n      .from(this.tables[tableName])\n      .where(where),\n  })\n\n  return Number(countResult[0].count)\n}\n"],"names":["count","sql","chainMethods","countDistinct","db","joins","tableName","where","chainedMethods","visitedPaths","Set","useDistinct","forEach","condition","queryPath","table","has","add","push","args","method","countResult","methods","query","select","tables","id","from","Number"],"mappings":";;;AAKA,SAASE,YAAY,QAAQ,0BAAyB;AALtD,SAASF,KAAK,EAAEC,GAAG,QAAQ,cAAa;;;;AAOjC,MAAME,gBAA+B,eAAeA,cAEzD,EAAEC,EAAE,EAAEC,KAAK,EAAEC,SAAS,EAAEC,KAAK,EAAE;IAE/B,MAAMC,iBAAiC,EAAE;IAEzC,qFAAqF;IACrF,MAAMC,eAAe,IAAIC,IAAI,EAAE;IAC/B,IAAIC,cAAc;IAClBN,MAAMO,OAAO,CAAC,CAAC,EAAEC,SAAS,EAAEC,SAAS,EAAEC,KAAK,EAAE;QAC5C,IAAI,CAACJ,eAAeG,WAAW;YAC7B,IAAIL,aAAaO,GAAG,CAACF,YAAY;gBAC/BH,cAAc;YAChB,OAAO;gBACLF,aAAaQ,GAAG,CAACH;YACnB;QACF;QACAN,eAAeU,IAAI,CAAC;YAClBC,MAAM;gBAACJ;gBAAOF;aAAU;YACxBO,QAAQ;QACV;IACF;IAEA,MAAMC,cAAc,MAAMnB,8YAAAA,EAAa;QACrCoB,SAASd;QACTe,OAAQnB,GACLoB,MAAM,CAAC;YACNxB,OAAOW,kUAAcV,OAAG,CAAC,eAAe,EAAE,IAAI,CAACwB,MAAM,CAACnB,UAAU,CAACoB,EAAE,CAAC,CAAC,CAAC,+UAAG1B,QAAAA;QAC3E,GACC2B,IAAI,CAAC,IAAI,CAACF,MAAM,CAACnB,UAAU,EAC3BC,KAAK,CAACA;IACX;IAEA,OAAOqB,OAAOP,WAAW,CAAC,EAAE,CAACrB,KAAK;AACpC,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8414, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8420, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/createDatabase.ts"],"sourcesContent":["import type { ClientConfig } from 'pg'\n\nimport type { BasePostgresAdapter } from './types.js'\n\nconst setConnectionStringDatabase = ({\n  connectionString,\n  database,\n}: {\n  connectionString: string\n  database: string\n}): string => {\n  const connectionURL = new URL(connectionString)\n  const newConnectionURL = new URL(connectionURL)\n  newConnectionURL.pathname = `/${database}`\n\n  return newConnectionURL.toString()\n}\n\ntype Args = {\n  /**\n   * Name of a database, defaults to the current one\n   */\n  name?: string\n  /**\n   * Schema to create in addition to 'public'. Defaults to adapter.schemaName if exists.\n   */\n  schemaName?: string\n}\nexport const createDatabase = async function (this: BasePostgresAdapter, args: Args = {}) {\n  // POSTGRES_URL - default Vercel env\n  const connectionString =\n    this.poolOptions?.connectionString ?? process.env.POSTGRES_URL ?? process.env.DATABASE_URL\n  let managementClientConfig: ClientConfig = {}\n  let dbName = args.name\n  const schemaName = this.schemaName || 'public'\n\n  if (connectionString) {\n    if (!dbName) {\n      dbName = new URL(connectionString).pathname.slice(1)\n    }\n\n    managementClientConfig.connectionString = setConnectionStringDatabase({\n      connectionString,\n      database: 'postgres',\n    })\n  } else {\n    if (!dbName) {\n      dbName = this.poolOptions.database\n    }\n\n    managementClientConfig = {\n      ...this.poolOptions,\n      database: 'postgres',\n    }\n  }\n\n  // import pg only when createDatabase is used\n  const pg = await import('pg').then((mod) => mod.default)\n\n  const managementClient = new pg.Client(managementClientConfig)\n\n  try {\n    await managementClient.connect()\n    await managementClient.query(`CREATE DATABASE \"${dbName}\"`)\n\n    this.payload.logger.info(`Created database \"${dbName}\"`)\n\n    if (schemaName !== 'public') {\n      let createdDatabaseConfig: ClientConfig = {}\n\n      if (connectionString) {\n        createdDatabaseConfig.connectionString = setConnectionStringDatabase({\n          connectionString,\n          database: dbName,\n        })\n      } else {\n        createdDatabaseConfig = {\n          ...this.poolOptions,\n          database: dbName,\n        }\n      }\n\n      const createdDatabaseClient = new pg.Client(createdDatabaseConfig)\n\n      try {\n        await createdDatabaseClient.connect()\n\n        await createdDatabaseClient.query(`CREATE SCHEMA ${schemaName}`)\n        this.payload.logger.info(`Created schema \"${dbName}.${schemaName}\"`)\n      } catch (err) {\n        this.payload.logger.error({\n          err,\n          msg: `Error: failed to create schema \"${dbName}.${schemaName}\". Details: ${err.message}`,\n        })\n      } finally {\n        await createdDatabaseClient.end()\n      }\n    }\n\n    return true\n  } catch (err) {\n    this.payload.logger.error({\n      err,\n      msg: `Error: failed to create database ${dbName}. Details: ${err.message}`,\n    })\n\n    return false\n  } finally {\n    await managementClient.end()\n  }\n}\n"],"names":["setConnectionStringDatabase","connectionString","database","connectionURL","URL","newConnectionURL","pathname","toString","createDatabase","args","poolOptions","process","env","POSTGRES_URL","DATABASE_URL","managementClientConfig","dbName","name","schemaName","slice","pg","then","mod","default","managementClient","Client","connect","query","payload","logger","info","createdDatabaseConfig","createdDatabaseClient","err","error","msg","message","end"],"mappings":";;;AAIA,MAAMA,8BAA8B,CAAC,EACnCC,gBAAgB,EAChBC,QAAQ,EAIT;IACC,MAAMC,gBAAgB,IAAIC,IAAIH;IAC9B,MAAMI,mBAAmB,IAAID,IAAID;IACjCE,iBAAiBC,QAAQ,GAAG,CAAC,CAAC,EAAEJ,UAAU;IAE1C,OAAOG,iBAAiBE,QAAQ;AAClC;AAYO,MAAMC,iBAAiB,eAA2CC,OAAa,CAAC,CAAC;IACtF,oCAAoC;IACpC,MAAMR,mBACJ,IAAI,CAACS,WAAW,EAAET,oBAAoBU,QAAQC,GAAG,CAACC,YAAY,IAAIF,QAAQC,GAAG,CAACE,YAAY;IAC5F,IAAIC,yBAAuC,CAAC;IAC5C,IAAIC,SAASP,KAAKQ,IAAI;IACtB,MAAMC,aAAa,IAAI,CAACA,UAAU,IAAI;IAEtC,IAAIjB,kBAAkB;QACpB,IAAI,CAACe,QAAQ;YACXA,SAAS,IAAIZ,IAAIH,kBAAkBK,QAAQ,CAACa,KAAK,CAAC;QACpD;QAEAJ,uBAAuBd,gBAAgB,GAAGD,4BAA4B;YACpEC;YACAC,UAAU;QACZ;IACF,OAAO;QACL,IAAI,CAACc,QAAQ;YACXA,SAAS,IAAI,CAACN,WAAW,CAACR,QAAQ;QACpC;QAEAa,yBAAyB;YACvB,GAAG,IAAI,CAACL,WAAW;YACnBR,UAAU;QACZ;IACF;IAEA,6CAA6C;IAC7C,MAAMkB,KAAK,MAAM,MAAM,CAAC,iJAAMC,IAAI,CAAC,CAACC,MAAQA,IAAIC,OAAO;IAEvD,MAAMC,mBAAmB,IAAIJ,GAAGK,MAAM,CAACV;IAEvC,IAAI;QACF,MAAMS,iBAAiBE,OAAO;QAC9B,MAAMF,iBAAiBG,KAAK,CAAC,CAAC,iBAAiB,EAAEX,OAAO,CAAC,CAAC;QAE1D,IAAI,CAACY,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,kBAAkB,EAAEd,OAAO,CAAC,CAAC;QAEvD,IAAIE,eAAe,UAAU;YAC3B,IAAIa,wBAAsC,CAAC;YAE3C,IAAI9B,kBAAkB;gBACpB8B,sBAAsB9B,gBAAgB,GAAGD,4BAA4B;oBACnEC;oBACAC,UAAUc;gBACZ;YACF,OAAO;gBACLe,wBAAwB;oBACtB,GAAG,IAAI,CAACrB,WAAW;oBACnBR,UAAUc;gBACZ;YACF;YAEA,MAAMgB,wBAAwB,IAAIZ,GAAGK,MAAM,CAACM;YAE5C,IAAI;gBACF,MAAMC,sBAAsBN,OAAO;gBAEnC,MAAMM,sBAAsBL,KAAK,CAAC,CAAC,cAAc,EAAET,YAAY;gBAC/D,IAAI,CAACU,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,gBAAgB,EAAEd,OAAO,CAAC,EAAEE,WAAW,CAAC,CAAC;YACrE,EAAE,OAAOe,KAAK;gBACZ,IAAI,CAACL,OAAO,CAACC,MAAM,CAACK,KAAK,CAAC;oBACxBD;oBACAE,KAAK,CAAC,gCAAgC,EAAEnB,OAAO,CAAC,EAAEE,WAAW,YAAY,EAAEe,IAAIG,OAAO,EAAE;gBAC1F;YACF,SAAU;gBACR,MAAMJ,sBAAsBK,GAAG;YACjC;QACF;QAEA,OAAO;IACT,EAAE,OAAOJ,KAAK;QACZ,IAAI,CAACL,OAAO,CAACC,MAAM,CAACK,KAAK,CAAC;YACxBD;YACAE,KAAK,CAAC,iCAAiC,EAAEnB,OAAO,WAAW,EAAEiB,IAAIG,OAAO,EAAE;QAC5E;QAEA,OAAO;IACT,SAAU;QACR,MAAMZ,iBAAiBa,GAAG;IAC5B;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8497, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8503, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/createExtensions.ts"],"sourcesContent":["import type { BasePostgresAdapter } from './types.js'\n\nexport const createExtensions = async function (this: BasePostgresAdapter): Promise<void> {\n  for (const extension in this.extensions) {\n    if (this.extensions[extension]) {\n      try {\n        await this.drizzle.execute(`CREATE EXTENSION IF NOT EXISTS \"${extension}\"`)\n      } catch (err) {\n        this.payload.logger.error({ err, msg: `Failed to create extension ${extension}` })\n      }\n    }\n  }\n}\n"],"names":["createExtensions","extension","extensions","drizzle","execute","err","payload","logger","error","msg"],"mappings":";;;AAEO,MAAMA,mBAAmB;IAC9B,IAAK,MAAMC,aAAa,IAAI,CAACC,UAAU,CAAE;QACvC,IAAI,IAAI,CAACA,UAAU,CAACD,UAAU,EAAE;YAC9B,IAAI;gBACF,MAAM,IAAI,CAACE,OAAO,CAACC,OAAO,CAAC,CAAC,gCAAgC,EAAEH,UAAU,CAAC,CAAC;YAC5E,EAAE,OAAOI,KAAK;gBACZ,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,KAAK,CAAC;oBAAEH;oBAAKI,KAAK,CAAC,2BAA2B,EAAER,WAAW;gBAAC;YAClF;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8520, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8526, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/createJSONQuery/index.ts"],"sourcesContent":["import type { CreateJSONQueryArgs } from '../../types.js'\n\nconst operatorMap: Record<string, string> = {\n  contains: '~',\n  equals: '==',\n  in: 'in',\n  like: 'like_regex',\n  not_equals: '!=',\n  not_in: 'in',\n}\n\nconst sanitizeValue = (value: unknown, operator?: string) => {\n  if (typeof value === 'string') {\n    // ignore casing with like\n    return `\"${operator === 'like' ? '(?i)' : ''}${value}\"`\n  }\n\n  return value as string\n}\n\nexport const createJSONQuery = ({ column, operator, pathSegments, value }: CreateJSONQueryArgs) => {\n  const columnName = typeof column === 'object' ? column.name : column\n  const jsonPaths = pathSegments\n    .slice(1)\n    .map((key) => {\n      return `${key}[*]`\n    })\n    .join('.')\n\n  let sql = ''\n\n  if (['in', 'not_in'].includes(operator) && Array.isArray(value)) {\n    value.forEach((item, i) => {\n      sql = `${sql}${createJSONQuery({ column, operator: operator === 'in' ? 'equals' : 'not_equals', pathSegments, value: item })}${i === value.length - 1 ? '' : ` ${operator === 'in' ? 'OR' : 'AND'} `}`\n    })\n  } else if (operator === 'exists') {\n    sql = `${value === false ? 'NOT ' : ''}jsonb_path_exists(${columnName}, '$.${jsonPaths}')`\n  } else {\n    sql = `jsonb_path_exists(${columnName}, '$.${jsonPaths} ? (@ ${operatorMap[operator]} ${sanitizeValue(value, operator)})')`\n  }\n\n  return sql\n}\n"],"names":["operatorMap","contains","equals","in","like","not_equals","not_in","sanitizeValue","value","operator","createJSONQuery","column","pathSegments","columnName","name","jsonPaths","slice","map","key","join","sql","includes","Array","isArray","forEach","item","i","length"],"mappings":";;;AAEA,MAAMA,cAAsC;IAC1CC,UAAU;IACVC,QAAQ;IACRC,IAAI;IACJC,MAAM;IACNC,YAAY;IACZC,QAAQ;AACV;AAEA,MAAMC,gBAAgB,CAACC,OAAgBC;IACrC,IAAI,OAAOD,UAAU,UAAU;QAC7B,0BAA0B;QAC1B,OAAO,CAAC,CAAC,EAAEC,aAAa,SAAS,SAAS,KAAKD,MAAM,CAAC,CAAC;IACzD;IAEA,OAAOA;AACT;AAEO,MAAME,kBAAkB,CAAC,EAAEC,MAAM,EAAEF,QAAQ,EAAEG,YAAY,EAAEJ,KAAK,EAAuB;IAC5F,MAAMK,aAAa,OAAOF,WAAW,WAAWA,OAAOG,IAAI,GAAGH;IAC9D,MAAMI,YAAYH,aACfI,KAAK,CAAC,GACNC,GAAG,CAAC,CAACC;QACJ,OAAO,GAAGA,IAAI,GAAG,CAAC;IACpB,GACCC,IAAI,CAAC;IAER,IAAIC,MAAM;IAEV,IAAI;QAAC;QAAM;KAAS,CAACC,QAAQ,CAACZ,aAAaa,MAAMC,OAAO,CAACf,QAAQ;QAC/DA,MAAMgB,OAAO,CAAC,CAACC,MAAMC;YACnBN,MAAM,GAAGA,MAAMV,gBAAgB;gBAAEC;gBAAQF,UAAUA,aAAa,OAAO,WAAW;gBAAcG;gBAAcJ,OAAOiB;YAAK,KAAKC,MAAMlB,MAAMmB,MAAM,GAAG,IAAI,KAAK,CAAC,CAAC,EAAElB,aAAa,OAAO,OAAO,MAAM,CAAC,CAAC,EAAE;QACxM;IACF,OAAO,IAAIA,aAAa,UAAU;QAChCW,MAAM,GAAGZ,UAAU,QAAQ,SAAS,GAAG,kBAAkB,EAAEK,WAAW,KAAK,EAAEE,UAAU,EAAE,CAAC;IAC5F,OAAO;QACLK,MAAM,CAAC,kBAAkB,EAAEP,WAAW,KAAK,EAAEE,UAAU,MAAM,EAAEf,WAAW,CAACS,SAAS,CAAC,CAAC,EAAEF,cAAcC,OAAOC,UAAU,GAAG,CAAC;IAC7H;IAEA,OAAOW;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8569, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8575, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/defaultSnapshot.ts"],"sourcesContent":["import type { DrizzleSnapshotJSON } from 'drizzle-kit/api'\n\nexport const defaultDrizzleSnapshot: DrizzleSnapshotJSON = {\n  id: '00000000-0000-0000-0000-000000000000',\n  _meta: {\n    columns: {},\n    schemas: {},\n    tables: {},\n  },\n  dialect: 'postgresql',\n  enums: {},\n  policies: {},\n  prevId: '00000000-0000-0000-0000-00000000000',\n  roles: {},\n  schemas: {},\n  sequences: {},\n  tables: {},\n  version: '7',\n  views: {},\n}\n"],"names":["defaultDrizzleSnapshot","id","_meta","columns","schemas","tables","dialect","enums","policies","prevId","roles","sequences","version","views"],"mappings":";;;AAEO,MAAMA,yBAA8C;IACzDC,IAAI;IACJC,OAAO;QACLC,SAAS,CAAC;QACVC,SAAS,CAAC;QACVC,QAAQ,CAAC;IACX;IACAC,SAAS;IACTC,OAAO,CAAC;IACRC,UAAU,CAAC;IACXC,QAAQ;IACRC,OAAO,CAAC;IACRN,SAAS,CAAC;IACVO,WAAW,CAAC;IACZN,QAAQ,CAAC;IACTO,SAAS;IACTC,OAAO,CAAC;AACV,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8596, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8602, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/deleteWhere.ts"],"sourcesContent":["import type { TransactionPg } from '../types.js'\nimport type { DeleteWhere } from './types.js'\n\nexport const deleteWhere: DeleteWhere = async function deleteWhere({ db, tableName, where }) {\n  const table = this.tables[tableName]\n  await (db as TransactionPg).delete(table).where(where)\n}\n"],"names":["deleteWhere","db","tableName","where","table","tables","delete"],"mappings":";;;AAGO,MAAMA,cAA2B,eAAeA,YAAY,EAAEC,EAAE,EAAEC,SAAS,EAAEC,KAAK,EAAE;IACzF,MAAMC,QAAQ,IAAI,CAACC,MAAM,CAACH,UAAU;IACpC,MAAOD,GAAqBK,MAAM,CAACF,OAAOD,KAAK,CAACA;AAClD,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8609, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8615, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/dropDatabase.ts"],"sourcesContent":["import type { DropDatabase } from './types.js'\n\nexport const dropDatabase: DropDatabase = async function dropDatabase({ adapter }) {\n  await adapter.execute({\n    drizzle: adapter.drizzle,\n    raw: `drop schema if exists ${this.schemaName || 'public'} cascade;\n    create schema ${this.schemaName || 'public'};`,\n  })\n}\n"],"names":["dropDatabase","adapter","execute","drizzle","raw","schemaName"],"mappings":";;;AAEO,MAAMA,eAA6B,eAAeA,aAAa,EAAEC,OAAO,EAAE;IAC/E,MAAMA,QAAQC,OAAO,CAAC;QACpBC,SAASF,QAAQE,OAAO;QACxBC,KAAK,CAAC,sBAAsB,EAAE,IAAI,CAACC,UAAU,IAAI,SAAS;kBAC5C,EAAE,IAAI,CAACA,UAAU,IAAI,SAAS,CAAC,CAAC;IAChD;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8625, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8631, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/execute.ts"],"sourcesContent":["import { sql } from 'drizzle-orm'\n\nimport type { Execute } from './types.js'\n\nexport const execute: Execute<any> = function execute({ db, drizzle, raw, sql: statement }) {\n  const executeFrom = db ?? drizzle\n\n  if (raw) {\n    return executeFrom.execute(sql.raw(raw))\n  } else {\n    return executeFrom.execute(sql`${statement}`)\n  }\n}\n"],"names":["sql","execute","db","drizzle","raw","statement","executeFrom"],"mappings":";;;AAAA,SAASA,GAAG,QAAQ,cAAa;;AAI1B,MAAMC,UAAwB,SAASA,QAAQ,EAAEC,EAAE,EAAEC,OAAO,EAAEC,GAAG,EAAEJ,KAAKK,SAAS,EAAE;IACxF,MAAMC,cAAcJ,MAAMC;IAE1B,IAAIC,KAAK;QACP,OAAOE,YAAYL,OAAO,sTAACD,MAAAA,CAAII,GAAG,CAACA;IACrC,OAAO;QACL,OAAOE,YAAYL,OAAO,sTAACD,MAAG,CAAC,EAAEK,UAAU,CAAC;IAC9C;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8644, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8650, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/schema/geometryColumn.ts"],"sourcesContent":["// Uses custom one instead of geometry() from drizzle-orm/pg-core because it's broken on pushDevSchema\n// Why?\n// It tries to give us a prompt \"you're about to change.. from geometry(Point) to geometry(point)\"\nimport { customType } from 'drizzle-orm/pg-core'\nimport { parseEWKB } from 'drizzle-orm/pg-core/columns/postgis_extension/utils'\n\ntype Point = [number, number]\n\nexport const geometryColumn = (name: string) =>\n  customType<{ data: Point; driverData: string }>({\n    dataType() {\n      return `geometry(Point)`\n    },\n    fromDriver(value: string) {\n      return parseEWKB(value)\n    },\n    toDriver(value: Point) {\n      return `SRID=4326;point(${value[0]} ${value[1]})`\n    },\n  })(name)\n"],"names":["customType","parseEWKB","geometryColumn","name","dataType","fromDriver","value","toDriver"],"mappings":"AAAA,sGAAsG;AACtG,OAAO;AACP,kGAAkG;;;;AAClG,SAASA,UAAU,QAAQ,sBAAqB;AAChD,SAASC,SAAS,QAAQ,sDAAqD;;;AAIxE,MAAMC,iBAAiB,CAACC,qVAC7BH,aAAAA,EAAgD;QAC9CI;YACE,OAAO,CAAC,eAAe,CAAC;QAC1B;QACAC,YAAWC,KAAa;YACtB,yWAAOL,YAAAA,EAAUK;QACnB;QACAC,UAASD,KAAY;YACnB,OAAO,CAAC,gBAAgB,EAAEA,KAAK,CAAC,EAAE,CAAC,CAAC,EAAEA,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;QACnD;IACF,GAAGH,MAAK","ignoreList":[0]}},
    {"offset": {"line": 8671, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8677, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/schema/buildDrizzleTable.ts"],"sourcesContent":["import type { ForeignKeyBuilder, IndexBuilder } from 'drizzle-orm/pg-core'\n\nimport {\n  boolean,\n  foreignKey,\n  index,\n  integer,\n  jsonb,\n  numeric,\n  serial,\n  text,\n  timestamp,\n  uniqueIndex,\n  uuid,\n  varchar,\n} from 'drizzle-orm/pg-core'\n\nimport type { RawColumn, RawTable } from '../../types.js'\nimport type { BasePostgresAdapter } from '../types.js'\n\nimport { geometryColumn } from './geometryColumn.js'\n\nconst rawColumnBuilderMap: Partial<Record<RawColumn['type'], any>> = {\n  boolean,\n  geometry: geometryColumn,\n  integer,\n  jsonb,\n  numeric,\n  serial,\n  text,\n  uuid,\n  varchar,\n}\n\nexport const buildDrizzleTable = ({\n  adapter,\n  rawTable,\n}: {\n  adapter: BasePostgresAdapter\n  rawTable: RawTable\n}) => {\n  const columns: Record<string, any> = {}\n\n  for (const [key, column] of Object.entries(rawTable.columns)) {\n    switch (column.type) {\n      case 'enum':\n        if ('locale' in column) {\n          columns[key] = adapter.enums.enum__locales(column.name)\n        } else {\n          adapter.enums[column.enumName] = adapter.pgSchema.enum(\n            column.enumName,\n            column.options as [string, ...string[]],\n          )\n          columns[key] = adapter.enums[column.enumName](column.name)\n        }\n        break\n\n      case 'timestamp': {\n        let builder = timestamp(column.name, {\n          mode: column.mode,\n          precision: column.precision,\n          withTimezone: column.withTimezone,\n        })\n\n        if (column.defaultNow) {\n          builder = builder.defaultNow()\n        }\n\n        columns[key] = builder\n        break\n      }\n\n      case 'uuid': {\n        let builder = uuid(column.name)\n\n        if (column.defaultRandom) {\n          builder = builder.defaultRandom()\n        }\n\n        columns[key] = builder\n        break\n      }\n\n      default:\n        columns[key] = rawColumnBuilderMap[column.type](column.name)\n        break\n    }\n\n    if (column.reference) {\n      columns[key].references(() => adapter.tables[column.reference.table][column.reference.name], {\n        onDelete: column.reference.onDelete,\n      })\n    }\n\n    if (column.primaryKey) {\n      columns[key].primaryKey()\n    }\n\n    if (column.notNull) {\n      columns[key].notNull()\n    }\n\n    if (typeof column.default !== 'undefined') {\n      let sanitizedDefault = column.default\n\n      if (column.type === 'geometry' && Array.isArray(column.default)) {\n        sanitizedDefault = `SRID=4326;POINT(${column.default[0]} ${column.default[1]})`\n      }\n\n      columns[key].default(sanitizedDefault)\n    }\n\n    if (column.type === 'geometry') {\n      if (!adapter.extensions.postgis) {\n        adapter.extensions.postgis = true\n      }\n    }\n  }\n\n  const extraConfig = (cols: any) => {\n    const config: Record<string, ForeignKeyBuilder | IndexBuilder> = {}\n\n    if (rawTable.indexes) {\n      for (const [key, rawIndex] of Object.entries(rawTable.indexes)) {\n        let fn: any = index\n        if (rawIndex.unique) {\n          fn = uniqueIndex\n        }\n\n        if (Array.isArray(rawIndex.on)) {\n          if (rawIndex.on.length) {\n            config[key] = fn(rawIndex.name).on(...rawIndex.on.map((colName) => cols[colName]))\n          }\n        } else {\n          config[key] = fn(rawIndex.name).on(cols[rawIndex.on])\n        }\n      }\n    }\n\n    if (rawTable.foreignKeys) {\n      for (const [key, rawForeignKey] of Object.entries(rawTable.foreignKeys)) {\n        let builder = foreignKey({\n          name: rawForeignKey.name,\n          columns: rawForeignKey.columns.map((colName) => cols[colName]) as any,\n          foreignColumns: rawForeignKey.foreignColumns.map(\n            (column) => adapter.tables[column.table][column.name],\n          ),\n        })\n\n        if (rawForeignKey.onDelete) {\n          builder = builder.onDelete(rawForeignKey.onDelete)\n        }\n\n        if (rawForeignKey.onUpdate) {\n          builder = builder.onDelete(rawForeignKey.onUpdate)\n        }\n\n        config[key] = builder\n      }\n    }\n\n    return config\n  }\n\n  adapter.tables[rawTable.name] = adapter.pgSchema.table(\n    rawTable.name,\n    columns as any,\n    extraConfig as any,\n  )\n}\n"],"names":["boolean","foreignKey","index","integer","jsonb","numeric","serial","text","timestamp","uniqueIndex","uuid","varchar","geometryColumn","rawColumnBuilderMap","geometry","buildDrizzleTable","adapter","rawTable","columns","key","column","Object","entries","type","enums","enum__locales","name","enumName","pgSchema","enum","options","builder","mode","precision","withTimezone","defaultNow","defaultRandom","reference","references","tables","table","onDelete","primaryKey","notNull","default","sanitizedDefault","Array","isArray","extensions","postgis","extraConfig","cols","config","indexes","rawIndex","fn","unique","on","length","map","colName","foreignKeys","rawForeignKey","foreignColumns","onUpdate"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8804, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8810, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/schema/setColumnID.ts"],"sourcesContent":["import type { SetColumnID } from '../../types.js'\n\nexport const setColumnID: SetColumnID = ({ adapter, columns, fields }) => {\n  const idField = fields.find((field) => field.name === 'id')\n  if (idField) {\n    if (idField.type === 'number') {\n      columns.id = {\n        name: 'id',\n        type: 'numeric',\n        primaryKey: true,\n      }\n\n      return 'numeric'\n    }\n\n    if (idField.type === 'text') {\n      columns.id = {\n        name: 'id',\n        type: 'varchar',\n        primaryKey: true,\n      }\n      return 'varchar'\n    }\n  }\n\n  if (adapter.idType === 'uuid') {\n    columns.id = {\n      name: 'id',\n      type: 'uuid',\n      defaultRandom: true,\n      primaryKey: true,\n    }\n\n    return 'uuid'\n  }\n\n  columns.id = {\n    name: 'id',\n    type: 'serial',\n    primaryKey: true,\n  }\n\n  return 'integer'\n}\n"],"names":["setColumnID","adapter","columns","fields","idField","find","field","name","type","id","primaryKey","idType","defaultRandom"],"mappings":";;;AAEO,MAAMA,cAA2B,CAAC,EAAEC,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAE;IACnE,MAAMC,UAAUD,OAAOE,IAAI,CAAC,CAACC,QAAUA,MAAMC,IAAI,KAAK;IACtD,IAAIH,SAAS;QACX,IAAIA,QAAQI,IAAI,KAAK,UAAU;YAC7BN,QAAQO,EAAE,GAAG;gBACXF,MAAM;gBACNC,MAAM;gBACNE,YAAY;YACd;YAEA,OAAO;QACT;QAEA,IAAIN,QAAQI,IAAI,KAAK,QAAQ;YAC3BN,QAAQO,EAAE,GAAG;gBACXF,MAAM;gBACNC,MAAM;gBACNE,YAAY;YACd;YACA,OAAO;QACT;IACF;IAEA,IAAIT,QAAQU,MAAM,KAAK,QAAQ;QAC7BT,QAAQO,EAAE,GAAG;YACXF,MAAM;YACNC,MAAM;YACNI,eAAe;YACfF,YAAY;QACd;QAEA,OAAO;IACT;IAEAR,QAAQO,EAAE,GAAG;QACXF,MAAM;QACNC,MAAM;QACNE,YAAY;IACd;IAEA,OAAO;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8849, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8855, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/init.ts"],"sourcesContent":["import type { Init } from 'payload'\n\nimport type { BasePostgresAdapter } from './types.js'\n\nimport { buildDrizzleRelations } from '../schema/buildDrizzleRelations.js'\nimport { buildRawSchema } from '../schema/buildRawSchema.js'\nimport { executeSchemaHooks } from '../utilities/executeSchemaHooks.js'\nimport { buildDrizzleTable } from './schema/buildDrizzleTable.js'\nimport { setColumnID } from './schema/setColumnID.js'\n\nexport const init: Init = async function init(this: BasePostgresAdapter) {\n  this.rawRelations = {}\n  this.rawTables = {}\n\n  buildRawSchema({\n    adapter: this,\n    setColumnID,\n  })\n\n  await executeSchemaHooks({ type: 'beforeSchemaInit', adapter: this })\n\n  if (this.payload.config.localization) {\n    this.enums.enum__locales = this.pgSchema.enum(\n      '_locales',\n      this.payload.config.localization.locales.map(({ code }) => code) as [string, ...string[]],\n    )\n  }\n\n  for (const tableName in this.rawTables) {\n    buildDrizzleTable({ adapter: this, rawTable: this.rawTables[tableName] })\n  }\n\n  buildDrizzleRelations({\n    adapter: this,\n  })\n\n  await executeSchemaHooks({ type: 'afterSchemaInit', adapter: this })\n}\n"],"names":["buildDrizzleRelations","buildRawSchema","executeSchemaHooks","buildDrizzleTable","setColumnID","init","rawRelations","rawTables","adapter","type","payload","config","localization","enums","enum__locales","pgSchema","enum","locales","map","code","tableName","rawTable"],"mappings":";;;AAIA,SAASA,qBAAqB,QAAQ,qCAAoC;AAC1E,SAASC,cAAc,QAAQ,8BAA6B;AAC5D,SAASC,kBAAkB,QAAQ,qCAAoC;AACvE,SAASC,iBAAiB,QAAQ,gCAA+B;AACjE,SAASC,WAAW,QAAQ,0BAAyB;;;;;;AAE9C,MAAMC,OAAa,eAAeA;IACvC,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,SAAS,GAAG,CAAC;QAElBN,gZAAAA,EAAe;QACbO,SAAS,IAAI;6ZACbJ,cAAAA;IACF;IAEA,gZAAMF,qBAAAA,EAAmB;QAAEO,MAAM;QAAoBD,SAAS,IAAI;IAAC;IAEnE,IAAI,IAAI,CAACE,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;QACpC,IAAI,CAACC,KAAK,CAACC,aAAa,GAAG,IAAI,CAACC,QAAQ,CAACC,IAAI,CAC3C,YACA,IAAI,CAACN,OAAO,CAACC,MAAM,CAACC,YAAY,CAACK,OAAO,CAACC,GAAG,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA;IAE/D;IAEA,IAAK,MAAMC,aAAa,IAAI,CAACb,SAAS,CAAE;QACtCJ,saAAAA,EAAkB;YAAEK,SAAS,IAAI;YAAEa,UAAU,IAAI,CAACd,SAAS,CAACa,UAAU;QAAC;IACzE;8YAEApB,wBAAAA,EAAsB;QACpBQ,SAAS,IAAI;IACf;IAEA,gZAAMN,qBAAAA,EAAmB;QAAEO,MAAM;QAAmBD,SAAS,IAAI;IAAC;AACpE,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8896, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8902, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/insert.ts"],"sourcesContent":["import type { TransactionPg } from '../types.js'\nimport type { Insert } from './types.js'\n\nexport const insert: Insert = async function insert({\n  db,\n  onConflictDoUpdate,\n  tableName,\n  values,\n}): Promise<Record<string, unknown>[]> {\n  const table = this.tables[tableName]\n  let result\n\n  if (onConflictDoUpdate) {\n    result = await (db as TransactionPg)\n      .insert(table)\n      .values(values)\n      .onConflictDoUpdate(onConflictDoUpdate)\n      .returning()\n  } else {\n    result = await (db as TransactionPg).insert(table).values(values).returning()\n  }\n\n  return result\n}\n"],"names":["insert","db","onConflictDoUpdate","tableName","values","table","tables","result","returning"],"mappings":";;;AAGO,MAAMA,SAAiB,eAAeA,OAAO,EAClDC,EAAE,EACFC,kBAAkB,EAClBC,SAAS,EACTC,MAAM,EACP;IACC,MAAMC,QAAQ,IAAI,CAACC,MAAM,CAACH,UAAU;IACpC,IAAII;IAEJ,IAAIL,oBAAoB;QACtBK,SAAS,MAAON,GACbD,MAAM,CAACK,OACPD,MAAM,CAACA,QACPF,kBAAkB,CAACA,oBACnBM,SAAS;IACd,OAAO;QACLD,SAAS,MAAON,GAAqBD,MAAM,CAACK,OAAOD,MAAM,CAACA,QAAQI,SAAS;IAC7E;IAEA,OAAOD;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8915, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8921, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/predefinedMigrations/v2-v3/groupUpSQLStatements.ts"],"sourcesContent":["export type Groups =\n  | 'addColumn'\n  | 'addConstraint'\n  | 'dropColumn'\n  | 'dropConstraint'\n  | 'dropTable'\n  | 'notNull'\n\n/**\n * Convert an \"ADD COLUMN\" statement to an \"ALTER COLUMN\" statement\n * example: ALTER TABLE \"pages_blocks_my_block\" ADD COLUMN \"person_id\" integer NOT NULL;\n * to: ALTER TABLE \"pages_blocks_my_block\" ALTER COLUMN \"person_id\" SET NOT NULL;\n * @param sql\n */\nfunction convertAddColumnToAlterColumn(sql) {\n  // Regular expression to match the ADD COLUMN statement with its constraints\n  const regex = /ALTER TABLE (\"[^\"]+\")\\.(\".*?\") ADD COLUMN (\"[^\"]+\") [\\w\\s]+ NOT NULL;/\n\n  // Replace the matched part with \"ALTER COLUMN ... SET NOT NULL;\"\n  return sql.replace(regex, 'ALTER TABLE $1.$2 ALTER COLUMN $3 SET NOT NULL;')\n}\n\nexport const groupUpSQLStatements = (list: string[]): Record<Groups, string[]> => {\n  const groups = {\n    addColumn: 'ADD COLUMN',\n    // example: ALTER TABLE \"posts\" ADD COLUMN \"category_id\" integer\n\n    addConstraint: 'ADD CONSTRAINT',\n    //example:\n    // DO $$ BEGIN\n    //  ALTER TABLE \"pages_blocks_my_block\" ADD CONSTRAINT \"pages_blocks_my_block_person_id_users_id_fk\" FOREIGN KEY (\"person_id\") REFERENCES \"users\"(\"id\") ON DELETE cascade ON UPDATE no action;\n    // EXCEPTION\n    //  WHEN duplicate_object THEN null;\n    // END $$;\n\n    dropColumn: 'DROP COLUMN',\n    // example: ALTER TABLE \"_posts_v_rels\" DROP COLUMN IF EXISTS \"posts_id\";\n\n    dropConstraint: 'DROP CONSTRAINT',\n    // example: ALTER TABLE \"_posts_v_rels\" DROP CONSTRAINT \"_posts_v_rels_posts_fk\";\n\n    dropTable: 'DROP TABLE',\n    // example: DROP TABLE \"pages_rels\";\n\n    notNull: 'NOT NULL',\n    // example: ALTER TABLE \"pages_blocks_my_block\" ALTER COLUMN \"person_id\" SET NOT NULL;\n  }\n\n  const result = Object.keys(groups).reduce((result, group: Groups) => {\n    result[group] = []\n    return result\n  }, {}) as Record<Groups, string[]>\n\n  for (const line of list) {\n    Object.entries(groups).some(([key, value]) => {\n      if (line.endsWith('NOT NULL;')) {\n        // split up the ADD COLUMN and ALTER COLUMN NOT NULL statements\n        // example: ALTER TABLE \"pages_blocks_my_block\" ADD COLUMN \"person_id\" integer NOT NULL;\n        // becomes two separate statements:\n        //  1. ALTER TABLE \"pages_blocks_my_block\" ADD COLUMN \"person_id\" integer;\n        //  2.  ALTER TABLE \"pages_blocks_my_block\" ALTER COLUMN \"person_id\" SET NOT NULL;\n        result.addColumn.push(line.replace(' NOT NULL;', ';'))\n        result.notNull.push(convertAddColumnToAlterColumn(line))\n        return true\n      }\n      if (line.includes(value)) {\n        result[key].push(line)\n        return true\n      }\n    })\n  }\n\n  return result\n}\n"],"names":["convertAddColumnToAlterColumn","sql","regex","replace","groupUpSQLStatements","list","groups","addColumn","addConstraint","dropColumn","dropConstraint","dropTable","notNull","result","Object","keys","reduce","group","line","entries","some","key","value","endsWith","push","includes"],"mappings":"AAQA;;;;;CAKC;;;AACD,SAASA,8BAA8BC,GAAG;IACxC,4EAA4E;IAC5E,MAAMC,QAAQ;IAEd,iEAAiE;IACjE,OAAOD,IAAIE,OAAO,CAACD,OAAO;AAC5B;AAEO,MAAME,uBAAuB,CAACC;IACnC,MAAMC,SAAS;QACbC,WAAW;QACX,gEAAgE;QAEhEC,eAAe;QACf,UAAU;QACV,cAAc;QACd,8LAA8L;QAC9L,YAAY;QACZ,oCAAoC;QACpC,UAAU;QAEVC,YAAY;QACZ,yEAAyE;QAEzEC,gBAAgB;QAChB,iFAAiF;QAEjFC,WAAW;QACX,oCAAoC;QAEpCC,SAAS;IAEX;IAEA,MAAMC,SAASC,OAAOC,IAAI,CAACT,QAAQU,MAAM,CAAC,CAACH,QAAQI;QACjDJ,MAAM,CAACI,MAAM,GAAG,EAAE;QAClB,OAAOJ;IACT,GAAG,CAAC;IAEJ,KAAK,MAAMK,QAAQb,KAAM;QACvBS,OAAOK,OAAO,CAACb,QAAQc,IAAI,CAAC,CAAC,CAACC,KAAKC,MAAM;YACvC,IAAIJ,KAAKK,QAAQ,CAAC,cAAc;gBAC9B,+DAA+D;gBAC/D,wFAAwF;gBACxF,mCAAmC;gBACnC,0EAA0E;gBAC1E,kFAAkF;gBAClFV,OAAON,SAAS,CAACiB,IAAI,CAACN,KAAKf,OAAO,CAAC,cAAc;gBACjDU,OAAOD,OAAO,CAACY,IAAI,CAACxB,8BAA8BkB;gBAClD,OAAO;YACT;YACA,IAAIA,KAAKO,QAAQ,CAACH,QAAQ;gBACxBT,MAAM,CAACQ,IAAI,CAACG,IAAI,CAACN;gBACjB,OAAO;YACT;QACF;IACF;IAEA,OAAOL;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8978, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8984, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/predefinedMigrations/v2-v3/fetchAndResave/traverseFields.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\ntype Args = {\n  doc: Record<string, unknown>\n  fields: FlattenedField[]\n  locale?: string\n  path: string\n  rows: Record<string, unknown>[]\n}\n\nexport const traverseFields = ({ doc, fields, locale, path, rows }: Args) => {\n  fields.forEach((field) => {\n    switch (field.type) {\n      case 'array': {\n        const rowData = doc?.[field.name]\n\n        if (field.localized && typeof rowData === 'object' && rowData !== null) {\n          Object.entries(rowData).forEach(([locale, localeRows]) => {\n            if (Array.isArray(localeRows)) {\n              localeRows.forEach((row, i) => {\n                return traverseFields({\n                  doc: row as Record<string, unknown>,\n                  fields: field.flattenedFields,\n                  locale,\n                  path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n                  rows,\n                })\n              })\n            }\n          })\n        }\n\n        if (Array.isArray(rowData)) {\n          rowData.forEach((row, i) => {\n            return traverseFields({\n              doc: row as Record<string, unknown>,\n              fields: field.flattenedFields,\n              path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n              rows,\n            })\n          })\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const rowData = doc?.[field.name]\n\n        if (field.localized && typeof rowData === 'object' && rowData !== null) {\n          Object.entries(rowData).forEach(([locale, localeRows]) => {\n            if (Array.isArray(localeRows)) {\n              localeRows.forEach((row, i) => {\n                const matchedBlock = field.blocks.find((block) => block.slug === row.blockType)\n\n                if (matchedBlock) {\n                  return traverseFields({\n                    doc: row as Record<string, unknown>,\n                    fields: matchedBlock.flattenedFields,\n                    locale,\n                    path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n                    rows,\n                  })\n                }\n              })\n            }\n          })\n        }\n\n        if (Array.isArray(rowData)) {\n          rowData.forEach((row, i) => {\n            const matchedBlock = field.blocks.find((block) => block.slug === row.blockType)\n\n            if (matchedBlock) {\n              return traverseFields({\n                doc: row as Record<string, unknown>,\n                fields: matchedBlock.flattenedFields,\n                path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n                rows,\n              })\n            }\n          })\n        }\n\n        break\n      }\n\n      case 'group':\n      case 'tab': {\n        const newPath = `${path ? `${path}.` : ''}${field.name}`\n        const newDoc = doc?.[field.name]\n\n        if (typeof newDoc === 'object' && newDoc !== null) {\n          if (field.localized) {\n            Object.entries(newDoc).forEach(([locale, localeDoc]) => {\n              return traverseFields({\n                doc: localeDoc,\n                fields: field.flattenedFields,\n                locale,\n                path: newPath,\n                rows,\n              })\n            })\n          } else {\n            return traverseFields({\n              doc: newDoc as Record<string, unknown>,\n              fields: field.flattenedFields,\n              path: newPath,\n              rows,\n            })\n          }\n        }\n\n        break\n      }\n\n      case 'relationship':\n      // falls through\n      case 'upload': {\n        if (typeof field.relationTo === 'string') {\n          if (field.type === 'upload' || !field.hasMany) {\n            const relationshipPath = `${path ? `${path}.` : ''}${field.name}`\n\n            if (field.localized) {\n              const matchedRelationshipsWithLocales = rows.filter(\n                (row) => row.path === relationshipPath,\n              )\n\n              if (matchedRelationshipsWithLocales.length && !doc[field.name]) {\n                doc[field.name] = {}\n              }\n\n              const newDoc = doc[field.name] as Record<string, unknown>\n\n              matchedRelationshipsWithLocales.forEach((localeRow) => {\n                if (typeof localeRow.locale === 'string') {\n                  const [, id] = Object.entries(localeRow).find(\n                    ([key, val]) =>\n                      val !== null && !['id', 'locale', 'order', 'parent_id', 'path'].includes(key),\n                  )\n\n                  newDoc[localeRow.locale] = id\n                }\n              })\n            } else {\n              const matchedRelationship = rows.find((row) => {\n                const matchesPath = row.path === relationshipPath\n\n                if (locale) {\n                  return matchesPath && locale === row.locale\n                }\n\n                return row.path === relationshipPath\n              })\n\n              if (matchedRelationship) {\n                const [, id] = Object.entries(matchedRelationship).find(\n                  ([key, val]) =>\n                    val !== null && !['id', 'locale', 'order', 'parent_id', 'path'].includes(key),\n                )\n\n                doc[field.name] = id\n              }\n            }\n          }\n        }\n        break\n      }\n    }\n  })\n}\n"],"names":["traverseFields","doc","fields","locale","path","rows","forEach","field","type","rowData","name","localized","Object","entries","localeRows","Array","isArray","row","i","flattenedFields","matchedBlock","blocks","find","block","slug","blockType","newPath","newDoc","localeDoc","relationTo","hasMany","relationshipPath","matchedRelationshipsWithLocales","filter","length","localeRow","id","key","val","includes","matchedRelationship","matchesPath"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9134, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9140, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/predefinedMigrations/v2-v3/fetchAndResave/index.ts"],"sourcesContent":["import type { FlattenedField, Payload, PayloadRequest } from 'payload'\n\nimport type { BasePostgresAdapter, PostgresDB } from '../../../types.js'\nimport type { DocsToResave } from '../types.js'\n\nimport { upsertRow } from '../../../../upsertRow/index.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: BasePostgresAdapter\n  collectionSlug?: string\n  db: PostgresDB\n  debug: boolean\n  docsToResave: DocsToResave\n  fields: FlattenedField[]\n  globalSlug?: string\n  isVersions: boolean\n  payload: Payload\n  req?: Partial<PayloadRequest>\n  tableName: string\n}\n\nexport const fetchAndResave = async ({\n  adapter,\n  collectionSlug,\n  db,\n  debug,\n  docsToResave,\n  fields,\n  globalSlug,\n  isVersions,\n  payload,\n  req,\n  tableName,\n}: Args) => {\n  for (const [id, rows] of Object.entries(docsToResave)) {\n    if (collectionSlug) {\n      const collectionConfig = payload.collections[collectionSlug].config\n\n      if (collectionConfig) {\n        if (isVersions) {\n          const doc = await payload.findVersionByID({\n            id,\n            collection: collectionSlug,\n            depth: 0,\n            fallbackLocale: null,\n            locale: 'all',\n            req,\n            showHiddenFields: true,\n          })\n\n          if (debug) {\n            payload.logger.info(\n              `The collection \"${collectionConfig.slug}\" version with ID ${id} will be migrated`,\n            )\n          }\n\n          traverseFields({\n            doc,\n            fields,\n            path: '',\n            rows,\n          })\n\n          try {\n            await upsertRow({\n              id: doc.id,\n              adapter,\n              data: doc,\n              db,\n              fields,\n              ignoreResult: true,\n              operation: 'update',\n              req,\n              tableName,\n            })\n          } catch (err) {\n            payload.logger.error(\n              `\"${collectionConfig.slug}\" version with ID ${doc.id} FAILED TO MIGRATE`,\n            )\n\n            throw err\n          }\n\n          if (debug) {\n            payload.logger.info(\n              `\"${collectionConfig.slug}\" version with ID ${doc.id} migrated successfully!`,\n            )\n          }\n        } else {\n          const doc = await payload.findByID({\n            id,\n            collection: collectionSlug,\n            depth: 0,\n            fallbackLocale: null,\n            locale: 'all',\n            req,\n            showHiddenFields: true,\n          })\n\n          if (debug) {\n            payload.logger.info(\n              `The collection \"${collectionConfig.slug}\" with ID ${doc.id} will be migrated`,\n            )\n          }\n\n          traverseFields({\n            doc,\n            fields,\n            path: '',\n            rows,\n          })\n\n          try {\n            await upsertRow({\n              id: doc.id,\n              adapter,\n              data: doc,\n              db,\n              fields,\n              ignoreResult: true,\n              operation: 'update',\n              req,\n              tableName,\n            })\n          } catch (err) {\n            payload.logger.error(\n              `The collection \"${collectionConfig.slug}\" with ID ${doc.id} has FAILED TO MIGRATE`,\n            )\n\n            throw err\n          }\n\n          if (debug) {\n            payload.logger.info(\n              `The collection \"${collectionConfig.slug}\" with ID ${doc.id} has migrated successfully!`,\n            )\n          }\n        }\n      }\n    }\n\n    if (globalSlug) {\n      const globalConfig = payload.config.globals?.find((global) => global.slug === globalSlug)\n\n      if (globalConfig) {\n        if (isVersions) {\n          const { docs } = await payload.findGlobalVersions({\n            slug: globalSlug,\n            depth: 0,\n            fallbackLocale: null,\n            limit: 0,\n            locale: 'all',\n            req,\n            showHiddenFields: true,\n          })\n\n          if (debug) {\n            payload.logger.info(`${docs.length} global \"${globalSlug}\" versions will be migrated`)\n          }\n\n          for (const doc of docs) {\n            traverseFields({\n              doc,\n              fields,\n              path: '',\n              rows,\n            })\n\n            try {\n              await upsertRow({\n                id: doc.id,\n                adapter,\n                data: doc,\n                db,\n                fields,\n                ignoreResult: true,\n                operation: 'update',\n                req,\n                tableName,\n              })\n            } catch (err) {\n              payload.logger.error(`\"${globalSlug}\" version with ID ${doc.id} FAILED TO MIGRATE`)\n\n              throw err\n            }\n\n            if (debug) {\n              payload.logger.info(\n                `\"${globalSlug}\" version with ID ${doc.id} migrated successfully!`,\n              )\n            }\n          }\n        } else {\n          const doc = await payload.findGlobal({\n            slug: globalSlug,\n            depth: 0,\n            fallbackLocale: null,\n            locale: 'all',\n            req,\n            showHiddenFields: true,\n          })\n\n          traverseFields({\n            doc,\n            fields,\n            path: '',\n            rows,\n          })\n\n          try {\n            await upsertRow({\n              adapter,\n              data: doc,\n              db,\n              fields,\n              ignoreResult: true,\n              operation: 'update',\n              req,\n              tableName,\n            })\n          } catch (err) {\n            payload.logger.error(`The global \"${globalSlug}\" has FAILED TO MIGRATE`)\n\n            throw err\n          }\n\n          if (debug) {\n            payload.logger.info(`The global \"${globalSlug}\" has migrated successfully!`)\n          }\n        }\n      }\n    }\n  }\n}\n"],"names":["upsertRow","traverseFields","fetchAndResave","adapter","collectionSlug","db","debug","docsToResave","fields","globalSlug","isVersions","payload","req","tableName","id","rows","Object","entries","collectionConfig","collections","config","doc","findVersionByID","collection","depth","fallbackLocale","locale","showHiddenFields","logger","info","slug","path","data","ignoreResult","operation","err","error","findByID","globalConfig","globals","find","global","docs","findGlobalVersions","limit","length","findGlobal"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9312, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9318, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/predefinedMigrations/v2-v3/migrateRelationships.ts"],"sourcesContent":["import type { PgSchema } from 'drizzle-orm/pg-core'\nimport type { FlattenedField, Payload, PayloadRequest } from 'payload'\n\nimport { sql } from 'drizzle-orm'\n\nimport type { BasePostgresAdapter, PostgresDB } from '../../types.js'\nimport type { DocsToResave, PathsToQuery } from './types.js'\n\nimport { fetchAndResave } from './fetchAndResave/index.js'\n\ntype Args = {\n  adapter: BasePostgresAdapter\n  collectionSlug?: string\n  db: PostgresDB\n  debug: boolean\n  fields: FlattenedField[]\n  globalSlug?: string\n  isVersions: boolean\n  pathsToQuery: PathsToQuery\n  payload: Payload\n  req?: Partial<PayloadRequest>\n  tableName: string\n}\n\nexport const migrateRelationships = async ({\n  adapter,\n  collectionSlug,\n  db,\n  debug,\n  fields,\n  globalSlug,\n  isVersions,\n  pathsToQuery,\n  payload,\n  req,\n  tableName,\n}: Args) => {\n  if (pathsToQuery.size === 0) {\n    return\n  }\n\n  let offset = 0\n\n  let paginationResult\n\n  const schemaName = (adapter.pgSchema as PgSchema).schemaName ?? 'public'\n\n  const where = Array.from(pathsToQuery).reduce((statement, path, i) => {\n    return (statement += `\n\"${schemaName}\".\"${tableName}${adapter.relationshipsSuffix}\".\"path\" LIKE '${path}'${pathsToQuery.size !== i + 1 ? ' OR' : ''}\n`)\n  }, '')\n\n  while (typeof paginationResult === 'undefined' || paginationResult.rows.length > 0) {\n    const paginationStatement = `SELECT DISTINCT parent_id FROM \"${schemaName}\".\"${tableName}${adapter.relationshipsSuffix}\" WHERE\n    ${where} ORDER BY parent_id LIMIT 500 OFFSET ${offset * 500};\n  `\n\n    paginationResult = await adapter.drizzle.execute(sql.raw(`${paginationStatement}`))\n\n    if (paginationResult.rows.length === 0) {\n      return\n    }\n\n    offset += 1\n\n    const statement = `SELECT * FROM \"${schemaName}\".\"${tableName}${adapter.relationshipsSuffix}\" WHERE\n    (${where}) AND parent_id IN (${paginationResult.rows.map((row) => `'${row.parent_id}'`).join(', ')});\n`\n    if (debug) {\n      payload.logger.info('FINDING ROWS TO MIGRATE')\n      payload.logger.info(statement)\n    }\n\n    const result = await adapter.drizzle.execute(sql.raw(`${statement}`))\n\n    const docsToResave: DocsToResave = {}\n\n    result.rows.forEach((row) => {\n      const parentID = row.parent_id\n\n      if (typeof parentID === 'string' || typeof parentID === 'number') {\n        if (!docsToResave[parentID]) {\n          docsToResave[parentID] = []\n        }\n        docsToResave[parentID].push(row)\n      }\n    })\n\n    await fetchAndResave({\n      adapter,\n      collectionSlug,\n      db,\n      debug,\n      docsToResave,\n      fields,\n      globalSlug,\n      isVersions,\n      payload,\n      req,\n      tableName,\n    })\n  }\n\n  const deleteStatement = `DELETE FROM \"${schemaName}\".\"${tableName}${adapter.relationshipsSuffix}\" WHERE ${where}`\n  if (debug) {\n    payload.logger.info('DELETING ROWS')\n    payload.logger.info(deleteStatement)\n  }\n  await db.execute(sql.raw(`${deleteStatement}`))\n}\n"],"names":["sql","fetchAndResave","migrateRelationships","adapter","collectionSlug","db","debug","fields","globalSlug","isVersions","pathsToQuery","payload","req","tableName","size","offset","paginationResult","schemaName","pgSchema","where","Array","from","reduce","statement","path","i","relationshipsSuffix","rows","length","paginationStatement","drizzle","execute","raw","map","row","parent_id","join","logger","info","result","docsToResave","forEach","parentID","push","deleteStatement"],"mappings":";;;AAQA,SAASC,cAAc,QAAQ,4BAA2B;AAL1D,SAASD,GAAG,QAAQ,cAAa;;;AAqB1B,MAAME,uBAAuB,OAAO,EACzCC,OAAO,EACPC,cAAc,EACdC,EAAE,EACFC,KAAK,EACLC,MAAM,EACNC,UAAU,EACVC,UAAU,EACVC,YAAY,EACZC,OAAO,EACPC,GAAG,EACHC,SAAS,EACJ;IACL,IAAIH,aAAaI,IAAI,KAAK,GAAG;QAC3B;IACF;IAEA,IAAIC,SAAS;IAEb,IAAIC;IAEJ,MAAMC,aAAcd,QAAQe,QAAQ,CAAcD,UAAU,IAAI;IAEhE,MAAME,QAAQC,MAAMC,IAAI,CAACX,cAAcY,MAAM,CAAC,CAACC,WAAWC,MAAMC;QAC9D,OAAQF,aAAa,CAAC;CACzB,EAAEN,WAAW,GAAG,EAAEJ,YAAYV,QAAQuB,mBAAmB,CAAC,eAAe,EAAEF,KAAK,CAAC,EAAEd,aAAaI,IAAI,KAAKW,IAAI,IAAI,QAAQ,GAAG;AAC7H,CAAC;IACC,GAAG;IAEH,MAAO,OAAOT,qBAAqB,eAAeA,iBAAiBW,IAAI,CAACC,MAAM,GAAG,EAAG;QAClF,MAAMC,sBAAsB,CAAC,gCAAgC,EAAEZ,WAAW,GAAG,EAAEJ,YAAYV,QAAQuB,mBAAmB,CAAC;IACvH,EAAEP,MAAM,qCAAqC,EAAEJ,SAAS,IAAI;EAC9D,CAAC;QAECC,mBAAmB,MAAMb,QAAQ2B,OAAO,CAACC,OAAO,sTAAC/B,MAAAA,CAAIgC,GAAG,CAAC,GAAGH,qBAAqB;QAEjF,IAAIb,iBAAiBW,IAAI,CAACC,MAAM,KAAK,GAAG;YACtC;QACF;QAEAb,UAAU;QAEV,MAAMQ,YAAY,CAAC,eAAe,EAAEN,WAAW,GAAG,EAAEJ,YAAYV,QAAQuB,mBAAmB,CAAC;KAC3F,EAAEP,MAAM,oBAAoB,EAAEH,iBAAiBW,IAAI,CAACM,GAAG,CAAC,CAACC,MAAQ,CAAC,CAAC,EAAEA,IAAIC,SAAS,CAAC,CAAC,CAAC,EAAEC,IAAI,CAAC,MAAM;AACvG,CAAC;QACG,IAAI9B,OAAO;YACTK,QAAQ0B,MAAM,CAACC,IAAI,CAAC;YACpB3B,QAAQ0B,MAAM,CAACC,IAAI,CAACf;QACtB;QAEA,MAAMgB,SAAS,MAAMpC,QAAQ2B,OAAO,CAACC,OAAO,sTAAC/B,MAAAA,CAAIgC,GAAG,CAAC,GAAGT,WAAW;QAEnE,MAAMiB,eAA6B,CAAC;QAEpCD,OAAOZ,IAAI,CAACc,OAAO,CAAC,CAACP;YACnB,MAAMQ,WAAWR,IAAIC,SAAS;YAE9B,IAAI,OAAOO,aAAa,YAAY,OAAOA,aAAa,UAAU;gBAChE,IAAI,CAACF,YAAY,CAACE,SAAS,EAAE;oBAC3BF,YAAY,CAACE,SAAS,GAAG,EAAE;gBAC7B;gBACAF,YAAY,CAACE,SAAS,CAACC,IAAI,CAACT;YAC9B;QACF;QAEA,MAAMjC,mcAAAA,EAAe;YACnBE;YACAC;YACAC;YACAC;YACAkC;YACAjC;YACAC;YACAC;YACAE;YACAC;YACAC;QACF;IACF;IAEA,MAAM+B,kBAAkB,CAAC,aAAa,EAAE3B,WAAW,GAAG,EAAEJ,YAAYV,QAAQuB,mBAAmB,CAAC,QAAQ,EAAEP,OAAO;IACjH,IAAIb,OAAO;QACTK,QAAQ0B,MAAM,CAACC,IAAI,CAAC;QACpB3B,QAAQ0B,MAAM,CAACC,IAAI,CAACM;IACtB;IACA,MAAMvC,GAAG0B,OAAO,sTAAC/B,MAAAA,CAAIgC,GAAG,CAAC,GAAGY,iBAAiB;AAC/C,EAAC","ignoreList":[0]}},
    {"offset": {"line": 9385, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9391, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/predefinedMigrations/v2-v3/traverseFields.ts"],"sourcesContent":["import type { FlattenedField, Payload } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { BasePostgresAdapter, PostgresDB } from '../../types.js'\nimport type { PathsToQuery } from './types.js'\n\ntype Args = {\n  adapter: BasePostgresAdapter\n  collectionSlug?: string\n  columnPrefix: string\n  db: PostgresDB\n  disableNotNull: boolean\n  fields: FlattenedField[]\n  globalSlug?: string\n  isVersions: boolean\n  newTableName: string\n  parentTableName: string\n  path: string\n  pathsToQuery: PathsToQuery\n  payload: Payload\n  rootTableName: string\n}\n\nexport const traverseFields = (args: Args) => {\n  args.fields.forEach((field) => {\n    switch (field.type) {\n      case 'array': {\n        const newTableName = args.adapter.tableNameMap.get(\n          `${args.newTableName}_${toSnakeCase(field.name)}`,\n        )\n\n        return traverseFields({\n          ...args,\n          columnPrefix: '',\n          fields: field.flattenedFields,\n          newTableName,\n          parentTableName: newTableName,\n          path: `${args.path ? `${args.path}.` : ''}${field.name}.%`,\n        })\n      }\n\n      case 'blocks': {\n        return field.blocks.forEach((block) => {\n          const newTableName = args.adapter.tableNameMap.get(\n            `${args.rootTableName}_blocks_${toSnakeCase(block.slug)}`,\n          )\n\n          traverseFields({\n            ...args,\n            columnPrefix: '',\n            fields: block.flattenedFields,\n            newTableName,\n            parentTableName: newTableName,\n            path: `${args.path ? `${args.path}.` : ''}${field.name}.%`,\n          })\n        })\n      }\n\n      case 'group':\n      case 'tab': {\n        let newTableName = `${args.newTableName}_${toSnakeCase(field.name)}`\n\n        if (field.localized && args.payload.config.localization) {\n          newTableName += args.adapter.localesSuffix\n        }\n\n        return traverseFields({\n          ...args,\n          columnPrefix: `${args.columnPrefix}${toSnakeCase(field.name)}_`,\n          fields: field.flattenedFields,\n          newTableName,\n          path: `${args.path ? `${args.path}.` : ''}${field.name}`,\n        })\n      }\n\n      case 'relationship':\n      case 'upload': {\n        if (typeof field.relationTo === 'string') {\n          if (field.type === 'upload' || !field.hasMany) {\n            args.pathsToQuery.add(`${args.path ? `${args.path}.` : ''}${field.name}`)\n          }\n        }\n\n        return null\n      }\n    }\n  })\n}\n"],"names":["toSnakeCase","traverseFields","args","fields","forEach","field","type","newTableName","adapter","tableNameMap","get","name","columnPrefix","flattenedFields","parentTableName","path","blocks","block","rootTableName","slug","localized","payload","config","localization","localesSuffix","relationTo","hasMany","pathsToQuery","add"],"mappings":";;;AAEA,OAAOA,iBAAiB,gBAAe;;AAsBhC,MAAMC,iBAAiB,CAACC;IAC7BA,KAAKC,MAAM,CAACC,OAAO,CAAC,CAACC;QACnB,OAAQA,MAAMC,IAAI;YAChB,KAAK;gBAAS;oBACZ,MAAMC,eAAeL,KAAKM,OAAO,CAACC,YAAY,CAACC,GAAG,CAChD,GAAGR,KAAKK,YAAY,CAAC,CAAC,mNAAEP,UAAAA,EAAYK,MAAMM,IAAI,GAAG;oBAGnD,OAAOV,eAAe;wBACpB,GAAGC,IAAI;wBACPU,cAAc;wBACdT,QAAQE,MAAMQ,eAAe;wBAC7BN;wBACAO,iBAAiBP;wBACjBQ,MAAM,GAAGb,KAAKa,IAAI,GAAG,GAAGb,KAAKa,IAAI,CAAC,CAAC,CAAC,GAAG,KAAKV,MAAMM,IAAI,CAAC,EAAE,CAAC;oBAC5D;gBACF;YAEA,KAAK;gBAAU;oBACb,OAAON,MAAMW,MAAM,CAACZ,OAAO,CAAC,CAACa;wBAC3B,MAAMV,eAAeL,KAAKM,OAAO,CAACC,YAAY,CAACC,GAAG,CAChD,GAAGR,KAAKgB,aAAa,CAAC,QAAQ,mNAAElB,UAAAA,EAAYiB,MAAME,IAAI,GAAG;wBAG3DlB,eAAe;4BACb,GAAGC,IAAI;4BACPU,cAAc;4BACdT,QAAQc,MAAMJ,eAAe;4BAC7BN;4BACAO,iBAAiBP;4BACjBQ,MAAM,GAAGb,KAAKa,IAAI,GAAG,GAAGb,KAAKa,IAAI,CAAC,CAAC,CAAC,GAAG,KAAKV,MAAMM,IAAI,CAAC,EAAE,CAAC;wBAC5D;oBACF;gBACF;YAEA,KAAK;YACL,KAAK;gBAAO;oBACV,IAAIJ,eAAe,GAAGL,KAAKK,YAAY,CAAC,CAAC,EAAEP,2NAAAA,EAAYK,MAAMM,IAAI,GAAG;oBAEpE,IAAIN,MAAMe,SAAS,IAAIlB,KAAKmB,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;wBACvDhB,gBAAgBL,KAAKM,OAAO,CAACgB,aAAa;oBAC5C;oBAEA,OAAOvB,eAAe;wBACpB,GAAGC,IAAI;wBACPU,cAAc,GAAGV,KAAKU,YAAY,oNAAGZ,UAAAA,EAAYK,MAAMM,IAAI,EAAE,CAAC,CAAC;wBAC/DR,QAAQE,MAAMQ,eAAe;wBAC7BN;wBACAQ,MAAM,GAAGb,KAAKa,IAAI,GAAG,GAAGb,KAAKa,IAAI,CAAC,CAAC,CAAC,GAAG,KAAKV,MAAMM,IAAI,EAAE;oBAC1D;gBACF;YAEA,KAAK;YACL,KAAK;gBAAU;oBACb,IAAI,OAAON,MAAMoB,UAAU,KAAK,UAAU;wBACxC,IAAIpB,MAAMC,IAAI,KAAK,YAAY,CAACD,MAAMqB,OAAO,EAAE;4BAC7CxB,KAAKyB,YAAY,CAACC,GAAG,CAAC,GAAG1B,KAAKa,IAAI,GAAG,GAAGb,KAAKa,IAAI,CAAC,CAAC,CAAC,GAAG,KAAKV,MAAMM,IAAI,EAAE;wBAC1E;oBACF;oBAEA,OAAO;gBACT;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 9453, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9459, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/predefinedMigrations/v2-v3/index.ts"],"sourcesContent":["import type { DrizzleSnapshotJSON } from 'drizzle-kit/api'\nimport type { Payload, PayloadRequest } from 'payload'\n\nimport { sql } from 'drizzle-orm'\nimport fs from 'fs'\nimport { buildVersionCollectionFields, buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { BasePostgresAdapter } from '../../types.js'\nimport type { PathsToQuery } from './types.js'\n\nimport { getTransaction } from '../../../utilities/getTransaction.js'\nimport { groupUpSQLStatements } from './groupUpSQLStatements.js'\nimport { migrateRelationships } from './migrateRelationships.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  debug?: boolean\n  payload: Payload\n  req?: Partial<PayloadRequest>\n}\n\n/**\n * Moves upload and relationship columns from the join table and into the tables while moving data\n * This is done in the following order:\n *    ADD COLUMNs\n *    -- manipulate data to move relationships to new columns\n *    ADD CONSTRAINTs\n *    NOT NULLs\n *    DROP TABLEs\n *    DROP CONSTRAINTs\n *    DROP COLUMNs\n * @param debug\n * @param payload\n * @param req\n */\nexport const migratePostgresV2toV3 = async ({ debug, payload, req }: Args) => {\n  const adapter = payload.db as unknown as BasePostgresAdapter\n  const db = await getTransaction(adapter, req)\n  const dir = payload.db.migrationDir\n\n  // get the drizzle migrateUpSQL from drizzle using the last schema\n  const { generateDrizzleJson, generateMigration, upSnapshot } = adapter.requireDrizzleKit()\n\n  const toSnapshot: Record<string, unknown> = {}\n\n  for (const key of Object.keys(adapter.schema).filter(\n    (key) => !key.startsWith('payload_locked_documents'),\n  )) {\n    toSnapshot[key] = adapter.schema[key]\n  }\n\n  const drizzleJsonAfter = generateDrizzleJson(toSnapshot) as DrizzleSnapshotJSON\n\n  // Get the previous migration snapshot\n  const previousSnapshot = fs\n    .readdirSync(dir)\n    .filter((file) => file.endsWith('.json') && !file.endsWith('relationships_v2_v3.json'))\n    .sort()\n    .reverse()?.[0]\n\n  if (!previousSnapshot) {\n    throw new Error(\n      `No previous migration schema file found! A prior migration from v2 is required to migrate to v3.`,\n    )\n  }\n\n  let drizzleJsonBefore = JSON.parse(\n    fs.readFileSync(`${dir}/${previousSnapshot}`, 'utf8'),\n  ) as DrizzleSnapshotJSON\n\n  if (upSnapshot && drizzleJsonBefore.version < drizzleJsonAfter.version) {\n    drizzleJsonBefore = upSnapshot(drizzleJsonBefore)\n  }\n\n  const generatedSQL = await generateMigration(drizzleJsonBefore, drizzleJsonAfter)\n\n  if (!generatedSQL.length) {\n    payload.logger.info(`No schema changes needed.`)\n    process.exit(0)\n  }\n\n  const sqlUpStatements = groupUpSQLStatements(generatedSQL)\n\n  const addColumnsStatement = sqlUpStatements.addColumn.join('\\n')\n\n  if (debug) {\n    payload.logger.info('CREATING NEW RELATIONSHIP COLUMNS')\n    payload.logger.info(addColumnsStatement)\n  }\n\n  await db.execute(sql.raw(addColumnsStatement))\n\n  for (const collection of payload.config.collections) {\n    const tableName = adapter.tableNameMap.get(toSnakeCase(collection.slug))\n    const pathsToQuery: PathsToQuery = new Set()\n\n    traverseFields({\n      adapter,\n      collectionSlug: collection.slug,\n      columnPrefix: '',\n      db,\n      disableNotNull: false,\n      fields: collection.flattenedFields,\n      isVersions: false,\n      newTableName: tableName,\n      parentTableName: tableName,\n      path: '',\n      pathsToQuery,\n      payload,\n      rootTableName: tableName,\n    })\n\n    await migrateRelationships({\n      adapter,\n      collectionSlug: collection.slug,\n      db,\n      debug,\n      fields: collection.flattenedFields,\n      isVersions: false,\n      pathsToQuery,\n      payload,\n      req,\n      tableName,\n    })\n\n    if (collection.versions) {\n      const versionsTableName = adapter.tableNameMap.get(\n        `_${toSnakeCase(collection.slug)}${adapter.versionsSuffix}`,\n      )\n      const versionFields = buildVersionCollectionFields(payload.config, collection, true)\n      const versionPathsToQuery: PathsToQuery = new Set()\n\n      traverseFields({\n        adapter,\n        collectionSlug: collection.slug,\n        columnPrefix: '',\n        db,\n        disableNotNull: true,\n        fields: versionFields,\n        isVersions: true,\n        newTableName: versionsTableName,\n        parentTableName: versionsTableName,\n        path: '',\n        pathsToQuery: versionPathsToQuery,\n        payload,\n        rootTableName: versionsTableName,\n      })\n\n      await migrateRelationships({\n        adapter,\n        collectionSlug: collection.slug,\n        db,\n        debug,\n        fields: versionFields,\n        isVersions: true,\n        pathsToQuery: versionPathsToQuery,\n        payload,\n        req,\n        tableName: versionsTableName,\n      })\n    }\n  }\n\n  for (const global of payload.config.globals) {\n    const tableName = adapter.tableNameMap.get(toSnakeCase(global.slug))\n\n    const pathsToQuery: PathsToQuery = new Set()\n\n    traverseFields({\n      adapter,\n      columnPrefix: '',\n      db,\n      disableNotNull: false,\n      fields: global.flattenedFields,\n      globalSlug: global.slug,\n      isVersions: false,\n      newTableName: tableName,\n      parentTableName: tableName,\n      path: '',\n      pathsToQuery,\n      payload,\n      rootTableName: tableName,\n    })\n\n    await migrateRelationships({\n      adapter,\n      db,\n      debug,\n      fields: global.flattenedFields,\n      globalSlug: global.slug,\n      isVersions: false,\n      pathsToQuery,\n      payload,\n      req,\n      tableName,\n    })\n\n    if (global.versions) {\n      const versionsTableName = adapter.tableNameMap.get(\n        `_${toSnakeCase(global.slug)}${adapter.versionsSuffix}`,\n      )\n\n      const versionFields = buildVersionGlobalFields(payload.config, global, true)\n\n      const versionPathsToQuery: PathsToQuery = new Set()\n\n      traverseFields({\n        adapter,\n        columnPrefix: '',\n        db,\n        disableNotNull: true,\n        fields: versionFields,\n        globalSlug: global.slug,\n        isVersions: true,\n        newTableName: versionsTableName,\n        parentTableName: versionsTableName,\n        path: '',\n        pathsToQuery: versionPathsToQuery,\n        payload,\n        rootTableName: versionsTableName,\n      })\n\n      await migrateRelationships({\n        adapter,\n        db,\n        debug,\n        fields: versionFields,\n        globalSlug: global.slug,\n        isVersions: true,\n        pathsToQuery: versionPathsToQuery,\n        payload,\n        req,\n        tableName: versionsTableName,\n      })\n    }\n  }\n\n  // ADD CONSTRAINT\n  const addConstraintsStatement = sqlUpStatements.addConstraint.join('\\n')\n\n  if (debug) {\n    payload.logger.info('ADDING CONSTRAINTS')\n    payload.logger.info(addConstraintsStatement)\n  }\n\n  await db.execute(sql.raw(addConstraintsStatement))\n\n  // NOT NULL\n  const notNullStatements = sqlUpStatements.notNull.join('\\n')\n\n  if (debug) {\n    payload.logger.info('NOT NULL CONSTRAINTS')\n    payload.logger.info(notNullStatements)\n  }\n\n  await db.execute(sql.raw(notNullStatements))\n\n  // DROP TABLE\n  const dropTablesStatement = sqlUpStatements.dropTable.join('\\n')\n\n  if (debug) {\n    payload.logger.info('DROPPING TABLES')\n    payload.logger.info(dropTablesStatement)\n  }\n\n  await db.execute(sql.raw(dropTablesStatement))\n\n  // DROP CONSTRAINT\n  const dropConstraintsStatement = sqlUpStatements.dropConstraint.join('\\n')\n\n  if (debug) {\n    payload.logger.info('DROPPING CONSTRAINTS')\n    payload.logger.info(dropConstraintsStatement)\n  }\n\n  await db.execute(sql.raw(dropConstraintsStatement))\n\n  // DROP COLUMN\n  const dropColumnsStatement = sqlUpStatements.dropColumn.join('\\n')\n\n  if (debug) {\n    payload.logger.info('DROPPING COLUMNS')\n    payload.logger.info(dropColumnsStatement)\n  }\n\n  await db.execute(sql.raw(dropColumnsStatement))\n}\n"],"names":["sql","fs","buildVersionCollectionFields","buildVersionGlobalFields","toSnakeCase","getTransaction","groupUpSQLStatements","migrateRelationships","traverseFields","migratePostgresV2toV3","debug","payload","req","adapter","db","dir","migrationDir","generateDrizzleJson","generateMigration","upSnapshot","requireDrizzleKit","toSnapshot","key","Object","keys","schema","filter","startsWith","drizzleJsonAfter","previousSnapshot","readdirSync","file","endsWith","sort","reverse","Error","drizzleJsonBefore","JSON","parse","readFileSync","version","generatedSQL","length","logger","info","process","exit","sqlUpStatements","addColumnsStatement","addColumn","join","execute","raw","collection","config","collections","tableName","tableNameMap","get","slug","pathsToQuery","Set","collectionSlug","columnPrefix","disableNotNull","fields","flattenedFields","isVersions","newTableName","parentTableName","path","rootTableName","versions","versionsTableName","versionsSuffix","versionFields","versionPathsToQuery","global","globals","globalSlug","addConstraintsStatement","addConstraint","notNullStatements","notNull","dropTablesStatement","dropTable","dropConstraintsStatement","dropConstraint","dropColumnsStatement","dropColumn"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9673, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9679, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/requireDrizzleKit.ts"],"sourcesContent":["import { createRequire } from 'module'\n\nimport type { RequireDrizzleKit } from '../types.js'\n\nconst require = createRequire(import.meta.url)\n\nexport const requireDrizzleKit: RequireDrizzleKit = () => {\n  const {\n    generateDrizzleJson,\n    generateMigration,\n    pushSchema,\n    upPgSnapshot,\n  } = require('drizzle-kit/api')\n\n  return {\n    generateDrizzleJson,\n    generateMigration,\n    pushSchema,\n    upSnapshot: upPgSnapshot,\n  }\n}\n"],"names":["createRequire","require","url","requireDrizzleKit","generateDrizzleJson","generateMigration","pushSchema","upPgSnapshot","upSnapshot"],"mappings":";;;AAAA,SAASA,aAAa,QAAQ,SAAQ;;;;;;;AAItC,MAAMC,oHAAUD,gBAAAA,EAAc,8BAAYE,GAAG;AAEtC,MAAMC,oBAAuC;IAClD,MAAM,EACJC,mBAAmB,EACnBC,iBAAiB,EACjBC,UAAU,EACVC,YAAY,EACb,GAAGN,QAAQ;IAEZ,OAAO;QACLG;QACAC;QACAC;QACAE,YAAYD;IACd;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 9699, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9705, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/postgres/types.ts"],"sourcesContent":["import type { DrizzleSnapshotJSON } from 'drizzle-kit/api'\nimport type {\n  ColumnBaseConfig,\n  ColumnDataType,\n  DrizzleConfig,\n  Relation,\n  Relations,\n  SQL,\n} from 'drizzle-orm'\nimport type { NodePgDatabase } from 'drizzle-orm/node-postgres'\nimport type {\n  ForeignKeyBuilder,\n  IndexBuilder,\n  PgColumn,\n  PgEnum,\n  pgEnum,\n  PgInsertOnConflictDoUpdateConfig,\n  PgSchema,\n  PgTableWithColumns,\n  UniqueConstraintBuilder,\n} from 'drizzle-orm/pg-core'\nimport type { PgTableFn } from 'drizzle-orm/pg-core/table'\nimport type { Payload, PayloadRequest } from 'payload'\nimport type { ClientConfig, QueryResult } from 'pg'\n\nimport type { extendDrizzleTable, Operators } from '../index.js'\nimport type { BuildQueryJoinAliases, DrizzleAdapter, TransactionPg } from '../types.js'\n\nexport type BaseExtraConfig = Record<\n  string,\n  (cols: GenericColumns) => ForeignKeyBuilder | IndexBuilder | UniqueConstraintBuilder\n>\n\nexport type RelationMap = Map<\n  string,\n  {\n    localized: boolean\n    relationName?: string\n    target: string\n    type: 'many' | 'one'\n  }\n>\n\nexport type GenericColumn = PgColumn<\n  ColumnBaseConfig<ColumnDataType, string>,\n  Record<string, unknown>\n>\n\nexport type GenericColumns = {\n  [x: string]: GenericColumn\n}\n\nexport type GenericTable = PgTableWithColumns<{\n  columns: GenericColumns\n  dialect: string\n  name: string\n  schema: string\n}>\n\nexport type GenericEnum = PgEnum<[string, ...string[]]>\n\nexport type GenericRelation = Relations<string, Record<string, Relation<string>>>\n\nexport type PostgresDB = NodePgDatabase<Record<string, unknown>>\n\nexport type CountDistinct = (args: {\n  db: PostgresDB | TransactionPg\n  joins: BuildQueryJoinAliases\n  tableName: string\n  where: SQL\n}) => Promise<number>\n\nexport type DeleteWhere = (args: {\n  db: PostgresDB | TransactionPg\n  tableName: string\n  where: SQL\n}) => Promise<void>\n\nexport type DropDatabase = (args: { adapter: BasePostgresAdapter }) => Promise<void>\n\nexport type Execute<T> = (args: {\n  db?: PostgresDB | TransactionPg\n  drizzle?: PostgresDB\n  raw?: string\n  sql?: SQL<unknown>\n}) => Promise<QueryResult<Record<string, T>>>\n\nexport type Insert = (args: {\n  db: PostgresDB | TransactionPg\n  onConflictDoUpdate?: PgInsertOnConflictDoUpdateConfig<any>\n  tableName: string\n  values: Record<string, unknown> | Record<string, unknown>[]\n}) => Promise<Record<string, unknown>[]>\n\nexport type CreateDatabase = (args?: {\n  /**\n   * Name of a database, defaults to the current one\n   */\n  name?: string\n  /**\n   * Schema to create in addition to 'public'. Defaults from adapter.schemaName if exists.\n   */\n  schemaName?: string\n}) => Promise<boolean>\n\ntype Schema =\n  | {\n      enum: typeof pgEnum\n      table: PgTableFn<string>\n    }\n  | PgSchema\n\ntype PostgresSchema = {\n  enums: Record<string, GenericEnum>\n  relations: Record<string, GenericRelation>\n  tables: Record<string, PgTableWithColumns<any>>\n}\n\ntype PostgresSchemaHookArgs = {\n  adapter: PostgresDrizzleAdapter\n  extendTable: typeof extendDrizzleTable\n  schema: PostgresSchema\n}\n\nexport type PostgresSchemaHook = (\n  args: PostgresSchemaHookArgs,\n) => PostgresSchema | Promise<PostgresSchema>\n\nexport type BasePostgresAdapter = {\n  afterSchemaInit: PostgresSchemaHook[]\n  beforeSchemaInit: PostgresSchemaHook[]\n  countDistinct: CountDistinct\n  createDatabase: CreateDatabase\n  createExtensions: () => Promise<void>\n  defaultDrizzleSnapshot: DrizzleSnapshotJSON\n  deleteWhere: DeleteWhere\n  disableCreateDatabase: boolean\n  drizzle: PostgresDB\n  dropDatabase: DropDatabase\n  enums: Record<string, GenericEnum>\n  execute: Execute<unknown>\n  extensions: Record<string, boolean>\n  /**\n   * An object keyed on each table, with a key value pair where the constraint name is the key, followed by the dot-notation field name\n   * Used for returning properly formed errors from unique fields\n   */\n  fieldConstraints: Record<string, Record<string, string>>\n  idType: 'serial' | 'uuid'\n  initializing: Promise<void>\n  insert: Insert\n  localesSuffix?: string\n  logger: DrizzleConfig['logger']\n  operators: Operators\n  pgSchema: Schema\n  poolOptions?: ClientConfig\n  prodMigrations?: {\n    down: (args: MigrateDownArgs) => Promise<void>\n    name: string\n    up: (args: MigrateUpArgs) => Promise<void>\n  }[]\n  push: boolean\n  rejectInitializing: () => void\n  relations: Record<string, GenericRelation>\n  relationshipsSuffix?: string\n  resolveInitializing: () => void\n  schemaName?: string\n  sessions: {\n    [id: string]: {\n      db: PostgresDB | TransactionPg\n      reject: () => Promise<void>\n      resolve: () => Promise<void>\n    }\n  }\n  tableNameMap: Map<string, string>\n  tables: Record<string, GenericTable>\n  tablesFilter?: string[]\n  versionsSuffix?: string\n} & PostgresDrizzleAdapter\n\nexport type PostgresDrizzleAdapter = Omit<\n  DrizzleAdapter,\n  | 'countDistinct'\n  | 'deleteWhere'\n  | 'drizzle'\n  | 'dropDatabase'\n  | 'execute'\n  | 'insert'\n  | 'operators'\n  | 'relations'\n>\n\nexport type IDType = 'integer' | 'numeric' | 'uuid' | 'varchar'\n\nexport type MigrateUpArgs = {\n  /**\n   * The Postgres Drizzle instance that you can use to execute SQL directly within the current transaction.\n   * @example\n   * ```ts\n   * import { type MigrateUpArgs, sql } from '@payloadcms/db-postgres'\n   *\n   * export async function up({ db, payload, req }: MigrateUpArgs): Promise<void> {\n   *   const { rows: posts } = await db.execute(sql`SELECT * FROM posts`)\n   * }\n   * ```\n   */\n  db: PostgresDB\n  /**\n   * The Payload instance that you can use to execute Local API methods\n   * To use the current transaction you must pass `req` to arguments\n   * @example\n   * ```ts\n   * import { type MigrateUpArgs, sql } from '@payloadcms/db-postgres'\n   *\n   * export async function up({ db, payload, req }: MigrateUpArgs): Promise<void> {\n   *   const posts = await payload.find({ collection: 'posts', req })\n   * }\n   * ```\n   */\n  payload: Payload\n  /**\n   * The `PayloadRequest` object that contains the current transaction\n   */\n  req: PayloadRequest\n}\n\nexport type MigrateDownArgs = {\n  /**\n   * The Postgres Drizzle instance that you can use to execute SQL directly within the current transaction.\n   * @example\n   * ```ts\n   * import { type MigrateDownArgs, sql } from '@payloadcms/db-postgres'\n   *\n   * export async function down({ db, payload, req }: MigrateDownArgs): Promise<void> {\n   *   const { rows: posts } = await db.execute(sql`SELECT * FROM posts`)\n   * }\n   * ```\n   */\n  db: PostgresDB\n  /**\n   * The Payload instance that you can use to execute Local API methods\n   * To use the current transaction you must pass `req` to arguments\n   * @example\n   * ```ts\n   * import { type MigrateDownArgs } from '@payloadcms/db-postgres'\n   *\n   * export async function down({ db, payload, req }: MigrateDownArgs): Promise<void> {\n   *   const posts = await payload.find({ collection: 'posts', req })\n   * }\n   * ```\n   */\n  payload: Payload\n  /**\n   * The `PayloadRequest` object that contains the current transaction\n   */\n  req: PayloadRequest\n}\n"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 9708, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9714, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/%40payloadcms%2Bdrizzle%403.23.0_%40types%2Bpg%408.10.2_%40types%2Breact%4019.0.1_payload%403.11.0_graphql%4016.10._6t6c5nsptc56w6cenghmbxtdia/node_modules/%40payloadcms/drizzle/src/exports/postgres.ts"],"sourcesContent":["export { columnToCodeConverter } from '../postgres/columnToCodeConverter.js'\nexport { countDistinct } from '../postgres/countDistinct.js'\nexport { createDatabase } from '../postgres/createDatabase.js'\nexport { createExtensions } from '../postgres/createExtensions.js'\nexport { createJSONQuery } from '../postgres/createJSONQuery/index.js'\nexport { defaultDrizzleSnapshot } from '../postgres/defaultSnapshot.js'\nexport { deleteWhere } from '../postgres/deleteWhere.js'\nexport { dropDatabase } from '../postgres/dropDatabase.js'\nexport { execute } from '../postgres/execute.js'\nexport { init } from '../postgres/init.js'\nexport { insert } from '../postgres/insert.js'\nexport { migratePostgresV2toV3 } from '../postgres/predefinedMigrations/v2-v3/index.js'\nexport { requireDrizzleKit } from '../postgres/requireDrizzleKit.js'\nexport { geometryColumn } from '../postgres/schema/geometryColumn.js'\nexport * from '../postgres/types.js'\n"],"names":["columnToCodeConverter","countDistinct","createDatabase","createExtensions","createJSONQuery","defaultDrizzleSnapshot","deleteWhere","dropDatabase","execute","init","insert","migratePostgresV2toV3","requireDrizzleKit","geometryColumn"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 9731, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}