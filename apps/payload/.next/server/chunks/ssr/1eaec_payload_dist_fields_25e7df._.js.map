{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/config/types.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { EditorProps } from '@monaco-editor/react'\nimport type { JSONSchema4 } from 'json-schema'\nimport type { CSSProperties } from 'react'\nimport type { DeepUndefinable, MarkRequired } from 'ts-essentials'\n\nimport type {\n  JoinFieldClientProps,\n  JoinFieldErrorClientComponent,\n  JoinFieldErrorServerComponent,\n  JoinFieldLabelClientComponent,\n  JoinFieldLabelServerComponent,\n} from '../../admin/fields/Join.js'\nimport type { FieldClientComponent, FieldServerComponent } from '../../admin/forms/Field.js'\nimport type { RichTextAdapter, RichTextAdapterProvider } from '../../admin/RichText.js'\nimport type {\n  ArrayFieldClientProps,\n  ArrayFieldErrorClientComponent,\n  ArrayFieldErrorServerComponent,\n  ArrayFieldLabelClientComponent,\n  ArrayFieldLabelServerComponent,\n  BlocksFieldClientProps,\n  BlocksFieldErrorClientComponent,\n  BlocksFieldErrorServerComponent,\n  CheckboxFieldClientProps,\n  CheckboxFieldErrorClientComponent,\n  CheckboxFieldErrorServerComponent,\n  CheckboxFieldLabelClientComponent,\n  CheckboxFieldLabelServerComponent,\n  ClientTab,\n  CodeFieldClientProps,\n  CodeFieldErrorClientComponent,\n  CodeFieldErrorServerComponent,\n  CodeFieldLabelClientComponent,\n  CodeFieldLabelServerComponent,\n  CollapsibleFieldClientProps,\n  CollapsibleFieldLabelClientComponent,\n  CollapsibleFieldLabelServerComponent,\n  ConditionalDateProps,\n  DateFieldClientProps,\n  DateFieldErrorClientComponent,\n  DateFieldErrorServerComponent,\n  DateFieldLabelClientComponent,\n  DateFieldLabelServerComponent,\n  Description,\n  EmailFieldClientProps,\n  EmailFieldErrorClientComponent,\n  EmailFieldErrorServerComponent,\n  EmailFieldLabelClientComponent,\n  EmailFieldLabelServerComponent,\n  FieldDescriptionClientComponent,\n  FieldDescriptionServerComponent,\n  GroupFieldClientProps,\n  GroupFieldLabelClientComponent,\n  GroupFieldLabelServerComponent,\n  HiddenFieldProps,\n  JSONFieldClientProps,\n  JSONFieldErrorClientComponent,\n  JSONFieldErrorServerComponent,\n  JSONFieldLabelClientComponent,\n  JSONFieldLabelServerComponent,\n  NumberFieldClientProps,\n  NumberFieldErrorClientComponent,\n  NumberFieldErrorServerComponent,\n  NumberFieldLabelClientComponent,\n  NumberFieldLabelServerComponent,\n  PointFieldClientProps,\n  PointFieldErrorClientComponent,\n  PointFieldErrorServerComponent,\n  PointFieldLabelClientComponent,\n  PointFieldLabelServerComponent,\n  RadioFieldClientProps,\n  RadioFieldErrorClientComponent,\n  RadioFieldErrorServerComponent,\n  RadioFieldLabelClientComponent,\n  RadioFieldLabelServerComponent,\n  RelationshipFieldClientProps,\n  RelationshipFieldErrorClientComponent,\n  RelationshipFieldErrorServerComponent,\n  RelationshipFieldLabelClientComponent,\n  RelationshipFieldLabelServerComponent,\n  RichTextFieldClientProps,\n  RowFieldClientProps,\n  RowLabelComponent,\n  SelectFieldClientProps,\n  SelectFieldErrorClientComponent,\n  SelectFieldErrorServerComponent,\n  SelectFieldLabelClientComponent,\n  SelectFieldLabelServerComponent,\n  StaticDescription,\n  TabsFieldClientProps,\n  TextareaFieldClientProps,\n  TextareaFieldErrorClientComponent,\n  TextareaFieldErrorServerComponent,\n  TextareaFieldLabelClientComponent,\n  TextareaFieldLabelServerComponent,\n  TextFieldClientProps,\n  TextFieldErrorClientComponent,\n  TextFieldErrorServerComponent,\n  TextFieldLabelClientComponent,\n  TextFieldLabelServerComponent,\n  UploadFieldClientProps,\n} from '../../admin/types.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'\nimport type {\n  CustomComponent,\n  LabelFunction,\n  PayloadComponent,\n  StaticLabel,\n} from '../../config/types.js'\nimport type { DBIdentifierName } from '../../database/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type {\n  ArrayFieldValidation,\n  BlocksFieldValidation,\n  CheckboxFieldValidation,\n  CodeFieldValidation,\n  CollectionSlug,\n  DateFieldValidation,\n  EmailFieldValidation,\n  JSONFieldValidation,\n  PointFieldValidation,\n  RadioFieldValidation,\n  RequestContext,\n  Sort,\n  TextareaFieldValidation,\n} from '../../index.js'\nimport type { DocumentPreferences } from '../../preferences/types.js'\nimport type { DefaultValue, Operation, PayloadRequest, Where } from '../../types/index.js'\nimport type {\n  NumberFieldManyValidation,\n  NumberFieldSingleValidation,\n  RelationshipFieldManyValidation,\n  RelationshipFieldSingleValidation,\n  SelectFieldManyValidation,\n  SelectFieldSingleValidation,\n  TextFieldManyValidation,\n  TextFieldSingleValidation,\n  UploadFieldManyValidation,\n  UploadFieldSingleValidation,\n} from '../validations.js'\n\nexport type FieldHookArgs<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = {\n  /** The collection which the field belongs to. If the field belongs to a global, this will be null. */\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  /**\n   * Only available in `afterRead` hooks\n   */\n  currentDepth?: number /**\n   * Only available in `afterRead` hooks\n   */\n  /** The data passed to update the document within create and update operations, and the full document itself in the afterRead hook. */\n  data?: Partial<TData>\n  /**\n   * Only available in the `afterRead` hook.\n   */\n  depth?: number\n  draft?: boolean\n  /** The field which the hook is running against. */\n  field: FieldAffectingData\n  /** Boolean to denote if this hook is running against finding one, or finding many within the afterRead hook. */\n  findMany?: boolean\n  /** The global which the field belongs to. If the field belongs to a collection, this will be null. */\n  global: null | SanitizedGlobalConfig\n  /** A string relating to which operation the field type is currently executing within. Useful within beforeValidate, beforeChange, and afterChange hooks to differentiate between create and update operations. */\n  operation?: 'create' | 'delete' | 'read' | 'update'\n  /** The full original document in `update` operations. In the `afterChange` hook, this is the resulting document of the operation. */\n  originalDoc?: TData\n  overrideAccess?: boolean\n  /**\n   * The path of the field, e.g. [\"group\", \"myArray\", 1, \"textField\"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.\n   */\n  path: (number | string)[]\n  /** The document before changes were applied, only in `afterChange` hooks. */\n  previousDoc?: TData\n  /** The sibling data of the document before changes being applied, only in `beforeChange`, `beforeValidate`, `beforeDuplicate` and `afterChange` field hooks. */\n  previousSiblingDoc?: TData\n  /** The previous value of the field, before changes, only in `beforeChange`, `afterChange`, `beforeDuplicate` and `beforeValidate` field hooks. */\n  previousValue?: TValue\n  /** The Express request object. It is mocked for Local API operations. */\n  req: PayloadRequest\n  /**\n   * The schemaPath of the field, e.g. [\"group\", \"myArray\", \"textField\"]. The schemaPath is the path but without indexes and would be used in the context of field schemas, not field data.\n   */\n  schemaPath: string[]\n  /**\n   * Only available in the `afterRead` hook.\n   */\n  showHiddenFields?: boolean\n  /** The sibling data passed to a field that the hook is running against. */\n  siblingData: Partial<TSiblingData>\n  /**\n   * The original siblingData with locales (not modified by any hooks). Only available in `beforeChange` and `beforeDuplicate` field hooks.\n   */\n  siblingDocWithLocales?: Record<string, unknown>\n  /** The value of the field. */\n  value?: TValue\n}\n\nexport type FieldHook<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = (\n  args: FieldHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type FieldAccess<TData extends TypeWithID = any, TSiblingData = any> = (args: {\n  /**\n   * The incoming data used to `create` or `update` the document with. `data` is undefined during the `read` operation.\n   */\n  data?: Partial<TData>\n  /**\n   * The original data of the document before the `update` is applied. `doc` is undefined during the `create` operation.\n   */\n  doc?: TData\n  /**\n   * The `id` of the current document being read or updated. `id` is undefined during the `create` operation.\n   */\n  id?: number | string\n  /** The `payload` object to interface with the payload API */\n  req: PayloadRequest\n  /**\n   * Immediately adjacent data to this field. For example, if this is a `group` field, then `siblingData` will be the other fields within the group.\n   */\n  siblingData?: Partial<TSiblingData>\n}) => boolean | Promise<boolean>\n\nexport type Condition<TData extends TypeWithID = any, TSiblingData = any> = (\n  data: Partial<TData>,\n  siblingData: Partial<TSiblingData>,\n  { user }: { user: PayloadRequest['user'] },\n) => boolean\n\nexport type FilterOptionsProps<TData = any> = {\n  /**\n   * An object containing the full collection or global document currently being edited.\n   */\n  data: TData\n  /**\n   * The `id` of the current document being edited. `id` is undefined during the `create` operation.\n   */\n  id: number | string\n  /**\n   * The collection `slug` to filter against, limited to this field's `relationTo` property.\n   */\n  relationTo: CollectionSlug\n  /**\n   * An object containing document data that is scoped to only fields within the same parent of this field.\n   */\n  siblingData: unknown\n  /**\n   * An object containing the currently authenticated user.\n   */\n  user: Partial<PayloadRequest['user']>\n}\n\nexport type FilterOptionsFunc<TData = any> = (\n  options: FilterOptionsProps<TData>,\n) => boolean | Promise<boolean | Where> | Where\n\nexport type FilterOptions<TData = any> =\n  | ((options: FilterOptionsProps<TData>) => boolean | Promise<boolean | Where> | Where)\n  | null\n  | Where\n\ntype Admin = {\n  className?: string\n  components?: {\n    Cell?: CustomComponent\n    Description?: CustomComponent<FieldDescriptionClientComponent | FieldDescriptionServerComponent>\n    Field?: CustomComponent<FieldClientComponent | FieldServerComponent>\n    /**\n     * The Filter component has to be a client component\n     */\n    Filter?: PayloadComponent\n  }\n  /**\n   * You can programmatically show / hide fields based on what other fields are doing.\n   * This is also run on the server, to determine if the field should be validated.\n   */\n  condition?: Condition\n  /** Extension point to add your custom data. Available in server and client. */\n  custom?: Record<string, any>\n  /**\n   * The field description will be displayed next to the field in the admin UI. Additionally,\n   * we use the field description to generate JSDoc comments for the generated TypeScript types.\n   */\n  description?: Description\n  disableBulkEdit?: boolean\n  disabled?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view column selector.\n   * @type boolean\n   */\n  disableListColumn?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view filter options.\n   * @type boolean\n   */\n  disableListFilter?: boolean\n  hidden?: boolean\n  position?: 'sidebar'\n  readOnly?: boolean\n  style?: CSSProperties\n  width?: CSSProperties['width']\n}\n\nexport type AdminClient = {\n  className?: string\n  /** Extension point to add your custom data. Available in server and client. */\n  custom?: Record<string, any>\n  description?: StaticDescription\n  disableBulkEdit?: boolean\n  disabled?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view column selector.\n   * @type boolean\n   */\n  disableListColumn?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view filter options.\n   * @type boolean\n   */\n  disableListFilter?: boolean\n  hidden?: boolean\n  position?: 'sidebar'\n  readOnly?: boolean\n  style?: { '--field-width'?: CSSProperties['width'] } & CSSProperties\n  width?: CSSProperties['width']\n}\n\nexport type Labels = {\n  plural: LabelFunction | StaticLabel\n  singular: LabelFunction | StaticLabel\n}\n\nexport type LabelsClient = {\n  plural: StaticLabel\n  singular: StaticLabel\n}\n\nexport type BaseValidateOptions<TData, TSiblingData, TValue> = {\n  collectionSlug?: string\n  data: Partial<TData>\n  id?: number | string\n  operation?: Operation\n  preferences: DocumentPreferences\n  previousValue?: TValue\n  req: PayloadRequest\n  required?: boolean\n  siblingData: Partial<TSiblingData>\n}\n\nexport type ValidateOptions<\n  TData,\n  TSiblingData,\n  TFieldConfig extends object,\n  TValue,\n> = BaseValidateOptions<TData, TSiblingData, TValue> & TFieldConfig\n\nexport type Validate<\n  TValue = any,\n  TData = any,\n  TSiblingData = any,\n  TFieldConfig extends object = object,\n> = (\n  value: null | TValue | undefined,\n  options: ValidateOptions<TData, TSiblingData, TFieldConfig, TValue>,\n) => Promise<string | true> | string | true\n\nexport type OptionObject = {\n  label: LabelFunction | StaticLabel\n  value: string\n}\n\nexport type Option = OptionObject | string\n\nexport type FieldGraphQLType = {\n  graphQL?: {\n    /**\n     * Complexity for the query. This is used to limit the complexity of the join query.\n     *\n     * @default 10\n     */\n    complexity?: number\n  }\n}\n\nexport interface FieldBase {\n  /**\n   * Do not set this property manually. This is set to true during sanitization, to avoid\n   * sanitizing the same field multiple times.\n   */\n  _sanitized?: boolean\n  access?: {\n    create?: FieldAccess\n    read?: FieldAccess\n    update?: FieldAccess\n  }\n  admin?: Admin\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  defaultValue?: DefaultValue\n  hidden?: boolean\n  hooks?: {\n    afterChange?: FieldHook[]\n    afterRead?: FieldHook[]\n    beforeChange?: FieldHook[]\n    /**\n     * Runs before a document is duplicated to prevent errors in unique fields or return null to use defaultValue.\n     */\n    beforeDuplicate?: FieldHook[]\n    beforeValidate?: FieldHook[]\n  }\n  index?: boolean\n  label?: false | LabelFunction | StaticLabel\n  localized?: boolean\n  /**\n   * The name of the field. Must be alphanumeric and cannot contain ' . '\n   *\n   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']\n   * @link https://payloadcms.com/docs/fields/overview#field-names\n   */\n  name: string\n  required?: boolean\n  saveToJWT?: boolean | string\n  /**\n   * Allows you to modify the base JSON schema that is generated during generate:types for this field.\n   * This JSON schema will be used to generate the TypeScript interface of this field.\n   */\n  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  unique?: boolean\n  validate?: Validate\n  /**\n   * Pass `true` to disable field in the DB\n   * for [Virtual Fields](https://payloadcms.com/blog/learn-how-virtual-fields-can-help-solve-common-cms-challenges):\n   * A virtual field cannot be used in `admin.useAsTitle`\n   */\n  virtual?: boolean\n}\n\nexport interface FieldBaseClient {\n  admin?: AdminClient\n  hidden?: boolean\n  index?: boolean\n  label?: StaticLabel\n  localized?: boolean\n  /**\n   * The name of the field. Must be alphanumeric and cannot contain ' . '\n   *\n   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']\n   * @link https://payloadcms.com/docs/fields/overview#field-names\n   */\n  name: string\n  required?: boolean\n  saveToJWT?: boolean | string\n  /**\n   * Allows you to modify the base JSON schema that is generated during generate:types for this field.\n   * This JSON schema will be used to generate the TypeScript interface of this field.\n   */\n  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  unique?: boolean\n}\n\nexport type NumberField = {\n  admin?: {\n    /** Set this property to a string that will be used for browser autocomplete. */\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<NumberFieldErrorClientComponent | NumberFieldErrorServerComponent>\n      Label?: CustomComponent<NumberFieldLabelClientComponent | NumberFieldLabelServerComponent>\n    } & Admin['components']\n    /** Set this property to define a placeholder string for the field. */\n    placeholder?: Record<string, string> | string\n    /** Set a value for the number field to increment / decrement using browser controls. */\n    step?: number\n  } & Admin\n  /** Maximum value accepted. Used in the default `validate` function. */\n  max?: number\n  /** Minimum value accepted. Used in the default `validate` function. */\n  min?: number\n  type: 'number'\n} & (\n  | {\n      /** Makes this field an ordered array of numbers instead of just a single number. */\n      hasMany: true\n      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */\n      maxRows?: number\n      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */\n      minRows?: number\n      validate?: NumberFieldManyValidation\n    }\n  | {\n      /** Makes this field an ordered array of numbers instead of just a single number. */\n      hasMany?: false | undefined\n      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */\n      maxRows?: undefined\n      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */\n      minRows?: undefined\n      validate?: NumberFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type NumberFieldClient = {\n  admin?: AdminClient & Pick<NumberField['admin'], 'autoComplete' | 'placeholder' | 'step'>\n} & FieldBaseClient &\n  Pick<NumberField, 'hasMany' | 'max' | 'maxRows' | 'min' | 'minRows' | 'type'>\n\nexport type TextField = {\n  admin?: {\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<TextFieldErrorClientComponent | TextFieldErrorServerComponent>\n      Label?: CustomComponent<TextFieldLabelClientComponent | TextFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    rtl?: boolean\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'text'\n} & (\n  | {\n      /** Makes this field an ordered array of strings instead of just a single string. */\n      hasMany: true\n      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */\n      maxRows?: number\n      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */\n      minRows?: number\n      validate?: TextFieldManyValidation\n    }\n  | {\n      /** Makes this field an ordered array of strings instead of just a single string. */\n      hasMany?: false | undefined\n      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */\n      maxRows?: undefined\n      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */\n      minRows?: undefined\n      validate?: TextFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type TextFieldClient = {\n  admin?: AdminClient & Pick<TextField['admin'], 'autoComplete' | 'placeholder' | 'rtl'>\n} & FieldBaseClient &\n  Pick<TextField, 'hasMany' | 'maxLength' | 'maxRows' | 'minLength' | 'minRows' | 'type'>\n\nexport type EmailField = {\n  admin?: {\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<EmailFieldErrorClientComponent | EmailFieldErrorServerComponent>\n      Label?: CustomComponent<EmailFieldLabelClientComponent | EmailFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n  } & Admin\n  type: 'email'\n  validate?: EmailFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type EmailFieldClient = {\n  admin?: AdminClient & Pick<EmailField['admin'], 'autoComplete' | 'placeholder'>\n} & FieldBaseClient &\n  Pick<EmailField, 'type'>\n\nexport type TextareaField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<TextareaFieldErrorClientComponent | TextareaFieldErrorServerComponent>\n      Label?: CustomComponent<TextareaFieldLabelClientComponent | TextareaFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    rows?: number\n    rtl?: boolean\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'textarea'\n  validate?: TextareaFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type TextareaFieldClient = {\n  admin?: AdminClient & Pick<TextareaField['admin'], 'placeholder' | 'rows' | 'rtl'>\n} & FieldBaseClient &\n  Pick<TextareaField, 'maxLength' | 'minLength' | 'type'>\n\nexport type CheckboxField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<CheckboxFieldErrorClientComponent | CheckboxFieldErrorServerComponent>\n      Label?: CustomComponent<CheckboxFieldLabelClientComponent | CheckboxFieldLabelServerComponent>\n    } & Admin['components']\n  } & Admin\n  type: 'checkbox'\n  validate?: CheckboxFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type CheckboxFieldClient = {\n  admin?: AdminClient\n} & FieldBaseClient &\n  Pick<CheckboxField, 'type'>\n\nexport type DateField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<DateFieldErrorClientComponent | DateFieldErrorServerComponent>\n      Label?: CustomComponent<DateFieldLabelClientComponent | DateFieldLabelServerComponent>\n    } & Admin['components']\n    date?: ConditionalDateProps\n    placeholder?: Record<string, string> | string\n  } & Admin\n  type: 'date'\n  validate?: DateFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type DateFieldClient = {\n  admin?: AdminClient & Pick<DateField['admin'], 'date' | 'placeholder'>\n} & FieldBaseClient &\n  Pick<DateField, 'type'>\n\nexport type GroupField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Label?: CustomComponent<GroupFieldLabelClientComponent | GroupFieldLabelServerComponent>\n    } & Admin['components']\n    hideGutter?: boolean\n  } & Admin\n  fields: Field[]\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  type: 'group'\n  validate?: Validate<unknown, unknown, unknown, GroupField>\n} & Omit<FieldBase, 'required' | 'validate'>\n\nexport type GroupFieldClient = {\n  admin?: AdminClient & Pick<GroupField['admin'], 'hideGutter'>\n  fields: ClientField[]\n} & Omit<FieldBaseClient, 'required'> &\n  Pick<GroupField, 'interfaceName' | 'type'>\n\nexport type RowField = {\n  admin?: Omit<Admin, 'description'>\n  fields: Field[]\n  type: 'row'\n} & Omit<FieldBase, 'admin' | 'label' | 'localized' | 'name' | 'validate' | 'virtual'>\n\nexport type RowFieldClient = {\n  admin?: Omit<AdminClient, 'description'>\n  fields: ClientField[]\n} & Omit<FieldBaseClient, 'admin' | 'label' | 'name'> &\n  Pick<RowField, 'type'>\n\nexport type CollapsibleField = {\n  fields: Field[]\n  type: 'collapsible'\n} & (\n  | {\n      admin: {\n        components: {\n          afterInput?: CustomComponent[]\n          beforeInput?: CustomComponent[]\n          Label: CustomComponent<\n            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent\n          >\n        } & Admin['components']\n        initCollapsed?: boolean\n      } & Admin\n      label?: Required<FieldBase['label']>\n    }\n  | {\n      admin?: {\n        components?: {\n          afterInput?: CustomComponent[]\n          beforeInput?: CustomComponent[]\n          Label?: CustomComponent<\n            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent\n          >\n        } & Admin['components']\n        initCollapsed?: boolean\n      } & Admin\n      label: Required<FieldBase['label']>\n    }\n) &\n  Omit<FieldBase, 'label' | 'localized' | 'name' | 'validate' | 'virtual'>\n\nexport type CollapsibleFieldClient = {\n  admin?: {\n    initCollapsed?: boolean\n  } & AdminClient\n  fields: ClientField[]\n  label: StaticLabel\n} & Omit<FieldBaseClient, 'label' | 'name' | 'validate'> &\n  Pick<CollapsibleField, 'type'>\n\ntype TabBase = {\n  description?: LabelFunction | StaticDescription\n  fields: Field[]\n  interfaceName?: string\n  saveToJWT?: boolean | string\n} & Omit<FieldBase, 'required' | 'validate'>\n\nexport type NamedTab = {\n  /** Customize generated GraphQL and Typescript schema names.\n   * The slug is used by default.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n} & TabBase\n\nexport type UnnamedTab = {\n  interfaceName?: never\n  /**\n   * Can be either:\n   * - A string, which will be used as the tab's label.\n   * - An object, where the key is the language code and the value is the label.\n   */\n  label:\n    | {\n        [selectedLanguage: string]: string\n      }\n    | LabelFunction\n    | string\n  localized?: never\n} & Omit<TabBase, 'name' | 'virtual'>\n\nexport type Tab = NamedTab | UnnamedTab\n\nexport type TabsField = {\n  admin?: Omit<Admin, 'description'>\n  tabs: Tab[]\n  type: 'tabs'\n} & Omit<FieldBase, 'admin' | 'localized' | 'name' | 'saveToJWT' | 'virtual'>\n\nexport type TabsFieldClient = {\n  admin?: Omit<AdminClient, 'description'>\n  tabs: ClientTab[]\n} & Omit<FieldBaseClient, 'admin' | 'localized' | 'name' | 'saveToJWT'> &\n  Pick<TabsField, 'type'>\n\nexport type TabAsField = {\n  name?: string\n  type: 'tab'\n} & Tab\n\nexport type TabAsFieldClient = ClientTab & Pick<TabAsField, 'name' | 'type'>\n\nexport type UIField = {\n  admin: {\n    components?: {\n      /**\n       * Allow any custom components to be added to the UI field. This allows\n       * the UI field to be used as a vessel for getting components rendered.\n       */\n      [key: string]: PayloadComponent | undefined\n      Cell?: CustomComponent\n      // Can be optional, in case the UI field is just used as a vessel for custom components\n      Field?: CustomComponent\n      /**\n       * The Filter component has to be a client component\n       */\n      Filter?: PayloadComponent\n    } & Admin['components']\n    condition?: Condition\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n    /**\n     * Set `false` make the UI field appear in the list view column selector. `true` by default for UI fields.\n     * @default true\n     */\n    disableBulkEdit?: boolean\n    /**\n     * Shows / hides fields from appearing in the list view column selector.\n     * @type boolean\n     */\n    disableListColumn?: boolean\n    position?: string\n    width?: CSSProperties['width']\n  }\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  label?: Record<string, string> | string\n  name: string\n  type: 'ui'\n}\n\nexport type UIFieldClient = {\n  // still include FieldBaseClient.admin (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))\n\n  admin: DeepUndefinable<FieldBaseClient['admin']> &\n    Pick<\n      UIField['admin'],\n      'custom' | 'disableBulkEdit' | 'disableListColumn' | 'position' | 'width'\n    >\n} & Omit<DeepUndefinable<FieldBaseClient>, 'admin'> & // still include FieldBaseClient (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))\n  Pick<UIField, 'label' | 'name' | 'type'>\n\ntype SharedUploadProperties = {\n  /**\n   * Toggle the preview in the admin interface.\n   */\n  displayPreview?: boolean\n  filterOptions?: FilterOptions\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'upload'\n} & (\n  | {\n      hasMany: true\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: number\n      maxRows?: number\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: number\n      minRows?: number\n      validate?: UploadFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: undefined\n      maxRows?: undefined\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: undefined\n      minRows?: undefined\n      validate?: UploadFieldSingleValidation\n    }\n) &\n  FieldGraphQLType &\n  Omit<FieldBase, 'validate'>\n\ntype SharedUploadPropertiesClient = FieldBaseClient &\n  Pick<\n    SharedUploadProperties,\n    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'\n  >\n\ntype UploadAdmin = {\n  allowCreate?: boolean\n  components?: {\n    Error?: CustomComponent<\n      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent\n    >\n    Label?: CustomComponent<\n      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent\n    >\n  } & Admin['components']\n  isSortable?: boolean\n} & Admin\n\ntype UploadAdminClient = AdminClient & Pick<UploadAdmin, 'allowCreate' | 'isSortable'>\n\nexport type PolymorphicUploadField = {\n  admin?: {\n    sortOptions?: Partial<Record<CollectionSlug, string>>\n  } & UploadAdmin\n  relationTo: CollectionSlug[]\n} & SharedUploadProperties\n\nexport type PolymorphicUploadFieldClient = {\n  admin?: {\n    sortOptions?: Pick<PolymorphicUploadField['admin'], 'sortOptions'>\n  } & UploadAdminClient\n} & Pick<PolymorphicUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &\n  SharedUploadPropertiesClient\n\nexport type SingleUploadField = {\n  admin?: {\n    sortOptions?: string\n  } & UploadAdmin\n  relationTo: CollectionSlug\n} & SharedUploadProperties\n\nexport type SingleUploadFieldClient = {\n  admin?: Pick<SingleUploadField['admin'], 'sortOptions'> & UploadAdminClient\n} & Pick<SingleUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &\n  SharedUploadPropertiesClient\n\nexport type UploadField = /* PolymorphicUploadField | */ SingleUploadField\n\nexport type UploadFieldClient = /* PolymorphicUploadFieldClient | */ SingleUploadFieldClient\n\nexport type CodeField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<CodeFieldErrorClientComponent | CodeFieldErrorServerComponent>\n      Label?: CustomComponent<CodeFieldLabelClientComponent | CodeFieldLabelServerComponent>\n    } & Admin['components']\n    editorOptions?: EditorProps['options']\n    language?: string\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'code'\n  validate?: CodeFieldValidation\n} & Omit<FieldBase, 'admin' | 'validate'>\n\nexport type CodeFieldClient = {\n  admin?: AdminClient & Pick<CodeField['admin'], 'editorOptions' | 'language'>\n} & Omit<FieldBaseClient, 'admin'> &\n  Pick<CodeField, 'maxLength' | 'minLength' | 'type'>\n\nexport type JSONField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<JSONFieldErrorClientComponent | JSONFieldErrorServerComponent>\n      Label?: CustomComponent<JSONFieldLabelClientComponent | JSONFieldLabelServerComponent>\n    } & Admin['components']\n    editorOptions?: EditorProps['options']\n    maxHeight?: number\n  } & Admin\n\n  jsonSchema?: {\n    fileMatch: string[]\n    schema: JSONSchema4\n    uri: string\n  }\n  type: 'json'\n  validate?: JSONFieldValidation\n} & Omit<FieldBase, 'admin' | 'validate'>\n\nexport type JSONFieldClient = {\n  admin?: AdminClient & Pick<JSONField['admin'], 'editorOptions' | 'maxHeight'>\n} & Omit<FieldBaseClient, 'admin'> &\n  Pick<JSONField, 'jsonSchema' | 'type'>\n\nexport type SelectField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<SelectFieldErrorClientComponent | SelectFieldErrorServerComponent>\n      Label?: CustomComponent<SelectFieldLabelClientComponent | SelectFieldLabelServerComponent>\n    } & Admin['components']\n    isClearable?: boolean\n    isSortable?: boolean\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  /**\n   * Customize the DB enum name\n   */\n  enumName?: DBIdentifierName\n  hasMany?: boolean\n  options: Option[]\n  type: 'select'\n} & (\n  | {\n      hasMany: true\n      validate?: SelectFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      validate?: SelectFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type SelectFieldClient = {\n  admin?: AdminClient & Pick<SelectField['admin'], 'isClearable' | 'isSortable'>\n} & FieldBaseClient &\n  Pick<SelectField, 'hasMany' | 'options' | 'type'>\n\ntype SharedRelationshipProperties = {\n  filterOptions?: FilterOptions\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'relationship'\n} & (\n  | {\n      hasMany: true\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: number\n      maxRows?: number\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: number\n      minRows?: number\n      validate?: RelationshipFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: undefined\n      maxRows?: undefined\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: undefined\n      minRows?: undefined\n      validate?: RelationshipFieldSingleValidation\n    }\n) &\n  FieldGraphQLType &\n  Omit<FieldBase, 'validate'>\n\ntype SharedRelationshipPropertiesClient = FieldBaseClient &\n  Pick<\n    SharedRelationshipProperties,\n    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'\n  >\n\ntype RelationshipAdmin = {\n  allowCreate?: boolean\n  allowEdit?: boolean\n  components?: {\n    afterInput?: CustomComponent[]\n    beforeInput?: CustomComponent[]\n    Error?: CustomComponent<\n      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent\n    >\n    Label?: CustomComponent<\n      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent\n    >\n  } & Admin['components']\n  isSortable?: boolean\n} & Admin\n\ntype RelationshipAdminClient = AdminClient &\n  Pick<RelationshipAdmin, 'allowCreate' | 'allowEdit' | 'isSortable'>\n\nexport type PolymorphicRelationshipField = {\n  admin?: {\n    sortOptions?: Partial<Record<CollectionSlug, string>>\n  } & RelationshipAdmin\n  relationTo: CollectionSlug[]\n} & SharedRelationshipProperties\n\nexport type PolymorphicRelationshipFieldClient = {\n  admin?: {\n    sortOptions?: Pick<PolymorphicRelationshipField['admin'], 'sortOptions'>\n  } & RelationshipAdminClient\n} & Pick<PolymorphicRelationshipField, 'relationTo'> &\n  SharedRelationshipPropertiesClient\n\nexport type SingleRelationshipField = {\n  admin?: {\n    sortOptions?: string\n  } & RelationshipAdmin\n  relationTo: CollectionSlug\n} & SharedRelationshipProperties\n\nexport type SingleRelationshipFieldClient = {\n  admin?: Partial<Pick<SingleRelationshipField['admin'], 'sortOptions'>> & RelationshipAdminClient\n} & Pick<SingleRelationshipField, 'relationTo'> &\n  SharedRelationshipPropertiesClient\n\nexport type RelationshipField = PolymorphicRelationshipField | SingleRelationshipField\n\nexport type RelationshipFieldClient =\n  | PolymorphicRelationshipFieldClient\n  | SingleRelationshipFieldClient\n\nexport type ValueWithRelation = {\n  relationTo: CollectionSlug\n  value: number | string\n}\n\nexport function valueIsValueWithRelation(value: unknown): value is ValueWithRelation {\n  return value !== null && typeof value === 'object' && 'relationTo' in value && 'value' in value\n}\n\nexport type RelationshipValue = RelationshipValueMany | RelationshipValueSingle\n\nexport type RelationshipValueMany = (number | string)[] | ValueWithRelation[]\n\nexport type RelationshipValueSingle = number | string | ValueWithRelation\n\nexport type RichTextField<\n  TValue extends object = any,\n  TAdapterProps = any,\n  TExtraProperties = object,\n> = {\n  admin?: {\n    components?: {\n      Error?: CustomComponent\n      Label?: CustomComponent\n    } & Admin['components']\n  } & Admin\n  editor?:\n    | RichTextAdapter<TValue, TAdapterProps, TExtraProperties>\n    | RichTextAdapterProvider<TValue, TAdapterProps, TExtraProperties>\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'richText'\n} & FieldBase &\n  TExtraProperties\n\nexport type RichTextFieldClient<\n  TValue extends object = any,\n  TAdapterProps = any,\n  TExtraProperties = object,\n> = FieldBaseClient &\n  Pick<RichTextField<TValue, TAdapterProps, TExtraProperties>, 'maxDepth' | 'type'> &\n  TExtraProperties\n\nexport type ArrayField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<ArrayFieldErrorClientComponent | ArrayFieldErrorServerComponent>\n      Label?: CustomComponent<ArrayFieldLabelClientComponent | ArrayFieldLabelServerComponent>\n      RowLabel?: RowLabelComponent\n    } & Admin['components']\n    initCollapsed?: boolean\n    /**\n     * Disable drag and drop sorting\n     */\n    isSortable?: boolean\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  fields: Field[]\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  labels?: Labels\n  maxRows?: number\n  minRows?: number\n  type: 'array'\n  validate?: ArrayFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type ArrayFieldClient = {\n  admin?: AdminClient & Pick<ArrayField['admin'], 'initCollapsed' | 'isSortable'>\n  fields: ClientField[]\n  labels?: LabelsClient\n} & FieldBaseClient &\n  Pick<ArrayField, 'interfaceName' | 'maxRows' | 'minRows' | 'type'>\n\nexport type RadioField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<RadioFieldErrorClientComponent | RadioFieldErrorServerComponent>\n      Label?: CustomComponent<RadioFieldLabelClientComponent | RadioFieldLabelServerComponent>\n    } & Admin['components']\n    layout?: 'horizontal' | 'vertical'\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  /**\n   * Customize the DB enum name\n   */\n  enumName?: DBIdentifierName\n  options: Option[]\n  type: 'radio'\n  validate?: RadioFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type RadioFieldClient = {\n  admin?: AdminClient & Pick<RadioField['admin'], 'layout'>\n} & FieldBaseClient &\n  Pick<RadioField, 'options' | 'type'>\n\ntype BlockFields = {\n  [key: string]: any\n  blockName?: string\n  blockType?: string\n}\n\nexport type BlockJSX = {\n  /**\n   * Override the default regex used to search for the start of the block in the JSX.\n   * By default, it's <BlockSlugHere\n   */\n  customEndRegex?:\n    | {\n        /**\n         * Whether the end match is optional. If true, the end match is\n         * not required to match for the transformer to be triggered.\n         * The entire text from regexpStart to the end of the document will then be matched.\n         */\n        optional?: true\n        regExp: RegExp\n      }\n    | RegExp\n  /**\n   * Override the default regex used to search for the start of the block in the JSX.\n   * By default, it's <BlockSlugHere/>\n   */\n  customStartRegex?: RegExp\n  /**\n   * By default, all spaces at the beginning and end of every line of the\n   * children (text between the open and close match) are removed.\n   * Set this to true to disable this behavior.\n   */\n  doNotTrimChildren?: boolean\n  /**\n   * Function that receives the data for a given block and returns a JSX representation of it.\n   *\n   * This is used to convert Lexical => JSX\n   */\n  export: (props: {\n    fields: BlockFields\n    lexicalToMarkdown?: (props: { editorState: Record<string, any> }) => string\n  }) =>\n    | {\n        children?: string\n        props?: object\n      }\n    | false\n    | string\n  /**\n   * Function that receives the markdown string and parsed\n   * JSX props for a given matched block and returns a Lexical representation of it.\n   *\n   * This is used to convert JSX => Lexical\n   */\n  import: (props: {\n    children: string\n    closeMatch: null | RegExpMatchArray // Only available when customEndRegex is set\n    htmlToLexical?: ((props: { html: string }) => any) | null\n    markdownToLexical?: (props: { markdown: string }) => Record<string, any>\n    openMatch?: RegExpMatchArray\n    props: Record<string, any>\n  }) => BlockFields | false\n}\n\nexport type Block = {\n  /**\n   * Do not set this property manually. This is set to true during sanitization, to avoid\n   * sanitizing the same block multiple times.\n   */\n  _sanitized?: boolean\n  admin?: {\n    components?: {\n      /**\n       * This will replace the entire block component, including the block header / collapsible.\n       */\n      Block?: PayloadComponent<any, any>\n      Label?: PayloadComponent<any, any>\n    }\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n    jsx?: PayloadComponent\n  }\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  fields: Field[]\n  /** @deprecated - please migrate to the interfaceName property instead. */\n  graphQL?: {\n    singularName?: string\n  }\n  imageAltText?: string\n  imageURL?: string\n  /** Customize generated GraphQL and Typescript schema names.\n   * The slug is used by default.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  jsx?: BlockJSX\n  labels?: Labels\n  slug: string\n}\n\nexport type ClientBlock = {\n  admin?: Pick<Block['admin'], 'custom'>\n  fields: ClientField[]\n  labels?: LabelsClient\n} & Pick<Block, 'imageAltText' | 'imageURL' | 'jsx' | 'slug'>\n\nexport type BlocksField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<BlocksFieldErrorClientComponent | BlocksFieldErrorServerComponent>\n    } & Admin['components']\n    initCollapsed?: boolean\n    /**\n     * Disable drag and drop sorting\n     */\n    isSortable?: boolean\n  } & Admin\n  blocks: Block[]\n  defaultValue?: DefaultValue\n  labels?: Labels\n  maxRows?: number\n  minRows?: number\n  type: 'blocks'\n  validate?: BlocksFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type BlocksFieldClient = {\n  admin?: AdminClient & Pick<BlocksField['admin'], 'initCollapsed' | 'isSortable'>\n  blocks: ClientBlock[]\n  labels?: LabelsClient\n} & FieldBaseClient &\n  Pick<BlocksField, 'maxRows' | 'minRows' | 'type'>\n\nexport type PointField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<PointFieldErrorClientComponent | PointFieldErrorServerComponent>\n      Label?: CustomComponent<PointFieldLabelClientComponent | PointFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    step?: number\n  } & Admin\n  type: 'point'\n  validate?: PointFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type PointFieldClient = {\n  admin?: AdminClient & Pick<PointField['admin'], 'placeholder' | 'step'>\n} & FieldBaseClient &\n  Pick<PointField, 'type'>\n\n/**\n * A virtual field that loads in related collections by querying a relationship or upload field.\n */\nexport type JoinField = {\n  access?: {\n    create?: never\n    read?: FieldAccess\n    update?: never\n  }\n  admin?: {\n    allowCreate?: boolean\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<JoinFieldErrorClientComponent | JoinFieldErrorServerComponent>\n      Label?: CustomComponent<JoinFieldLabelClientComponent | JoinFieldLabelServerComponent>\n    } & Admin['components']\n    defaultColumns?: string[]\n    disableBulkEdit?: never\n    readOnly?: never\n  } & Admin\n  /**\n   * The slug of the collection to relate with.\n   */\n  collection: CollectionSlug\n  defaultLimit?: number\n  defaultSort?: Sort\n  defaultValue?: never\n  /**\n   * This does not need to be set and will be overridden by the relationship field's hasMany property.\n   */\n  hasMany?: boolean\n  hidden?: false\n  index?: never\n  /**\n   * This does not need to be set and will be overridden by the relationship field's localized property.\n   */\n  localized?: boolean\n  maxDepth?: number\n  /**\n   * A string for the field in the collection being joined to.\n   */\n  on: string\n  type: 'join'\n  validate?: never\n  where?: Where\n} & FieldBase &\n  FieldGraphQLType\n\nexport type JoinFieldClient = {\n  admin?: AdminClient &\n    Pick<JoinField['admin'], 'allowCreate' | 'defaultColumns' | 'disableBulkEdit' | 'readOnly'>\n} & { targetField: Pick<RelationshipFieldClient, 'relationTo'> } & FieldBaseClient &\n  Pick<\n    JoinField,\n    'collection' | 'defaultLimit' | 'defaultSort' | 'index' | 'maxDepth' | 'on' | 'type' | 'where'\n  >\n\nexport type FlattenedBlock = {\n  flattenedFields: FlattenedField[]\n} & Block\n\nexport type FlattenedBlocksField = {\n  blocks: FlattenedBlock[]\n} & BlocksField\n\nexport type FlattenedGroupField = {\n  flattenedFields: FlattenedField[]\n} & GroupField\n\nexport type FlattenedArrayField = {\n  flattenedFields: FlattenedField[]\n} & ArrayField\n\nexport type FlattenedTabAsField = {\n  flattenedFields: FlattenedField[]\n} & MarkRequired<TabAsField, 'name'>\n\nexport type FlattenedJoinField = {\n  targetField: RelationshipField | UploadField\n} & JoinField\n\nexport type FlattenedField =\n  | CheckboxField\n  | CodeField\n  | DateField\n  | EmailField\n  | FlattenedArrayField\n  | FlattenedBlocksField\n  | FlattenedGroupField\n  | FlattenedJoinField\n  | FlattenedTabAsField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | SelectField\n  | TextareaField\n  | TextField\n  | UploadField\nexport type Field =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | CollapsibleField\n  | DateField\n  | EmailField\n  | GroupField\n  | JoinField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | RowField\n  | SelectField\n  | TabsField\n  | TextareaField\n  | TextField\n  | UIField\n  | UploadField\n\nexport type ClientField =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | CollapsibleFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JoinFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | RowFieldClient\n  | SelectFieldClient\n  | TabsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UIFieldClient\n  | UploadFieldClient\n\nexport type ClientFieldProps =\n  | ArrayFieldClientProps\n  | BlocksFieldClientProps\n  | CheckboxFieldClientProps\n  | CodeFieldClientProps\n  | CollapsibleFieldClientProps\n  | DateFieldClientProps\n  | EmailFieldClientProps\n  | GroupFieldClientProps\n  | HiddenFieldProps\n  | JoinFieldClientProps\n  | JSONFieldClientProps\n  | NumberFieldClientProps\n  | PointFieldClientProps\n  | RadioFieldClientProps\n  | RelationshipFieldClientProps\n  | RichTextFieldClientProps\n  | RowFieldClientProps\n  | SelectFieldClientProps\n  | TabsFieldClientProps\n  | TextareaFieldClientProps\n  | TextFieldClientProps\n  | UploadFieldClientProps\n\ntype ExtractFieldTypes<T> = T extends { type: infer U } ? U : never\n\nexport type FieldTypes = ExtractFieldTypes<Field>\n\nexport type FieldAffectingData =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | DateField\n  | EmailField\n  | GroupField\n  | JoinField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | SelectField\n  | TabAsField\n  | TextareaField\n  | TextField\n  | UploadField\n\nexport type FieldAffectingDataClient =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JoinFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | SelectFieldClient\n  | TabAsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UploadFieldClient\n\nexport type NonPresentationalField =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | CollapsibleField\n  | DateField\n  | EmailField\n  | GroupField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | RowField\n  | SelectField\n  | TabsField\n  | TextareaField\n  | TextField\n  | UploadField\n\nexport type NonPresentationalFieldClient =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | CollapsibleFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | RowFieldClient\n  | SelectFieldClient\n  | TabsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UploadFieldClient\n\nexport type FieldWithPath = {\n  path?: string\n} & Field\n\nexport type FieldWithPathClient = {\n  path?: string\n} & ClientField\n\nexport type FieldWithSubFields = ArrayField | CollapsibleField | GroupField | RowField\n\nexport type FieldWithSubFieldsClient =\n  | ArrayFieldClient\n  | CollapsibleFieldClient\n  | GroupFieldClient\n  | RowFieldClient\n\nexport type FieldPresentationalOnly = UIField\nexport type FieldPresentationalOnlyClient = UIFieldClient\n\nexport type FieldWithMany = RelationshipField | SelectField\nexport type FieldWithManyClient = RelationshipFieldClient | SelectFieldClient\n\nexport type FieldWithMaxDepth = RelationshipField | UploadField\nexport type FieldWithMaxDepthClient = JoinFieldClient | RelationshipFieldClient | UploadFieldClient\n\nexport function fieldHasSubFields<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithSubFieldsClient : FieldWithSubFields) {\n  return (\n    field.type === 'group' ||\n    field.type === 'array' ||\n    field.type === 'row' ||\n    field.type === 'collapsible'\n  )\n}\n\nexport function fieldIsArrayType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? ArrayFieldClient : ArrayField) {\n  return field.type === 'array'\n}\n\nexport function fieldIsBlockType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? BlocksFieldClient : BlocksField) {\n  return field.type === 'blocks'\n}\n\nexport function fieldIsGroupType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? GroupFieldClient : GroupField) {\n  return field.type === 'group'\n}\n\nexport function optionIsObject(option: Option): option is OptionObject {\n  return typeof option === 'object'\n}\n\nexport function optionsAreObjects(options: Option[]): options is OptionObject[] {\n  return Array.isArray(options) && typeof options?.[0] === 'object'\n}\n\nexport function optionIsValue(option: Option): option is string {\n  return typeof option === 'string'\n}\n\nexport function fieldSupportsMany<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithManyClient : FieldWithMany) {\n  return field.type === 'select' || field.type === 'relationship' || field.type === 'upload'\n}\n\nexport function fieldHasMaxDepth<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithMaxDepthClient : FieldWithMaxDepth) {\n  return (\n    (field.type === 'upload' || field.type === 'relationship' || field.type === 'join') &&\n    typeof field.maxDepth === 'number'\n  )\n}\n\nexport function fieldIsPresentationalOnly<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(\n  field: TField,\n): field is TField & (TField extends ClientField | TabAsFieldClient ? UIFieldClient : UIField) {\n  return field.type === 'ui'\n}\n\nexport function fieldIsSidebar<TField extends ClientField | Field | TabAsField | TabAsFieldClient>(\n  field: TField,\n): field is { admin: { position: 'sidebar' } } & TField {\n  return 'admin' in field && 'position' in field.admin && field.admin.position === 'sidebar'\n}\n\nexport function fieldIsID<TField extends ClientField | Field>(\n  field: TField,\n): field is { name: 'id' } & TField {\n  return 'name' in field && field.name === 'id'\n}\n\nexport function fieldIsHiddenOrDisabled<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(field: TField): field is { admin: { hidden: true } } & TField {\n  return (\n    ('hidden' in field && field.hidden) ||\n    ('admin' in field && 'disabled' in field.admin && field.admin.disabled)\n  )\n}\n\nexport function fieldAffectsData<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(\n  field: TField,\n): field is TField &\n  (TField extends ClientField | TabAsFieldClient ? FieldAffectingDataClient : FieldAffectingData) {\n  return 'name' in field && !fieldIsPresentationalOnly(field)\n}\n\nexport function tabHasName<TField extends ClientTab | Tab>(tab: TField): tab is NamedTab & TField {\n  return 'name' in tab\n}\n\nexport function fieldIsLocalized(field: Field | Tab): boolean {\n  return 'localized' in field && field.localized\n}\n\nexport function fieldIsVirtual(field: Field | Tab): boolean {\n  return 'virtual' in field && field.virtual\n}\n\nexport type HookName =\n  | 'afterChange'\n  | 'afterRead'\n  | 'beforeChange'\n  | 'beforeRead'\n  | 'beforeValidate'\n"],"names":["valueIsValueWithRelation","value","fieldHasSubFields","field","type","fieldIsArrayType","fieldIsBlockType","fieldIsGroupType","optionIsObject","option","optionsAreObjects","options","Array","isArray","optionIsValue","fieldSupportsMany","fieldHasMaxDepth","maxDepth","fieldIsPresentationalOnly","fieldIsSidebar","admin","position","fieldIsID","name","fieldIsHiddenOrDisabled","hidden","disabled","fieldAffectsData","tabHasName","tab","fieldIsLocalized","localized","fieldIsVirtual","virtual"],"mappings":"AAAA,qDAAqD,GAklCrD;;;;;;;;;;;;;;;;;;;;AAAO,SAASA,yBAAyBC,KAAc;IACrD,OAAOA,UAAU,QAAQ,OAAOA,UAAU,YAAY,gBAAgBA,SAAS,WAAWA;AAC5F;AAgjBO,SAASC,kBACdC,KAAa;IAEb,OACEA,MAAMC,IAAI,KAAK,WACfD,MAAMC,IAAI,KAAK,WACfD,MAAMC,IAAI,KAAK,SACfD,MAAMC,IAAI,KAAK;AAEnB;AAEO,SAASC,iBACdF,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASE,iBACdH,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASG,iBACdJ,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASI,eAAeC,MAAc;IAC3C,OAAO,OAAOA,WAAW;AAC3B;AAEO,SAASC,kBAAkBC,OAAiB;IACjD,OAAOC,MAAMC,OAAO,CAACF,YAAY,OAAOA,SAAS,CAAC,EAAE,KAAK;AAC3D;AAEO,SAASG,cAAcL,MAAc;IAC1C,OAAO,OAAOA,WAAW;AAC3B;AAEO,SAASM,kBACdZ,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK,YAAYD,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK;AACpF;AAEO,SAASY,iBACdb,KAAa;IAEb,OACGA,CAAAA,MAAMC,IAAI,KAAK,YAAYD,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK,MAAK,KACjF,OAAOD,MAAMc,QAAQ,KAAK;AAE9B;AAEO,SAASC,0BAGdf,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASe,eACdhB,KAAa;IAEb,OAAO,WAAWA,SAAS,cAAcA,MAAMiB,KAAK,IAAIjB,MAAMiB,KAAK,CAACC,QAAQ,KAAK;AACnF;AAEO,SAASC,UACdnB,KAAa;IAEb,OAAO,UAAUA,SAASA,MAAMoB,IAAI,KAAK;AAC3C;AAEO,SAASC,wBAEdrB,KAAa;IACb,OACG,YAAYA,SAASA,MAAMsB,MAAM,IACjC,WAAWtB,SAAS,cAAcA,MAAMiB,KAAK,IAAIjB,MAAMiB,KAAK,CAACM,QAAQ;AAE1E;AAEO,SAASC,iBAGdxB,KAAa;IAGb,OAAO,UAAUA,SAAS,CAACe,0BAA0Bf;AACvD;AAEO,SAASyB,WAA2CC,GAAW;IACpE,OAAO,UAAUA;AACnB;AAEO,SAASC,iBAAiB3B,KAAkB;IACjD,OAAO,eAAeA,SAASA,MAAM4B,SAAS;AAChD;AAEO,SAASC,eAAe7B,KAAkB;IAC/C,OAAO,aAAaA,SAASA,MAAM8B,OAAO;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/getFieldPaths.ts"],"sourcesContent":["import type { ClientField, Field, TabAsField, TabAsFieldClient } from './config/types.js'\n\ntype Args = {\n  field: ClientField | Field | TabAsField | TabAsFieldClient\n  index: number\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n}\n\ntype Result = {\n  /**\n   * A string of '-' separated indexes representing where\n   * to find this field in a given field schema array.\n   * It will always be complete and accurate.\n   */\n  indexPath: string\n  /**\n   * Path for this field specifically.\n   */\n  path: string\n  /**\n   * Schema path for this field specifically.\n   */\n  schemaPath: string\n}\n\nexport function getFieldPaths({\n  field,\n  index,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n}: Args): Result {\n  if ('name' in field) {\n    return {\n      indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,\n      path: `${parentPath ? parentPath + '.' : ''}${field.name}`,\n      schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${field.name}`,\n    }\n  }\n\n  const indexSuffix = `_index-${`${parentIndexPath ? parentIndexPath + '-' : ''}${index}`}`\n\n  return {\n    indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,\n    path: `${parentPath ? parentPath + '.' : ''}${indexSuffix}`,\n    schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${indexSuffix}`,\n  }\n}\n"],"names":["getFieldPaths","field","index","parentIndexPath","parentPath","parentSchemaPath","indexPath","path","name","schemaPath","indexSuffix"],"mappings":";;;AA2BO,SAASA,cAAc,EAC5BC,KAAK,EACLC,KAAK,EACLC,eAAe,EACfC,UAAU,EACVC,gBAAgB,EACX;IACL,IAAI,UAAUJ,OAAO;QACnB,OAAO;YACLK,WAAW,GAAGH,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO;YACpEK,MAAM,GAAGH,aAAaA,aAAa,MAAM,KAAKH,MAAMO,IAAI,EAAE;YAC1DC,YAAY,GAAGJ,mBAAmBA,mBAAmB,MAAM,KAAKJ,MAAMO,IAAI,EAAE;QAC9E;IACF;IAEA,MAAME,cAAc,CAAC,OAAO,EAAE,GAAGP,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO,EAAE;IAEzF,OAAO;QACLI,WAAW,GAAGH,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO;QACpEK,MAAM,GAAGH,aAAaA,aAAa,MAAM,KAAKM,aAAa;QAC3DD,YAAY,GAAGJ,mBAAmBA,mBAAmB,MAAM,KAAKK,aAAa;IAC/E;AACF","ignoreList":[0]}},
    {"offset": {"line": 105, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/validations.ts"],"sourcesContent":["import Ajv from 'ajv'\nimport ObjectIdImport from 'bson-objectid'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nimport type { RichTextAdapter } from '../admin/types.js'\nimport type { CollectionSlug } from '../index.js'\nimport type { Where } from '../types/index.js'\nimport type {\n  ArrayField,\n  BlocksField,\n  CheckboxField,\n  CodeField,\n  DateField,\n  EmailField,\n  JSONField,\n  NumberField,\n  PointField,\n  RadioField,\n  RelationshipField,\n  RelationshipValue,\n  RelationshipValueMany,\n  RelationshipValueSingle,\n  RichTextField,\n  SelectField,\n  TextareaField,\n  TextField,\n  UploadField,\n  Validate,\n} from './config/types.js'\n\nimport { isNumber } from '../utilities/isNumber.js'\nimport { isValidID } from '../utilities/isValidID.js'\n\nexport type TextFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport type TextFieldManyValidation = Validate<string[], unknown, unknown, TextField>\n\nexport type TextFieldSingleValidation = Validate<string, unknown, unknown, TextField>\n\nexport const text: TextFieldValidation = (\n  value,\n  {\n    hasMany,\n    maxLength: fieldMaxLength,\n    maxRows,\n    minLength,\n    minRows,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (!required) {\n    if (!value) {\n      return true\n    }\n  }\n\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  const stringsToValidate: string[] = Array.isArray(value) ? value : [value]\n\n  for (const stringValue of stringsToValidate) {\n    const length = stringValue?.length || 0\n\n    if (typeof maxLength === 'number' && length > maxLength) {\n      return t('validation:shorterThanMax', { label: t('general:value'), maxLength, stringValue })\n    }\n\n    if (typeof minLength === 'number' && length < minLength) {\n      return t('validation:longerThanMin', { label: t('general:value'), minLength, stringValue })\n    }\n  }\n\n  if (required) {\n    if (!(typeof value === 'string' || Array.isArray(value)) || value?.length === 0) {\n      return t('validation:required')\n    }\n  }\n\n  return true\n}\n\nexport type PasswordFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport const password: PasswordFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength = 3,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type ConfirmPasswordFieldValidation = Validate<\n  string,\n  unknown,\n  { password: string },\n  TextField\n>\n\nexport const confirmPassword: ConfirmPasswordFieldValidation = (\n  value,\n  { req: { t }, required, siblingData },\n) => {\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (value && value !== siblingData.password) {\n    return t('fields:passwordsDoNotMatch')\n  }\n\n  return true\n}\n\nexport type EmailFieldValidation = Validate<string, unknown, { username?: string }, EmailField>\n\nexport const email: EmailFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  if (collectionSlug) {\n    const collection = config.collections.find(({ slug }) => slug === collectionSlug)\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.username) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  if ((value && !/\\S[^\\s@]*@\\S+\\.\\S+/.test(value)) || (!value && required)) {\n    return t('validation:emailAddress')\n  }\n\n  return true\n}\n\nexport type UsernameFieldValidation = Validate<string, unknown, { email?: string }, TextField>\n\nexport const username: UsernameFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  let maxLength: number\n\n  if (collectionSlug) {\n    const collection = config.collections.find(({ slug }) => slug === collectionSlug)\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.email) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (!value && required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type TextareaFieldValidation = Validate<string, unknown, unknown, TextareaField>\n\nexport const textarea: TextareaFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type CodeFieldValidation = Validate<string, unknown, unknown, CodeField>\n\nexport const code: CodeFieldValidation = (value, { req: { t }, required }) => {\n  if (required && value === undefined) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type JSONFieldValidation = Validate<\n  string,\n  unknown,\n  unknown,\n  { jsonError?: string } & JSONField\n>\n\nexport const json: JSONFieldValidation = async (\n  value,\n  { jsonError, jsonSchema, req: { t }, required },\n) => {\n  const isNotEmpty = (value) => {\n    if (value === undefined || value === null) {\n      return false\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false\n    }\n\n    if (typeof value === 'object' && Object.keys(value).length === 0) {\n      return false\n    }\n\n    return true\n  }\n\n  const fetchSchema = ({ schema, uri }: Record<string, unknown>) => {\n    if (uri && schema) {\n      return schema\n    }\n    // @ts-expect-error\n    return fetch(uri)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok')\n        }\n        return response.json()\n      })\n      .then((json) => {\n        const jsonSchemaSanitizations = {\n          id: undefined,\n          $id: json.id,\n          $schema: 'http://json-schema.org/draft-07/schema#',\n        }\n\n        return Object.assign(json, jsonSchemaSanitizations)\n      })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (jsonError !== undefined) {\n    return t('validation:invalidInput')\n  }\n\n  if (jsonSchema && isNotEmpty(value)) {\n    try {\n      jsonSchema.schema = await fetchSchema(jsonSchema)\n      const { schema } = jsonSchema\n      // @ts-expect-error\n      const ajv = new Ajv()\n\n      if (!ajv.validate(schema, value)) {\n        return t(ajv.errorsText())\n      }\n    } catch (error) {\n      return t(error.message)\n    }\n  }\n  return true\n}\n\nexport type CheckboxFieldValidation = Validate<boolean, unknown, unknown, CheckboxField>\n\nexport const checkbox: CheckboxFieldValidation = (value, { req: { t }, required }) => {\n  if ((value && typeof value !== 'boolean') || (required && typeof value !== 'boolean')) {\n    return t('validation:trueOrFalse')\n  }\n\n  return true\n}\n\nexport type DateFieldValidation = Validate<Date, unknown, unknown, DateField>\n\nexport const date: DateFieldValidation = (value, { req: { t }, required }) => {\n  if (value && !isNaN(Date.parse(value.toString()))) {\n    return true\n  }\n\n  if (value) {\n    return t('validation:notValidDate', { value })\n  }\n\n  if (required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RichTextFieldValidation = Validate<object, unknown, unknown, RichTextField>\n\nexport const richText: RichTextFieldValidation = async (value, options) => {\n  if (!options?.editor) {\n    throw new Error('richText field has no editor property.')\n  }\n  if (typeof options?.editor === 'function') {\n    throw new Error('Attempted to access unsanitized rich text editor.')\n  }\n\n  const editor: RichTextAdapter = options?.editor\n\n  return editor.validate(value, options)\n}\n\nconst validateArrayLength = (\n  value,\n  options: {\n    maxRows?: number\n    minRows?: number\n    required?: boolean\n    t: (key: string, options?: { [key: string]: number | string }) => string\n  },\n) => {\n  const { maxRows, minRows, required, t } = options\n\n  const arrayLength = Array.isArray(value) ? value.length : value || 0\n\n  if (!required && arrayLength === 0) {\n    return true\n  }\n\n  if (minRows && arrayLength < minRows) {\n    return t('validation:requiresAtLeast', { count: minRows, label: t('general:rows') })\n  }\n\n  if (maxRows && arrayLength > maxRows) {\n    return t('validation:requiresNoMoreThan', { count: maxRows, label: t('general:rows') })\n  }\n\n  if (required && !arrayLength) {\n    return t('validation:requiresAtLeast', { count: 1, label: t('general:row') })\n  }\n\n  return true\n}\n\nexport type NumberFieldValidation = Validate<number | number[], unknown, unknown, NumberField>\n\nexport type NumberFieldManyValidation = Validate<number[], unknown, unknown, NumberField>\n\nexport type NumberFieldSingleValidation = Validate<number, unknown, unknown, NumberField>\n\nexport const number: NumberFieldValidation = (\n  value,\n  { hasMany, max, maxRows, min, minRows, req: { t }, required },\n) => {\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (!value && !isNumber(value)) {\n    // if no value is present, validate based on required\n    if (required) {\n      return t('validation:required')\n    }\n    if (!required) {\n      return true\n    }\n  }\n\n  const numbersToValidate: number[] = Array.isArray(value) ? value : [value]\n\n  for (const number of numbersToValidate) {\n    if (!isNumber(number)) {\n      return t('validation:enterNumber')\n    }\n\n    const numberValue = parseFloat(number as unknown as string)\n\n    if (typeof max === 'number' && numberValue > max) {\n      return t('validation:greaterThanMax', { label: t('general:value'), max, value })\n    }\n\n    if (typeof min === 'number' && numberValue < min) {\n      return t('validation:lessThanMin', { label: t('general:value'), min, value })\n    }\n  }\n\n  return true\n}\n\nexport type ArrayFieldValidation = Validate<unknown[], unknown, unknown, ArrayField>\n\nexport const array: ArrayFieldValidation = (value, { maxRows, minRows, req: { t }, required }) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nexport type BlocksFieldValidation = Validate<unknown, unknown, unknown, BlocksField>\n\nexport const blocks: BlocksFieldValidation = (\n  value,\n  { maxRows, minRows, req: { t }, required },\n) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nconst validateFilterOptions: Validate<\n  unknown,\n  unknown,\n  unknown,\n  RelationshipField | UploadField\n> = async (\n  value,\n  { id, data, filterOptions, relationTo, req, req: { payload, t, user }, siblingData },\n) => {\n  if (typeof filterOptions !== 'undefined' && value) {\n    const options: {\n      [collection: string]: (number | string)[]\n    } = {}\n\n    const falseCollections: CollectionSlug[] = []\n    const collections = !Array.isArray(relationTo) ? [relationTo] : relationTo\n    const values = Array.isArray(value) ? value : [value]\n\n    for (const collection of collections) {\n      try {\n        let optionFilter =\n          typeof filterOptions === 'function'\n            ? await filterOptions({\n                id,\n                data,\n                relationTo: collection,\n                siblingData,\n                user,\n              })\n            : filterOptions\n\n        if (optionFilter === true) {\n          optionFilter = null\n        }\n\n        const valueIDs: (number | string)[] = []\n\n        values.forEach((val) => {\n          if (typeof val === 'object') {\n            if (val?.value) {\n              valueIDs.push(val.value)\n            } else if (ObjectId.isValid(val)) {\n              valueIDs.push(new ObjectId(val).toHexString())\n            }\n          }\n\n          if (typeof val === 'string' || typeof val === 'number') {\n            valueIDs.push(val)\n          }\n        })\n\n        if (valueIDs.length > 0) {\n          const findWhere: Where = {\n            and: [{ id: { in: valueIDs } }],\n          }\n\n          if (optionFilter && optionFilter !== true) {\n            findWhere.and.push(optionFilter)\n          }\n\n          if (optionFilter === false) {\n            falseCollections.push(collection)\n          }\n\n          const result = await payload.find({\n            collection,\n            depth: 0,\n            limit: 0,\n            pagination: false,\n            req,\n            where: findWhere,\n          })\n\n          options[collection] = result.docs.map((doc) => doc.id)\n        } else {\n          options[collection] = []\n        }\n      } catch (err) {\n        req.payload.logger.error({\n          err,\n          msg: `Error validating filter options for collection ${collection}`,\n        })\n        options[collection] = []\n      }\n    }\n\n    const invalidRelationships = values.filter((val) => {\n      let collection: string\n      let requestedID: number | string\n\n      if (typeof relationTo === 'string') {\n        collection = relationTo\n\n        if (typeof val === 'string' || typeof val === 'number') {\n          requestedID = val\n        }\n\n        if (typeof val === 'object' && ObjectId.isValid(val)) {\n          requestedID = new ObjectId(val).toHexString()\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collection = val.relationTo\n        requestedID = val.value\n      }\n\n      if (falseCollections.find((slug) => relationTo === slug)) {\n        return true\n      }\n\n      if (!options[collection]) {\n        return true\n      }\n\n      return options[collection].indexOf(requestedID) === -1\n    })\n\n    if (invalidRelationships.length > 0) {\n      return invalidRelationships.reduce((err, invalid, i) => {\n        return `${err} ${JSON.stringify(invalid)}${\n          invalidRelationships.length === i + 1 ? ',' : ''\n        } `\n      }, t('validation:invalidSelections')) as string\n    }\n\n    return true\n  }\n\n  return true\n}\n\nexport type UploadFieldValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport type UploadFieldManyValidation = Validate<unknown[], unknown, unknown, UploadField>\n\nexport type UploadFieldSingleValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport const upload: UploadFieldValidation = async (value, options) => {\n  const {\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type RelationshipFieldValidation = Validate<\n  RelationshipValue,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldManyValidation = Validate<\n  RelationshipValueMany,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldSingleValidation = Validate<\n  RelationshipValueSingle,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport const relationship: RelationshipFieldValidation = async (value, options) => {\n  const {\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type SelectFieldValidation = Validate<string | string[], unknown, unknown, SelectField>\n\nexport type SelectFieldManyValidation = Validate<string[], unknown, unknown, SelectField>\n\nexport type SelectFieldSingleValidation = Validate<string, unknown, unknown, SelectField>\n\nexport const select: SelectFieldValidation = (\n  value,\n  { hasMany, options, req: { t }, required },\n) => {\n  if (\n    Array.isArray(value) &&\n    value.some(\n      (input) =>\n        !options.some(\n          (option) => option === input || (typeof option !== 'string' && option?.value === input),\n        ),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    typeof value === 'string' &&\n    !options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    required &&\n    (typeof value === 'undefined' ||\n      value === null ||\n      (hasMany && Array.isArray(value) && (value as [])?.length === 0))\n  ) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RadioFieldValidation = Validate<unknown, unknown, unknown, RadioField>\n\nexport const radio: RadioFieldValidation = (value, { options, req: { t }, required }) => {\n  if (value) {\n    const valueMatchesOption = options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n    return valueMatchesOption || t('validation:invalidSelection')\n  }\n\n  return required ? t('validation:required') : true\n}\n\nexport type PointFieldValidation = Validate<\n  [number | string, number | string],\n  unknown,\n  unknown,\n  PointField\n>\n\nexport const point: PointFieldValidation = (value = ['', ''], { req: { t }, required }) => {\n  const lng = parseFloat(String(value[0]))\n  const lat = parseFloat(String(value[1]))\n  if (\n    required &&\n    ((value[0] && value[1] && typeof lng !== 'number' && typeof lat !== 'number') ||\n      Number.isNaN(lng) ||\n      Number.isNaN(lat) ||\n      (Array.isArray(value) && value.length !== 2))\n  ) {\n    return t('validation:requiresTwoNumbers')\n  }\n\n  if ((value[1] && Number.isNaN(lng)) || (value[0] && Number.isNaN(lat))) {\n    return t('validation:invalidInput')\n  }\n\n  return true\n}\n\n/**\n * Built-in field validations used by Payload\n *\n * These can be re-used in custom validations\n */\nexport const validations = {\n  array,\n  blocks,\n  checkbox,\n  code,\n  confirmPassword,\n  date,\n  email,\n  json,\n  number,\n  password,\n  point,\n  radio,\n  relationship,\n  richText,\n  select,\n  text,\n  textarea,\n  upload,\n}\n"],"names":["Ajv","ObjectIdImport","ObjectId","default","isNumber","isValidID","text","value","hasMany","maxLength","fieldMaxLength","maxRows","minLength","minRows","req","payload","config","t","required","lengthValidationResult","validateArrayLength","defaultMaxTextLength","stringsToValidate","Array","isArray","stringValue","length","label","password","confirmPassword","siblingData","email","collectionSlug","collection","collections","find","slug","auth","loginWithUsername","requireUsername","requireEmail","username","test","textarea","code","undefined","json","jsonError","jsonSchema","isNotEmpty","Object","keys","fetchSchema","schema","uri","fetch","then","response","ok","Error","jsonSchemaSanitizations","id","$id","$schema","assign","ajv","validate","errorsText","error","message","checkbox","date","isNaN","Date","parse","toString","richText","options","editor","arrayLength","count","number","max","min","numbersToValidate","numberValue","parseFloat","array","blocks","validateFilterOptions","data","filterOptions","relationTo","user","falseCollections","values","optionFilter","valueIDs","forEach","val","push","isValid","toHexString","findWhere","and","in","result","depth","limit","pagination","where","docs","map","doc","err","logger","msg","invalidRelationships","filter","requestedID","indexOf","reduce","invalid","i","JSON","stringify","upload","idType","customIDType","db","defaultIDType","join","relationship","select","some","input","option","radio","valueMatchesOption","point","lng","String","lat","Number","validations"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 725, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 731, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/config/sanitizeJoinField.ts"],"sourcesContent":["import type { SanitizedJoin, SanitizedJoins } from '../../collections/config/types.js'\nimport type { Config } from '../../config/types.js'\nimport type { FlattenedJoinField, JoinField, RelationshipField, UploadField } from './types.js'\n\nimport { APIError } from '../../errors/index.js'\nimport { InvalidFieldJoin } from '../../errors/InvalidFieldJoin.js'\nimport { traverseFields } from '../../utilities/traverseFields.js'\nexport const sanitizeJoinField = ({\n  config,\n  field,\n  joinPath,\n  joins,\n}: {\n  config: Config\n  field: FlattenedJoinField | JoinField\n  joinPath?: string\n  joins?: SanitizedJoins\n}) => {\n  // the `joins` arg is not passed for globals or when recursing on fields that do not allow a join field\n  if (typeof joins === 'undefined') {\n    throw new APIError('Join fields cannot be added to arrays, blocks or globals.')\n  }\n  if (!field.maxDepth) {\n    field.maxDepth = 1\n  }\n  const join: SanitizedJoin = {\n    field,\n    joinPath: `${joinPath ? joinPath + '.' : ''}${field.name}`,\n    targetField: undefined,\n  }\n  const joinCollection = config.collections.find(\n    (collection) => collection.slug === field.collection,\n  )\n  if (!joinCollection) {\n    throw new InvalidFieldJoin(field)\n  }\n  let joinRelationship: RelationshipField | UploadField\n\n  const pathSegments = field.on.split('.') // Split the schema path into segments\n  let currentSegmentIndex = 0\n\n  // Traverse fields and match based on the schema path\n  traverseFields({\n    callback: ({ field, next }) => {\n      if (!('name' in field) || !field.name) {\n        return\n      }\n      const currentSegment = pathSegments[currentSegmentIndex]\n      // match field on path segments\n      if ('name' in field && field.name === currentSegment) {\n        // Check if this is the last segment in the path\n        if (\n          (currentSegmentIndex === pathSegments.length - 1 &&\n            'type' in field &&\n            field.type === 'relationship') ||\n          field.type === 'upload'\n        ) {\n          joinRelationship = field // Return the matched field\n          next()\n          return true\n        } else {\n          // Move to the next path segment and continue traversal\n          currentSegmentIndex++\n        }\n      } else {\n        // skip fields in non-matching path segments\n        next()\n        return\n      }\n    },\n    fields: joinCollection.fields,\n  })\n\n  if (!joinRelationship) {\n    throw new InvalidFieldJoin(join.field)\n  }\n\n  join.targetField = joinRelationship\n\n  // override the join field localized property to use whatever the relationship field has\n  field.localized = joinRelationship.localized\n  // override the join field hasMany property to use whatever the relationship field has\n  field.hasMany = joinRelationship.hasMany\n\n  // @ts-expect-error converting JoinField to FlattenedJoinField to track targetField\n  field.targetField = join.targetField\n\n  if (!joins[field.collection]) {\n    joins[field.collection] = [join]\n  } else {\n    joins[field.collection].push(join)\n  }\n}\n"],"names":["APIError","InvalidFieldJoin","traverseFields","sanitizeJoinField","config","field","joinPath","joins","maxDepth","join","name","targetField","undefined","joinCollection","collections","find","collection","slug","joinRelationship","pathSegments","on","split","currentSegmentIndex","callback","next","currentSegment","length","type","fields","localized","hasMany","push"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,gBAAgB,QAAQ,mCAAkC;AACnE,SAASC,cAAc,QAAQ,oCAAmC;;;;AAC3D,MAAMC,oBAAoB,CAAC,EAChCC,MAAM,EACNC,KAAK,EACLC,QAAQ,EACRC,KAAK,EAMN;IACC,uGAAuG;IACvG,IAAI,OAAOA,UAAU,aAAa;QAChC,MAAM,+WAAIP,YAAAA,CAAS;IACrB;IACA,IAAI,CAACK,MAAMG,QAAQ,EAAE;QACnBH,MAAMG,QAAQ,GAAG;IACnB;IACA,MAAMC,OAAsB;QAC1BJ;QACAC,UAAU,GAAGA,WAAWA,WAAW,MAAM,KAAKD,MAAMK,IAAI,EAAE;QAC1DC,aAAaC;IACf;IACA,MAAMC,iBAAiBT,OAAOU,WAAW,CAACC,IAAI,CAC5C,CAACC,aAAeA,WAAWC,IAAI,KAAKZ,MAAMW,UAAU;IAEtD,IAAI,CAACH,gBAAgB;QACnB,MAAM,IAAIZ,uYAAAA,CAAiBI;IAC7B;IACA,IAAIa;IAEJ,MAAMC,eAAed,MAAMe,EAAE,CAACC,KAAK,CAAC,KAAK,sCAAsC;;IAC/E,IAAIC,sBAAsB;IAE1B,qDAAqD;6XACrDpB,iBAAAA,EAAe;QACbqB,UAAU,CAAC,EAAElB,KAAK,EAAEmB,IAAI,EAAE;YACxB,IAAI,CAAE,CAAA,UAAUnB,KAAI,KAAM,CAACA,MAAMK,IAAI,EAAE;gBACrC;YACF;YACA,MAAMe,iBAAiBN,YAAY,CAACG,oBAAoB;YACxD,+BAA+B;YAC/B,IAAI,UAAUjB,SAASA,MAAMK,IAAI,KAAKe,gBAAgB;gBACpD,gDAAgD;gBAChD,IACGH,wBAAwBH,aAAaO,MAAM,GAAG,KAC7C,UAAUrB,SACVA,MAAMsB,IAAI,KAAK,kBACjBtB,MAAMsB,IAAI,KAAK,UACf;oBACAT,mBAAmBb,MAAM,2BAA2B;;oBACpDmB;oBACA,OAAO;gBACT,OAAO;oBACL,uDAAuD;oBACvDF;gBACF;YACF,OAAO;gBACL,4CAA4C;gBAC5CE;gBACA;YACF;QACF;QACAI,QAAQf,eAAee,MAAM;IAC/B;IAEA,IAAI,CAACV,kBAAkB;QACrB,MAAM,wXAAIjB,mBAAAA,CAAiBQ,KAAKJ,KAAK;IACvC;IAEAI,KAAKE,WAAW,GAAGO;IAEnB,wFAAwF;IACxFb,MAAMwB,SAAS,GAAGX,iBAAiBW,SAAS;IAC5C,sFAAsF;IACtFxB,MAAMyB,OAAO,GAAGZ,iBAAiBY,OAAO;IAExC,mFAAmF;IACnFzB,MAAMM,WAAW,GAAGF,KAAKE,WAAW;IAEpC,IAAI,CAACJ,KAAK,CAACF,MAAMW,UAAU,CAAC,EAAE;QAC5BT,KAAK,CAACF,MAAMW,UAAU,CAAC,GAAG;YAACP;SAAK;IAClC,OAAO;QACLF,KAAK,CAACF,MAAMW,UAAU,CAAC,CAACe,IAAI,CAACtB;IAC/B;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 812, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/baseFields/baseIDField.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { TextField } from '../config/types.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport const baseIDField: TextField = {\n  name: 'id',\n  type: 'text',\n  admin: {\n    hidden: true,\n  },\n  defaultValue: () => new ObjectId().toHexString(),\n  hooks: {\n    beforeChange: [({ value }) => value || new ObjectId().toHexString()],\n    beforeDuplicate: [() => new ObjectId().toHexString()],\n  },\n  label: 'ID',\n}\n"],"names":["ObjectIdImport","ObjectId","default","baseIDField","name","type","admin","hidden","defaultValue","toHexString","hooks","beforeChange","value","beforeDuplicate","label"],"mappings":";;;AAAA,OAAOA,oBAAoB,gBAAe;;AAI1C,MAAMC,qNAAYD,UAAAA,CAAeE,OAAO,8MACtCF,UAAAA;AAEK,MAAMG,cAAyB;IACpCC,MAAM;IACNC,MAAM;IACNC,OAAO;QACLC,QAAQ;IACV;IACAC,cAAc,IAAM,IAAIP,WAAWQ,WAAW;IAC9CC,OAAO;QACLC,cAAc;YAAC,CAAC,EAAEC,KAAK,EAAE,GAAKA,SAAS,IAAIX,WAAWQ,WAAW;SAAG;QACpEI,iBAAiB;YAAC,IAAM,IAAIZ,WAAWQ,WAAW;SAAG;IACvD;IACAK,OAAO;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 835, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 841, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/setDefaultBeforeDuplicate.ts"],"sourcesContent":["// default beforeDuplicate hook for required and unique fields\nimport type { FieldAffectingData, FieldHook } from './config/types.js'\n\nconst unique: FieldHook = ({ value }) => (typeof value === 'string' ? `${value} - Copy` : undefined)\nconst localizedUnique: FieldHook = ({ req, value }) =>\n  value ? `${value} - ${req?.t('general:copy') ?? 'Copy'}` : undefined\nconst uniqueRequired: FieldHook = ({ value }) => `${value} - Copy`\nconst localizedUniqueRequired: FieldHook = ({ req, value }) =>\n  `${value} - ${req?.t('general:copy') ?? 'Copy'}`\n\nexport const setDefaultBeforeDuplicate = (field: FieldAffectingData) => {\n  if (\n    (('required' in field && field.required) || field.unique) &&\n    (!field.hooks?.beforeDuplicate ||\n      (Array.isArray(field.hooks.beforeDuplicate) && field.hooks.beforeDuplicate.length === 0))\n  ) {\n    if ((field.type === 'text' || field.type === 'textarea') && field.required && field.unique) {\n      field.hooks.beforeDuplicate = [field.localized ? localizedUniqueRequired : uniqueRequired]\n    } else if (field.unique) {\n      field.hooks.beforeDuplicate = [field.localized ? localizedUnique : unique]\n    }\n  }\n}\n"],"names":["unique","value","undefined","localizedUnique","req","t","uniqueRequired","localizedUniqueRequired","setDefaultBeforeDuplicate","field","required","hooks","beforeDuplicate","Array","isArray","length","type","localized"],"mappings":"AAAA,8DAA8D;;;;AAG9D,MAAMA,SAAoB,CAAC,EAAEC,KAAK,EAAE,GAAM,OAAOA,UAAU,WAAW,GAAGA,MAAM,OAAO,CAAC,GAAGC;AAC1F,MAAMC,kBAA6B,CAAC,EAAEC,GAAG,EAAEH,KAAK,EAAE,GAChDA,QAAQ,GAAGA,MAAM,GAAG,EAAEG,KAAKC,EAAE,mBAAmB,QAAQ,GAAGH;AAC7D,MAAMI,iBAA4B,CAAC,EAAEL,KAAK,EAAE,GAAK,GAAGA,MAAM,OAAO,CAAC;AAClE,MAAMM,0BAAqC,CAAC,EAAEH,GAAG,EAAEH,KAAK,EAAE,GACxD,GAAGA,MAAM,GAAG,EAAEG,KAAKC,EAAE,mBAAmB,QAAQ;AAE3C,MAAMG,4BAA4B,CAACC;IACxC,IACG,CAAC,cAAcA,SAASA,MAAMC,QAAQ,IAAKD,MAAMT,MAAK,KACtD,CAAA,CAACS,MAAME,KAAK,EAAEC,mBACZC,MAAMC,OAAO,CAACL,MAAME,KAAK,CAACC,eAAe,KAAKH,MAAME,KAAK,CAACC,eAAe,CAACG,MAAM,KAAK,CAAC,GACzF;QACA,IAAKN,CAAAA,MAAMO,IAAI,KAAK,UAAUP,MAAMO,IAAI,KAAK,UAAS,KAAMP,MAAMC,QAAQ,IAAID,MAAMT,MAAM,EAAE;YAC1FS,MAAME,KAAK,CAACC,eAAe,GAAG;gBAACH,MAAMQ,SAAS,GAAGV,0BAA0BD;aAAe;QAC5F,OAAO,IAAIG,MAAMT,MAAM,EAAE;YACvBS,MAAME,KAAK,CAACC,eAAe,GAAG;gBAACH,MAAMQ,SAAS,GAAGd,kBAAkBH;aAAO;QAC5E;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 862, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 868, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/baseFields/baseBlockFields.ts"],"sourcesContent":["import type { Field } from '../config/types.js'\n\nimport { baseIDField } from './baseIDField.js'\n\nexport const baseBlockFields: Field[] = [\n  baseIDField,\n  {\n    name: 'blockName',\n    type: 'text',\n    admin: {\n      disabled: true,\n    },\n    label: 'Block Name',\n    required: false,\n  },\n]\n"],"names":["baseIDField","baseBlockFields","name","type","admin","disabled","label","required"],"mappings":";;;AAEA,SAASA,WAAW,QAAQ,mBAAkB;;AAEvC,MAAMC,kBAA2B;iYACtCD,cAAAA;IACA;QACEE,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,UAAU;QACZ;QACAC,OAAO;QACPC,UAAU;IACZ;CACD,CAAA","ignoreList":[0]}},
    {"offset": {"line": 885, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 891, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/config/sanitize.ts"],"sourcesContent":["import { deepMergeSimple } from '@payloadcms/translations/utilities'\n\nimport type { CollectionConfig, SanitizedJoins } from '../../collections/config/types.js'\nimport type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { Field } from './types.js'\n\nimport {\n  DuplicateFieldName,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  MissingEditorProp,\n  MissingFieldType,\n} from '../../errors/index.js'\nimport { formatLabels, toWords } from '../../utilities/formatLabels.js'\nimport { baseBlockFields } from '../baseFields/baseBlockFields.js'\nimport { baseIDField } from '../baseFields/baseIDField.js'\nimport { setDefaultBeforeDuplicate } from '../setDefaultBeforeDuplicate.js'\nimport { validations } from '../validations.js'\nimport { sanitizeJoinField } from './sanitizeJoinField.js'\nimport { fieldAffectsData, fieldIsLocalized, tabHasName } from './types.js'\n\ntype Args = {\n  collectionConfig?: CollectionConfig\n  config: Config\n  existingFieldNames?: Set<string>\n  fields: Field[]\n  joinPath?: string\n  /**\n   * When not passed in, assume that join are not supported (globals, arrays, blocks)\n   */\n  joins?: SanitizedJoins\n  parentIsLocalized: boolean\n\n  /**\n   * If true, a richText field will require an editor property to be set, as the sanitizeFields function will not add it from the payload config if not present.\n   *\n   * @default false\n   */\n  requireFieldLevelRichTextEditor?: boolean\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>\n  /**\n   * If not null, will validate that upload and relationship fields do not relate to a collection that is not in this array.\n   * This validation will be skipped if validRelationships is null.\n   */\n  validRelationships: null | string[]\n}\n\nexport const sanitizeFields = async ({\n  config,\n  existingFieldNames = new Set(),\n  fields,\n  joinPath = '',\n  joins,\n  parentIsLocalized,\n  requireFieldLevelRichTextEditor = false,\n  richTextSanitizationPromises,\n  validRelationships,\n}: Args): Promise<Field[]> => {\n  if (!fields) {\n    return []\n  }\n\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i]\n\n    if ('_sanitized' in field && field._sanitized === true) {\n      continue\n    }\n\n    if (!field.type) {\n      throw new MissingFieldType(field)\n    }\n\n    // assert that field names do not contain forbidden characters\n    if (fieldAffectsData(field) && field.name.includes('.')) {\n      throw new InvalidFieldName(field, field.name)\n    }\n\n    // Auto-label\n    if (\n      'name' in field &&\n      field.name &&\n      typeof field.label !== 'object' &&\n      typeof field.label !== 'string' &&\n      typeof field.label !== 'function' &&\n      field.label !== false\n    ) {\n      field.label = toWords(field.name)\n    }\n\n    if (\n      field.type === 'checkbox' &&\n      typeof field.defaultValue === 'undefined' &&\n      field.required === true\n    ) {\n      field.defaultValue = false\n    }\n\n    if (field.type === 'join') {\n      sanitizeJoinField({ config, field, joinPath, joins })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (validRelationships) {\n        const relationships = Array.isArray(field.relationTo)\n          ? field.relationTo\n          : [field.relationTo]\n        relationships.forEach((relationship: string) => {\n          if (!validRelationships.includes(relationship)) {\n            throw new InvalidFieldRelationship(field, relationship)\n          }\n        })\n      }\n\n      if (field.min && !field.minRows) {\n        console.warn(\n          `(payload): The \"min\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"minRows\" instead.`,\n        )\n      }\n      if (field.max && !field.maxRows) {\n        console.warn(\n          `(payload): The \"max\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"maxRows\" instead.`,\n        )\n      }\n      field.minRows = field.minRows || field.min\n      field.maxRows = field.maxRows || field.max\n    }\n\n    if (field.type === 'upload') {\n      if (!field.admin || !('isSortable' in field.admin)) {\n        field.admin = {\n          isSortable: true,\n          ...field.admin,\n        }\n      }\n    }\n\n    if (field.type === 'array' && field.fields) {\n      field.fields.push(baseIDField)\n    }\n\n    if ((field.type === 'blocks' || field.type === 'array') && field.label) {\n      field.labels = field.labels || formatLabels(field.name)\n    }\n\n    if (fieldAffectsData(field)) {\n      if (existingFieldNames.has(field.name)) {\n        throw new DuplicateFieldName(field.name)\n      } else if (!['blockName', 'id'].includes(field.name)) {\n        existingFieldNames.add(field.name)\n      }\n\n      if (typeof field.localized !== 'undefined') {\n        let shouldDisableLocalized = !config.localization\n\n        if (!config.compatibility?.allowLocalizedWithinLocalized && parentIsLocalized) {\n          shouldDisableLocalized = true\n        }\n\n        if (shouldDisableLocalized) {\n          delete field.localized\n        }\n      }\n\n      if (typeof field.validate === 'undefined') {\n        const defaultValidate = validations[field.type]\n        if (defaultValidate) {\n          field.validate = (val, options) => defaultValidate(val, { ...field, ...options })\n        } else {\n          field.validate = (): true => true\n        }\n      }\n\n      if (!field.hooks) {\n        field.hooks = {}\n      }\n      if (!field.access) {\n        field.access = {}\n      }\n\n      setDefaultBeforeDuplicate(field)\n    }\n\n    if (!field.admin) {\n      field.admin = {}\n    }\n\n    // Make sure that the richText field has an editor\n    if (field.type === 'richText') {\n      const sanitizeRichText = async (_config: SanitizedConfig) => {\n        if (!field.editor) {\n          if (_config.editor && !requireFieldLevelRichTextEditor) {\n            // config.editor should be sanitized at this point\n            field.editor = _config.editor\n          } else {\n            throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n          }\n        }\n\n        if (typeof field.editor === 'function') {\n          field.editor = await field.editor({\n            config: _config,\n            isRoot: requireFieldLevelRichTextEditor,\n            parentIsLocalized: parentIsLocalized || field.localized,\n          })\n        }\n\n        if (field.editor.i18n && Object.keys(field.editor.i18n).length >= 0) {\n          config.i18n.translations = deepMergeSimple(config.i18n.translations, field.editor.i18n)\n        }\n      }\n      if (richTextSanitizationPromises) {\n        richTextSanitizationPromises.push(sanitizeRichText)\n      } else {\n        await sanitizeRichText(config as unknown as SanitizedConfig)\n      }\n    }\n\n    if (field.type === 'blocks' && field.blocks) {\n      for (const block of field.blocks) {\n        if (block._sanitized === true) {\n          continue\n        }\n        block._sanitized = true\n        block.fields = block.fields.concat(baseBlockFields)\n        block.labels = !block.labels ? formatLabels(block.slug) : block.labels\n        block.fields = await sanitizeFields({\n          config,\n          existingFieldNames: new Set(),\n          fields: block.fields,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n      }\n    }\n\n    if ('fields' in field && field.fields) {\n      field.fields = await sanitizeFields({\n        config,\n        existingFieldNames: fieldAffectsData(field) ? new Set() : existingFieldNames,\n        fields: field.fields,\n        joinPath: fieldAffectsData(field)\n          ? `${joinPath ? joinPath + '.' : ''}${field.name}`\n          : joinPath,\n        joins,\n        parentIsLocalized: parentIsLocalized || fieldIsLocalized(field),\n        requireFieldLevelRichTextEditor,\n        richTextSanitizationPromises,\n        validRelationships,\n      })\n    }\n\n    if (field.type === 'tabs') {\n      for (let j = 0; j < field.tabs.length; j++) {\n        const tab = field.tabs[j]\n        if (tabHasName(tab) && typeof tab.label === 'undefined') {\n          tab.label = toWords(tab.name)\n        }\n\n        tab.fields = await sanitizeFields({\n          config,\n          existingFieldNames: tabHasName(tab) ? new Set() : existingFieldNames,\n          fields: tab.fields,\n          joinPath: tabHasName(tab) ? `${joinPath ? joinPath + '.' : ''}${tab.name}` : joinPath,\n          joins,\n          parentIsLocalized: parentIsLocalized || (tabHasName(tab) && tab.localized),\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n        field.tabs[j] = tab\n      }\n    }\n\n    if (field.type === 'ui' && typeof field.admin.disableBulkEdit === 'undefined') {\n      field.admin.disableBulkEdit = true\n    }\n\n    if ('_sanitized' in field) {\n      field._sanitized = true\n    }\n\n    fields[i] = field\n  }\n\n  return fields\n}\n"],"names":["deepMergeSimple","DuplicateFieldName","InvalidFieldName","InvalidFieldRelationship","MissingEditorProp","MissingFieldType","formatLabels","toWords","baseBlockFields","baseIDField","setDefaultBeforeDuplicate","validations","sanitizeJoinField","fieldAffectsData","fieldIsLocalized","tabHasName","sanitizeFields","config","existingFieldNames","Set","fields","joinPath","joins","parentIsLocalized","requireFieldLevelRichTextEditor","richTextSanitizationPromises","validRelationships","i","length","field","_sanitized","type","name","includes","label","defaultValue","required","relationships","Array","isArray","relationTo","forEach","relationship","min","minRows","console","warn","max","maxRows","admin","isSortable","push","labels","has","add","localized","shouldDisableLocalized","localization","compatibility","allowLocalizedWithinLocalized","validate","defaultValidate","val","options","hooks","access","sanitizeRichText","_config","editor","isRoot","i18n","Object","keys","translations","blocks","block","concat","slug","j","tabs","tab","disableBulkEdit"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1113, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1119, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/mergeBaseFields.ts"],"sourcesContent":["import type { Field, FieldWithSubFields } from './config/types.js'\n\nimport { deepMergeWithReactComponents } from '../utilities/deepMerge.js'\nimport { fieldAffectsData, fieldHasSubFields } from './config/types.js'\n\nconst mergeBaseFields = (fields: Field[], baseFields: Field[]): Field[] => {\n  const mergedFields = [...(fields || [])]\n\n  baseFields.forEach((baseField) => {\n    let matchedIndex = null\n\n    if (fieldAffectsData(baseField)) {\n      const match = mergedFields.find((field, i) => {\n        if (fieldAffectsData(field) && field.name === baseField.name) {\n          matchedIndex = i\n          return true\n        }\n\n        return false\n      })\n\n      if (match) {\n        const matchCopy: Field = { ...match }\n        mergedFields.splice(matchedIndex, 1)\n\n        const mergedField = deepMergeWithReactComponents<Field>(baseField, matchCopy)\n\n        if (fieldHasSubFields(baseField) && fieldHasSubFields(matchCopy)) {\n          ;(mergedField as FieldWithSubFields).fields = mergeBaseFields(\n            matchCopy.fields,\n            baseField.fields,\n          )\n        }\n\n        mergedFields.push(mergedField)\n      } else {\n        mergedFields.push(baseField)\n      }\n    }\n  })\n\n  return mergedFields\n}\n\nexport default mergeBaseFields\n"],"names":["deepMergeWithReactComponents","fieldAffectsData","fieldHasSubFields","mergeBaseFields","fields","baseFields","mergedFields","forEach","baseField","matchedIndex","match","find","field","i","name","matchCopy","splice","mergedField","push"],"mappings":";;;AAGA,SAASC,gBAAgB,EAAEC,iBAAiB,QAAQ,oBAAmB;AADvE,SAASF,4BAA4B,QAAQ,4BAA2B;;;AAGxE,MAAMG,kBAAkB,CAACC,QAAiBC;IACxC,MAAMC,eAAe;WAAKF,UAAU,EAAE;KAAE;IAExCC,WAAWE,OAAO,CAAC,CAACC;QAClB,IAAIC,eAAe;QAEnB,KAAIR,yYAAAA,EAAiBO,YAAY;YAC/B,MAAME,QAAQJ,aAAaK,IAAI,CAAC,CAACC,OAAOC;gBACtC,KAAIZ,yYAAAA,EAAiBW,UAAUA,MAAME,IAAI,KAAKN,UAAUM,IAAI,EAAE;oBAC5DL,eAAeI;oBACf,OAAO;gBACT;gBAEA,OAAO;YACT;YAEA,IAAIH,OAAO;gBACT,MAAMK,YAAmB;oBAAE,GAAGL,KAAK;gBAAC;gBACpCJ,aAAaU,MAAM,CAACP,cAAc;gBAElC,MAAMQ,kZAAcjB,+BAAAA,EAAoCQ,WAAWO;gBAEnE,2XAAIb,oBAAAA,EAAkBM,qYAAcN,oBAAAA,EAAkBa,YAAY;;oBAC9DE,YAAmCb,MAAM,GAAGD,gBAC5CY,UAAUX,MAAM,EAChBI,UAAUJ,MAAM;gBAEpB;gBAEAE,aAAaY,IAAI,CAACD;YACpB,OAAO;gBACLX,aAAaY,IAAI,CAACV;YACpB;QACF;IACF;IAEA,OAAOF;AACT;uCAEeH,gBAAe","ignoreList":[0]}},
    {"offset": {"line": 1160, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1166, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/getDefaultValue.ts"],"sourcesContent":["import type { DefaultValue, JsonValue, PayloadRequest } from '../types/index.js'\n\nimport { deepCopyObjectSimple } from '../utilities/deepCopyObject.js'\n\ntype Args = {\n  defaultValue: DefaultValue\n  locale: string | undefined\n  req: PayloadRequest\n  user: PayloadRequest['user']\n  value?: JsonValue\n}\n\nexport const getDefaultValue = async ({\n  defaultValue,\n  locale,\n  req,\n  user,\n  value,\n}: Args): Promise<JsonValue> => {\n  if (typeof value !== 'undefined') {\n    return value\n  }\n\n  if (defaultValue && typeof defaultValue === 'function') {\n    return await defaultValue({ locale, req, user })\n  }\n\n  if (typeof defaultValue === 'object') {\n    return deepCopyObjectSimple(defaultValue)\n  }\n\n  return defaultValue\n}\n"],"names":["deepCopyObjectSimple","getDefaultValue","defaultValue","locale","req","user","value"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,iCAAgC;;AAU9D,MAAMC,kBAAkB,OAAO,EACpCC,YAAY,EACZC,MAAM,EACNC,GAAG,EACHC,IAAI,EACJC,KAAK,EACA;IACL,IAAI,OAAOA,UAAU,aAAa;QAChC,OAAOA;IACT;IAEA,IAAIJ,gBAAgB,OAAOA,iBAAiB,YAAY;QACtD,OAAO,MAAMA,aAAa;YAAEC;YAAQC;YAAKC;QAAK;IAChD;IAEA,IAAI,OAAOH,iBAAiB,UAAU;QACpC,gYAAOF,uBAAAA,EAAqBE;IAC9B;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1187, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1193, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterRead/relationshipPopulationPromise.ts"],"sourcesContent":["import type { PayloadRequest, PopulateType } from '../../../types/index.js'\nimport type { JoinField, RelationshipField, UploadField } from '../../config/types.js'\n\nimport { createDataloaderCacheKey } from '../../../collections/dataloader.js'\nimport { fieldHasMaxDepth, fieldSupportsMany } from '../../config/types.js'\n\ntype PopulateArgs = {\n  currentDepth: number\n  data: Record<string, unknown>\n  dataReference: Record<string, any>\n  depth: number\n  draft: boolean\n  fallbackLocale: null | string\n  field: JoinField | RelationshipField | UploadField\n  index?: number\n  key?: string\n  locale: null | string\n  overrideAccess: boolean\n  populateArg?: PopulateType\n  req: PayloadRequest\n  showHiddenFields: boolean\n}\n\nconst populate = async ({\n  currentDepth,\n  data,\n  dataReference,\n  depth,\n  draft,\n  fallbackLocale,\n  field,\n  index,\n  key,\n  locale,\n  overrideAccess,\n  populateArg,\n  req,\n  showHiddenFields,\n}: PopulateArgs) => {\n  const dataToUpdate = dataReference\n  let relation\n  if (field.type === 'join') {\n    relation = field.collection\n  } else {\n    relation = Array.isArray(field.relationTo) ? (data.relationTo as string) : field.relationTo\n  }\n  const relatedCollection = req.payload.collections[relation]\n\n  if (relatedCollection) {\n    let id = field.type !== 'join' && Array.isArray(field.relationTo) ? data.value : data\n    let relationshipValue\n    const shouldPopulate = depth && currentDepth <= depth\n\n    if (\n      typeof id !== 'string' &&\n      typeof id !== 'number' &&\n      typeof id?.toString === 'function' &&\n      typeof id !== 'object'\n    ) {\n      id = id.toString()\n    }\n\n    if (shouldPopulate) {\n      relationshipValue = await req.payloadDataLoader.load(\n        createDataloaderCacheKey({\n          collectionSlug: relatedCollection.config.slug,\n          currentDepth: currentDepth + 1,\n          depth,\n          docID: id as string,\n          draft,\n          fallbackLocale,\n          locale,\n          overrideAccess,\n          select:\n            populateArg?.[relatedCollection.config.slug] ??\n            relatedCollection.config.defaultPopulate,\n          showHiddenFields,\n          transactionID: req.transactionID,\n        }),\n      )\n    }\n\n    if (!relationshipValue) {\n      // ids are visible regardless of access controls\n      relationshipValue = id\n    }\n    if (typeof index === 'number' && typeof key === 'string') {\n      if (field.type !== 'join' && Array.isArray(field.relationTo)) {\n        dataToUpdate[field.name][key][index].value = relationshipValue\n      } else {\n        dataToUpdate[field.name][key][index] = relationshipValue\n      }\n    } else if (typeof index === 'number' || typeof key === 'string') {\n      if (field.type === 'join') {\n        dataToUpdate[field.name].docs[index ?? key] = relationshipValue\n      } else if (Array.isArray(field.relationTo)) {\n        dataToUpdate[field.name][index ?? key].value = relationshipValue\n      } else {\n        dataToUpdate[field.name][index ?? key] = relationshipValue\n      }\n    } else if (field.type !== 'join' && Array.isArray(field.relationTo)) {\n      dataToUpdate[field.name].value = relationshipValue\n    } else {\n      dataToUpdate[field.name] = relationshipValue\n    }\n  }\n}\n\ntype PromiseArgs = {\n  currentDepth: number\n  depth: number\n  draft: boolean\n  fallbackLocale: null | string\n  field: JoinField | RelationshipField | UploadField\n  locale: null | string\n  overrideAccess: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields: boolean\n  siblingDoc: Record<string, any>\n}\n\nexport const relationshipPopulationPromise = async ({\n  currentDepth,\n  depth,\n  draft,\n  fallbackLocale,\n  field,\n  locale,\n  overrideAccess,\n  populate: populateArg,\n  req,\n  showHiddenFields,\n  siblingDoc,\n}: PromiseArgs): Promise<void> => {\n  const resultingDoc = siblingDoc\n  const populateDepth = fieldHasMaxDepth(field) && field.maxDepth < depth ? field.maxDepth : depth\n  const rowPromises = []\n\n  if (field.type === 'join' || (fieldSupportsMany(field) && field.hasMany)) {\n    if (\n      field.localized &&\n      locale === 'all' &&\n      typeof siblingDoc[field.name] === 'object' &&\n      siblingDoc[field.name] !== null\n    ) {\n      Object.keys(siblingDoc[field.name]).forEach((localeKey) => {\n        if (Array.isArray(siblingDoc[field.name][localeKey])) {\n          siblingDoc[field.name][localeKey].forEach((relatedDoc, index) => {\n            const rowPromise = async () => {\n              await populate({\n                currentDepth,\n                data: siblingDoc[field.name][localeKey][index],\n                dataReference: resultingDoc,\n                depth: populateDepth,\n                draft,\n                fallbackLocale,\n                field,\n                index,\n                key: localeKey,\n                locale,\n                overrideAccess,\n                populateArg,\n                req,\n                showHiddenFields,\n              })\n            }\n            rowPromises.push(rowPromise())\n          })\n        }\n      })\n    } else if (\n      Array.isArray(siblingDoc[field.name]) ||\n      Array.isArray(siblingDoc[field.name]?.docs)\n    ) {\n      ;(Array.isArray(siblingDoc[field.name])\n        ? siblingDoc[field.name]\n        : siblingDoc[field.name].docs\n      ).forEach((relatedDoc, index) => {\n        const rowPromise = async () => {\n          if (relatedDoc) {\n            await populate({\n              currentDepth,\n              data: relatedDoc?.id ? relatedDoc.id : relatedDoc,\n              dataReference: resultingDoc,\n              depth: populateDepth,\n              draft,\n              fallbackLocale,\n              field,\n              index,\n              locale,\n              overrideAccess,\n              populateArg,\n              req,\n              showHiddenFields,\n            })\n          }\n        }\n\n        rowPromises.push(rowPromise())\n      })\n    }\n  } else if (\n    field.localized &&\n    locale === 'all' &&\n    typeof siblingDoc[field.name] === 'object' &&\n    siblingDoc[field.name] !== null\n  ) {\n    Object.keys(siblingDoc[field.name]).forEach((localeKey) => {\n      const rowPromise = async () => {\n        await populate({\n          currentDepth,\n          data: siblingDoc[field.name][localeKey],\n          dataReference: resultingDoc,\n          depth: populateDepth,\n          draft,\n          fallbackLocale,\n          field,\n          key: localeKey,\n          locale,\n          overrideAccess,\n          populateArg,\n          req,\n          showHiddenFields,\n        })\n      }\n      rowPromises.push(rowPromise())\n    })\n\n    await Promise.all(rowPromises)\n  } else if (siblingDoc[field.name]) {\n    await populate({\n      currentDepth,\n      data: siblingDoc[field.name],\n      dataReference: resultingDoc,\n      depth: populateDepth,\n      draft,\n      fallbackLocale,\n      field,\n      locale,\n      overrideAccess,\n      populateArg,\n      req,\n      showHiddenFields,\n    })\n  }\n  await Promise.all(rowPromises)\n}\n"],"names":["createDataloaderCacheKey","fieldHasMaxDepth","fieldSupportsMany","populate","currentDepth","data","dataReference","depth","draft","fallbackLocale","field","index","key","locale","overrideAccess","populateArg","req","showHiddenFields","dataToUpdate","relation","type","collection","Array","isArray","relationTo","relatedCollection","payload","collections","id","value","relationshipValue","shouldPopulate","toString","payloadDataLoader","load","collectionSlug","config","slug","docID","select","defaultPopulate","transactionID","name","docs","relationshipPopulationPromise","siblingDoc","resultingDoc","populateDepth","maxDepth","rowPromises","hasMany","localized","Object","keys","forEach","localeKey","relatedDoc","rowPromise","push","Promise","all"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1352, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1358, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterRead/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectMode,\n  SelectType,\n} from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { relationshipPopulationPromise } from './relationshipPopulationPromise.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: null | string\n  field: Field | TabAsField\n  fieldIndex: number\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  /**\n   * The parent's path.\n   */\n  parentPath: (number | string)[]\n  /**\n   * The parent's schemaPath (path without indexes).\n   */\n  parentSchemaPath: string[]\n  populate?: PopulateType\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  select?: SelectType\n  selectMode?: SelectMode\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Remove hidden fields from response\n// - Flatten locales into requested locale\n// - Sanitize outgoing data (point field, etc.)\n// - Execute field hooks\n// - Execute read access control\n// - Populate relationships\n\nexport const promise = async ({\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  field,\n  fieldIndex,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  parentPath,\n  parentSchemaPath,\n  populate,\n  populationPromises,\n  req,\n  select,\n  selectMode,\n  showHiddenFields,\n  siblingDoc,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): Promise<void> => {\n  const { path: _fieldPath, schemaPath: _fieldSchemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath: '', // Doesn't matter, as unnamed fields do not affect data, and hooks are only run on fields that affect data\n    parentPath: parentPath.join('.'),\n    parentSchemaPath: parentSchemaPath.join('.'),\n  })\n  const fieldPath = _fieldPath ? _fieldPath.split('.') : []\n  const fieldSchemaPath = _fieldSchemaPath ? _fieldSchemaPath.split('.') : []\n\n  if (\n    fieldAffectsData(field) &&\n    field.hidden &&\n    typeof siblingDoc[field.name] !== 'undefined' &&\n    !showHiddenFields\n  ) {\n    delete siblingDoc[field.name]\n  }\n\n  if (fieldAffectsData(field) && select && selectMode) {\n    if (selectMode === 'include') {\n      if (!select[field.name]) {\n        delete siblingDoc[field.name]\n        return\n      }\n    }\n\n    if (selectMode === 'exclude') {\n      if (select[field.name] === false) {\n        delete siblingDoc[field.name]\n        return\n      }\n    }\n  }\n\n  const shouldHoistLocalizedValue =\n    flattenLocales &&\n    fieldAffectsData(field) &&\n    typeof siblingDoc[field.name] === 'object' &&\n    siblingDoc[field.name] !== null &&\n    field.localized &&\n    locale !== 'all' &&\n    req.payload.config.localization\n\n  if (shouldHoistLocalizedValue) {\n    // replace actual value with localized value before sanitizing\n    // { [locale]: fields } -> fields\n    const value = siblingDoc[field.name][locale]\n\n    let hoistedValue = value\n\n    if (fallbackLocale && fallbackLocale !== locale) {\n      const fallbackValue = siblingDoc[field.name][fallbackLocale]\n      const isNullOrUndefined = typeof value === 'undefined' || value === null\n\n      if (fallbackValue) {\n        switch (field.type) {\n          case 'text':\n          case 'textarea': {\n            if (value === '' || isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n\n          default: {\n            if (isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n        }\n      }\n    }\n\n    siblingDoc[field.name] = hoistedValue\n  }\n\n  // Sanitize outgoing field value\n  switch (field.type) {\n    case 'group': {\n      // Fill groups with empty objects so fields with hooks within groups can populate\n      // themselves virtually as necessary\n      if (typeof siblingDoc[field.name] === 'undefined') {\n        siblingDoc[field.name] = {}\n      }\n\n      break\n    }\n    case 'point': {\n      const pointDoc = siblingDoc[field.name] as Record<string, unknown>\n      if (Array.isArray(pointDoc?.coordinates) && pointDoc.coordinates.length === 2) {\n        siblingDoc[field.name] = pointDoc.coordinates\n      } else {\n        siblingDoc[field.name] = undefined\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      // Rich Text fields should use afterRead hooks to do population. The previous editor.populationPromises have been renamed to editor.graphQLPopulationPromises\n      break\n    }\n\n    case 'tabs': {\n      field.tabs.forEach((tab) => {\n        if (\n          tabHasName(tab) &&\n          (typeof siblingDoc[tab.name] === 'undefined' || siblingDoc[tab.name] === null)\n        ) {\n          siblingDoc[tab.name] = {}\n        }\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (triggerHooks && field.hooks?.afterRead) {\n      await field.hooks.afterRead.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const shouldRunHookOnAllLocales =\n          field.localized &&\n          (locale === 'all' || !flattenLocales) &&\n          typeof siblingDoc[field.name] === 'object'\n\n        if (shouldRunHookOnAllLocales) {\n          const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value]) =>\n            (async () => {\n              const hookedValue = await currentHook({\n                collection,\n                context,\n                currentDepth,\n                data: doc,\n                depth,\n                draft,\n                field,\n                findMany,\n                global,\n                operation: 'read',\n                originalDoc: doc,\n                overrideAccess,\n                path: fieldPath,\n                req,\n                schemaPath: fieldSchemaPath,\n                showHiddenFields,\n                siblingData: siblingDoc,\n                value,\n              })\n\n              if (hookedValue !== undefined) {\n                siblingDoc[field.name][locale] = hookedValue\n              }\n            })(),\n          )\n\n          await Promise.all(hookPromises)\n        } else {\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            currentDepth,\n            data: doc,\n            depth,\n            draft,\n            field,\n            findMany,\n            global,\n            operation: 'read',\n            originalDoc: doc,\n            overrideAccess,\n            path: fieldPath,\n            req,\n            schemaPath: fieldSchemaPath,\n            showHiddenFields,\n            siblingData: siblingDoc,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }\n      }, Promise.resolve())\n    }\n\n    // Execute access control\n    let allowDefaultValue = true\n    if (triggerAccessControl && field.access && field.access.read) {\n      const result = overrideAccess\n        ? true\n        : await field.access.read({\n            id: doc.id as number | string,\n            data: doc,\n            doc,\n            req,\n            siblingData: siblingDoc,\n          })\n\n      if (!result) {\n        allowDefaultValue = false\n        delete siblingDoc[field.name]\n      }\n    }\n\n    // Set defaultValue on the field for globals being returned without being first created\n    // or collection documents created prior to having a default\n    if (\n      allowDefaultValue &&\n      typeof siblingDoc[field.name] === 'undefined' &&\n      typeof field.defaultValue !== 'undefined'\n    ) {\n      siblingDoc[field.name] = await getDefaultValue({\n        defaultValue: field.defaultValue,\n        locale,\n        req,\n        user: req.user,\n        value: siblingDoc[field.name],\n      })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload' || field.type === 'join') {\n      populationPromises.push(\n        relationshipPopulationPromise({\n          currentDepth,\n          depth,\n          draft,\n          fallbackLocale,\n          field,\n          locale,\n          overrideAccess,\n          populate,\n          req,\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name] as JsonObject\n\n      let arraySelect = select?.[field.name]\n\n      if (selectMode === 'include' && typeof arraySelect === 'object') {\n        arraySelect = {\n          ...arraySelect,\n          id: true,\n        }\n      }\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, i) => {\n          traverseFields({\n            collection,\n            context,\n            currentDepth,\n            depth,\n            doc,\n            draft,\n            fallbackLocale,\n            fieldPromises,\n            fields: field.fields,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            path: [...fieldPath, i],\n            populate,\n            populationPromises,\n            req,\n            schemaPath: fieldSchemaPath,\n            select: typeof arraySelect === 'object' ? arraySelect : undefined,\n            selectMode,\n            showHiddenFields,\n            siblingDoc: row || {},\n            triggerAccessControl,\n            triggerHooks,\n          })\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, i) => {\n              traverseFields({\n                collection,\n                context,\n                currentDepth,\n                depth,\n                doc,\n                draft,\n                fallbackLocale,\n                fieldPromises,\n                fields: field.fields,\n                findMany,\n                flattenLocales,\n                global,\n                locale,\n                overrideAccess,\n                path: [...fieldPath, i],\n                populate,\n                populationPromises,\n                req,\n                schemaPath: fieldSchemaPath,\n                showHiddenFields,\n                siblingDoc: (row as JsonObject) || {},\n                triggerAccessControl,\n                triggerHooks,\n              })\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      let blocksSelect = select?.[field.name]\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, i) => {\n          const block = field.blocks.find(\n            (blockType) => blockType.slug === (row as JsonObject).blockType,\n          )\n\n          let blockSelectMode = selectMode\n\n          if (typeof blocksSelect === 'object') {\n            blocksSelect = {\n              ...blocksSelect,\n            }\n\n            // sanitize blocks: {cta: false} to blocks: {cta: {id: true, blockType: true}}\n            if (selectMode === 'exclude' && blocksSelect[block.slug] === false) {\n              blockSelectMode = 'include'\n              blocksSelect[block.slug] = {\n                id: true,\n                blockType: true,\n              }\n            } else if (selectMode === 'include') {\n              if (!blocksSelect[block.slug]) {\n                blocksSelect[block.slug] = {}\n              }\n\n              if (typeof blocksSelect[block.slug] === 'object') {\n                blocksSelect[block.slug] = {\n                  ...(blocksSelect[block.slug] as object),\n                }\n\n                blocksSelect[block.slug]['id'] = true\n                blocksSelect[block.slug]['blockType'] = true\n              }\n            }\n          }\n\n          const blockSelect = blocksSelect?.[block.slug]\n\n          if (block) {\n            traverseFields({\n              collection,\n              context,\n              currentDepth,\n              depth,\n              doc,\n              draft,\n              fallbackLocale,\n              fieldPromises,\n              fields: block.fields,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              path: [...fieldPath, i],\n              populate,\n              populationPromises,\n              req,\n              schemaPath: fieldSchemaPath,\n              select: typeof blockSelect === 'object' ? blockSelect : undefined,\n              selectMode: blockSelectMode,\n              showHiddenFields,\n              siblingDoc: (row as JsonObject) || {},\n              triggerAccessControl,\n              triggerHooks,\n            })\n          }\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, i) => {\n              const block = field.blocks.find(\n                (blockType) => blockType.slug === (row as JsonObject).blockType,\n              )\n\n              if (block) {\n                traverseFields({\n                  collection,\n                  context,\n                  currentDepth,\n                  depth,\n                  doc,\n                  draft,\n                  fallbackLocale,\n                  fieldPromises,\n                  fields: block.fields,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  overrideAccess,\n                  path: [...fieldPath, i],\n                  populate,\n                  populationPromises,\n                  req,\n                  schemaPath: fieldSchemaPath,\n                  showHiddenFields,\n                  siblingDoc: (row as JsonObject) || {},\n                  triggerAccessControl,\n                  triggerHooks,\n                })\n              }\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populate,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n    case 'group': {\n      let groupDoc = siblingDoc[field.name] as JsonObject\n      if (typeof siblingDoc[field.name] !== 'object') {\n        groupDoc = {}\n      }\n\n      const groupSelect = select?.[field.name]\n\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populate,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        select: typeof groupSelect === 'object' ? groupSelect : undefined,\n        selectMode,\n        showHiddenFields,\n        siblingDoc: groupDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterRead?.length) {\n        await editor.hooks.afterRead.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const shouldRunHookOnAllLocales =\n            field.localized &&\n            (locale === 'all' || !flattenLocales) &&\n            typeof siblingDoc[field.name] === 'object'\n\n          if (shouldRunHookOnAllLocales) {\n            const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value]) =>\n              (async () => {\n                const hookedValue = await currentHook({\n                  collection,\n                  context,\n                  currentDepth,\n                  data: doc,\n                  depth,\n                  draft,\n                  fallbackLocale,\n                  field,\n                  fieldPromises,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  operation: 'read',\n                  originalDoc: doc,\n                  overrideAccess,\n                  path: fieldPath,\n                  populate,\n                  populationPromises,\n                  req,\n                  schemaPath: fieldSchemaPath,\n                  showHiddenFields,\n                  siblingData: siblingDoc,\n                  triggerAccessControl,\n                  triggerHooks,\n                  value,\n                })\n\n                if (hookedValue !== undefined) {\n                  siblingDoc[field.name][locale] = hookedValue\n                }\n              })(),\n            )\n\n            await Promise.all(hookPromises)\n          } else {\n            const hookedValue = await currentHook({\n              collection,\n              context,\n              currentDepth,\n              data: doc,\n              depth,\n              draft,\n              fallbackLocale,\n              field,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              operation: 'read',\n              originalDoc: doc,\n              overrideAccess,\n              path: fieldPath,\n              populate,\n              populationPromises,\n              req,\n              schemaPath: fieldSchemaPath,\n              showHiddenFields,\n              siblingData: siblingDoc,\n              triggerAccessControl,\n              triggerHooks,\n              value: siblingDoc[field.name],\n            })\n\n            if (hookedValue !== undefined) {\n              siblingDoc[field.name] = hookedValue\n            }\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabDoc = siblingDoc\n      let tabSelect: SelectType | undefined\n      if (tabHasName(field)) {\n        tabDoc = siblingDoc[field.name] as JsonObject\n        if (typeof siblingDoc[field.name] !== 'object') {\n          tabDoc = {}\n        }\n\n        if (typeof select?.[field.name] === 'object') {\n          tabSelect = select?.[field.name] as SelectType\n        }\n      } else {\n        tabSelect = select\n      }\n\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populate,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        select: tabSelect,\n        selectMode,\n        showHiddenFields,\n        siblingDoc: tabDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      traverseFields({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        path: fieldPath,\n        populate,\n        populationPromises,\n        req,\n        schemaPath: fieldSchemaPath,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getDefaultValue","getFieldPaths","relationshipPopulationPromise","traverseFields","promise","collection","context","currentDepth","depth","doc","draft","fallbackLocale","field","fieldIndex","fieldPromises","findMany","flattenLocales","global","locale","overrideAccess","parentPath","parentSchemaPath","populate","populationPromises","req","select","selectMode","showHiddenFields","siblingDoc","triggerAccessControl","triggerHooks","path","_fieldPath","schemaPath","_fieldSchemaPath","index","parentIndexPath","join","fieldPath","split","fieldSchemaPath","hidden","name","shouldHoistLocalizedValue","localized","payload","config","localization","value","hoistedValue","fallbackValue","isNullOrUndefined","type","pointDoc","Array","isArray","coordinates","length","undefined","editor","Error","tabs","forEach","tab","hooks","afterRead","reduce","priorHook","currentHook","shouldRunHookOnAllLocales","hookPromises","Object","entries","map","hookedValue","data","operation","originalDoc","siblingData","Promise","all","resolve","allowDefaultValue","access","read","result","id","defaultValue","user","push","rows","arraySelect","row","i","fields","values","localeRows","blocksSelect","block","blocks","find","blockType","slug","blockSelectMode","blockSelect","groupDoc","groupSelect","tabDoc","tabSelect"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2010, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2016, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterRead/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectMode,\n  SelectType,\n} from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: null | string\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  fields: (Field | TabAsField)[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  path: (number | string)[]\n  populate?: PopulateType\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  schemaPath: string[]\n  select?: SelectType\n  selectMode?: SelectMode\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\nexport const traverseFields = ({\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  fieldPromises,\n  fields,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  path,\n  populate,\n  populationPromises,\n  req,\n  schemaPath,\n  select,\n  selectMode,\n  showHiddenFields,\n  siblingDoc,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): void => {\n  fields.forEach((field, fieldIndex) => {\n    fieldPromises.push(\n      promise({\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        field,\n        fieldIndex,\n        fieldPromises,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      }),\n    )\n  })\n}\n"],"names":["promise","traverseFields","collection","context","currentDepth","depth","doc","draft","fallbackLocale","fieldPromises","fields","findMany","flattenLocales","global","locale","overrideAccess","path","populate","populationPromises","req","schemaPath","select","selectMode","showHiddenFields","siblingDoc","triggerAccessControl","triggerHooks","forEach","field","fieldIndex","push","parentPath","parentSchemaPath"],"mappings":";;;AAYA,SAASA,OAAO,QAAQ,eAAc;;AAiC/B,MAAMC,iBAAiB,CAAC,EAC7BC,UAAU,EACVC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,GAAG,EACHC,KAAK,EACLC,cAAc,EACdC,aAAa,EACbC,MAAM,EACNC,QAAQ,EACRC,cAAc,EACdC,MAAM,EACNC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,QAAQ,EACRC,kBAAkB,EAClBC,GAAG,EACHC,UAAU,EACVC,MAAM,EACNC,UAAU,EACVC,gBAAgB,EAChBC,UAAU,EACVC,uBAAuB,IAAI,EAC3BC,eAAe,IAAI,EACd;IACLhB,OAAOiB,OAAO,CAAC,CAACC,OAAOC;QACrBpB,cAAcqB,IAAI,sYAChB9B,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAoB;YACAC;YACApB;YACAE;YACAC;YACAC;YACAC;YACAC;YACAgB,YAAYf;YACZgB,kBAAkBZ;YAClBH;YACAC;YACAC;YACAE;YACAC;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2053, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2069, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterChange/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  /**\n   * The parent's path\n   */\n  parentPath: (number | string)[]\n  /**\n   * The parent's schemaPath (path without indexes).\n   */\n  parentSchemaPath: string[]\n  previousDoc: JsonObject\n  previousSiblingDoc: JsonObject\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n}\n\n// This function is responsible for the following actions, in order:\n// - Execute field hooks\n\nexport const promise = async ({\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  fieldIndex,\n  global,\n  operation,\n  parentPath,\n  parentSchemaPath,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args): Promise<void> => {\n  const { path: _fieldPath, schemaPath: _fieldSchemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath: '', // Doesn't matter, as unnamed fields do not affect data, and hooks are only run on fields that affect data\n    parentPath: parentPath.join('.'),\n    parentSchemaPath: parentSchemaPath.join('.'),\n  })\n  const fieldPath = _fieldPath ? _fieldPath.split('.') : []\n  const fieldSchemaPath = _fieldSchemaPath ? _fieldSchemaPath.split('.') : []\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (field.hooks?.afterChange) {\n      await field.hooks.afterChange.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          collection,\n          context,\n          data,\n          field,\n          global,\n          operation,\n          originalDoc: doc,\n          path: fieldPath,\n          previousDoc,\n          previousSiblingDoc,\n          previousValue: previousDoc[field.name],\n          req,\n          schemaPath: fieldSchemaPath,\n          siblingData,\n          value: siblingDoc[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingDoc[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          promises.push(\n            traverseFields({\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              path: [...fieldPath, i],\n              previousDoc,\n              previousSiblingDoc: previousDoc?.[field.name]?.[i] || ({} as JsonObject),\n              req,\n              schemaPath: fieldSchemaPath,\n              siblingData: siblingData?.[field.name]?.[i] || {},\n              siblingDoc: row ? { ...row } : {},\n            }),\n          )\n        })\n        await Promise.all(promises)\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          const block = field.blocks.find(\n            (blockType) => blockType.slug === (row as JsonObject).blockType,\n          )\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                path: [...fieldPath, i],\n                previousDoc,\n                previousSiblingDoc: previousDoc?.[field.name]?.[i] || ({} as JsonObject),\n                req,\n                schemaPath: fieldSchemaPath,\n                siblingData: siblingData?.[field.name]?.[i] || {},\n                siblingDoc: row ? { ...row } : {},\n              }),\n            )\n          }\n        })\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n\n    case 'row': {\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n    case 'group': {\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: previousDoc[field.name] as JsonObject,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: (siblingData?.[field.name] as JsonObject) || {},\n        siblingDoc: siblingDoc[field.name] as JsonObject,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterChange?.length) {\n        await editor.hooks.afterChange.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            operation,\n            originalDoc: doc,\n            path: fieldPath,\n            previousDoc,\n            previousSiblingDoc,\n            previousValue: previousDoc[field.name],\n            req,\n            schemaPath: fieldSchemaPath,\n            siblingData,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabPreviousSiblingDoc = siblingDoc\n\n      if (tabHasName(field)) {\n        tabSiblingData = siblingData[field.name] as JsonObject\n        tabSiblingDoc = siblingDoc[field.name] as JsonObject\n        tabPreviousSiblingDoc = previousDoc[field.name] as JsonObject\n      }\n\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: tabPreviousSiblingDoc,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        path: fieldPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getFieldPaths","traverseFields","promise","collection","context","data","doc","field","fieldIndex","global","operation","parentPath","parentSchemaPath","previousDoc","previousSiblingDoc","req","siblingData","siblingDoc","path","_fieldPath","schemaPath","_fieldSchemaPath","index","parentIndexPath","join","fieldPath","split","fieldSchemaPath","hooks","afterChange","reduce","priorHook","currentHook","hookedValue","originalDoc","previousValue","name","value","undefined","Promise","resolve","type","rows","Array","isArray","promises","forEach","row","i","push","fields","all","block","blocks","find","blockType","slug","editor","Error","length","tabSiblingData","tabSiblingDoc","tabPreviousSiblingDoc","tabs","map","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2330, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2336, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterChange/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  path: (number | string)[]\n  previousDoc: JsonObject\n  previousSiblingDoc: JsonObject\n  req: PayloadRequest\n  schemaPath: string[]\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async ({\n  collection,\n  context,\n  data,\n  doc,\n  fields,\n  global,\n  operation,\n  path,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  schemaPath,\n  siblingData,\n  siblingDoc,\n}: Args): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        collection,\n        context,\n        data,\n        doc,\n        field,\n        fieldIndex,\n        global,\n        operation,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc,\n        req,\n        siblingData,\n        siblingDoc,\n      }),\n    )\n  })\n\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","collection","context","data","doc","fields","global","operation","path","previousDoc","previousSiblingDoc","req","schemaPath","siblingData","siblingDoc","promises","forEach","field","fieldIndex","push","parentPath","parentSchemaPath","Promise","all"],"mappings":";;;AAMA,SAASA,OAAO,QAAQ,eAAc;;AAmB/B,MAAMC,iBAAiB,OAAO,EACnCC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,IAAI,EACJC,WAAW,EACXC,kBAAkB,EAClBC,GAAG,EACHC,UAAU,EACVC,WAAW,EACXC,UAAU,EACL;IACL,MAAMC,WAAW,EAAE;IAEnBV,OAAOW,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,wYACXpB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAa;YACAC;YACAZ;YACAC;YACAa,YAAYZ;YACZa,kBAAkBT;YAClBH;YACAC;YACAC;YACAE;YACAC;QACF;IAEJ;IAEA,MAAMQ,QAAQC,GAAG,CAACR;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2364, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2380, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeChange/getExistingRowDoc.ts"],"sourcesContent":["/**\n * If there is an incoming row id,\n * and it matches the existing sibling doc id,\n * this is an existing row, so it should be merged.\n * Otherwise, return an empty object.\n */\nimport type { JsonObject } from '../../../types/index.js'\n\nexport const getExistingRowDoc = (incomingRow: JsonObject, existingRows?: unknown): JsonObject => {\n  if (incomingRow.id && Array.isArray(existingRows)) {\n    const matchedExistingRow = existingRows.find((existingRow) => {\n      if (typeof existingRow === 'object' && 'id' in existingRow) {\n        if (existingRow.id === incomingRow.id) {\n          return existingRow\n        }\n      }\n\n      return false\n    })\n\n    if (matchedExistingRow) {\n      return matchedExistingRow\n    }\n  }\n\n  return {}\n}\n"],"names":["getExistingRowDoc","incomingRow","existingRows","id","Array","isArray","matchedExistingRow","find","existingRow"],"mappings":"AAAA;;;;;CAKC,GAGD;;;AAAO,MAAMA,oBAAoB,CAACC,aAAyBC;IACzD,IAAID,YAAYE,EAAE,IAAIC,MAAMC,OAAO,CAACH,eAAe;QACjD,MAAMI,qBAAqBJ,aAAaK,IAAI,CAAC,CAACC;YAC5C,IAAI,OAAOA,gBAAgB,YAAY,QAAQA,aAAa;gBAC1D,IAAIA,YAAYL,EAAE,KAAKF,YAAYE,EAAE,EAAE;oBACrC,OAAOK;gBACT;YACF;YAEA,OAAO;QACT;QAEA,IAAIF,oBAAoB;YACtB,OAAOA;QACT;IACF;IAEA,OAAO,CAAC;AACV,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2404, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2410, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeChange/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { deepMergeWithSourceArrays } from '../../../utilities/deepMerge.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { getExistingRowDoc } from './getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  docWithLocales: JsonObject\n  errors: ValidationFieldError[]\n  field: Field | TabAsField\n  /**\n   * The index of the field as it appears in the parent's fields array. This is used to construct the field path / schemaPath\n   * for unnamed fields like rows and collapsibles.\n   */\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void>)[]\n  operation: Operation\n  /**\n   * The parent's path.\n   */\n  parentPath: (number | string)[]\n  /**\n   * The parent's schemaPath (path without indexes).\n   */\n  parentSchemaPath: string[]\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingDocWithLocales?: JsonObject\n  skipValidation: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Run condition\n// - Execute field hooks\n// - Validate data\n// - Transform data for storage\n// - beforeDuplicate hooks (if duplicate)\n// - Unflatten locales\n\nexport const promise = async ({\n  id,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  field,\n  fieldIndex,\n  global,\n  mergeLocaleActions,\n  operation,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  skipValidation,\n}: Args): Promise<void> => {\n  const passesCondition = field.admin?.condition\n    ? Boolean(field.admin.condition(data, siblingData, { user: req.user }))\n    : true\n  let skipValidationFromHere = skipValidation || !passesCondition\n  const { localization } = req.payload.config\n  const defaultLocale = localization ? localization?.defaultLocale : 'en'\n  const operationLocale = req.locale || defaultLocale\n\n  const { path: _fieldPath, schemaPath: _fieldSchemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath: '', // Doesn't matter, as unnamed fields do not affect data, and hooks are only run on fields that affect data\n    parentPath: parentPath.join('.'),\n    parentSchemaPath: parentSchemaPath.join('.'),\n  })\n  const fieldPath = _fieldPath ? _fieldPath.split('.') : []\n  const fieldSchemaPath = _fieldSchemaPath ? _fieldSchemaPath.split('.') : []\n\n  if (fieldAffectsData(field)) {\n    // skip validation if the field is localized and the incoming data is null\n    if (field.localized && operationLocale !== defaultLocale) {\n      if (['array', 'blocks'].includes(field.type) && siblingData[field.name] === null) {\n        skipValidationFromHere = true\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeChange) {\n      await field.hooks.beforeChange.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          collection,\n          context,\n          data,\n          field,\n          global,\n          operation,\n          originalDoc: doc,\n          path: fieldPath,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: parentSchemaPath,\n          siblingData,\n          siblingDocWithLocales,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n\n    // Validate\n    if (!skipValidationFromHere && 'validate' in field && field.validate) {\n      const valueToValidate = siblingData[field.name]\n      let jsonError: object\n\n      if (field.type === 'json' && typeof siblingData[field.name] === 'string') {\n        try {\n          JSON.parse(siblingData[field.name] as string)\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      const validationResult = await field.validate(\n        valueToValidate as never,\n        {\n          ...field,\n          id,\n          collectionSlug: collection?.slug,\n          data: deepMergeWithSourceArrays(doc, data),\n          jsonError,\n          operation,\n          preferences: { fields: {} },\n          previousValue: siblingDoc[field.name],\n          req,\n          siblingData: deepMergeWithSourceArrays(siblingDoc, siblingData),\n        } as any,\n      )\n\n      if (typeof validationResult === 'string') {\n        errors.push({\n          message: validationResult,\n          path: fieldPath.join('.'),\n        })\n      }\n    }\n\n    // Push merge locale action if applicable\n    if (localization && field.localized) {\n      mergeLocaleActions.push(async () => {\n        const localeData = await localization.localeCodes.reduce(\n          async (localizedValuesPromise: Promise<JsonObject>, locale) => {\n            const localizedValues = await localizedValuesPromise\n            const fieldValue =\n              locale === req.locale\n                ? siblingData[field.name]\n                : siblingDocWithLocales?.[field.name]?.[locale]\n\n            // const result = await localizedValues\n            // update locale value if it's not undefined\n            if (typeof fieldValue !== 'undefined') {\n              return {\n                ...localizedValues,\n                [locale]: fieldValue,\n              }\n            }\n\n            return localizedValuesPromise\n          },\n          Promise.resolve({}),\n        )\n\n        // If there are locales with data, set the data\n        if (Object.keys(localeData).length > 0) {\n          siblingData[field.name] = localeData\n        }\n      })\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          promises.push(\n            traverseFields({\n              id,\n              collection,\n              context,\n              data,\n              doc,\n              docWithLocales,\n              errors,\n              fields: field.fields,\n              global,\n              mergeLocaleActions,\n              operation,\n              path: [...fieldPath, i],\n              req,\n              schemaPath: fieldSchemaPath,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n              siblingDocWithLocales: getExistingRowDoc(\n                row as JsonObject,\n                siblingDocWithLocales[field.name],\n              ),\n              skipValidation: skipValidationFromHere,\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n          const rowSiblingDocWithLocales = getExistingRowDoc(\n            row as JsonObject,\n            siblingDocWithLocales ? siblingDocWithLocales[field.name] : {},\n          )\n\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n          const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                id,\n                collection,\n                context,\n                data,\n                doc,\n                docWithLocales,\n                errors,\n                fields: block.fields,\n                global,\n                mergeLocaleActions,\n                operation,\n                path: [...fieldPath, i],\n                req,\n                schemaPath: fieldSchemaPath,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n                siblingDocWithLocales: rowSiblingDocWithLocales,\n                skipValidation: skipValidationFromHere,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') {\n        siblingData[field.name] = {}\n      }\n      if (typeof siblingDoc[field.name] !== 'object') {\n        siblingDoc[field.name] = {}\n      }\n      if (typeof siblingDocWithLocales[field.name] !== 'object') {\n        siblingDocWithLocales[field.name] = {}\n      }\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: siblingData[field.name] as JsonObject,\n        siblingDoc: siblingDoc[field.name] as JsonObject,\n        siblingDocWithLocales: siblingDocWithLocales[field.name] as JsonObject,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n    case 'point': {\n      // Transform point data for storage\n      if (\n        Array.isArray(siblingData[field.name]) &&\n        siblingData[field.name][0] !== null &&\n        siblingData[field.name][1] !== null\n      ) {\n        siblingData[field.name] = {\n          type: 'Point',\n          coordinates: [\n            parseFloat(siblingData[field.name][0]),\n            parseFloat(siblingData[field.name][1]),\n          ],\n        }\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeChange?.length) {\n        await editor.hooks.beforeChange.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            docWithLocales,\n            errors,\n            field,\n            global,\n            mergeLocaleActions,\n            operation,\n            originalDoc: doc,\n            path: fieldPath,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingDoc[field.name],\n            req,\n            schemaPath: parentSchemaPath,\n            siblingData,\n            siblingDocWithLocales,\n            skipValidation,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabSiblingDocWithLocales = siblingDocWithLocales\n\n      if (tabHasName(field)) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n        if (typeof siblingDocWithLocales[field.name] !== 'object') {\n          siblingDocWithLocales[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as JsonObject\n        tabSiblingDoc = siblingDoc[field.name] as JsonObject\n        tabSiblingDocWithLocales = siblingDocWithLocales[field.name] as JsonObject\n      }\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n        siblingDocWithLocales: tabSiblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        mergeLocaleActions,\n        operation,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","deepMergeWithSourceArrays","fieldAffectsData","tabHasName","getFieldPaths","getExistingRowDoc","traverseFields","promise","id","collection","context","data","doc","docWithLocales","errors","field","fieldIndex","global","mergeLocaleActions","operation","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingDocWithLocales","skipValidation","passesCondition","admin","condition","Boolean","user","skipValidationFromHere","localization","payload","config","defaultLocale","operationLocale","locale","path","_fieldPath","schemaPath","_fieldSchemaPath","index","parentIndexPath","join","fieldPath","split","fieldSchemaPath","localized","includes","type","name","hooks","beforeChange","reduce","priorHook","currentHook","hookedValue","originalDoc","previousSiblingDoc","previousValue","value","undefined","Promise","resolve","validate","valueToValidate","jsonError","JSON","parse","e","validationResult","collectionSlug","slug","preferences","fields","push","message","localeData","localeCodes","localizedValuesPromise","localizedValues","fieldValue","Object","keys","length","rows","Array","isArray","promises","forEach","row","i","all","rowSiblingDoc","rowSiblingDocWithLocales","blockTypeToMatch","blockType","block","blocks","find","coordinates","parseFloat","editor","Error","tabSiblingData","tabSiblingDoc","tabSiblingDocWithLocales","tabs","map","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2795, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2801, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeChange/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: JsonObject\n  /**\n   * The original data with locales (not modified by any hooks)\n   */\n  docWithLocales: JsonObject\n  errors: ValidationFieldError[]\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void>)[]\n  operation: Operation\n  path: (number | string)[]\n  req: PayloadRequest\n  schemaPath: string[]\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n  /**\n   * The original siblingData with locales (not modified by any hooks)\n   */\n  siblingDocWithLocales: JsonObject\n  skipValidation?: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Run condition\n * - Execute field hooks\n * - Validate data\n * - Transform data for storage\n * - Unflatten locales. The input `data` is the normal document for one locale. The output result will become the document with locales.\n */\nexport const traverseFields = async ({\n  id,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  fields,\n  global,\n  mergeLocaleActions,\n  operation,\n  path,\n  req,\n  schemaPath,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  skipValidation,\n}: Args): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        field,\n        fieldIndex,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation,\n      }),\n    )\n  })\n\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","collection","context","data","doc","docWithLocales","errors","fields","global","mergeLocaleActions","operation","path","req","schemaPath","siblingData","siblingDoc","siblingDocWithLocales","skipValidation","promises","forEach","field","fieldIndex","push","parentPath","parentSchemaPath","Promise","all"],"mappings":";;;AAOA,SAASA,OAAO,QAAQ,eAAc;;AA2C/B,MAAMC,iBAAiB,OAAO,EACnCC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,cAAc,EACdC,MAAM,EACNC,MAAM,EACNC,MAAM,EACNC,kBAAkB,EAClBC,SAAS,EACTC,IAAI,EACJC,GAAG,EACHC,UAAU,EACVC,WAAW,EACXC,UAAU,EACVC,qBAAqB,EACrBC,cAAc,EACT;IACL,MAAMC,WAAW,EAAE;IAEnBX,OAAOY,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,yYACXxB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAc;YACAC;YACAb;YACAC;YACAC;YACAa,YAAYZ;YACZa,kBAAkBX;YAClBD;YACAE;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,MAAMQ,QAAQC,GAAG,CAACR;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2833, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2849, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeChange/cloneDataFromOriginalDoc.ts"],"sourcesContent":["import type { JsonArray, JsonObject } from '../../../types/index.js'\n\nexport const cloneDataFromOriginalDoc = (\n  originalDocData: JsonArray | JsonObject,\n): JsonArray | JsonObject => {\n  if (Array.isArray(originalDocData)) {\n    return originalDocData.map((row) => {\n      if (typeof row === 'object' && row != null) {\n        return {\n          ...row,\n        }\n      }\n\n      return row\n    })\n  }\n\n  if (typeof originalDocData === 'object' && originalDocData !== null) {\n    return { ...originalDocData }\n  }\n\n  return originalDocData\n}\n"],"names":["cloneDataFromOriginalDoc","originalDocData","Array","isArray","map","row"],"mappings":";;;AAEO,MAAMA,2BAA2B,CACtCC;IAEA,IAAIC,MAAMC,OAAO,CAACF,kBAAkB;QAClC,OAAOA,gBAAgBG,GAAG,CAAC,CAACC;YAC1B,IAAI,OAAOA,QAAQ,YAAYA,OAAO,MAAM;gBAC1C,OAAO;oBACL,GAAGA,GAAG;gBACR;YACF;YAEA,OAAOA;QACT;IACF;IAEA,IAAI,OAAOJ,oBAAoB,YAAYA,oBAAoB,MAAM;QACnE,OAAO;YAAE,GAAGA,eAAe;QAAC;IAC9B;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2870, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2876, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeValidate/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, JsonValue, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName, valueIsValueWithRelation } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { cloneDataFromOriginalDoc } from '../beforeChange/cloneDataFromOriginalDoc.js'\nimport { getExistingRowDoc } from '../beforeChange/getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: T\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  parentPath: (number | string)[]\n  parentSchemaPath: string[]\n  req: PayloadRequest\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n}\n\n// This function is responsible for the following actions, in order:\n// - Sanitize incoming data\n// - Execute field hooks\n// - Execute field access control\n// - Merge original document data into incoming data\n// - Compute default values for undefined fields\n\nexport const promise = async <T>({\n  id,\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  fieldIndex,\n  global,\n  operation,\n  overrideAccess,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const { path: _fieldPath, schemaPath: _fieldSchemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath: '', // Doesn't matter, as unnamed fields do not affect data, and hooks are only run on fields that affect data\n    parentPath: parentPath.join('.'),\n    parentSchemaPath: parentSchemaPath.join('.'),\n  })\n  const fieldPath = _fieldPath ? _fieldPath.split('.') : []\n  const fieldSchemaPath = _fieldSchemaPath ? _fieldSchemaPath.split('.') : []\n\n  if (fieldAffectsData(field)) {\n    if (field.name === 'id') {\n      if (field.type === 'number' && typeof siblingData[field.name] === 'string') {\n        const value = siblingData[field.name] as string\n\n        siblingData[field.name] = parseFloat(value)\n      }\n\n      if (\n        field.type === 'text' &&\n        typeof siblingData[field.name]?.toString === 'function' &&\n        typeof siblingData[field.name] !== 'string'\n      ) {\n        siblingData[field.name] = siblingData[field.name].toString()\n      }\n    }\n\n    // Sanitize incoming data\n    switch (field.type) {\n      case 'array':\n      case 'blocks': {\n        // Handle cases of arrays being intentionally set to 0\n        if (siblingData[field.name] === '0' || siblingData[field.name] === 0) {\n          siblingData[field.name] = []\n        }\n\n        break\n      }\n\n      case 'checkbox': {\n        if (siblingData[field.name] === 'true') {\n          siblingData[field.name] = true\n        }\n        if (siblingData[field.name] === 'false') {\n          siblingData[field.name] = false\n        }\n        if (siblingData[field.name] === '') {\n          siblingData[field.name] = false\n        }\n\n        break\n      }\n\n      case 'number': {\n        if (typeof siblingData[field.name] === 'string') {\n          const value = siblingData[field.name] as string\n          const trimmed = value.trim()\n          siblingData[field.name] = trimmed.length === 0 ? null : parseFloat(trimmed)\n        }\n\n        break\n      }\n\n      case 'point': {\n        if (Array.isArray(siblingData[field.name])) {\n          siblingData[field.name] = (siblingData[field.name] as string[]).map((coordinate, i) => {\n            if (typeof coordinate === 'string') {\n              const value = siblingData[field.name][i] as string\n              const trimmed = value.trim()\n              return trimmed.length === 0 ? null : parseFloat(trimmed)\n            }\n            return coordinate\n          })\n        }\n\n        break\n      }\n      case 'relationship':\n      case 'upload': {\n        if (\n          siblingData[field.name] === '' ||\n          siblingData[field.name] === 'none' ||\n          siblingData[field.name] === 'null' ||\n          siblingData[field.name] === null\n        ) {\n          if (field.hasMany === true) {\n            siblingData[field.name] = []\n          } else {\n            siblingData[field.name] = null\n          }\n        }\n\n        const value = siblingData[field.name]\n\n        if (Array.isArray(field.relationTo)) {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: { relationTo: string; value: JsonValue }, i) => {\n              const relatedCollection = req.payload.config.collections.find(\n                (collection) => collection.slug === relatedDoc.relationTo,\n              )\n\n              if (\n                typeof relatedDoc.value === 'object' &&\n                relatedDoc.value &&\n                'id' in relatedDoc.value\n              ) {\n                relatedDoc.value = relatedDoc.value.id\n              }\n\n              if (relatedCollection?.fields) {\n                const relationshipIDField = relatedCollection.fields.find(\n                  (collectionField) =>\n                    fieldAffectsData(collectionField) && collectionField.name === 'id',\n                )\n                if (relationshipIDField?.type === 'number') {\n                  siblingData[field.name][i] = {\n                    ...relatedDoc,\n                    value: parseFloat(relatedDoc.value as string),\n                  }\n                }\n              }\n            })\n          }\n          if (field.hasMany !== true && valueIsValueWithRelation(value)) {\n            const relatedCollection = req.payload.config.collections.find(\n              (collection) => collection.slug === value.relationTo,\n            )\n\n            if (typeof value.value === 'object' && value.value && 'id' in value.value) {\n              value.value = (value.value as TypeWithID).id\n            }\n\n            if (relatedCollection?.fields) {\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name] = { ...value, value: parseFloat(value.value as string) }\n              }\n            }\n          }\n        } else {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: unknown, i) => {\n              const relatedCollection = req.payload.config.collections.find(\n                (collection) => collection.slug === field.relationTo,\n              )\n\n              if (typeof relatedDoc === 'object' && relatedDoc && 'id' in relatedDoc) {\n                value[i] = relatedDoc.id\n              }\n\n              if (relatedCollection?.fields) {\n                const relationshipIDField = relatedCollection.fields.find(\n                  (collectionField) =>\n                    fieldAffectsData(collectionField) && collectionField.name === 'id',\n                )\n                if (relationshipIDField?.type === 'number') {\n                  siblingData[field.name][i] = parseFloat(relatedDoc as string)\n                }\n              }\n            })\n          }\n          if (field.hasMany !== true && value) {\n            const relatedCollection = req.payload.config.collections.find(\n              (collection) => collection.slug === field.relationTo,\n            )\n\n            if (typeof value === 'object' && value && 'id' in value) {\n              siblingData[field.name] = value.id\n            }\n\n            if (relatedCollection?.fields) {\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name] = parseFloat(value as string)\n              }\n            }\n          }\n        }\n        break\n      }\n      case 'richText': {\n        if (typeof siblingData[field.name] === 'string') {\n          try {\n            const richTextJSON = JSON.parse(siblingData[field.name] as string)\n            siblingData[field.name] = richTextJSON\n          } catch {\n            // Disregard this data as it is not valid.\n            // Will be reported to user by field validation\n          }\n        }\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeValidate) {\n      await field.hooks.beforeValidate.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          collection,\n          context,\n          data,\n          field,\n          global,\n          operation,\n          originalDoc: doc,\n          overrideAccess,\n          path: fieldPath,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: fieldSchemaPath,\n          siblingData,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n\n    // Execute access control\n    if (field.access && field.access[operation]) {\n      const result = overrideAccess\n        ? true\n        : await field.access[operation]({ id, data, doc, req, siblingData })\n\n      if (!result) {\n        delete siblingData[field.name]\n      }\n    }\n\n    if (typeof siblingData[field.name] === 'undefined') {\n      // If no incoming data, but existing document data is found, merge it in\n      if (typeof siblingDoc[field.name] !== 'undefined') {\n        siblingData[field.name] = cloneDataFromOriginalDoc(siblingDoc[field.name])\n\n        // Otherwise compute default value\n      } else if (typeof field.defaultValue !== 'undefined') {\n        siblingData[field.name] = await getDefaultValue({\n          defaultValue: field.defaultValue,\n          locale: req.locale,\n          req,\n          user: req.user,\n          value: siblingData[field.name],\n        })\n      }\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          promises.push(\n            traverseFields({\n              id,\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              overrideAccess,\n              path: [...fieldPath, i],\n              req,\n              schemaPath: fieldSchemaPath,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n            }),\n          )\n        })\n        await Promise.all(promises)\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, i) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n          const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n          if (block) {\n            ;(row as JsonObject).blockType = blockTypeToMatch\n\n            promises.push(\n              traverseFields({\n                id,\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                overrideAccess,\n                path: [...fieldPath, i],\n                req,\n                schemaPath: fieldSchemaPath,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n              }),\n            )\n          }\n        })\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') {\n        siblingData[field.name] = {}\n      }\n      if (typeof siblingDoc[field.name] !== 'object') {\n        siblingDoc[field.name] = {}\n      }\n\n      const groupData = siblingData[field.name] as Record<string, unknown>\n      const groupDoc = siblingDoc[field.name] as Record<string, unknown>\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: groupData as JsonObject,\n        siblingDoc: groupDoc as JsonObject,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeValidate?.length) {\n        await editor.hooks.beforeValidate.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            operation,\n            originalDoc: doc,\n            overrideAccess,\n            path: fieldPath,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingData[field.name],\n            req,\n            schemaPath: fieldSchemaPath,\n            siblingData,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData\n      let tabSiblingDoc\n      if (tabHasName(field)) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as Record<string, unknown>\n        tabSiblingDoc = siblingDoc[field.name] as Record<string, unknown>\n      } else {\n        tabSiblingData = siblingData\n        tabSiblingDoc = siblingDoc\n      }\n\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        overrideAccess,\n        path: fieldPath,\n        req,\n        schemaPath: fieldSchemaPath,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","valueIsValueWithRelation","getDefaultValue","getFieldPaths","cloneDataFromOriginalDoc","getExistingRowDoc","traverseFields","promise","id","collection","context","data","doc","field","fieldIndex","global","operation","overrideAccess","parentPath","parentSchemaPath","req","siblingData","siblingDoc","path","_fieldPath","schemaPath","_fieldSchemaPath","index","parentIndexPath","join","fieldPath","split","fieldSchemaPath","name","type","value","parseFloat","toString","trimmed","trim","length","Array","isArray","map","coordinate","i","hasMany","relationTo","forEach","relatedDoc","relatedCollection","payload","config","collections","find","slug","fields","relationshipIDField","collectionField","richTextJSON","JSON","parse","hooks","beforeValidate","reduce","priorHook","currentHook","hookedValue","originalDoc","previousSiblingDoc","previousValue","undefined","Promise","resolve","access","result","defaultValue","locale","user","rows","promises","row","push","all","rowSiblingDoc","blockTypeToMatch","blockType","block","blocks","groupData","groupDoc","editor","Error","tabSiblingData","tabSiblingDoc","tabs","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3326, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3332, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeValidate/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args<T> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: T\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  path: (number | string)[]\n  req: PayloadRequest\n  schemaPath: string[]\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async <T>({\n  id,\n  collection,\n  context,\n  data,\n  doc,\n  fields,\n  global,\n  operation,\n  overrideAccess,\n  path,\n  req,\n  schemaPath,\n  siblingData,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const promises = []\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        id,\n        collection,\n        context,\n        data,\n        doc,\n        field,\n        fieldIndex,\n        global,\n        operation,\n        overrideAccess,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n      }),\n    )\n  })\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","collection","context","data","doc","fields","global","operation","overrideAccess","path","req","schemaPath","siblingData","siblingDoc","promises","forEach","field","fieldIndex","push","parentPath","parentSchemaPath","Promise","all"],"mappings":";;;AAMA,SAASA,OAAO,QAAQ,eAAc;;AAyB/B,MAAMC,iBAAiB,OAAU,EACtCC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,IAAI,EACJC,GAAG,EACHC,UAAU,EACVC,WAAW,EACXC,UAAU,EACF;IACR,MAAMC,WAAW,EAAE;IACnBT,OAAOU,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,2YACXpB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAY;YACAC;YACAX;YACAC;YACAC;YACAW,YAAYV;YACZW,kBAAkBT;YAClBD;YACAE;YACAC;QACF;IAEJ;IACA,MAAMQ,QAAQC,GAAG,CAACR;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3360, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3376, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterRead/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'\n\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { getSelectMode } from '../../../utilities/getSelectMode.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth?: number\n  depth: number\n  doc: T\n  draft: boolean\n  fallbackLocale: null | string\n  findMany?: boolean\n  flattenLocales?: boolean\n  global: null | SanitizedGlobalConfig\n  locale: string\n  overrideAccess: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  select?: SelectType\n  showHiddenFields: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Remove hidden fields from response\n * - Flatten locales into requested locale. If the input doc contains all locales, the output doc after this function will only contain the requested locale.\n * - Sanitize outgoing data (point field, etc.)\n * - Execute field hooks\n * - Execute read access control\n * - Populate relationships\n */\n\nexport async function afterRead<T extends JsonObject>(args: Args<T>): Promise<T> {\n  const {\n    collection,\n    context,\n    currentDepth: incomingCurrentDepth,\n    depth: incomingDepth,\n    doc: incomingDoc,\n    draft,\n    fallbackLocale,\n    findMany,\n    flattenLocales = true,\n    global,\n    locale,\n    overrideAccess,\n    populate,\n    req,\n    select,\n    showHiddenFields,\n  } = args\n\n  const doc = deepCopyObjectSimple(incomingDoc)\n  const fieldPromises = []\n  const populationPromises = []\n\n  let depth =\n    incomingDepth || incomingDepth === 0\n      ? parseInt(String(incomingDepth), 10)\n      : req.payload.config.defaultDepth\n  if (depth > req.payload.config.maxDepth) {\n    depth = req.payload.config.maxDepth\n  }\n\n  const currentDepth = incomingCurrentDepth || 1\n\n  traverseFields({\n    collection,\n    context,\n    currentDepth,\n    depth,\n    doc,\n    draft,\n    fallbackLocale,\n    fieldPromises,\n    fields: collection?.fields || global?.fields,\n    findMany,\n    flattenLocales,\n    global,\n    locale,\n    overrideAccess,\n    path: [],\n    populate,\n    populationPromises,\n    req,\n    schemaPath: [],\n    select,\n    selectMode: select ? getSelectMode(select) : undefined,\n    showHiddenFields,\n    siblingDoc: doc,\n  })\n\n  await Promise.all(fieldPromises)\n  await Promise.all(populationPromises)\n\n  return doc\n}\n"],"names":["deepCopyObjectSimple","getSelectMode","traverseFields","afterRead","args","collection","context","currentDepth","incomingCurrentDepth","depth","incomingDepth","doc","incomingDoc","draft","fallbackLocale","findMany","flattenLocales","global","locale","overrideAccess","populate","req","select","showHiddenFields","fieldPromises","populationPromises","parseInt","String","payload","config","defaultDepth","maxDepth","fields","path","schemaPath","selectMode","undefined","siblingDoc","Promise","all"],"mappings":";;;AAKA,SAASA,oBAAoB,QAAQ,uCAAsC;AAE3E,SAASE,cAAc,QAAQ,sBAAqB;AADpD,SAASD,aAAa,QAAQ,sCAAqC;;;;AAgC5D,eAAeE,UAAgCC,IAAa;IACjE,MAAM,EACJC,UAAU,EACVC,OAAO,EACPC,cAAcC,oBAAoB,EAClCC,OAAOC,aAAa,EACpBC,KAAKC,WAAW,EAChBC,KAAK,EACLC,cAAc,EACdC,QAAQ,EACRC,iBAAiB,IAAI,EACrBC,MAAM,EACNC,MAAM,EACNC,cAAc,EACdC,QAAQ,EACRC,GAAG,EACHC,MAAM,EACNC,gBAAgB,EACjB,GAAGnB;IAEJ,MAAMO,OAAMX,+YAAAA,EAAqBY;IACjC,MAAMY,gBAAgB,EAAE;IACxB,MAAMC,qBAAqB,EAAE;IAE7B,IAAIhB,QACFC,iBAAiBA,kBAAkB,IAC/BgB,SAASC,OAAOjB,gBAAgB,MAChCW,IAAIO,OAAO,CAACC,MAAM,CAACC,YAAY;IACrC,IAAIrB,QAAQY,IAAIO,OAAO,CAACC,MAAM,CAACE,QAAQ,EAAE;QACvCtB,QAAQY,IAAIO,OAAO,CAACC,MAAM,CAACE,QAAQ;IACrC;IAEA,MAAMxB,eAAeC,wBAAwB;gZAE7CN,iBAAAA,EAAe;QACbG;QACAC;QACAC;QACAE;QACAE;QACAE;QACAC;QACAU;QACAQ,QAAQ3B,YAAY2B,UAAUf,QAAQe;QACtCjB;QACAC;QACAC;QACAC;QACAC;QACAc,MAAM,EAAE;QACRb;QACAK;QACAJ;QACAa,YAAY,EAAE;QACdZ;QACAa,YAAYb,iYAASrB,gBAAAA,EAAcqB,UAAUc;QAC7Cb;QACAc,YAAY1B;IACd;IAEA,MAAM2B,QAAQC,GAAG,CAACf;IAClB,MAAMc,QAAQC,GAAG,CAACd;IAElB,OAAOd;AACT","ignoreList":[0]}},
    {"offset": {"line": 3424, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3430, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeDuplicate/runHook.ts"],"sourcesContent":["import type { FieldHookArgs } from '../../config/types.js'\n\nexport const runBeforeDuplicateHooks = async (args: FieldHookArgs) =>\n  await args.field.hooks.beforeDuplicate.reduce(async (priorHook, currentHook) => {\n    await priorHook\n    return await currentHook(args)\n  }, Promise.resolve())\n"],"names":["runBeforeDuplicateHooks","args","field","hooks","beforeDuplicate","reduce","priorHook","currentHook","Promise","resolve"],"mappings":";;;AAEO,MAAMA,0BAA0B,OAAOC,OAC5C,MAAMA,KAAKC,KAAK,CAACC,KAAK,CAACC,eAAe,CAACC,MAAM,CAAC,OAAOC,WAAWC;QAC9D,MAAMD;QACN,OAAO,MAAMC,YAAYN;IAC3B,GAAGO,QAAQC,OAAO,IAAG","ignoreList":[0]}},
    {"offset": {"line": 3437, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3443, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeDuplicate/promise.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, FieldHookArgs, TabAsField } from '../../config/types.js'\n\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { runBeforeDuplicateHooks } from './runHook.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc: T\n  field: Field | TabAsField\n  fieldIndex: number\n  id?: number | string\n  overrideAccess: boolean\n  parentPath: (number | string)[]\n  parentSchemaPath: string[]\n  req: PayloadRequest\n  siblingDoc: JsonObject\n}\n\nexport const promise = async <T>({\n  id,\n  collection,\n  context,\n  doc,\n  field,\n  fieldIndex,\n  overrideAccess,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const { localization } = req.payload.config\n\n  const { path: _fieldPath, schemaPath: _fieldSchemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath: '', // Doesn't matter, as unnamed fields do not affect data, and hooks are only run on fields that affect data\n    parentPath: parentPath.join('.'),\n    parentSchemaPath: parentSchemaPath.join('.'),\n  })\n  const fieldPath = _fieldPath ? _fieldPath.split('.') : []\n  const fieldSchemaPath = _fieldSchemaPath ? _fieldSchemaPath.split('.') : []\n\n  // Handle unnamed tabs\n  if (field.type === 'tab' && !tabHasName(field)) {\n    await traverseFields({\n      id,\n      collection,\n      context,\n      doc,\n      fields: field.fields,\n      overrideAccess,\n      path: fieldPath,\n      req,\n      schemaPath: fieldSchemaPath,\n      siblingDoc,\n    })\n\n    return\n  }\n\n  if (fieldAffectsData(field)) {\n    let fieldData = siblingDoc?.[field.name]\n    const fieldIsLocalized = field.localized && localization\n\n    // Run field beforeDuplicate hooks\n    if (Array.isArray(field.hooks?.beforeDuplicate)) {\n      if (fieldIsLocalized) {\n        const localeData = await localization.localeCodes.reduce(\n          async (localizedValuesPromise: Promise<JsonObject>, locale) => {\n            const localizedValues = await localizedValuesPromise\n\n            const beforeDuplicateArgs: FieldHookArgs = {\n              collection,\n              context,\n              data: doc,\n              field,\n              global: undefined,\n              path: fieldPath,\n              previousSiblingDoc: siblingDoc,\n              previousValue: siblingDoc[field.name]?.[locale],\n              req,\n              schemaPath: parentSchemaPath,\n              siblingData: siblingDoc,\n              siblingDocWithLocales: siblingDoc,\n              value: siblingDoc[field.name]?.[locale],\n            }\n\n            const hookResult = await runBeforeDuplicateHooks(beforeDuplicateArgs)\n\n            if (typeof hookResult !== 'undefined') {\n              return {\n                ...localizedValues,\n                [locale]: hookResult,\n              }\n            }\n\n            return localizedValuesPromise\n          },\n          Promise.resolve({}),\n        )\n\n        siblingDoc[field.name] = localeData\n      } else {\n        const beforeDuplicateArgs: FieldHookArgs = {\n          collection,\n          context,\n          data: doc,\n          field,\n          global: undefined,\n          path: fieldPath,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: parentSchemaPath,\n          siblingData: siblingDoc,\n          siblingDocWithLocales: siblingDoc,\n          value: siblingDoc[field.name],\n        }\n\n        const hookResult = await runBeforeDuplicateHooks(beforeDuplicateArgs)\n        if (typeof hookResult !== 'undefined') {\n          siblingDoc[field.name] = hookResult\n        }\n      }\n    }\n\n    // First, for any localized fields, we will loop over locales\n    // and if locale data is present, traverse the sub fields.\n    // There are only a few different fields where this is possible.\n    if (fieldIsLocalized) {\n      if (typeof fieldData !== 'object' || fieldData === null) {\n        siblingDoc[field.name] = {}\n        fieldData = siblingDoc[field.name]\n      }\n\n      const promises = []\n\n      localization.localeCodes.forEach((locale) => {\n        if (fieldData[locale]) {\n          switch (field.type) {\n            case 'array': {\n              const rows = fieldData[locale]\n\n              if (Array.isArray(rows)) {\n                const promises = []\n                rows.forEach((row, i) => {\n                  promises.push(\n                    traverseFields({\n                      id,\n                      collection,\n                      context,\n                      doc,\n                      fields: field.fields,\n                      overrideAccess,\n                      path: [...fieldPath, i],\n                      req,\n                      schemaPath: fieldSchemaPath,\n                      siblingDoc: row,\n                    }),\n                  )\n                })\n              }\n              break\n            }\n            case 'blocks': {\n              const rows = fieldData[locale]\n\n              if (Array.isArray(rows)) {\n                const promises = []\n                rows.forEach((row, i) => {\n                  const blockTypeToMatch = row.blockType\n\n                  const block = field.blocks.find(\n                    (blockType) => blockType.slug === blockTypeToMatch,\n                  )\n\n                  promises.push(\n                    traverseFields({\n                      id,\n                      collection,\n                      context,\n                      doc,\n                      fields: block.fields,\n                      overrideAccess,\n                      path: [...fieldPath, i],\n                      req,\n                      schemaPath: fieldSchemaPath,\n                      siblingDoc: row,\n                    }),\n                  )\n                })\n              }\n              break\n            }\n\n            case 'group':\n\n            case 'tab': {\n              promises.push(\n                traverseFields({\n                  id,\n                  collection,\n                  context,\n                  doc,\n                  fields: field.fields,\n                  overrideAccess,\n                  path: fieldSchemaPath,\n                  req,\n                  schemaPath: fieldSchemaPath,\n                  siblingDoc: fieldData[locale],\n                }),\n              )\n\n              break\n            }\n          }\n        }\n      })\n\n      await Promise.all(promises)\n    } else {\n      // If the field is not localized, but it affects data,\n      // we need to further traverse its children\n      // so the child fields can run beforeDuplicate hooks\n      switch (field.type) {\n        case 'array': {\n          const rows = siblingDoc[field.name]\n\n          if (Array.isArray(rows)) {\n            const promises = []\n            rows.forEach((row, i) => {\n              promises.push(\n                traverseFields({\n                  id,\n                  collection,\n                  context,\n                  doc,\n                  fields: field.fields,\n                  overrideAccess,\n                  path: [...fieldPath, i],\n                  req,\n                  schemaPath: fieldSchemaPath,\n                  siblingDoc: row,\n                }),\n              )\n            })\n            await Promise.all(promises)\n          }\n          break\n        }\n        case 'blocks': {\n          const rows = siblingDoc[field.name]\n\n          if (Array.isArray(rows)) {\n            const promises = []\n            rows.forEach((row, i) => {\n              const blockTypeToMatch = row.blockType\n              const block = field.blocks.find((blockType) => blockType.slug === blockTypeToMatch)\n\n              if (block) {\n                ;(row as JsonObject).blockType = blockTypeToMatch\n\n                promises.push(\n                  traverseFields({\n                    id,\n                    collection,\n                    context,\n                    doc,\n                    fields: block.fields,\n                    overrideAccess,\n                    path: [...fieldPath, i],\n                    req,\n                    schemaPath: fieldSchemaPath,\n                    siblingDoc: row,\n                  }),\n                )\n              }\n            })\n            await Promise.all(promises)\n          }\n\n          break\n        }\n\n        case 'group':\n\n        case 'tab': {\n          if (typeof siblingDoc[field.name] !== 'object') {\n            siblingDoc[field.name] = {}\n          }\n\n          const groupDoc = siblingDoc[field.name] as Record<string, unknown>\n\n          await traverseFields({\n            id,\n            collection,\n            context,\n            doc,\n            fields: field.fields,\n            overrideAccess,\n            path: fieldPath,\n            req,\n            schemaPath: fieldSchemaPath,\n            siblingDoc: groupDoc as JsonObject,\n          })\n\n          break\n        }\n      }\n    }\n  } else {\n    // Finally, we traverse fields which do not affect data here\n    switch (field.type) {\n      case 'collapsible':\n      case 'row': {\n        await traverseFields({\n          id,\n          collection,\n          context,\n          doc,\n          fields: field.fields,\n          overrideAccess,\n          path: fieldPath,\n          req,\n          schemaPath: fieldSchemaPath,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      case 'tabs': {\n        await traverseFields({\n          id,\n          collection,\n          context,\n          doc,\n          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n          overrideAccess,\n          path: fieldPath,\n          req,\n          schemaPath: fieldSchemaPath,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n  }\n}\n"],"names":["fieldAffectsData","tabHasName","getFieldPaths","runBeforeDuplicateHooks","traverseFields","promise","id","collection","context","doc","field","fieldIndex","overrideAccess","parentPath","parentSchemaPath","req","siblingDoc","localization","payload","config","path","_fieldPath","schemaPath","_fieldSchemaPath","index","parentIndexPath","join","fieldPath","split","fieldSchemaPath","type","fields","fieldData","name","fieldIsLocalized","localized","Array","isArray","hooks","beforeDuplicate","localeData","localeCodes","reduce","localizedValuesPromise","locale","localizedValues","beforeDuplicateArgs","data","global","undefined","previousSiblingDoc","previousValue","siblingData","siblingDocWithLocales","value","hookResult","Promise","resolve","promises","forEach","rows","row","i","push","blockTypeToMatch","blockType","block","blocks","find","slug","all","groupDoc","tabs","map","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3753, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3759, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeDuplicate/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args<T> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc: T\n  fields: (Field | TabAsField)[]\n  id?: number | string\n  overrideAccess: boolean\n  path: (number | string)[]\n  req: PayloadRequest\n  schemaPath: string[]\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async <T>({\n  id,\n  collection,\n  context,\n  doc,\n  fields,\n  overrideAccess,\n  path,\n  req,\n  schemaPath,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const promises = []\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        id,\n        collection,\n        context,\n        doc,\n        field,\n        fieldIndex,\n        overrideAccess,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingDoc,\n      }),\n    )\n  })\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","collection","context","doc","fields","overrideAccess","path","req","schemaPath","siblingDoc","promises","forEach","field","fieldIndex","push","parentPath","parentSchemaPath","Promise","all"],"mappings":";;;AAKA,SAASA,OAAO,QAAQ,eAAc;;AAe/B,MAAMC,iBAAiB,OAAU,EACtCC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,GAAG,EACHC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,GAAG,EACHC,UAAU,EACVC,UAAU,EACF;IACR,MAAMC,WAAW,EAAE;IACnBN,OAAOO,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,4YACXhB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAS;YACAC;YACAR;YACAU,YAAYT;YACZU,kBAAkBR;YAClBD;YACAE;QACF;IAEJ;IACA,MAAMQ,QAAQC,GAAG,CAACR;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3783, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3789, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeDuplicate/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\n\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc?: T\n  id?: number | string\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for running beforeDuplicate hooks\n * against a document including all locale data.\n * It will run each field's beforeDuplicate hook\n * and return the resulting docWithLocales.\n */\nexport const beforeDuplicate = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  doc,\n  overrideAccess,\n  req,\n}: Args<T>): Promise<T> => {\n  const newDoc = deepCopyObjectSimple(doc)\n\n  await traverseFields({\n    id,\n    collection,\n    context,\n    doc: newDoc,\n    fields: collection?.fields,\n    overrideAccess,\n    path: [],\n    req,\n    schemaPath: [],\n    siblingDoc: newDoc,\n  })\n\n  return newDoc\n}\n"],"names":["deepCopyObjectSimple","traverseFields","beforeDuplicate","id","collection","context","doc","overrideAccess","req","newDoc","fields","path","schemaPath","siblingDoc"],"mappings":";;;AAIA,SAASA,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;;;AAiB7C,MAAMC,kBAAkB,OAA6B,EAC1DC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,GAAG,EACHC,cAAc,EACdC,GAAG,EACK;IACR,MAAMC,kYAAST,uBAAAA,EAAqBM;IAEpC,wZAAML,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC,KAAKG;QACLC,QAAQN,YAAYM;QACpBH;QACAI,MAAM,EAAE;QACRH;QACAI,YAAY,EAAE;QACdC,YAAYJ;IACd;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3812, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3818, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeValidate/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\n\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  doc?: T\n  duplicate?: boolean\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Sanitize incoming data\n * - Execute field hooks\n * - Execute field access control\n * - Merge original document data into incoming data\n * - Compute default values for undefined fields\n */\nexport const beforeValidate = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  data: incomingData,\n  doc,\n  global,\n  operation,\n  overrideAccess,\n  req,\n}: Args<T>): Promise<T> => {\n  const data = deepCopyObjectSimple(incomingData)\n\n  await traverseFields({\n    id,\n    collection,\n    context,\n    data,\n    doc,\n    fields: collection?.fields || global?.fields,\n    global,\n    operation,\n    overrideAccess,\n    path: [],\n    req,\n    schemaPath: [],\n    siblingData: data,\n    siblingDoc: doc,\n  })\n\n  return data\n}\n"],"names":["deepCopyObjectSimple","traverseFields","beforeValidate","id","collection","context","data","incomingData","doc","global","operation","overrideAccess","req","fields","path","schemaPath","siblingData","siblingDoc"],"mappings":";;;AAKA,SAASA,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;;;AAuB7C,MAAMC,iBAAiB,OAA6B,EACzDC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,MAAMC,YAAY,EAClBC,GAAG,EACHC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,GAAG,EACK;IACR,MAAMN,gYAAON,uBAAAA,EAAqBO;IAElC,OAAMN,iaAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC;QACAE;QACAK,QAAQT,YAAYS,UAAUJ,QAAQI;QACtCJ;QACAC;QACAC;QACAG,MAAM,EAAE;QACRF;QACAG,YAAY,EAAE;QACdC,aAAaV;QACbW,YAAYT;IACd;IAEA,OAAOF;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3845, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3851, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/beforeChange/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\n\nimport { ValidationError } from '../../../errors/index.js'\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\nexport type Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  doc: T\n  docWithLocales: JsonObject\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: Operation\n  req: PayloadRequest\n  skipValidation?: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Run condition\n * - Execute field hooks\n * - Validate data\n * - Transform data for storage\n * - Unflatten locales. The input `data` is the normal document for one locale. The output result will become the document with locales.\n */\nexport const beforeChange = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  data: incomingData,\n  doc,\n  docWithLocales,\n  global,\n  operation,\n  req,\n  skipValidation,\n}: Args<T>): Promise<T> => {\n  const data = deepCopyObjectSimple(incomingData)\n  const mergeLocaleActions = []\n  const errors: ValidationFieldError[] = []\n\n  await traverseFields({\n    id,\n    collection,\n    context,\n    data,\n    doc,\n    docWithLocales,\n    errors,\n    fields: collection?.fields || global?.fields,\n    global,\n    mergeLocaleActions,\n    operation,\n    path: [],\n    req,\n    schemaPath: [],\n    siblingData: data,\n    siblingDoc: doc,\n    siblingDocWithLocales: docWithLocales,\n    skipValidation,\n  })\n\n  if (errors.length > 0) {\n    throw new ValidationError(\n      {\n        id,\n        collection: collection?.slug,\n        errors,\n        global: global?.slug,\n      },\n      req.t,\n    )\n  }\n\n  await mergeLocaleActions.reduce(async (priorAction, action) => {\n    await priorAction\n    await action()\n  }, Promise.resolve())\n\n  return data\n}\n"],"names":["ValidationError","deepCopyObjectSimple","traverseFields","beforeChange","id","collection","context","data","incomingData","doc","docWithLocales","global","operation","req","skipValidation","mergeLocaleActions","errors","fields","path","schemaPath","siblingData","siblingDoc","siblingDocWithLocales","length","slug","t","reduce","priorAction","action","Promise","resolve"],"mappings":";;;AAOA,SAASC,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;AAFpD,SAASF,eAAe,QAAQ,2BAA0B;;;;AAwBnD,MAAMG,eAAe,OAA6B,EACvDC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,MAAMC,YAAY,EAClBC,GAAG,EACHC,cAAc,EACdC,MAAM,EACNC,SAAS,EACTC,GAAG,EACHC,cAAc,EACN;IACR,MAAMP,gYAAON,uBAAAA,EAAqBO;IAClC,MAAMO,qBAAqB,EAAE;IAC7B,MAAMC,SAAiC,EAAE;IAEzC,qZAAMd,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC;QACAE;QACAC;QACAM;QACAC,QAAQZ,YAAYY,UAAUN,QAAQM;QACtCN;QACAI;QACAH;QACAM,MAAM,EAAE;QACRL;QACAM,YAAY,EAAE;QACdC,aAAab;QACbc,YAAYZ;QACZa,uBAAuBZ;QACvBI;IACF;IAEA,IAAIE,OAAOO,MAAM,GAAG,GAAG;QACrB,MAAM,uXAAIvB,kBAAAA,CACR;YACEI;YACAC,YAAYA,YAAYmB;YACxBR;YACAL,QAAQA,QAAQa;QAClB,GACAX,IAAIY,CAAC;IAET;IAEA,MAAMV,mBAAmBW,MAAM,CAAC,OAAOC,aAAaC;QAClD,MAAMD;QACN,MAAMC;IACR,GAAGC,QAAQC,OAAO;IAElB,OAAOvB;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3898, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3904, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/hooks/afterChange/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\n\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  /**\n   * The data before hooks\n   */\n  data: T\n  /**\n   * The data after hooks\n   */\n  doc: T\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  previousDoc: T\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Execute field hooks\n */\nexport const afterChange = async <T extends JsonObject>({\n  collection,\n  context,\n  data,\n  doc: incomingDoc,\n  global,\n  operation,\n  previousDoc,\n  req,\n}: Args<T>): Promise<T> => {\n  const doc = deepCopyObjectSimple(incomingDoc)\n\n  await traverseFields({\n    collection,\n    context,\n    data,\n    doc,\n    fields: collection?.fields || global?.fields,\n    global,\n    operation,\n    path: [],\n    previousDoc,\n    previousSiblingDoc: previousDoc,\n    req,\n    schemaPath: [],\n    siblingData: data,\n    siblingDoc: doc,\n  })\n\n  return doc\n}\n"],"names":["deepCopyObjectSimple","traverseFields","afterChange","collection","context","data","doc","incomingDoc","global","operation","previousDoc","req","fields","path","previousSiblingDoc","schemaPath","siblingData","siblingDoc"],"mappings":";;;AAKA,SAASA,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;;;AAuB7C,MAAMC,cAAc,OAA6B,EACtDC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,KAAKC,WAAW,EAChBC,MAAM,EACNC,SAAS,EACTC,WAAW,EACXC,GAAG,EACK;IACR,MAAML,+XAAMN,uBAAAA,EAAqBO;IAEjC,oZAAMN,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC;QACAM,QAAQT,YAAYS,UAAUJ,QAAQI;QACtCJ;QACAC;QACAI,MAAM,EAAE;QACRH;QACAI,oBAAoBJ;QACpBC;QACAI,YAAY,EAAE;QACdC,aAAaX;QACbY,YAAYX;IACd;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3931, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3937, "column": 0}, "map": {"version":3,"sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/payload/node_modules/.pnpm/payload%403.11.0_graphql%4016.10.0_monaco-editor%400.52.2_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_typescript%405.7.2/node_modules/payload/src/fields/config/client.ts"],"sourcesContent":["import type { I18nClient } from '@payloadcms/translations'\n\nimport type {\n  AdminClient,\n  BlockJSX,\n  BlocksFieldClient,\n  ClientBlock,\n  ClientField,\n  Field,\n  FieldBase,\n  JoinFieldClient,\n  LabelsClient,\n  RadioFieldClient,\n  RowFieldClient,\n  SelectFieldClient,\n  TabsFieldClient,\n} from '../../fields/config/types.js'\nimport type { Payload } from '../../types/index.js'\n\nimport { getFromImportMap } from '../../bin/generateImportMap/getFromImportMap.js'\nimport { MissingEditorProp } from '../../errors/MissingEditorProp.js'\nimport { fieldAffectsData } from '../../fields/config/types.js'\nimport { flattenTopLevelFields, type ImportMap } from '../../index.js'\nimport { removeUndefined } from '../../utilities/removeUndefined.js'\n\n// Should not be used - ClientField should be used instead. This is why we don't export ClientField, we don't want people\n// to accidentally use it instead of ClientField and get confused\n\nexport { ClientField }\n\nexport type ServerOnlyFieldProperties =\n  | 'dbName' // can be a function\n  | 'editor' // This is a `richText` only property\n  | 'enumName' // can be a function\n  | 'filterOptions' // This is a `relationship` and `upload` only property\n  | 'graphQL'\n  | 'label'\n  | 'typescriptSchema'\n  | 'validate'\n  | keyof Pick<FieldBase, 'access' | 'custom' | 'defaultValue' | 'hooks'>\n\nexport type ServerOnlyFieldAdminProperties = keyof Pick<\n  FieldBase['admin'],\n  'components' | 'condition'\n>\n\nconst serverOnlyFieldProperties: Partial<ServerOnlyFieldProperties>[] = [\n  'hooks',\n  'access',\n  'validate',\n  'defaultValue',\n  'filterOptions', // This is a `relationship` and `upload` only property\n  'editor', // This is a `richText` only property\n  'custom',\n  'typescriptSchema',\n  'dbName', // can be a function\n  'enumName', // can be a function\n  'graphQL', // client does not need graphQL\n  // the following props are handled separately (see below):\n  // `label`\n  // `fields`\n  // `blocks`\n  // `tabs`\n  // `admin`\n]\nconst serverOnlyFieldAdminProperties: Partial<ServerOnlyFieldAdminProperties>[] = [\n  'condition',\n  'components',\n]\ntype FieldWithDescription = {\n  admin: AdminClient\n} & ClientField\n\nexport const createClientField = ({\n  defaultIDType,\n  field: incomingField,\n  i18n,\n  importMap,\n}: {\n  defaultIDType: Payload['config']['db']['defaultIDType']\n  field: Field\n  i18n: I18nClient\n  importMap: ImportMap\n}): ClientField => {\n  const clientField: ClientField = {} as ClientField\n\n  for (const key in incomingField) {\n    if (serverOnlyFieldProperties.includes(key as any)) {\n      continue\n    }\n\n    switch (key) {\n      case 'admin':\n        if (!incomingField.admin) {\n          break\n        }\n\n        clientField.admin = {} as AdminClient\n\n        for (const adminKey in incomingField.admin) {\n          if (serverOnlyFieldAdminProperties.includes(adminKey as any)) {\n            continue\n          }\n\n          switch (adminKey) {\n            case 'description':\n              if ('description' in incomingField.admin) {\n                if (typeof incomingField.admin?.description !== 'function') {\n                  ;(clientField as FieldWithDescription).admin.description =\n                    incomingField.admin.description\n                }\n              }\n\n              break\n\n            default:\n              clientField.admin[adminKey] = incomingField.admin[adminKey]\n          }\n        }\n\n        break\n\n      case 'blocks':\n      case 'fields':\n      case 'tabs':\n        // Skip - we handle sub-fields in the switch below\n        break\n\n      case 'label':\n        //@ts-expect-error - would need to type narrow\n        if (typeof incomingField.label === 'function') {\n          //@ts-expect-error - would need to type narrow\n          clientField.label = incomingField.label({ t: i18n.t })\n        } else {\n          //@ts-expect-error - would need to type narrow\n          clientField.label = incomingField.label\n        }\n\n        break\n\n      default:\n        clientField[key] = incomingField[key]\n    }\n  }\n\n  switch (incomingField.type) {\n    case 'array':\n    case 'collapsible':\n    case 'group':\n    case 'row': {\n      const field = clientField as unknown as RowFieldClient\n\n      if (!field.fields) {\n        field.fields = []\n      }\n\n      field.fields = createClientFields({\n        defaultIDType,\n        disableAddingID: incomingField.type !== 'array',\n        fields: incomingField.fields,\n        i18n,\n        importMap,\n      })\n\n      break\n    }\n\n    case 'blocks': {\n      const field = clientField as unknown as BlocksFieldClient\n\n      if (incomingField.blocks?.length) {\n        for (let i = 0; i < incomingField.blocks.length; i++) {\n          const block = incomingField.blocks[i]\n\n          // prevent $undefined from being passed through the rsc requests\n          const clientBlock = removeUndefined<ClientBlock>({\n            slug: block.slug,\n            fields: field.blocks?.[i]?.fields || [],\n            imageAltText: block.imageAltText,\n            imageURL: block.imageURL,\n          }) satisfies ClientBlock\n\n          if (block.admin?.custom) {\n            clientBlock.admin = {\n              custom: block.admin.custom,\n            }\n          }\n\n          if (block?.admin?.jsx) {\n            const jsxResolved = getFromImportMap<BlockJSX>({\n              importMap,\n              PayloadComponent: block.admin.jsx,\n              schemaPath: '',\n            })\n            clientBlock.jsx = jsxResolved\n          }\n\n          if (block.labels) {\n            clientBlock.labels = {} as unknown as LabelsClient\n\n            if (block.labels.singular) {\n              if (typeof block.labels.singular === 'function') {\n                clientBlock.labels.singular = block.labels.singular({ t: i18n.t })\n              } else {\n                clientBlock.labels.singular = block.labels.singular\n              }\n              if (typeof block.labels.plural === 'function') {\n                clientBlock.labels.plural = block.labels.plural({ t: i18n.t })\n              } else {\n                clientBlock.labels.plural = block.labels.plural\n              }\n            }\n          }\n\n          clientBlock.fields = createClientFields({\n            defaultIDType,\n            fields: block.fields,\n            i18n,\n            importMap,\n          })\n\n          if (!field.blocks) {\n            field.blocks = []\n          }\n\n          field.blocks[i] = clientBlock\n        }\n      }\n\n      break\n    }\n\n    case 'join': {\n      const field = clientField as JoinFieldClient\n\n      field.targetField = {\n        relationTo: field.targetField.relationTo,\n      }\n\n      break\n    }\n\n    case 'radio':\n    // falls through\n    case 'select': {\n      const field = clientField as RadioFieldClient | SelectFieldClient\n\n      if (incomingField.options?.length) {\n        for (let i = 0; i < incomingField.options.length; i++) {\n          const option = incomingField.options[i]\n\n          if (typeof option === 'object' && typeof option.label === 'function') {\n            if (!field.options) {\n              field.options = []\n            }\n\n            field.options[i] = {\n              label: option.label({ t: i18n.t }),\n              value: option.value,\n            }\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!incomingField?.editor) {\n        throw new MissingEditorProp(incomingField) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof incomingField?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      break\n    }\n\n    case 'tabs': {\n      const field = clientField as unknown as TabsFieldClient\n\n      if (incomingField.tabs?.length) {\n        field.tabs = []\n\n        for (let i = 0; i < incomingField.tabs.length; i++) {\n          const tab = incomingField.tabs[i]\n          const clientTab = {} as unknown as TabsFieldClient['tabs'][0]\n\n          for (const key in tab) {\n            if (serverOnlyFieldProperties.includes(key as any)) {\n              continue\n            }\n\n            if (key === 'fields') {\n              clientTab.fields = createClientFields({\n                defaultIDType,\n                disableAddingID: true,\n                fields: tab.fields,\n                i18n,\n                importMap,\n              })\n            } else {\n              clientTab[key] = tab[key]\n            }\n          }\n          field.tabs[i] = clientTab\n        }\n      }\n\n      break\n    }\n\n    default:\n      break\n  }\n\n  return clientField\n}\n\nexport const createClientFields = ({\n  defaultIDType,\n  disableAddingID,\n  fields,\n  i18n,\n  importMap,\n}: {\n  defaultIDType: Payload['config']['db']['defaultIDType']\n  disableAddingID?: boolean\n  fields: Field[]\n  i18n: I18nClient\n  importMap: ImportMap\n}): ClientField[] => {\n  const clientFields: ClientField[] = []\n\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i]\n\n    const clientField = createClientField({\n      defaultIDType,\n      field,\n      i18n,\n      importMap,\n    })\n\n    clientFields.push(clientField)\n  }\n\n  const hasID = flattenTopLevelFields(fields).some((f) => fieldAffectsData(f) && f.name === 'id')\n\n  if (!disableAddingID && !hasID) {\n    clientFields.push({\n      name: 'id',\n      type: defaultIDType,\n      admin: {\n        description: 'The unique identifier for this document',\n        disableBulkEdit: true,\n        disabled: true,\n        hidden: true,\n      },\n      hidden: true,\n      label: 'ID',\n    })\n  }\n\n  return clientFields\n}\n"],"names":["getFromImportMap","MissingEditorProp","fieldAffectsData","flattenTopLevelFields","removeUndefined","serverOnlyFieldProperties","serverOnlyFieldAdminProperties","createClientField","defaultIDType","field","incomingField","i18n","importMap","clientField","key","includes","admin","adminKey","description","label","t","type","fields","createClientFields","disableAddingID","blocks","length","i","block","clientBlock","slug","imageAltText","imageURL","custom","jsx","jsxResolved","PayloadComponent","schemaPath","labels","singular","plural","targetField","relationTo","options","option","value","editor","Error","tabs","tab","clientTab","clientFields","push","hasID","some","f","name","disableBulkEdit","disabled","hidden"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4201, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}