{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"EditorTheme.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/lexical/theme/EditorTheme.tsx"],"sourcesContent":["import type { EditorThemeClasses } from 'lexical'\n\nexport const LexicalEditorTheme: EditorThemeClasses = {\n  block: 'LexicalEditorTheme__block',\n  blockCursor: 'LexicalEditorTheme__blockCursor',\n  characterLimit: 'LexicalEditorTheme__characterLimit',\n  code: 'LexicalEditorTheme__code',\n  codeHighlight: {\n    atrule: 'LexicalEditorTheme__tokenAttr',\n    attr: 'LexicalEditorTheme__tokenAttr',\n    boolean: 'LexicalEditorTheme__tokenProperty',\n    builtin: 'LexicalEditorTheme__tokenSelector',\n    cdata: 'LexicalEditorTheme__tokenComment',\n    char: 'LexicalEditorTheme__tokenSelector',\n    class: 'LexicalEditorTheme__tokenFunction',\n    'class-name': 'LexicalEditorTheme__tokenFunction',\n    comment: 'LexicalEditorTheme__tokenComment',\n    constant: 'LexicalEditorTheme__tokenProperty',\n    deleted: 'LexicalEditorTheme__tokenProperty',\n    doctype: 'LexicalEditorTheme__tokenComment',\n    entity: 'LexicalEditorTheme__tokenOperator',\n    function: 'LexicalEditorTheme__tokenFunction',\n    important: 'LexicalEditorTheme__tokenVariable',\n    inserted: 'LexicalEditorTheme__tokenSelector',\n    keyword: 'LexicalEditorTheme__tokenAttr',\n    namespace: 'LexicalEditorTheme__tokenVariable',\n    number: 'LexicalEditorTheme__tokenProperty',\n    operator: 'LexicalEditorTheme__tokenOperator',\n    prolog: 'LexicalEditorTheme__tokenComment',\n    property: 'LexicalEditorTheme__tokenProperty',\n    punctuation: 'LexicalEditorTheme__tokenPunctuation',\n    regex: 'LexicalEditorTheme__tokenVariable',\n    selector: 'LexicalEditorTheme__tokenSelector',\n    string: 'LexicalEditorTheme__tokenSelector',\n    symbol: 'LexicalEditorTheme__tokenProperty',\n    tag: 'LexicalEditorTheme__tokenProperty',\n    url: 'LexicalEditorTheme__tokenOperator',\n    variable: 'LexicalEditorTheme__tokenVariable',\n  },\n  embedBlock: {\n    base: 'LexicalEditorTheme__embedBlock',\n    focus: 'LexicalEditorTheme__embedBlockFocus',\n  },\n  hashtag: 'LexicalEditorTheme__hashtag',\n  heading: {\n    h1: 'LexicalEditorTheme__h1',\n    h2: 'LexicalEditorTheme__h2',\n    h3: 'LexicalEditorTheme__h3',\n    h4: 'LexicalEditorTheme__h4',\n    h5: 'LexicalEditorTheme__h5',\n    h6: 'LexicalEditorTheme__h6',\n  },\n  hr: 'LexicalEditorTheme__hr',\n  indent: 'LexicalEditorTheme__indent',\n  inlineImage: 'LexicalEditor__inline-image',\n  link: 'LexicalEditorTheme__link',\n  list: {\n    checklist: 'LexicalEditorTheme__checklist',\n    listitem: 'LexicalEditorTheme__listItem',\n    listitemChecked: 'LexicalEditorTheme__listItemChecked',\n    listitemUnchecked: 'LexicalEditorTheme__listItemUnchecked',\n    nested: {\n      listitem: 'LexicalEditorTheme__nestedListItem',\n    },\n    olDepth: [\n      'LexicalEditorTheme__ol1',\n      'LexicalEditorTheme__ol2',\n      'LexicalEditorTheme__ol3',\n      'LexicalEditorTheme__ol4',\n      'LexicalEditorTheme__ol5',\n    ],\n    ul: 'LexicalEditorTheme__ul',\n  },\n  ltr: 'LexicalEditorTheme__ltr',\n  mark: 'LexicalEditorTheme__mark',\n  markOverlap: 'LexicalEditorTheme__markOverlap',\n  paragraph: 'LexicalEditorTheme__paragraph',\n  quote: 'LexicalEditorTheme__quote',\n  relationship: 'LexicalEditorTheme__relationship',\n  rtl: 'LexicalEditorTheme__rtl',\n  table: 'LexicalEditorTheme__table',\n  tableAddColumns: 'LexicalEditorTheme__tableAddColumns',\n  tableAddRows: 'LexicalEditorTheme__tableAddRows',\n  tableCell: 'LexicalEditorTheme__tableCell',\n  tableCellActionButton: 'LexicalEditorTheme__tableCellActionButton',\n  tableCellActionButtonContainer: 'LexicalEditorTheme__tableCellActionButtonContainer',\n  tableCellHeader: 'LexicalEditorTheme__tableCellHeader',\n  tableCellResizer: 'LexicalEditorTheme__tableCellResizer',\n  tableCellSelected: 'LexicalEditorTheme__tableCellSelected',\n  tableRowStriping: 'LexicalEditorTheme__tableRowStriping',\n  tableScrollableWrapper: 'LexicalEditorTheme__tableScrollableWrapper',\n  tableSelected: 'LexicalEditorTheme__tableSelected',\n  tableSelection: 'LexicalEditorTheme__tableSelection',\n  text: {\n    bold: 'LexicalEditorTheme__textBold',\n    code: 'LexicalEditorTheme__textCode',\n    italic: 'LexicalEditorTheme__textItalic',\n    strikethrough: 'LexicalEditorTheme__textStrikethrough',\n    subscript: 'LexicalEditorTheme__textSubscript',\n    superscript: 'LexicalEditorTheme__textSuperscript',\n    underline: 'LexicalEditorTheme__textUnderline',\n    underlineStrikethrough: 'LexicalEditorTheme__textUnderlineStrikethrough',\n  },\n  upload: 'editor-upload',\n}\n"],"names":["LexicalEditorTheme","block","blockCursor","characterLimit","code","codeHighlight","atrule","attr","boolean","builtin","cdata","char","class","comment","constant","deleted","doctype","entity","function","important","inserted","keyword","namespace","number","operator","prolog","property","punctuation","regex","selector","string","symbol","tag","url","variable","embedBlock","base","focus","hashtag","heading","h1","h2","h3","h4","h5","h6","hr","indent","inlineImage","link","list","checklist","listitem","listitemChecked","listitemUnchecked","nested","olDepth","ul","ltr","mark","markOverlap","paragraph","quote","relationship","rtl","table","tableAddColumns","tableAddRows","tableCell","tableCellActionButton","tableCellActionButtonContainer","tableCellHeader","tableCellResizer","tableCellSelected","tableRowStriping","tableScrollableWrapper","tableSelected","tableSelection","text","bold","italic","strikethrough","subscript","superscript","underline","underlineStrikethrough","upload"],"mappings":";;;AAEO,MAAMA,kBAAA,GAAyC;IACpDC,KAAA,EAAO;IACPC,WAAA,EAAa;IACbC,cAAA,EAAgB;IAChBC,IAAA,EAAM;IACNC,aAAA,EAAe;QACbC,MAAA,EAAQ;QACRC,IAAA,EAAM;QACNC,OAAA,EAAS;QACTC,OAAA,EAAS;QACTC,KAAA,EAAO;QACPC,IAAA,EAAM;QACNC,KAAA,EAAO;QACP,cAAc;QACdC,OAAA,EAAS;QACTC,QAAA,EAAU;QACVC,OAAA,EAAS;QACTC,OAAA,EAAS;QACTC,MAAA,EAAQ;QACRC,QAAA,EAAU;QACVC,SAAA,EAAW;QACXC,QAAA,EAAU;QACVC,OAAA,EAAS;QACTC,SAAA,EAAW;QACXC,MAAA,EAAQ;QACRC,QAAA,EAAU;QACVC,MAAA,EAAQ;QACRC,QAAA,EAAU;QACVC,WAAA,EAAa;QACbC,KAAA,EAAO;QACPC,QAAA,EAAU;QACVC,MAAA,EAAQ;QACRC,MAAA,EAAQ;QACRC,GAAA,EAAK;QACLC,GAAA,EAAK;QACLC,QAAA,EAAU;IACZ;IACAC,UAAA,EAAY;QACVC,IAAA,EAAM;QACNC,KAAA,EAAO;IACT;IACAC,OAAA,EAAS;IACTC,OAAA,EAAS;QACPC,EAAA,EAAI;QACJC,EAAA,EAAI;QACJC,EAAA,EAAI;QACJC,EAAA,EAAI;QACJC,EAAA,EAAI;QACJC,EAAA,EAAI;IACN;IACAC,EAAA,EAAI;IACJC,MAAA,EAAQ;IACRC,WAAA,EAAa;IACbC,IAAA,EAAM;IACNC,IAAA,EAAM;QACJC,SAAA,EAAW;QACXC,QAAA,EAAU;QACVC,eAAA,EAAiB;QACjBC,iBAAA,EAAmB;QACnBC,MAAA,EAAQ;YACNH,QAAA,EAAU;QACZ;QACAI,OAAA,EAAS;YACP;YACA;YACA;YACA;YACA;SACD;QACDC,EAAA,EAAI;IACN;IACAC,GAAA,EAAK;IACLC,IAAA,EAAM;IACNC,WAAA,EAAa;IACbC,SAAA,EAAW;IACXC,KAAA,EAAO;IACPC,YAAA,EAAc;IACdC,GAAA,EAAK;IACLC,KAAA,EAAO;IACPC,eAAA,EAAiB;IACjBC,YAAA,EAAc;IACdC,SAAA,EAAW;IACXC,qBAAA,EAAuB;IACvBC,8BAAA,EAAgC;IAChCC,eAAA,EAAiB;IACjBC,gBAAA,EAAkB;IAClBC,iBAAA,EAAmB;IACnBC,gBAAA,EAAkB;IAClBC,sBAAA,EAAwB;IACxBC,aAAA,EAAe;IACfC,cAAA,EAAgB;IAChBC,IAAA,EAAM;QACJC,IAAA,EAAM;QACN3E,IAAA,EAAM;QACN4E,MAAA,EAAQ;QACRC,aAAA,EAAe;QACfC,SAAA,EAAW;QACXC,WAAA,EAAa;QACbC,SAAA,EAAW;QACXC,sBAAA,EAAwB;IAC1B;IACAC,MAAA,EAAQ;AACV","ignoreList":[0]}},
    {"offset": {"line": 113, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"file":"createServerFeature.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/utilities/createServerFeature.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  FeatureProviderProviderServer,\n  FeatureProviderServer,\n  ResolvedServerFeatureMap,\n  ServerFeature,\n  ServerFeatureProviderMap,\n} from '../features/typesServer.js'\nimport type { ServerEditorConfig } from '../lexical/config/types.js'\n\nexport type CreateServerFeatureArgs<UnSanitizedProps, SanitizedProps, ClientProps> = {\n  feature:\n    | ((props: {\n        config: SanitizedConfig\n        /** unSanitizedEditorConfig.features, but mapped */\n        featureProviderMap: ServerFeatureProviderMap\n        isRoot?: boolean\n        parentIsLocalized: boolean\n        props: UnSanitizedProps\n        // other resolved features, which have been loaded before this one. All features declared in 'dependencies' should be available here\n        resolvedFeatures: ResolvedServerFeatureMap\n        // unSanitized EditorConfig,\n        unSanitizedEditorConfig: ServerEditorConfig\n      }) =>\n        | Promise<ServerFeature<SanitizedProps, ClientProps>>\n        | ServerFeature<SanitizedProps, ClientProps>)\n    | Omit<ServerFeature<SanitizedProps, ClientProps>, 'sanitizedServerFeatureProps'>\n} & Pick<\n  FeatureProviderServer<UnSanitizedProps, ClientProps>,\n  'dependencies' | 'dependenciesPriority' | 'dependenciesSoft' | 'key'\n>\n\nexport const createServerFeature: <\n  UnSanitizedProps = undefined,\n  SanitizedProps = UnSanitizedProps,\n  ClientProps = undefined,\n>(\n  args: CreateServerFeatureArgs<UnSanitizedProps, SanitizedProps, ClientProps>,\n) => FeatureProviderProviderServer<UnSanitizedProps, SanitizedProps, ClientProps> = ({\n  dependencies,\n  dependenciesPriority,\n  dependenciesSoft,\n  feature,\n  key,\n}) => {\n  const featureProviderProviderServer: FeatureProviderProviderServer<any, any, any> = (props) => {\n    const featureProviderServer: Partial<FeatureProviderServer<any, any, any>> = {\n      dependencies,\n      dependenciesPriority,\n      dependenciesSoft,\n      key,\n      serverFeatureProps: props,\n    }\n\n    if (typeof feature === 'function') {\n      featureProviderServer.feature = async ({\n        config,\n        featureProviderMap,\n        isRoot,\n        parentIsLocalized,\n        resolvedFeatures,\n        unSanitizedEditorConfig,\n      }) => {\n        const toReturn = await feature({\n          config,\n          featureProviderMap,\n          isRoot,\n          parentIsLocalized,\n          props,\n          resolvedFeatures,\n          unSanitizedEditorConfig,\n        })\n\n        if (toReturn.sanitizedServerFeatureProps === null) {\n          toReturn.sanitizedServerFeatureProps = props\n        }\n        return toReturn\n      }\n    } else {\n      // For explanation why we have to spread feature, see createClientFeature.ts\n      const newFeature: ServerFeature<any, any> = { ...feature }\n\n      newFeature.sanitizedServerFeatureProps = props\n      featureProviderServer.feature = newFeature\n    }\n    return featureProviderServer as FeatureProviderServer<any, any, any>\n  }\n\n  return featureProviderProviderServer\n}\n"],"names":["createServerFeature","dependencies","dependenciesPriority","dependenciesSoft","feature","key","featureProviderProviderServer","props","featureProviderServer","serverFeatureProps","config","featureProviderMap","isRoot","parentIsLocalized","resolvedFeatures","unSanitizedEditorConfig","toReturn","sanitizedServerFeatureProps","newFeature"],"mappings":";;;AAiCO,MAAMA,mBAAA,GAMuEA,CAAC,EACnFC,YAAY,EACZC,oBAAoB,EACpBC,gBAAgB,EAChBC,OAAO,EACPC,GAAAA,EACD;IACC,MAAMC,6BAAA,IAA+EC,KAAA;QACnF,MAAMC,qBAAA,GAAuE;YAC3EP,YAAA;YACAC,oBAAA;YACAC,gBAAA;YACAE,GAAA;YACAI,kBAAA,EAAoBF;QACtB;QAEA,IAAI,OAAOH,OAAA,KAAY,YAAY;YACjCI,qBAAA,CAAsBJ,OAAO,GAAG,OAAO,EACrCM,MAAM,EACNC,kBAAkB,EAClBC,MAAM,EACNC,iBAAiB,EACjBC,gBAAgB,EAChBC,uBAAAA,EACD;gBACC,MAAMC,QAAA,GAAW,MAAMZ,OAAA,CAAQ;oBAC7BM,MAAA;oBACAC,kBAAA;oBACAC,MAAA;oBACAC,iBAAA;oBACAN,KAAA;oBACAO,gBAAA;oBACAC;gBACF;gBAEA,IAAIC,QAAA,CAASC,2BAA2B,KAAK,MAAM;oBACjDD,QAAA,CAASC,2BAA2B,GAAGV,KAAA;gBACzC;gBACA,OAAOS,QAAA;YACT;QACF,OAAO;YACL,4EAAA;YACA,MAAME,UAAA,GAAsC;gBAAE,GAAGd,OAAAA;YAAQ;YAEzDc,UAAA,CAAWD,2BAA2B,GAAGV,KAAA;YACzCC,qBAAA,CAAsBJ,OAAO,GAAGc,UAAA;QAClC;QACA,OAAOV,qBAAA;IACT;IAEA,OAAOF,6BAAA;AACT","ignoreList":[0]}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"file":"markdownTransformers.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/bold/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const BOLD_ITALIC_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold', 'italic'],\n  tag: '***',\n}\n\nexport const BOLD_ITALIC_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n}\n\nexport const BOLD_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold'],\n  tag: '**',\n}\n\nexport const BOLD_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n}\n"],"names":["BOLD_ITALIC_STAR","type","format","tag","BOLD_ITALIC_UNDERSCORE","intraword","BOLD_STAR","BOLD_UNDERSCORE"],"mappings":";;;;;;AAEO,MAAMA,gBAAA,GAA0C;IACrDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;QAAQ;KAAS;IAC1BC,GAAA,EAAK;AACP;AAEO,MAAMC,sBAAA,GAAgD;IAC3DH,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;QAAQ;KAAS;IAC1BG,SAAA,EAAW;IACXF,GAAA,EAAK;AACP;AAEO,MAAMG,SAAA,GAAmC;IAC9CL,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAO;IAChBC,GAAA,EAAK;AACP;AAEO,MAAMI,eAAA,GAAyC;IACpDN,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAO;IAChBG,SAAA,EAAW;IACXF,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 203, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/bold/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport {\n  BOLD_ITALIC_STAR,\n  BOLD_ITALIC_UNDERSCORE,\n  BOLD_STAR,\n  BOLD_UNDERSCORE,\n} from './markdownTransformers.js'\n\nexport const BoldFeature = createServerFeature({\n  dependenciesSoft: ['italic'],\n  feature: ({ featureProviderMap }) => {\n    const markdownTransformers = [BOLD_STAR, BOLD_UNDERSCORE]\n    if (featureProviderMap.get('italic')) {\n      markdownTransformers.push(BOLD_ITALIC_UNDERSCORE, BOLD_ITALIC_STAR)\n    }\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#BoldFeatureClient',\n      markdownTransformers,\n    }\n  },\n  key: 'bold',\n})\n"],"names":["createServerFeature","BOLD_ITALIC_STAR","BOLD_ITALIC_UNDERSCORE","BOLD_STAR","BOLD_UNDERSCORE","BoldFeature","dependenciesSoft","feature","featureProviderMap","markdownTransformers","get","push","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SACEC,gBAAgB,EAChBC,sBAAsB,EACtBC,SAAS,EACTC,eAAe,QACV;;;AAEA,MAAMC,WAAA,qTAAcL,sBAAAA,AAAA,EAAoB;IAC7CM,gBAAA,EAAkB;QAAC;KAAS;IAC5BC,OAAA,EAASA,CAAC,EAAEC,kBAAAA,EAAoB;QAC9B,MAAMC,oBAAA,GAAuB;4UAACN,YAAA;4UAAWC,kBAAA;SAAgB;QACzD,IAAII,kBAAA,CAAmBE,GAAG,CAAC,WAAW;YACpCD,oBAAA,CAAqBE,IAAI,iUAACT,yBAAA,kUAAwBD,mBAAA;QACpD;QAEA,OAAO;YACLW,aAAA,EAAe;YACfH;QACF;IACF;IACAI,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"file":"markdownTransformers.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/italic/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const ITALIC_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['italic'],\n  tag: '*',\n}\n\nexport const ITALIC_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n}\n"],"names":["ITALIC_STAR","type","format","tag","ITALIC_UNDERSCORE","intraword"],"mappings":";;;;AAEO,MAAMA,WAAA,GAAqC;IAChDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAS;IAClBC,GAAA,EAAK;AACP;AAEO,MAAMC,iBAAA,GAA2C;IACtDH,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAS;IAClBG,SAAA,EAAW;IACXF,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 260, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 266, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/italic/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { ITALIC_STAR, ITALIC_UNDERSCORE } from './markdownTransformers.js'\n\nexport const ItalicFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#ItalicFeatureClient',\n    markdownTransformers: [ITALIC_STAR, ITALIC_UNDERSCORE],\n  },\n  key: 'italic',\n})\n"],"names":["createServerFeature","ITALIC_STAR","ITALIC_UNDERSCORE","ItalicFeature","feature","ClientFeature","markdownTransformers","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,WAAW,EAAEC,iBAAiB,QAAQ;;;AAExC,MAAMC,aAAA,qTAAgBH,sBAAAA,AAAA,EAAoB;IAC/CI,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,oBAAA,EAAsB;8UAACL,cAAA;8UAAaC,oBAAA;SAAA;IACtC;IACAK,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 289, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/underline/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\n\nexport const UnderlineFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#UnderlineFeatureClient',\n  },\n  key: 'underline',\n})\n"],"names":["createServerFeature","UnderlineFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,gBAAA,qTAAmBD,sBAAAA,AAAA,EAAoB;IAClDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 300, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 306, "column": 0}, "map": {"version":3,"file":"markdownTransformers.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/strikethrough/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const STRIKETHROUGH: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['strikethrough'],\n  tag: '~~',\n}\n"],"names":["STRIKETHROUGH","type","format","tag"],"mappings":";;;AAEO,MAAMA,aAAA,GAAuC;IAClDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAgB;IACzBC,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 316, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/strikethrough/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { STRIKETHROUGH } from './markdownTransformers.js'\n\nexport const StrikethroughFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#StrikethroughFeatureClient',\n\n    markdownTransformers: [STRIKETHROUGH],\n  },\n  key: 'strikethrough',\n})\n"],"names":["createServerFeature","STRIKETHROUGH","StrikethroughFeature","feature","ClientFeature","markdownTransformers","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,aAAa,QAAQ;;;AAEvB,MAAMC,oBAAA,qTAAuBF,sBAAAA,AAAA,EAAoB;IACtDG,OAAA,EAAS;QACPC,aAAA,EAAe;QAEfC,oBAAA,EAAsB;qVAACJ,gBAAA;SAAA;IACzB;IACAK,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 344, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/subscript/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\n\nexport const SubscriptFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#SubscriptFeatureClient',\n  },\n  key: 'subscript',\n})\n"],"names":["createServerFeature","SubscriptFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,gBAAA,qTAAmBD,sBAAAA,AAAA,EAAoB;IAClDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 361, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/superscript/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\n\nexport const SuperscriptFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#SuperscriptFeatureClient',\n  },\n  key: 'superscript',\n})\n"],"names":["createServerFeature","SuperscriptFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,kBAAA,qTAAqBD,sBAAAA,AAAA,EAAoB;IACpDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 372, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 378, "column": 0}, "map": {"version":3,"file":"markdownTransformers.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/inlineCode/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const INLINE_CODE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['code'],\n  tag: '`',\n}\n"],"names":["INLINE_CODE","type","format","tag"],"mappings":";;;AAEO,MAAMA,WAAA,GAAqC;IAChDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAO;IAChBC,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 388, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 394, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/format/inlineCode/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { INLINE_CODE } from './markdownTransformers.js'\n\nexport const InlineCodeFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#InlineCodeFeatureClient',\n    markdownTransformers: [INLINE_CODE],\n  },\n  key: 'inlineCode',\n})\n"],"names":["createServerFeature","INLINE_CODE","InlineCodeFeature","feature","ClientFeature","markdownTransformers","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,WAAW,QAAQ;;;AAErB,MAAMC,iBAAA,qTAAoBF,sBAAAA,AAAA,EAAoB;IACnDG,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,oBAAA,EAAsB;kVAACJ,cAAA;SAAA;IACzB;IACAK,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 410, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 416, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/paragraph/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'فقرة',\n    label2: 'نص عادي',\n  },\n  az: {\n    label: 'Paraqraf',\n    label2: 'Normal Mətn',\n  },\n  bg: {\n    label: 'Параграф',\n    label2: 'Нормален текст',\n  },\n  cs: {\n    label: 'Odstavec',\n    label2: 'Normální text',\n  },\n  da: {\n    label: 'Afsnit',\n    label2: 'Normal tekst',\n  },\n  de: {\n    label: 'Paragraph',\n    label2: 'Normaler Text',\n  },\n  en: {\n    label: 'Paragraph',\n    label2: 'Normal Text',\n  },\n  es: {\n    label: 'Párrafo',\n    label2: 'Texto normal',\n  },\n  et: {\n    label: 'Paragrahv',\n    label2: 'Tavaline tekst',\n  },\n  fa: {\n    label: 'پاراگراف',\n    label2: 'متن عادی',\n  },\n  fr: {\n    label: 'Paragraphe',\n    label2: 'Texte normal',\n  },\n  he: {\n    label: 'פסקה',\n    label2: 'טקסט רגיל',\n  },\n  hr: {\n    label: 'Odlomak',\n    label2: 'Normalan tekst',\n  },\n  hu: {\n    label: 'Bekezdés',\n    label2: 'Normál szöveg',\n  },\n  it: {\n    label: 'Paragrafo',\n    label2: 'Testo normale',\n  },\n  ja: {\n    label: '段落',\n    label2: '通常のテキスト',\n  },\n  ko: {\n    label: '문단',\n    label2: '일반 텍스트',\n  },\n  my: {\n    label: 'Perenggan',\n    label2: 'ပုံမှန်စာသား',\n  },\n  nb: {\n    label: 'Avsnitt',\n    label2: 'Normal tekst',\n  },\n  nl: {\n    label: 'Paragraaf',\n    label2: 'Normale tekst',\n  },\n  pl: {\n    label: 'Akapit',\n    label2: 'Normalny tekst',\n  },\n  pt: {\n    label: 'Parágrafo',\n    label2: 'Texto Normal',\n  },\n  ro: {\n    label: 'Paragraf',\n    label2: 'Text normal',\n  },\n  rs: {\n    label: 'Параграф',\n    label2: 'Oбичан текст',\n  },\n  'rs-latin': {\n    label: 'Paragraf',\n    label2: 'Običan tekst',\n  },\n  ru: {\n    label: 'Параграф',\n    label2: 'Нормальный текст',\n  },\n  sk: {\n    label: 'Odsek',\n    label2: 'Normálny text',\n  },\n  sl: {\n    label: 'Odstavek',\n    label2: 'Navaden besedilo',\n  },\n  sv: {\n    label: 'Stycke',\n    label2: 'Normal Text',\n  },\n  th: {\n    label: 'ย่อหน้า',\n    label2: 'ข้อความธรรมดา',\n  },\n  tr: {\n    label: 'Paragraf',\n    label2: 'Normal Metin',\n  },\n  uk: {\n    label: 'Абзац',\n    label2: 'Звичайний текст',\n  },\n  vi: {\n    label: 'Đoạn văn',\n    label2: 'Văn bản bình thường',\n  },\n  zh: {\n    label: '段落',\n    label2: '正常文本',\n  },\n  'zh-TW': {\n    label: '段落',\n    label2: '正常文本',\n  },\n}\n"],"names":["i18n","ar","label","label2","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAC,EAAA,EAAI;QACFF,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAE,EAAA,EAAI;QACFH,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAG,EAAA,EAAI;QACFJ,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAI,EAAA,EAAI;QACFL,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAK,EAAA,EAAI;QACFN,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAM,EAAA,EAAI;QACFP,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAO,EAAA,EAAI;QACFR,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAQ,EAAA,EAAI;QACFT,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAS,EAAA,EAAI;QACFV,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAU,EAAA,EAAI;QACFX,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAW,EAAA,EAAI;QACFZ,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAY,EAAA,EAAI;QACFb,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAa,EAAA,EAAI;QACFd,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAc,EAAA,EAAI;QACFf,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAe,EAAA,EAAI;QACFhB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAgB,EAAA,EAAI;QACFjB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAiB,EAAA,EAAI;QACFlB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAkB,EAAA,EAAI;QACFnB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAmB,EAAA,EAAI;QACFpB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAoB,EAAA,EAAI;QACFrB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAqB,EAAA,EAAI;QACFtB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAsB,EAAA,EAAI;QACFvB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAuB,EAAA,EAAI;QACFxB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA,YAAY;QACVD,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAwB,EAAA,EAAI;QACFzB,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAyB,EAAA,EAAI;QACF1B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA0B,EAAA,EAAI;QACF3B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA2B,EAAA,EAAI;QACF5B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA4B,EAAA,EAAI;QACF7B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA6B,EAAA,EAAI;QACF9B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA8B,EAAA,EAAI;QACF/B,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA+B,EAAA,EAAI;QACFhC,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACAgC,EAAA,EAAI;QACFjC,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;IACA,SAAS;QACPD,KAAA,EAAO;QACPC,MAAA,EAAQ;IACV;AACF","ignoreList":[0]}},
    {"offset": {"line": 561, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 567, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/paragraph/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { i18n } from './i18n.js'\n\nexport const ParagraphFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#ParagraphFeatureClient',\n    clientFeatureProps: null,\n    i18n,\n  },\n  key: 'paragraph',\n})\n"],"names":["createServerFeature","i18n","ParagraphFeature","feature","ClientFeature","clientFeatureProps","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;AAEd,MAAMC,gBAAA,qTAAmBF,sBAAAA,AAAA,EAAoB;IAClDG,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,kBAAA,EAAoB;mUACpBJ,OAAAA;IACF;IACAK,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 582, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 588, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/heading/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'العنوان {{headingLevel}}',\n  },\n  az: {\n    label: 'Başlıq {{headingLevel}}',\n  },\n  bg: {\n    label: 'Заглавие {{headingLevel}}',\n  },\n  cs: {\n    label: 'Nadpis {{headingLevel}}',\n  },\n  da: {\n    label: 'Overskrift {{overskriftNiveau}}',\n  },\n  de: {\n    label: 'Überschrift {{headingLevel}}',\n  },\n  en: {\n    label: 'Heading {{headingLevel}}',\n  },\n  es: {\n    label: 'Encabezado {{headingLevel}}',\n  },\n  et: {\n    label: 'Pealkiri {{headingLevel}}',\n  },\n  fa: {\n    label: '[SKIPPED]',\n  },\n  fr: {\n    label: 'En-tête {{headingLevel}}',\n  },\n  he: {\n    label: 'כותרת {{רמת כותרת}}',\n  },\n  hr: {\n    label: 'Naslov {{headingLevel}}',\n  },\n  hu: {\n    label: 'Címsor {{headingLevel}}',\n  },\n  it: {\n    label: 'Intestazione {{headingLevel}}',\n  },\n  ja: {\n    label: '見出し{{headingLevel}}',\n  },\n  ko: {\n    label: '제목 {{headingLevel}}',\n  },\n  my: {\n    label: '[SURAT]\\n\\nKepala {{headingLevel}}',\n  },\n  nb: {\n    label: 'Overskrift {{headingLevel}}',\n  },\n  nl: {\n    label: 'Kop {{headingLevel}}',\n  },\n  pl: {\n    label: 'Nagłówek {{headingLevel}}',\n  },\n  pt: {\n    label: 'Cabeçalho {{headingLevel}}',\n  },\n  ro: {\n    label: 'Titlu {{headingLevel}}',\n  },\n  rs: {\n    label: 'Наслов {{headingLevel}}',\n  },\n  'rs-latin': {\n    label: 'Naslov {{headingLevel}}',\n  },\n  ru: {\n    label: 'Заголовок {{headingLevel}}',\n  },\n  sk: {\n    label: 'Nadpis {{headingLevel}}',\n  },\n  sl: {\n    label: 'Naslov {{headingLevel}}',\n  },\n  sv: {\n    label: 'Rubrik {{headingLevel}}',\n  },\n  th: {\n    label: 'หัวข้อ {{headingLevel}}',\n  },\n  tr: {\n    label: 'Başlık {{headingLevel}}',\n  },\n  uk: {\n    label: 'Заголовок {{headingLevel}}',\n  },\n  vi: {\n    label: 'Tiêu đề {{headingLevel}}',\n  },\n  zh: {\n    label: '标题 {{headingLevel}}',\n  },\n  'zh-TW': {\n    label: '標題 {{headingLevel}}',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 698, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 704, "column": 0}, "map": {"version":3,"file":"createBlockNode.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/markdown/createBlockNode.ts"],"sourcesContent":["import type { ElementNode } from 'lexical'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const createBlockNode = (\n  createNode: (match: Array<string>) => ElementNode,\n): ElementTransformer['replace'] => {\n  return (parentNode, children, match) => {\n    const node = createNode(match)\n    if (node) {\n      node.append(...children)\n      parentNode.replace(node)\n      node.select(0, 0)\n    }\n  }\n}\n"],"names":["createBlockNode","createNode","parentNode","children","match","node","append","replace","select"],"mappings":";;;AAIO,MAAMA,eAAA,IACXC,UAAA;IAEA,OAAO,CAACC,UAAA,EAAYC,QAAA,EAAUC,KAAA;QAC5B,MAAMC,IAAA,GAAOJ,UAAA,CAAWG,KAAA;QACxB,IAAIC,IAAA,EAAM;YACRA,IAAA,CAAKC,MAAM,IAAIH,QAAA;YACfD,UAAA,CAAWK,OAAO,CAACF,IAAA;YACnBA,IAAA,CAAKG,MAAM,CAAC,GAAG;QACjB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 717, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 723, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/heading/markdownTransformer.ts"],"sourcesContent":["import type { HeadingTagType } from '@lexical/rich-text'\n\nimport { $createHeadingNode, $isHeadingNode, HeadingNode } from '@lexical/rich-text'\n\nimport type { ElementTransformer } from '../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { createBlockNode } from '../../lexical/utils/markdown/createBlockNode.js'\n\nexport const MarkdownTransformer: (enabledHeadingSizes: HeadingTagType[]) => ElementTransformer = (\n  enabledHeadingSizes,\n) => {\n  // Convert enabledHeadingSizes to a list of numbers (1 for h1, 2 for h2, etc.)\n  const enabledSizes = enabledHeadingSizes.map((tag) => Number(tag.slice(1)))\n\n  // Create a regex pattern that matches any of the enabled sizes\n  const pattern = `^(${enabledSizes.map((size) => `#{${size}}`).join('|')})\\\\s`\n  const regExp = new RegExp(pattern)\n\n  return {\n    type: 'element',\n    dependencies: [HeadingNode],\n    export: (node, exportChildren) => {\n      if (!$isHeadingNode(node)) {\n        return null\n      }\n      const level = Number(node.getTag().slice(1))\n      return '#'.repeat(level) + ' ' + exportChildren(node)\n    },\n    regExp,\n    replace: createBlockNode((match) => {\n      const tag = ('h' + match[1]?.length) as HeadingTagType\n      return $createHeadingNode(tag)\n    }),\n  }\n}\n"],"names":["$createHeadingNode","$isHeadingNode","HeadingNode","createBlockNode","MarkdownTransformer","enabledHeadingSizes","enabledSizes","map","tag","Number","slice","pattern","size","join","regExp","RegExp","type","dependencies","export","node","exportChildren","level","getTag","repeat","replace","match","length"],"mappings":";;;AAEA,SAASA,kBAAkB,EAAEC,cAAc,EAAEC,WAAW,QAAQ;AAIhE,SAASC,eAAe,QAAQ;;;AAEzB,MAAMC,mBAAA,IACXC,mBAAA;IAEA,8EAAA;IACA,MAAMC,YAAA,GAAeD,mBAAA,CAAoBE,GAAG,EAAEC,GAAA,GAAQC,MAAA,CAAOD,GAAA,CAAIE,KAAK,CAAC;IAEvE,+DAAA;IACA,MAAMC,OAAA,GAAU,CAAA,EAAA,EAAKL,YAAA,CAAaC,GAAG,EAAEK,IAAA,GAAS,CAAA,EAAA,EAAKA,IAAA,CAAA,CAAA,CAAO,EAAEC,IAAI,CAAC,KAAA,IAAA,CAAU;IAC7E,MAAMC,MAAA,GAAS,IAAIC,MAAA,CAAOJ,OAAA;IAE1B,OAAO;QACLK,IAAA,EAAM;QACNC,YAAA,EAAc;0PAACf,cAAA;SAAY;QAC3BgB,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;YACb,IAAI,mPAACnB,iBAAAA,AAAA,EAAekB,IAAA,GAAO;gBACzB,OAAO;YACT;YACA,MAAME,KAAA,GAAQZ,MAAA,CAAOU,IAAA,CAAKG,MAAM,GAAGZ,KAAK,CAAC;YACzC,OAAO,IAAIa,MAAM,CAACF,KAAA,IAAS,MAAMD,cAAA,CAAeD,IAAA;QAClD;QACAL,MAAA;QACAU,OAAA,mUAASrB,kBAAAA,AAAA,GAAiBsB,KAAA;YACxB,MAAMjB,GAAA,GAAO,MAAMiB,KAAK,CAAC,EAAE,EAAEC,MAAA;YAC7B,yPAAO1B,qBAAAA,AAAA,EAAmBQ,GAAA;QAC5B;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 755, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 761, "column": 0}, "map": {"version":3,"file":"typeUtilities.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/typeUtilities.ts"],"sourcesContent":["import type { LexicalNode } from 'lexical'\n\nimport type { NodeWithHooks } from './typesServer.js'\n\n/**\n * Utility function to create a node with hooks. You don't have to use this utility, but it improves type inference\n * @param node the node\n */\nexport function createNode<Node extends LexicalNode>(\n  node: NodeWithHooks<Node>,\n): NodeWithHooks<Node> {\n  return node\n}\n"],"names":["createNode","node"],"mappings":"AAIA;;;GAIA;;;AAAO,SAASA,WACdC,IAAyB;IAEzB,OAAOA,IAAA;AACT","ignoreList":[0]}},
    {"offset": {"line": 770, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 776, "column": 0}, "map": {"version":3,"file":"hasText.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/validate/hasText.ts"],"sourcesContent":["import type {\n  SerializedEditorState,\n  SerializedLexicalNode,\n  SerializedParagraphNode,\n  SerializedTextNode,\n} from 'lexical'\n\nexport function hasText(\n  value: null | SerializedEditorState<SerializedLexicalNode> | undefined,\n): boolean {\n  const hasChildren = !!value?.root?.children?.length\n\n  let hasOnlyEmptyParagraph = false\n  if (value?.root?.children?.length === 1) {\n    if (value?.root?.children[0]?.type === 'paragraph') {\n      const paragraphNode = value?.root?.children[0] as SerializedParagraphNode\n\n      if (!paragraphNode?.children || paragraphNode?.children?.length === 0) {\n        hasOnlyEmptyParagraph = true\n      } else if (paragraphNode?.children?.length === 1) {\n        const paragraphNodeChild = paragraphNode?.children[0]\n        if (paragraphNodeChild.type === 'text') {\n          if (!(paragraphNodeChild as SerializedTextNode | undefined)?.['text']?.length) {\n            hasOnlyEmptyParagraph = true\n          }\n        }\n      }\n    }\n  }\n\n  if (!hasChildren || hasOnlyEmptyParagraph) {\n    return false\n  } else {\n    return true\n  }\n}\n"],"names":["hasText","value","hasChildren","root","children","length","hasOnlyEmptyParagraph","type","paragraphNode","paragraphNodeChild"],"mappings":";;;AAOO,SAASA,QACdC,KAAsE;IAEtE,MAAMC,WAAA,GAAc,CAAC,CAACD,KAAA,EAAOE,IAAA,EAAMC,QAAA,EAAUC,MAAA;IAE7C,IAAIC,qBAAA,GAAwB;IAC5B,IAAIL,KAAA,EAAOE,IAAA,EAAMC,QAAA,EAAUC,MAAA,KAAW,GAAG;QACvC,IAAIJ,KAAA,EAAOE,IAAA,EAAMC,QAAQ,CAAC,EAAE,EAAEG,IAAA,KAAS,aAAa;YAClD,MAAMC,aAAA,GAAgBP,KAAA,EAAOE,IAAA,EAAMC,QAAQ,CAAC,EAAE;YAE9C,IAAI,CAACI,aAAA,EAAeJ,QAAA,IAAYI,aAAA,EAAeJ,QAAA,EAAUC,MAAA,KAAW,GAAG;gBACrEC,qBAAA,GAAwB;YAC1B,OAAO,IAAIE,aAAA,EAAeJ,QAAA,EAAUC,MAAA,KAAW,GAAG;gBAChD,MAAMI,kBAAA,GAAqBD,aAAA,EAAeJ,QAAQ,CAAC,EAAE;gBACrD,IAAIK,kBAAA,CAAmBF,IAAI,KAAK,QAAQ;oBACtC,IAAI,CAAEE,kBAAA,EAAA,CAAwD,OAAO,EAAEJ,MAAA,EAAQ;wBAC7EC,qBAAA,GAAwB;oBAC1B;gBACF;YACF;QACF;IACF;IAEA,IAAI,CAACJ,WAAA,IAAeI,qBAAA,EAAuB;QACzC,OAAO;IACT,OAAO;QACL,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 803, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 809, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/converters/html/converter/index.ts"],"sourcesContent":["import type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\nimport type { Payload, PayloadRequest } from 'payload'\n\nimport { createLocalReq } from 'payload'\n\nimport type { HTMLConverter, SerializedLexicalNodeWithParent } from './types.js'\n\nimport { hasText } from '../../../../validate/hasText.js'\n\nexport type ConvertLexicalToHTMLArgs = {\n  converters: HTMLConverter[]\n  currentDepth?: number\n  data: SerializedEditorState\n  depth?: number\n  draft?: boolean // default false\n  overrideAccess?: boolean // default false\n  showHiddenFields?: boolean // default false\n} & (\n  | {\n      /**\n       * This payload property will only be used if req is undefined.\n       */\n      payload?: never\n      /**\n       * When the converter is called, req CAN be passed in depending on where it's run.\n       * If this is undefined and config is passed through, lexical will create a new req object for you. If this is null or\n       * config is undefined, lexical will not create a new req object for you and local API / server-side-only\n       * functionality will be disabled.\n       */\n      req: PayloadRequest\n    }\n  | {\n      /**\n       * This payload property will only be used if req is undefined.\n       */\n      payload?: Payload\n      /**\n       * When the converter is called, req CAN be passed in depending on where it's run.\n       * If this is undefined and config is passed through, lexical will create a new req object for you. If this is null or\n       * config is undefined, lexical will not create a new req object for you and local API / server-side-only\n       * functionality will be disabled.\n       */\n      req?: null | undefined\n    }\n)\n\nexport async function convertLexicalToHTML({\n  converters,\n  currentDepth,\n  data,\n  depth,\n  draft,\n  overrideAccess,\n  payload,\n  req,\n  showHiddenFields,\n}: ConvertLexicalToHTMLArgs): Promise<string> {\n  if (hasText(data)) {\n    if (req === undefined && payload) {\n      req = await createLocalReq({}, payload)\n    }\n\n    if (!currentDepth) {\n      currentDepth = 0\n    }\n\n    if (!depth) {\n      depth = req?.payload?.config?.defaultDepth\n    }\n\n    return await convertLexicalNodesToHTML({\n      converters,\n      currentDepth,\n      depth: depth!,\n      draft: draft === undefined ? false : draft,\n      lexicalNodes: data?.root?.children,\n      overrideAccess: overrideAccess === undefined ? false : overrideAccess,\n      parent: data?.root,\n      req: req!,\n      showHiddenFields: showHiddenFields === undefined ? false : showHiddenFields,\n    })\n  }\n  return ''\n}\n\nexport async function convertLexicalNodesToHTML({\n  converters,\n  currentDepth,\n  depth,\n  draft,\n  lexicalNodes,\n  overrideAccess,\n  parent,\n  req,\n  showHiddenFields,\n}: {\n  converters: HTMLConverter[]\n  currentDepth: number\n  depth: number\n  draft: boolean\n  lexicalNodes: SerializedLexicalNode[]\n  overrideAccess: boolean\n  parent: SerializedLexicalNodeWithParent\n  /**\n   * When the converter is called, req CAN be passed in depending on where it's run.\n   */\n  req: null | PayloadRequest\n  showHiddenFields: boolean\n}): Promise<string> {\n  const unknownConverter = converters.find((converter) => converter.nodeTypes.includes('unknown'))\n\n  const htmlArray = await Promise.all(\n    lexicalNodes.map(async (node, i) => {\n      const converterForNode = converters.find((converter) =>\n        converter.nodeTypes.includes(node.type),\n      )\n      try {\n        if (!converterForNode) {\n          if (unknownConverter) {\n            return await unknownConverter.converter({\n              childIndex: i,\n              converters,\n              currentDepth,\n              depth,\n              draft,\n              node,\n              overrideAccess,\n              parent,\n              req,\n              showHiddenFields,\n            })\n          }\n          return '<span>unknown node</span>'\n        }\n        return await converterForNode.converter({\n          childIndex: i,\n          converters,\n          currentDepth,\n          depth,\n          draft,\n          node,\n          overrideAccess,\n          parent,\n          req,\n          showHiddenFields,\n        })\n      } catch (error) {\n        console.error('Error converting lexical node to HTML:', error, 'node:', node)\n        return ''\n      }\n    }),\n  )\n\n  return htmlArray.join('') || ''\n}\n"],"names":["createLocalReq","hasText","convertLexicalToHTML","converters","currentDepth","data","depth","draft","overrideAccess","payload","req","showHiddenFields","undefined","config","defaultDepth","convertLexicalNodesToHTML","lexicalNodes","root","children","parent","unknownConverter","find","converter","nodeTypes","includes","htmlArray","Promise","all","map","node","i","converterForNode","type","childIndex","error","console","join"],"mappings":";;;;AAOA,SAASC,OAAO,QAAQ;AAJxB,SAASD,cAAc,QAAQ;;;AA2CxB,eAAeE,qBAAqB,EACzCC,UAAU,EACVC,YAAY,EACZC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,cAAc,EACdC,OAAO,EACPC,GAAG,EACHC,gBAAAA,EACyB;IACzB,KAAIV,8SAAAA,AAAA,EAAQI,IAAA,GAAO;QACjB,IAAIK,GAAA,KAAQE,SAAA,IAAaH,OAAA,EAAS;YAChCC,GAAA,GAAM,UAAMV,wYAAA,AAAAA,EAAe,CAAC,GAAGS,OAAA;QACjC;QAEA,IAAI,CAACL,YAAA,EAAc;YACjBA,YAAA,GAAe;QACjB;QAEA,IAAI,CAACE,KAAA,EAAO;YACVA,KAAA,GAAQI,GAAA,EAAKD,OAAA,EAASI,MAAA,EAAQC,YAAA;QAChC;QAEA,OAAO,MAAMC,yBAAA,CAA0B;YACrCZ,UAAA;YACAC,YAAA;YACAE,KAAA,EAAOA,KAAA;YACPC,KAAA,EAAOA,KAAA,KAAUK,SAAA,GAAY,QAAQL,KAAA;YACrCS,YAAA,EAAcX,IAAA,EAAMY,IAAA,EAAMC,QAAA;YAC1BV,cAAA,EAAgBA,cAAA,KAAmBI,SAAA,GAAY,QAAQJ,cAAA;YACvDW,MAAA,EAAQd,IAAA,EAAMY,IAAA;YACdP,GAAA,EAAKA,GAAA;YACLC,gBAAA,EAAkBA,gBAAA,KAAqBC,SAAA,GAAY,QAAQD;QAC7D;IACF;IACA,OAAO;AACT;AAEO,eAAeI,0BAA0B,EAC9CZ,UAAU,EACVC,YAAY,EACZE,KAAK,EACLC,KAAK,EACLS,YAAY,EACZR,cAAc,EACdW,MAAM,EACNT,GAAG,EACHC,gBAAAA,EAcD;IACC,MAAMS,gBAAA,GAAmBjB,UAAA,CAAWkB,IAAI,CAAEC,SAAA,IAAcA,SAAA,CAAUC,SAAS,CAACC,QAAQ,CAAC;IAErF,MAAMC,SAAA,GAAY,MAAMC,OAAA,CAAQC,GAAG,CACjCX,YAAA,CAAaY,GAAG,CAAC,OAAOC,IAAA,EAAMC,CAAA;QAC5B,MAAMC,gBAAA,GAAmB5B,UAAA,CAAWkB,IAAI,EAAEC,SAAA,GACxCA,SAAA,CAAUC,SAAS,CAACC,QAAQ,CAACK,IAAA,CAAKG,IAAI;QAExC,IAAI;YACF,IAAI,CAACD,gBAAA,EAAkB;gBACrB,IAAIX,gBAAA,EAAkB;oBACpB,OAAO,MAAMA,gBAAA,CAAiBE,SAAS,CAAC;wBACtCW,UAAA,EAAYH,CAAA;wBACZ3B,UAAA;wBACAC,YAAA;wBACAE,KAAA;wBACAC,KAAA;wBACAsB,IAAA;wBACArB,cAAA;wBACAW,MAAA;wBACAT,GAAA;wBACAC;oBACF;gBACF;gBACA,OAAO;YACT;YACA,OAAO,MAAMoB,gBAAA,CAAiBT,SAAS,CAAC;gBACtCW,UAAA,EAAYH,CAAA;gBACZ3B,UAAA;gBACAC,YAAA;gBACAE,KAAA;gBACAC,KAAA;gBACAsB,IAAA;gBACArB,cAAA;gBACAW,MAAA;gBACAT,GAAA;gBACAC;YACF;QACF,EAAE,OAAOuB,KAAA,EAAO;YACdC,OAAA,CAAQD,KAAK,CAAC,0CAA0CA,KAAA,EAAO,SAASL,IAAA;YACxE,OAAO;QACT;IACF;IAGF,OAAOJ,SAAA,CAAUW,IAAI,CAAC,OAAO;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 883, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 889, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/heading/server/index.ts"],"sourcesContent":["import type {\n  SerializedHeadingNode as _SerializedHeadingNode,\n  HeadingTagType,\n} from '@lexical/rich-text'\nimport type { Spread } from 'lexical'\n\nimport { HeadingNode } from '@lexical/rich-text'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { convertLexicalNodesToHTML } from '../../converters/html/converter/index.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { MarkdownTransformer } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport type SerializedHeadingNode = Spread<\n  {\n    type: 'heading'\n  },\n  _SerializedHeadingNode\n>\n\nexport type HeadingFeatureProps = {\n  enabledHeadingSizes?: HeadingTagType[]\n}\n\nexport const HeadingFeature = createServerFeature<\n  HeadingFeatureProps,\n  HeadingFeatureProps,\n  HeadingFeatureProps\n>({\n  feature: ({ props }) => {\n    if (!props) {\n      props = {}\n    }\n\n    const { enabledHeadingSizes = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] } = props\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#HeadingFeatureClient',\n      clientFeatureProps: props,\n      i18n,\n      markdownTransformers: [MarkdownTransformer(enabledHeadingSizes)],\n      nodes: [\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n                const style = [\n                  node.format ? `text-align: ${node.format};` : '',\n                  node.indent > 0 ? `padding-inline-start: ${node.indent * 40}px;` : '',\n                ]\n                  .filter(Boolean)\n                  .join(' ')\n                return `<${node?.tag}${style ? ` style='${style}'` : ''}>${childrenText}</${node?.tag}>`\n              },\n              nodeTypes: [HeadingNode.getType()],\n            },\n          },\n          node: HeadingNode,\n        }),\n      ],\n      sanitizedServerFeatureProps: props,\n    }\n  },\n  key: 'heading',\n})\n"],"names":["HeadingNode","createServerFeature","convertLexicalNodesToHTML","createNode","MarkdownTransformer","i18n","HeadingFeature","feature","props","enabledHeadingSizes","ClientFeature","clientFeatureProps","markdownTransformers","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","style","format","indent","filter","Boolean","join","tag","nodeTypes","getType","sanitizedServerFeatureProps","key"],"mappings":";;;AAQA,SAASC,mBAAmB,QAAQ;AAIpC,SAASI,IAAI,QAAQ;AADrB,SAASD,mBAAmB,QAAQ;AADpC,SAASD,UAAU,QAAQ;AAD3B,SAASD,yBAAyB,QAAQ;AAH1C,SAASF,WAAW,QAAQ;;;;;;;AAmBrB,MAAMM,cAAA,qTAAiBL,sBAAAA,AAAA,EAI5B;IACAM,OAAA,EAASA,CAAC,EAAEC,KAAAA,EAAO;QACjB,IAAI,CAACA,KAAA,EAAO;YACVA,KAAA,GAAQ,CAAC;QACX;QAEA,MAAM,EAAEC,mBAAA,GAAsB;YAAC;YAAM;YAAM;YAAM;YAAM;YAAM;SAAA,EAAO,GAAGD,KAAA;QAEvE,OAAO;YACLE,aAAA,EAAe;YACfC,kBAAA,EAAoBH,KAAA;qUACpBH,OAAA;YACAO,oBAAA,EAAsB;4UAACR,sBAAAA,AAAA,EAAoBK,mBAAA;aAAqB;YAChEI,KAAA,EAAO;gBACLV,wTAAAA,AAAA,EAAW;oBACTW,UAAA,EAAY;wBACVC,IAAA,EAAM;4BACJC,SAAA,EAAW,MAAAA,CAAO,EAChBF,UAAU,EACVG,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;gCACC,MAAMC,YAAA,GAAe,4UAAMvB,4BAAAA,AAAA,EAA0B;oCACnDY,UAAA;oCACAG,YAAA;oCACAC,KAAA;oCACAC,KAAA;oCACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;oCAC3BN,cAAA;oCACAC,MAAA,EAAQ;wCACN,GAAGF,IAAI;wCACPE;oCACF;oCACAC,GAAA;oCACAC;gCACF;gCACA,MAAMI,KAAA,GAAQ;oCACZR,IAAA,CAAKS,MAAM,GAAG,CAAA,YAAA,EAAeT,IAAA,CAAKS,MAAM,CAAA,CAAA,CAAG,GAAG;oCAC9CT,IAAA,CAAKU,MAAM,GAAG,IAAI,CAAA,sBAAA,EAAyBV,IAAA,CAAKU,MAAM,GAAG,GAAA,GAAA,CAAO,GAAG;iCACpE,CACEC,MAAM,CAACC,OAAA,EACPC,IAAI,CAAC;gCACR,OAAO,CAAA,CAAA,EAAIb,IAAA,EAAMc,GAAA,GAAMN,KAAA,GAAQ,CAAA,QAAA,EAAWA,KAAA,CAAA,CAAA,CAAQ,GAAG,GAAA,CAAA,EAAMH,YAAA,CAAA,EAAA,EAAiBL,IAAA,EAAMc,GAAA,CAAA,CAAA,CAAM;4BAC1F;4BACAC,SAAA,EAAW;8QAACnC,cAAA,CAAYoC,OAAO;6BAAA;wBACjC;oBACF;oBACAhB,IAAA,gPAAMpB,cAAAA;gBACR;aACD;YACDqC,2BAAA,EAA6B7B;QAC/B;IACF;IACA8B,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 962, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 968, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/align/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    alignCenterLabel: 'محاذاة في الوسط',\n    alignJustifyLabel: 'محاذاة التبرير',\n    alignLeftLabel: 'محاذاة إلى اليسار',\n    alignRightLabel: 'محاذاة إلى اليمين',\n  },\n  az: {\n    alignCenterLabel: 'Mərkəzə Düzəlt',\n    alignJustifyLabel: 'Düzəldin Səsləndirin',\n    alignLeftLabel: 'Sola Doğru Hizalama',\n    alignRightLabel: 'Sağa Doğru Hizalama',\n  },\n  bg: {\n    alignCenterLabel: 'Центрирай',\n    alignJustifyLabel: 'Подравняване по двата края',\n    alignLeftLabel: 'Подравняване отляво',\n    alignRightLabel: 'Подравняване вдясно',\n  },\n  cs: {\n    alignCenterLabel: 'Zarovnat na střed',\n    alignJustifyLabel: 'Zarovnat do bloku',\n    alignLeftLabel: 'Zarovnat vlevo',\n    alignRightLabel: 'Zarovnat vpravo',\n  },\n  da: {\n    alignCenterLabel: 'Centrer teksten',\n    alignJustifyLabel: 'Justér til begge sider',\n    alignLeftLabel: 'Justér til venstre',\n    alignRightLabel: 'Juster til højre',\n  },\n  de: {\n    alignCenterLabel: 'Zentrieren',\n    alignJustifyLabel: 'Blocksatz',\n    alignLeftLabel: 'Linksbündig',\n    alignRightLabel: 'Rechtsbündig',\n  },\n  en: {\n    alignCenterLabel: 'Align Center',\n    alignJustifyLabel: 'Align Justify',\n    alignLeftLabel: 'Align Left',\n    alignRightLabel: 'Align Right',\n  },\n  es: {\n    alignCenterLabel: 'Alinear al centro',\n    alignJustifyLabel: 'Alinear Justificar',\n    alignLeftLabel: 'Alinear a la izquierda',\n    alignRightLabel: 'Alinear a la derecha',\n  },\n  et: {\n    alignCenterLabel: 'Keskjoondus',\n    alignJustifyLabel: 'Rööpjoondus',\n    alignLeftLabel: 'Vasakjoondus',\n    alignRightLabel: 'Paremjoondus',\n  },\n  fa: {\n    alignCenterLabel: 'تراز در مرکز',\n    alignJustifyLabel: 'تراز کردن از دو طرف',\n    alignLeftLabel: 'چپ تراز',\n    alignRightLabel: 'راست چین',\n  },\n  fr: {\n    alignCenterLabel: 'Aligner au centre',\n    alignJustifyLabel: 'Aligner Justifier',\n    alignLeftLabel: 'Aligner à gauche',\n    alignRightLabel: 'Aligner à droite',\n  },\n  he: {\n    alignCenterLabel: 'ממורכז',\n    alignJustifyLabel: 'יישור דו-צדדי',\n    alignLeftLabel: 'הסב לשמאל',\n    alignRightLabel: 'יישור לימין',\n  },\n  hr: {\n    alignCenterLabel: 'Poravnaj središnje',\n    alignJustifyLabel: 'Poravnaj opravdaj',\n    alignLeftLabel: 'Poravnaj lijevo',\n    alignRightLabel: 'Poravnaj desno',\n  },\n  hu: {\n    alignCenterLabel: 'Középre igazítás',\n    alignJustifyLabel: 'Igazítás Sorkizárás',\n    alignLeftLabel: 'Igazítás balra',\n    alignRightLabel: 'Igazítás jobbra',\n  },\n  it: {\n    alignCenterLabel: 'Allinea al centro',\n    alignJustifyLabel: 'Allinea Giustifica',\n    alignLeftLabel: 'Allinea a sinistra',\n    alignRightLabel: 'Allinea a destra',\n  },\n  ja: {\n    alignCenterLabel: '中央揃え',\n    alignJustifyLabel: '両端揃え',\n    alignLeftLabel: '左揃え',\n    alignRightLabel: '右揃え',\n  },\n  ko: {\n    alignCenterLabel: '중앙 정렬',\n    alignJustifyLabel: '정렬 맞춤',\n    alignLeftLabel: '왼쪽 정렬',\n    alignRightLabel: '오른쪽 정렬',\n  },\n  my: {\n    alignCenterLabel: 'Pusat Selaras',\n    alignJustifyLabel: 'Penjajaran Justify',\n    alignLeftLabel: 'ဘယ်ဘက်ဦးတည်ခြင်း',\n    alignRightLabel: 'Penjajaran Kanan',\n  },\n  nb: {\n    alignCenterLabel: 'Sentrer tekst',\n    alignJustifyLabel: 'Juster linje',\n    alignLeftLabel: 'Juster til venstre',\n    alignRightLabel: 'Juster til høyre',\n  },\n  nl: {\n    alignCenterLabel: 'Centreer uitlijnen',\n    alignJustifyLabel: 'Uitlijnen Rechtvaardigen',\n    alignLeftLabel: 'Links uitlijnen',\n    alignRightLabel: 'Rechts uitlijnen',\n  },\n  pl: {\n    alignCenterLabel: 'Wyśrodkuj',\n    alignJustifyLabel: 'Wyjustuj wyrównanie',\n    alignLeftLabel: 'Wyrównaj do lewej',\n    alignRightLabel: 'Wyrównaj do prawej',\n  },\n  pt: {\n    alignCenterLabel: 'Alinhar ao Centro',\n    alignJustifyLabel: 'Alinhar Justificar',\n    alignLeftLabel: 'Alinhar à Esquerda',\n    alignRightLabel: 'Alinhar à Direita',\n  },\n  ro: {\n    alignCenterLabel: 'Aliniați Centrul',\n    alignJustifyLabel: 'Aliniaza Justifica',\n    alignLeftLabel: 'Aliniați la stânga',\n    alignRightLabel: 'Aliniați la dreapta',\n  },\n  rs: {\n    alignCenterLabel: 'Поравнај по средини',\n    alignJustifyLabel: 'Поравнај обострано',\n    alignLeftLabel: 'Поравнај лево',\n    alignRightLabel: 'Поравнај десно',\n  },\n  'rs-latin': {\n    alignCenterLabel: 'Poravnaj po sredini',\n    alignJustifyLabel: 'Poravnaj obostrano',\n    alignLeftLabel: 'Poravnaj levo',\n    alignRightLabel: 'Poravnaj desno',\n  },\n  ru: {\n    alignCenterLabel: 'Выровнять по центру',\n    alignJustifyLabel: 'Выровнять по ширине',\n    alignLeftLabel: 'Выровнять по левому краю',\n    alignRightLabel: 'Выровнять по правому краю',\n  },\n  sk: {\n    alignCenterLabel: 'Vycentrovať',\n    alignJustifyLabel: 'Zarovnať do bloku',\n    alignLeftLabel: 'Zarovnať doľava',\n    alignRightLabel: 'Zarovnať doprava',\n  },\n  sl: {\n    alignCenterLabel: 'Poravnaj na sredino',\n    alignJustifyLabel: 'Poravnaj Obojestransko',\n    alignLeftLabel: 'Poravnaj na levo',\n    alignRightLabel: 'Poravnaj na desno',\n  },\n  sv: {\n    alignCenterLabel: 'Centrera',\n    alignJustifyLabel: 'Justera Justify',\n    alignLeftLabel: 'Justera till vänster',\n    alignRightLabel: 'Justera till höger',\n  },\n  th: {\n    alignCenterLabel: 'จัดแนวกึ่งกลาง',\n    alignJustifyLabel: 'จัดแนวตรง',\n    alignLeftLabel: 'จัดชิดซ้าย',\n    alignRightLabel: 'จัดชิดขวา',\n  },\n  tr: {\n    alignCenterLabel: 'Ortaya Hizala',\n    alignJustifyLabel: 'Hizala Yasla',\n    alignLeftLabel: 'Sola Hizala',\n    alignRightLabel: 'Sağa Hizala',\n  },\n  uk: {\n    alignCenterLabel: 'Вирівняти по центру',\n    alignJustifyLabel: 'Вирівняти за шириною',\n    alignLeftLabel: 'Вирівняти по лівому краю',\n    alignRightLabel: 'Вирівняти по правому краю',\n  },\n  vi: {\n    alignCenterLabel: 'Căn giữa',\n    alignJustifyLabel: 'Căn đều',\n    alignLeftLabel: 'Căn lề trái',\n    alignRightLabel: 'Căn phải',\n  },\n  zh: {\n    alignCenterLabel: '居中对齐',\n    alignJustifyLabel: '对齐调整',\n    alignLeftLabel: '向左对齐',\n    alignRightLabel: '向右对齐',\n  },\n  'zh-TW': {\n    alignCenterLabel: '對齊中心',\n    alignJustifyLabel: '對齊並排列',\n    alignLeftLabel: '向左對齊',\n    alignRightLabel: '向右對齊',\n  },\n}\n"],"names":["i18n","ar","alignCenterLabel","alignJustifyLabel","alignLeftLabel","alignRightLabel","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1183, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1189, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/align/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { i18n } from './i18n.js'\n\nexport const AlignFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#AlignFeatureClient',\n    i18n,\n  },\n  key: 'align',\n})\n"],"names":["createServerFeature","i18n","AlignFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;AAEd,MAAMC,YAAA,qTAAeF,sBAAAA,AAAA,EAAoB;IAC9CG,OAAA,EAAS;QACPC,aAAA,EAAe;+TACfH,OAAAA;IACF;IACAI,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 1203, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1209, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/indent/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    decreaseLabel: 'تقليل المسافة البادئة',\n    increaseLabel: 'زيادة المسافة البادئة',\n  },\n  az: {\n    decreaseLabel: 'İntervalı Azaltın',\n    increaseLabel: 'Girintiyi Artırın',\n  },\n  bg: {\n    decreaseLabel: 'Намали отстоянието',\n    increaseLabel: 'Увеличете отстоянието',\n  },\n  cs: {\n    decreaseLabel: 'Zmenšit odsazení',\n    increaseLabel: 'Zvětšit odsazení',\n  },\n  da: {\n    decreaseLabel: 'Reducer Indrykning',\n    increaseLabel: 'Forøg indrykning',\n  },\n  de: {\n    decreaseLabel: 'Einzug verkleinern',\n    increaseLabel: 'Einzug erhöhen',\n  },\n  en: {\n    decreaseLabel: 'Decrease Indent',\n    increaseLabel: 'Increase Indent',\n  },\n  es: {\n    decreaseLabel: 'Disminuir Sangría',\n    increaseLabel: 'Aumentar Sangría',\n  },\n  et: {\n    decreaseLabel: 'Taande vähendamine',\n    increaseLabel: 'Taande suurendamine',\n  },\n  fa: {\n    decreaseLabel: 'کاهش تورفتگی',\n    increaseLabel: 'افزایش تورفتگی',\n  },\n  fr: {\n    decreaseLabel: \"Diminuer l'indentation\",\n    increaseLabel: \"Augmenter l'indentation\",\n  },\n  he: {\n    decreaseLabel: 'הקטן הזחה',\n    increaseLabel: 'הגדל כניסה',\n  },\n  hr: {\n    decreaseLabel: 'Smanji uvlačenje',\n    increaseLabel: 'Povećaj uvlačenje',\n  },\n  hu: {\n    decreaseLabel: 'Csökkentse a behúzást',\n    increaseLabel: 'Behúzás növelése',\n  },\n  it: {\n    decreaseLabel: 'Diminuisci rientro',\n    increaseLabel: 'Aumenta Rientro',\n  },\n  ja: {\n    decreaseLabel: 'インデントを減らす',\n    increaseLabel: 'インデントを増やす',\n  },\n  ko: {\n    decreaseLabel: '들여쓰기 줄이기',\n    increaseLabel: '들여쓰기 늘리기',\n  },\n  my: {\n    decreaseLabel: 'Kurangkan Inden',\n    increaseLabel: 'Tingkatkan Inden',\n  },\n  nb: {\n    decreaseLabel: 'Reduser innrykk',\n    increaseLabel: 'Øke innrykk',\n  },\n  nl: {\n    decreaseLabel: 'Verminder Inspringing',\n    increaseLabel: 'Inspring verhogen',\n  },\n  pl: {\n    decreaseLabel: 'Zmniejsz wcięcie',\n    increaseLabel: 'Zwiększ wcięcie',\n  },\n  pt: {\n    decreaseLabel: 'Diminuir recuo',\n    increaseLabel: 'Aumentar Indentação',\n  },\n  ro: {\n    decreaseLabel: 'Reducere indentare',\n    increaseLabel: 'Crește indentarea',\n  },\n  rs: {\n    decreaseLabel: 'Смањи увлачење',\n    increaseLabel: 'Повећај увлачење',\n  },\n  'rs-latin': {\n    decreaseLabel: 'Smanji uvlačenje',\n    increaseLabel: 'Povećaj uvlačenje',\n  },\n  ru: {\n    decreaseLabel: 'Уменьшить отступ',\n    increaseLabel: 'Увеличить отступ',\n  },\n  sk: {\n    decreaseLabel: 'Znížiť odsadenie',\n    increaseLabel: 'Zväčšiť odsadenie',\n  },\n  sl: {\n    decreaseLabel: 'Zmanjšaj zamik',\n    increaseLabel: 'Povečaj zamik',\n  },\n  sv: {\n    decreaseLabel: 'Minska indrag',\n    increaseLabel: 'Öka indrag',\n  },\n  th: {\n    decreaseLabel: 'ลดการเยื้อง',\n    increaseLabel: 'เพิ่มการเยื้อง',\n  },\n  tr: {\n    decreaseLabel: 'Girintiyi Azalt',\n    increaseLabel: 'Girintiyi Artır',\n  },\n  uk: {\n    decreaseLabel: 'Зменшити відступ',\n    increaseLabel: 'Збільшити відступ',\n  },\n  vi: {\n    decreaseLabel: 'Giảm lề',\n    increaseLabel: 'Tăng lề',\n  },\n  zh: {\n    decreaseLabel: '减少缩进',\n    increaseLabel: '增加缩进',\n  },\n  'zh-TW': {\n    decreaseLabel: '減少縮排',\n    increaseLabel: '增加縮排',\n  },\n}\n"],"names":["i18n","ar","decreaseLabel","increaseLabel","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAC,EAAA,EAAI;QACFF,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAE,EAAA,EAAI;QACFH,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAG,EAAA,EAAI;QACFJ,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAI,EAAA,EAAI;QACFL,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAK,EAAA,EAAI;QACFN,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAM,EAAA,EAAI;QACFP,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAO,EAAA,EAAI;QACFR,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAQ,EAAA,EAAI;QACFT,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAS,EAAA,EAAI;QACFV,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAU,EAAA,EAAI;QACFX,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAW,EAAA,EAAI;QACFZ,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAY,EAAA,EAAI;QACFb,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAa,EAAA,EAAI;QACFd,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAc,EAAA,EAAI;QACFf,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAe,EAAA,EAAI;QACFhB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAgB,EAAA,EAAI;QACFjB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAiB,EAAA,EAAI;QACFlB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAkB,EAAA,EAAI;QACFnB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAmB,EAAA,EAAI;QACFpB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAoB,EAAA,EAAI;QACFrB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAqB,EAAA,EAAI;QACFtB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAsB,EAAA,EAAI;QACFvB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAuB,EAAA,EAAI;QACFxB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA,YAAY;QACVD,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAwB,EAAA,EAAI;QACFzB,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAyB,EAAA,EAAI;QACF1B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA0B,EAAA,EAAI;QACF3B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA2B,EAAA,EAAI;QACF5B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA4B,EAAA,EAAI;QACF7B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA6B,EAAA,EAAI;QACF9B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA8B,EAAA,EAAI;QACF/B,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA+B,EAAA,EAAI;QACFhC,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACAgC,EAAA,EAAI;QACFjC,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;IACA,SAAS;QACPD,aAAA,EAAe;QACfC,aAAA,EAAe;IACjB;AACF","ignoreList":[0]}},
    {"offset": {"line": 1354, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1360, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/indent/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { i18n } from './i18n.js'\n\nexport const IndentFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#IndentFeatureClient',\n    i18n,\n  },\n  key: 'indent',\n})\n"],"names":["createServerFeature","i18n","IndentFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;AAEd,MAAMC,aAAA,qTAAgBF,sBAAAA,AAAA,EAAoB;IAC/CG,OAAA,EAAS;QACPC,aAAA,EAAe;gUACfH,OAAAA;IACF;IACAI,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 1374, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1380, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/unorderedList/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'قائمة غير مرتبة',\n  },\n  az: {\n    label: 'Sırasız Siyahı',\n  },\n  bg: {\n    label: 'Неподреден списък',\n  },\n  cs: {\n    label: 'Neuspořádaný seznam',\n  },\n  da: {\n    label: 'Usorteret Liste',\n  },\n  de: {\n    label: 'Ungeordnete Liste',\n  },\n  en: {\n    label: 'Unordered List',\n  },\n  es: {\n    label: 'Lista desordenada',\n  },\n  et: {\n    label: 'Sorteerimata loend',\n  },\n  fa: {\n    label: 'لیست بدون ترتیب',\n  },\n  fr: {\n    label: 'Liste non ordonnée',\n  },\n  he: {\n    label: 'רשימה לא מסודרת',\n  },\n  hr: {\n    label: 'Neuređeni popis',\n  },\n  hu: {\n    label: 'Rendezetlen lista',\n  },\n  it: {\n    label: 'Elenco non ordinato',\n  },\n  ja: {\n    label: '順不同リスト',\n  },\n  ko: {\n    label: '비정렬 목록',\n  },\n  my: {\n    label: 'Senarai Tidak Tertib',\n  },\n  nb: {\n    label: 'Usortert liste',\n  },\n  nl: {\n    label: 'Ongeordende lijst',\n  },\n  pl: {\n    label: 'Nieuporządkowana lista',\n  },\n  pt: {\n    label: 'Lista Não Ordenada',\n  },\n  ro: {\n    label: 'Listă neordonată',\n  },\n  rs: {\n    label: 'Неуређена листа',\n  },\n  'rs-latin': {\n    label: 'Neuređena lista',\n  },\n  ru: {\n    label: 'Несортированный список',\n  },\n  sk: {\n    label: 'Neusporiadaný zoznam',\n  },\n  sl: {\n    label: 'Neurejen seznam',\n  },\n  sv: {\n    label: 'Oordnad lista',\n  },\n  th: {\n    label: 'รายการที่ไม่ได้เรียงลำดับ',\n  },\n  tr: {\n    label: 'Sırasız Liste',\n  },\n  uk: {\n    label: 'Невпорядкований список',\n  },\n  vi: {\n    label: 'Danh sách không theo thứ tự',\n  },\n  zh: {\n    label: '无序列表',\n  },\n  'zh-TW': {\n    label: '無順序列表',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 1490, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1496, "column": 0}, "map": {"version":3,"file":"markdown.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/shared/markdown.ts"],"sourcesContent":["// Copied from https://github.com/facebook/lexical/blob/176b8cf16ecb332ee5efe2c75219e223b7b019f2/packages/lexical-markdown/src/MarkdownTransformers.ts#L97C1-L172C1\n\nimport type { ListNode, ListType } from '@lexical/list'\nimport type { ElementNode } from 'lexical'\n\nimport { $createListItemNode, $createListNode, $isListItemNode, $isListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\n// Amount of spaces that define indentation level\nconst LIST_INDENT_SIZE = 4\n\nexport const listReplace = (listType: ListType): ElementTransformer['replace'] => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling()\n    const nextNode = parentNode.getNextSibling()\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined)\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild()\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem)\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem)\n      }\n      parentNode.remove()\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem)\n      parentNode.remove()\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined)\n      list.append(listItem)\n      parentNode.replace(list)\n    }\n    listItem.append(...children)\n    listItem.select(0, 0)\n    const indent = Math.floor(match[1]!.length / LIST_INDENT_SIZE)\n    if (indent) {\n      listItem.setIndent(indent)\n    }\n  }\n}\n\nexport const listExport = (\n  listNode: ListNode,\n  exportChildren: (node: ElementNode) => string,\n  depth: number,\n): string => {\n  const output: string[] = []\n  const children = listNode.getChildren()\n  let index = 0\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild()\n        if ($isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1))\n          continue\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE)\n      const listType = listNode.getListType()\n      const prefix =\n        listType === 'number'\n          ? `${listNode.getStart() + index}. `\n          : listType === 'check'\n            ? `- [${listItemNode.getChecked() ? 'x' : ' '}] `\n            : '- '\n      output.push(indent + prefix + exportChildren(listItemNode))\n      index++\n    }\n  }\n\n  return output.join('\\n')\n}\n"],"names":["$createListItemNode","$createListNode","$isListItemNode","$isListNode","LIST_INDENT_SIZE","listReplace","listType","parentNode","children","match","previousNode","getPreviousSibling","nextNode","getNextSibling","listItem","undefined","getListType","firstChild","getFirstChild","insertBefore","append","remove","list","Number","replace","select","indent","Math","floor","length","setIndent","listExport","listNode","exportChildren","depth","output","getChildren","index","listItemNode","getChildrenSize","push","repeat","prefix","getStart","getChecked","join"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1557, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1563, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/unorderedList/markdownTransformer.ts"],"sourcesContent":["import { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const UNORDERED_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n}\n"],"names":["$isListNode","ListItemNode","ListNode","listExport","listReplace","UNORDERED_LIST","type","dependencies","export","node","exportChildren","regExp","replace"],"mappings":";;;AAAA,SAASA,WAAW,EAAEC,YAAY,EAAEC,QAAQ,QAAQ;AAIpD,SAASC,UAAU,EAAEC,WAAW,QAAQ;;;AAEjC,MAAMC,cAAA,GAAqC;IAChDC,IAAA,EAAM;IACNC,YAAA,EAAc;kOAACL,WAAA;kOAAUD,eAAA;KAAa;IACtCO,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,qOAAOV,cAAAA,AAAA,EAAYS,IAAA,6TAAQN,aAAAA,AAAA,EAAWM,IAAA,EAAMC,cAAA,EAAgB,KAAK;IACnE;IACAC,MAAA,EAAQ;IACRC,OAAA,2TAASR,cAAAA,AAAA,EAAY;AACvB","ignoreList":[0]}},
    {"offset": {"line": 1582, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1588, "column": 0}, "map": {"version":3,"file":"htmlConverter.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/htmlConverter.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport type { HTMLConverter } from '../converters/html/converter/types.js'\nimport type { SerializedListItemNode, SerializedListNode } from './plugin/index.js'\n\nimport { convertLexicalNodesToHTML } from '../converters/html/converter/index.js'\n\nexport const ListHTMLConverter: HTMLConverter<SerializedListNode> = {\n  converter: async ({\n    converters,\n    currentDepth,\n    depth,\n    draft,\n    node,\n    overrideAccess,\n    parent,\n    req,\n    showHiddenFields,\n  }) => {\n    const childrenText = await convertLexicalNodesToHTML({\n      converters,\n      currentDepth,\n      depth,\n      draft,\n      lexicalNodes: node.children,\n      overrideAccess,\n      parent: {\n        ...node,\n        parent,\n      },\n      req,\n      showHiddenFields,\n    })\n\n    return `<${node?.tag} class=\"list-${node?.listType}\">${childrenText}</${node?.tag}>`\n  },\n  nodeTypes: [ListNode.getType()],\n}\n\nexport const ListItemHTMLConverter: HTMLConverter<SerializedListItemNode> = {\n  converter: async ({\n    converters,\n    currentDepth,\n    depth,\n    draft,\n    node,\n    overrideAccess,\n    parent,\n    req,\n    showHiddenFields,\n  }) => {\n    const hasSubLists = node.children.some((child) => child.type === 'list')\n\n    const childrenText = await convertLexicalNodesToHTML({\n      converters,\n      currentDepth,\n      depth,\n      draft,\n      lexicalNodes: node.children,\n      overrideAccess,\n      parent: {\n        ...node,\n        parent,\n      },\n      req,\n      showHiddenFields,\n    })\n\n    if ('listType' in parent && parent?.listType === 'check') {\n      const uuid = uuidv4()\n\n      return `<li aria-checked=${node.checked ? 'true' : 'false'} class=\"${\n        'list-item-checkbox' +\n        (node.checked ? ' list-item-checkbox-checked' : ' list-item-checkbox-unchecked') +\n        (hasSubLists ? ' nestedListItem' : '')\n      }\"\n          role=\"checkbox\"\n          tabIndex=${-1}\n          value=${node?.value}\n      >\n      ${\n        hasSubLists\n          ? childrenText\n          : `\n        <input type=\"checkbox\" id=\"${uuid}\"${node.checked ? ' checked' : ''}>\n        <label for=\"${uuid}\">${childrenText}</label><br>\n      `\n      }\n\n\n          </li>`\n    } else {\n      return `<li ${hasSubLists ? `class=\"nestedListItem\" ` : ''}value=${node?.value}>${childrenText}</li>`\n    }\n  },\n  nodeTypes: [ListItemNode.getType()],\n}\n"],"names":["ListItemNode","ListNode","v4","uuidv4","convertLexicalNodesToHTML","ListHTMLConverter","converter","converters","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","tag","listType","nodeTypes","getType","ListItemHTMLConverter","hasSubLists","some","child","type","uuid","checked","value"],"mappings":";;;;AAMA,SAASI,yBAAyB,QAAQ;AAN1C,SAASJ,YAAY,EAAEC,QAAQ,QAAQ;AACvC,SAASC,EAAA,IAAMC,MAAM,QAAQ;;;;AAOtB,MAAME,iBAAA,GAAuD;IAClEC,SAAA,EAAW,MAAAA,CAAO,EAChBC,UAAU,EACVC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;QACC,MAAMC,YAAA,GAAe,4UAAMZ,4BAAA,AAAAA,EAA0B;YACnDG,UAAA;YACAC,YAAA;YACAC,KAAA;YACAC,KAAA;YACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;YAC3BN,cAAA;YACAC,MAAA,EAAQ;gBACN,GAAGF,IAAI;gBACPE;YACF;YACAC,GAAA;YACAC;QACF;QAEA,OAAO,CAAA,CAAA,EAAIJ,IAAA,EAAMQ,GAAA,CAAA,aAAA,EAAmBR,IAAA,EAAMS,QAAA,CAAA,EAAA,EAAaJ,YAAA,CAAA,EAAA,EAAiBL,IAAA,EAAMQ,GAAA,CAAA,CAAA,CAAM;IACtF;IACAE,SAAA,EAAW;iOAACpB,YAAA,CAASqB,OAAO;KAAA;AAC9B;AAEO,MAAMC,qBAAA,GAA+D;IAC1EjB,SAAA,EAAW,MAAAA,CAAO,EAChBC,UAAU,EACVC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;QACC,MAAMS,WAAA,GAAcb,IAAA,CAAKO,QAAQ,CAACO,IAAI,EAAEC,KAAA,GAAUA,KAAA,CAAMC,IAAI,KAAK;QAEjE,MAAMX,YAAA,GAAe,4UAAMZ,4BAAAA,AAAA,EAA0B;YACnDG,UAAA;YACAC,YAAA;YACAC,KAAA;YACAC,KAAA;YACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;YAC3BN,cAAA;YACAC,MAAA,EAAQ;gBACN,GAAGF,IAAI;gBACPE;YACF;YACAC,GAAA;YACAC;QACF;QAEA,IAAI,cAAcF,MAAA,IAAUA,MAAA,EAAQO,QAAA,KAAa,SAAS;YACxD,MAAMQ,IAAA,8OAAOzB,KAAAA,AAAA;YAEb,OAAO,CAAA,iBAAA,EAAoBQ,IAAA,CAAKkB,OAAO,GAAG,SAAS,QAAA,QAAA,EACjD,uBAAA,CACClB,IAAA,CAAKkB,OAAO,GAAG,gCAAgC,+BAA8B,IAAA,CAC7EL,WAAA,GAAc,oBAAoB,EAAC,EAAA;;qBAGvB,CAAC,EAAA;kBACJb,IAAA,EAAMmB,KAAA,CAAA;;QAGhBN,WAAA,GACIR,YAAA,GACA,CAAA;qCACyBY,IAAA,CAAA,CAAA,EAAQjB,IAAA,CAAKkB,OAAO,GAAG,aAAa,GAAA;sBACnDD,IAAA,CAAA,EAAA,EAASZ,YAAA,CAAA;OACxB,CAAA;;;gBAIS;QACZ,OAAO;YACL,OAAO,CAAA,IAAA,EAAOQ,WAAA,GAAc,CAAA,uBAAA,CAAyB,GAAG,GAAA,MAAA,EAAWb,IAAA,EAAMmB,KAAA,CAAA,CAAA,EAASd,YAAA,CAAA,KAAA,CAAmB;QACvG;IACF;IACAK,SAAA,EAAW;kOAACrB,eAAA,CAAasB,OAAO;KAAA;AAClC","ignoreList":[0]}},
    {"offset": {"line": 1659, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1665, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/unorderedList/server/index.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\n\nimport { createServerFeature } from '../../../../utilities/createServerFeature.js'\nimport { createNode } from '../../../typeUtilities.js'\nimport { ListHTMLConverter, ListItemHTMLConverter } from '../../htmlConverter.js'\nimport { UNORDERED_LIST } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport const UnorderedListFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#UnorderedListFeatureClient',\n    i18n,\n    markdownTransformers: [UNORDERED_LIST],\n    nodes: [\n      createNode({\n        converters: {\n          html: ListHTMLConverter as any, // ListHTMLConverter uses a different generic type than ListNode[exportJSON], thus we need to cast as any\n        },\n        node: ListNode,\n      }),\n      createNode({\n        converters: {\n          html: ListItemHTMLConverter as any,\n        },\n        node: ListItemNode,\n      }),\n    ],\n  },\n  key: 'unorderedList',\n})\n"],"names":["ListItemNode","ListNode","createServerFeature","createNode","ListHTMLConverter","ListItemHTMLConverter","UNORDERED_LIST","i18n","UnorderedListFeature","feature","ClientFeature","markdownTransformers","nodes","converters","html","node","key"],"mappings":";;;AAEA,SAASE,mBAAmB,QAAQ;AAIpC,SAASK,IAAI,QAAQ;AADrB,SAASD,cAAc,QAAQ;AAF/B,SAASH,UAAU,QAAQ;AAC3B,SAASC,iBAAiB,EAAEC,qBAAqB,QAAQ;AAJzD,SAASL,YAAY,EAAEC,QAAQ,QAAQ;;;;;;;AAQhC,MAAMO,oBAAA,qTAAuBN,sBAAAA,AAAA,EAAoB;IACtDO,OAAA,EAAS;QACPC,aAAA,EAAe;QACfH,+UAAA;QACAI,oBAAA,EAAsB;mVAACL,iBAAA;SAAe;QACtCM,KAAA,EAAO;uTACLT,aAAAA,AAAA,EAAW;gBACTU,UAAA,EAAY;oBACVC,IAAA,EAAMV,oUAAAA;gBACR;gBACAW,IAAA,4NAAMd,WAAAA;YACR;uTACAE,aAAAA,AAAA,EAAW;gBACTU,UAAA,EAAY;oBACVC,IAAA,kTAAMT,wBAAAA;gBACR;gBACAU,IAAA,4NAAMf,eAAAA;YACR;SAAA;IAEJ;IACAgB,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 1704, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1710, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/orderedList/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'قائمة مرتبة',\n  },\n  az: {\n    label: 'Sıralı Siyahı',\n  },\n  bg: {\n    label: 'Подреден списък',\n  },\n  cs: {\n    label: 'Seřazený seznam',\n  },\n  da: {\n    label: 'Ordnet Liste',\n  },\n  de: {\n    label: 'Geordnete Liste',\n  },\n  en: {\n    label: 'Ordered List',\n  },\n  es: {\n    label: 'Lista ordenada',\n  },\n  et: {\n    label: 'Sorteeritud loend',\n  },\n  fa: {\n    label: 'لیست مرتب شده',\n  },\n  fr: {\n    label: 'Liste ordonnée',\n  },\n  he: {\n    label: 'רשימה ממוינת',\n  },\n  hr: {\n    label: 'Naručeni popis',\n  },\n  hu: {\n    label: 'Rendelt lista',\n  },\n  it: {\n    label: 'Elenco ordinato',\n  },\n  ja: {\n    label: '順序付きリスト',\n  },\n  ko: {\n    label: '주문된 목록',\n  },\n  my: {\n    label: 'စီစဉ်ထားသော စာရင်း',\n  },\n  nb: {\n    label: 'Ordnet Liste',\n  },\n  nl: {\n    label: 'Geordende Lijst',\n  },\n  pl: {\n    label: 'Uporządkowana lista',\n  },\n  pt: {\n    label: 'Lista Ordenada',\n  },\n  ro: {\n    label: 'Lista ordonată',\n  },\n  rs: {\n    label: 'Уређена листа',\n  },\n  'rs-latin': {\n    label: 'Uređena lista',\n  },\n  ru: {\n    label: 'Упорядоченный список',\n  },\n  sk: {\n    label: 'Zoradený zoznam',\n  },\n  sl: {\n    label: 'Urejen seznam',\n  },\n  sv: {\n    label: 'Ordnad Lista',\n  },\n  th: {\n    label: 'รายการที่ถูกจัดลำดับ',\n  },\n  tr: {\n    label: 'Sıralı Liste',\n  },\n  uk: {\n    label: 'Впорядкований список',\n  },\n  vi: {\n    label: 'Danh sách đã sắp xếp',\n  },\n  zh: {\n    label: '有序列表',\n  },\n  'zh-TW': {\n    label: '有序列表',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 1820, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1826, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/orderedList/markdownTransformer.ts"],"sourcesContent":["import { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const ORDERED_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)(\\d+)\\.\\s/,\n  replace: listReplace('number'),\n}\n"],"names":["$isListNode","ListItemNode","ListNode","listExport","listReplace","ORDERED_LIST","type","dependencies","export","node","exportChildren","regExp","replace"],"mappings":";;;AAAA,SAASA,WAAW,EAAEC,YAAY,EAAEC,QAAQ,QAAQ;AAIpD,SAASC,UAAU,EAAEC,WAAW,QAAQ;;;AAEjC,MAAMC,YAAA,GAAmC;IAC9CC,IAAA,EAAM;IACNC,YAAA,EAAc;kOAACL,WAAA;kOAAUD,eAAA;KAAa;IACtCO,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,qOAAOV,cAAAA,AAAA,EAAYS,IAAA,6TAAQN,aAAAA,AAAA,EAAWM,IAAA,EAAMC,cAAA,EAAgB,KAAK;IACnE;IACAC,MAAA,EAAQ;IACRC,OAAA,2TAASR,cAAAA,AAAA,EAAY;AACvB","ignoreList":[0]}},
    {"offset": {"line": 1845, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1851, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/orderedList/server/index.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\n\nimport { createServerFeature } from '../../../../utilities/createServerFeature.js'\nimport { createNode } from '../../../typeUtilities.js'\nimport { ListHTMLConverter, ListItemHTMLConverter } from '../../htmlConverter.js'\nimport { ORDERED_LIST } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport const OrderedListFeature = createServerFeature({\n  feature: ({ featureProviderMap }) => {\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#OrderedListFeatureClient',\n      i18n,\n      markdownTransformers: [ORDERED_LIST],\n      nodes: featureProviderMap.has('unorderedList')\n        ? []\n        : [\n            createNode({\n              converters: {\n                html: ListHTMLConverter as any, // ListHTMLConverter uses a different generic type than ListNode[exportJSON], thus we need to cast as any\n              },\n              node: ListNode,\n            }),\n            createNode({\n              converters: {\n                html: ListItemHTMLConverter as any,\n              },\n              node: ListItemNode,\n            }),\n          ],\n    }\n  },\n  key: 'orderedList',\n})\n"],"names":["ListItemNode","ListNode","createServerFeature","createNode","ListHTMLConverter","ListItemHTMLConverter","ORDERED_LIST","i18n","OrderedListFeature","feature","featureProviderMap","ClientFeature","markdownTransformers","nodes","has","converters","html","node","key"],"mappings":";;;AAEA,SAASE,mBAAmB,QAAQ;AAIpC,SAASK,IAAI,QAAQ;AADrB,SAASD,YAAY,QAAQ;AAF7B,SAASH,UAAU,QAAQ;AAC3B,SAASC,iBAAiB,EAAEC,qBAAqB,QAAQ;AAJzD,SAASL,YAAY,EAAEC,QAAQ,QAAQ;;;;;;;AAQhC,MAAMO,kBAAA,qTAAqBN,sBAAAA,AAAA,EAAoB;IACpDO,OAAA,EAASA,CAAC,EAAEC,kBAAAA,EAAoB;QAC9B,OAAO;YACLC,aAAA,EAAe;YACfJ,6UAAA;YACAK,oBAAA,EAAsB;qVAACN,eAAA;aAAa;YACpCO,KAAA,EAAOH,kBAAA,CAAmBI,GAAG,CAAC,mBAC1B,EAAE,GACF;2TACEX,aAAAA,AAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,kTAAMZ,oBAAAA;oBACR;oBACAa,IAAA,4NAAMhB,WAAAA;gBACR;gBACAE,wTAAAA,AAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,kTAAMX,wBAAAA;oBACR;oBACAY,IAAA,4NAAMjB,eAAAA;gBACR;aAAA;QAER;IACF;IACAkB,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 1892, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1898, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/checklist/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'قائمة التحقق',\n  },\n  az: {\n    label: 'Yoxlama Siyahısı',\n  },\n  bg: {\n    label: 'Списък за проверка',\n  },\n  cs: {\n    label: 'Seznam kontrol',\n  },\n  da: {\n    label: 'Tjekliste',\n  },\n  de: {\n    label: 'Checkliste',\n  },\n  en: {\n    label: 'Check List',\n  },\n  es: {\n    label: 'Lista de comprobación',\n  },\n  et: {\n    label: '',\n  },\n  fa: {\n    label: 'لیست بررسی',\n  },\n  fr: {\n    label: 'Liste de contrôle',\n  },\n  he: {\n    label: 'רשימת בדיקה',\n  },\n  hr: {\n    label: 'Kontrolni popis',\n  },\n  hu: {\n    label: 'Ellenőrzőlista',\n  },\n  it: {\n    label: 'Lista di controllo',\n  },\n  ja: {\n    label: 'チェックリスト',\n  },\n  ko: {\n    label: '체크 리스트',\n  },\n  my: {\n    label: 'Senarai Semak',\n  },\n  nb: {\n    label: 'Sjekkliste',\n  },\n  nl: {\n    label: 'Checklist',\n  },\n  pl: {\n    label: 'Lista kontrolna',\n  },\n  pt: {\n    label: 'Lista de Verificação',\n  },\n  ro: {\n    label: 'Listă de verificare',\n  },\n  rs: {\n    label: 'Контролна листа',\n  },\n  'rs-latin': {\n    label: 'Kontrolna lista',\n  },\n  ru: {\n    label: 'Список Проверки',\n  },\n  sk: {\n    label: 'Kontrolný zoznam',\n  },\n  sl: {\n    label: 'Nimekiri',\n  },\n  sv: {\n    label: 'Kontrollista',\n  },\n  th: {\n    label: 'รายการตรวจสอบ',\n  },\n  tr: {\n    label: 'Kontrol Listesi',\n  },\n  uk: {\n    label: 'Список перевірки',\n  },\n  vi: {\n    label: 'Danh sách kiểm tra',\n  },\n  zh: {\n    label: '检查清单',\n  },\n  'zh-TW': {\n    label: '檢查清單',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2008, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2014, "column": 0}, "map": {"version":3,"file":"markdownTransformers.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/checklist/markdownTransformers.ts"],"sourcesContent":["import { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const CHECK_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n}\n"],"names":["$isListNode","ListItemNode","ListNode","listExport","listReplace","CHECK_LIST","type","dependencies","export","node","exportChildren","regExp","replace"],"mappings":";;;AAAA,SAASA,WAAW,EAAEC,YAAY,EAAEC,QAAQ,QAAQ;AAIpD,SAASC,UAAU,EAAEC,WAAW,QAAQ;;;AAEjC,MAAMC,UAAA,GAAiC;IAC5CC,IAAA,EAAM;IACNC,YAAA,EAAc;kOAACL,WAAA;kOAAUD,eAAA;KAAa;IACtCO,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,qOAAOV,cAAAA,AAAA,EAAYS,IAAA,6TAAQN,aAAAA,AAAA,EAAWM,IAAA,EAAMC,cAAA,EAAgB,KAAK;IACnE;IACAC,MAAA,EAAQ;IACRC,OAAA,2TAASR,cAAAA,AAAA,EAAY;AACvB","ignoreList":[0]}},
    {"offset": {"line": 2033, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2039, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/lists/checklist/server/index.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\n\nimport { createServerFeature } from '../../../../utilities/createServerFeature.js'\nimport { createNode } from '../../../typeUtilities.js'\nimport { ListHTMLConverter, ListItemHTMLConverter } from '../../htmlConverter.js'\nimport { CHECK_LIST } from '../markdownTransformers.js'\nimport { i18n } from './i18n.js'\n\nexport const ChecklistFeature = createServerFeature({\n  feature: ({ featureProviderMap }) => {\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#ChecklistFeatureClient',\n      i18n,\n      markdownTransformers: [CHECK_LIST],\n      nodes:\n        featureProviderMap.has('unorderedList') || featureProviderMap.has('orderedList')\n          ? []\n          : [\n              createNode({\n                converters: {\n                  html: ListHTMLConverter as any, // ListHTMLConverter uses a different generic type than ListNode[exportJSON], thus we need to cast as any\n                },\n                node: ListNode,\n              }),\n              createNode({\n                converters: {\n                  html: ListItemHTMLConverter as any,\n                },\n                node: ListItemNode,\n              }),\n            ],\n    }\n  },\n  key: 'checklist',\n})\n"],"names":["ListItemNode","ListNode","createServerFeature","createNode","ListHTMLConverter","ListItemHTMLConverter","CHECK_LIST","i18n","ChecklistFeature","feature","featureProviderMap","ClientFeature","markdownTransformers","nodes","has","converters","html","node","key"],"mappings":";;;AAEA,SAASE,mBAAmB,QAAQ;AAIpC,SAASK,IAAI,QAAQ;AADrB,SAASD,UAAU,QAAQ;AAF3B,SAASH,UAAU,QAAQ;AAC3B,SAASC,iBAAiB,EAAEC,qBAAqB,QAAQ;AAJzD,SAASL,YAAY,EAAEC,QAAQ,QAAQ;;;;;;;AAQhC,MAAMO,gBAAA,qTAAmBN,sBAAAA,AAAA,EAAoB;IAClDO,OAAA,EAASA,CAAC,EAAEC,kBAAAA,EAAoB;QAC9B,OAAO;YACLC,aAAA,EAAe;YACfJ,2UAAA;YACAK,oBAAA,EAAsB;oVAACN,aAAA;aAAW;YAClCO,KAAA,EACEH,kBAAA,CAAmBI,GAAG,CAAC,oBAAoBJ,kBAAA,CAAmBI,GAAG,CAAC,iBAC9D,EAAE,GACF;iBACEX,uTAAAA,AAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,kTAAMZ,oBAAAA;oBACR;oBACAa,IAAA,4NAAMhB,WAAAA;gBACR;2TACAE,aAAAA,AAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,kTAAMX,wBAAAA;oBACR;oBACAY,IAAA,4NAAMjB,eAAAA;gBACR;aAAA;QAEV;IACF;IACAkB,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 2080, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2086, "column": 0}, "map": {"version":3,"file":"url.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/url.ts"],"sourcesContent":["export function sanitizeUrl(url: string): string {\n  /** A pattern that matches safe  URLs. */\n  const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi\n\n  /** A pattern that matches safe data URLs. */\n  const DATA_URL_PATTERN =\n    /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z\\d+/]+=*$/i\n\n  url = String(url).trim()\n\n  if (url.match(SAFE_URL_PATTERN) != null || url.match(DATA_URL_PATTERN) != null) {\n    return url\n  }\n\n  return 'https://'\n}\n\n/**\n * This regex checks for absolute URLs in a string. Tested for the following use cases:\n * - http://example.com\n * - https://example.com\n * - ftp://files.example.com\n * - http://example.com/resource\n * - https://example.com/resource?key=value\n * - http://example.com/resource#anchor\n * - http://www.example.com\n * - https://sub.example.com/path/file\n * - mailto:\n */\nexport const absoluteRegExp =\n  /^(?:[a-zA-Z][a-zA-Z\\d+.-]*:(?:\\/\\/)?(?:[-;:&=+$,\\w]+@)?[A-Za-z\\d]+(?:\\.[A-Za-z\\d]+)+|www\\.[A-Za-z\\d]+(?:\\.[A-Za-z\\d]+)+|(?:tel|mailto):[\\w+.-]+)(?:\\/[+~%/\\w-]*)?(?:\\?[-;&=%\\w]*)?(?:#\\w+)?$/\n\n/**\n * This regex checks for relative URLs starting with / or anchor links starting with # in a string. Tested for the following use cases:\n * - /privacy-policy\n * - /privacy-policy#primary-terms\n * - #primary-terms\n *  */\nexport const relativeOrAnchorRegExp = /^(?:\\/[\\w\\-./]*(?:#\\w[\\w-]*)?|#[\\w\\-]+)$/\n\n/**\n * Prevents unreasonable URLs from being inserted into the editor.\n * @param url\n */\nexport function validateUrlMinimal(url: string): boolean {\n  if (!url) {\n    return false\n  }\n\n  return !url.includes(' ')\n}\n\n// Do not keep validateUrl function too loose. This is run when pasting in text, to determine if links are in that text and if it should create AutoLinkNodes.\n// This is why we do not allow stuff like anchors here, as we don't want copied anchors to be turned into AutoLinkNodes.\nexport function validateUrl(url: string): boolean {\n  // TODO Fix UI for link insertion; it should never default to an invalid URL such as https://.\n  // Maybe show a dialog where they user can type the URL before inserting it.\n\n  if (!url) {\n    return false\n  }\n\n  if (url === 'https://') {\n    return true\n  }\n\n  // This makes sure URLs starting with www. instead of https are valid too\n  if (absoluteRegExp.test(url)) {\n    return true\n  }\n\n  // Check relative or anchor links\n  if (relativeOrAnchorRegExp.test(url)) {\n    return true\n  }\n\n  // While this doesn't allow URLs starting with www (which is why we use the regex above), it does properly handle tel: URLs\n  try {\n    new URL(url)\n    return true\n  } catch {\n    /* empty */\n  }\n\n  return false\n}\n"],"names":["sanitizeUrl","url","SAFE_URL_PATTERN","DATA_URL_PATTERN","String","trim","match","absoluteRegExp","relativeOrAnchorRegExp","validateUrlMinimal","includes","validateUrl","test","URL"],"mappings":";;;;;;;AAAO,SAASA,YAAYC,GAAW;IACrC,uCAAA,GACA,MAAMC,gBAAA,GAAmB;IAEzB,2CAAA,GACA,MAAMC,gBAAA,GACJ;IAEFF,GAAA,GAAMG,MAAA,CAAOH,GAAA,EAAKI,IAAI;IAEtB,IAAIJ,GAAA,CAAIK,KAAK,CAACJ,gBAAA,KAAqB,QAAQD,GAAA,CAAIK,KAAK,CAACH,gBAAA,KAAqB,MAAM;QAC9E,OAAOF,GAAA;IACT;IAEA,OAAO;AACT;AAcO,MAAMM,cAAA,GACX;AAQK,MAAMC,sBAAA,GAAyB;AAM/B,SAASC,mBAAmBR,GAAW;IAC5C,IAAI,CAACA,GAAA,EAAK;QACR,OAAO;IACT;IAEA,OAAO,CAACA,GAAA,CAAIS,QAAQ,CAAC;AACvB;AAIO,SAASC,YAAYV,GAAW;IACrC,8FAAA;IACA,4EAAA;IAEA,IAAI,CAACA,GAAA,EAAK;QACR,OAAO;IACT;IAEA,IAAIA,GAAA,KAAQ,YAAY;QACtB,OAAO;IACT;IAEA,yEAAA;IACA,IAAIM,cAAA,CAAeK,IAAI,CAACX,GAAA,GAAM;QAC5B,OAAO;IACT;IAEA,iCAAA;IACA,IAAIO,sBAAA,CAAuBI,IAAI,CAACX,GAAA,GAAM;QACpC,OAAO;IACT;IAEA,2HAAA;IACA,IAAI;QACF,IAAIY,GAAA,CAAIZ,GAAA;QACR,OAAO;IACT,EAAE,OAAM;IACN,SAAA,GAAA;IAGF,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 2135, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2141, "column": 0}, "map": {"version":3,"file":"baseFields.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/baseFields.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  FieldAffectingData,\n  RadioField,\n  SanitizedConfig,\n  TextField,\n  TextFieldSingleValidation,\n  User,\n} from 'payload'\n\nimport type { LinkFields } from '../nodes/types.js'\n\nimport { validateUrl, validateUrlMinimal } from '../../../lexical/utils/url.js'\n\nexport const getBaseFields = (\n  config: SanitizedConfig,\n  enabledCollections?: CollectionSlug[],\n  disabledCollections?: CollectionSlug[],\n  maxDepth?: number,\n): FieldAffectingData[] => {\n  let enabledRelations: CollectionSlug[]\n\n  /**\n   * Figure out which relations should be enabled (enabledRelations) based on a collection's admin.enableRichTextLink property,\n   * or the Link Feature's enabledCollections and disabledCollections properties which override it.\n   */\n  if (enabledCollections) {\n    enabledRelations = enabledCollections\n  } else if (disabledCollections) {\n    enabledRelations = config.collections\n      .filter(({ slug }) => !disabledCollections.includes(slug))\n      .map(({ slug }) => slug)\n  } else {\n    enabledRelations = config.collections\n      .filter(({ admin: { enableRichTextLink, hidden } }) => {\n        if (typeof hidden !== 'function' && hidden) {\n          return false\n        }\n        return enableRichTextLink\n      })\n      .map(({ slug }) => slug)\n  }\n\n  const baseFields: FieldAffectingData[] = [\n    {\n      name: 'text',\n      type: 'text',\n      label: ({ t }) => t('fields:textToDisplay'),\n      required: true,\n    },\n    {\n      name: 'linkType',\n      type: 'radio',\n      admin: {\n        description: ({ t }) => t('fields:chooseBetweenCustomTextOrDocument'),\n      },\n      defaultValue: 'custom',\n      label: ({ t }) => t('fields:linkType'),\n      options: [\n        {\n          label: ({ t }) => t('fields:customURL'),\n          value: 'custom',\n        },\n      ],\n      required: true,\n    } as RadioField,\n    {\n      name: 'url',\n      type: 'text',\n      hooks: {\n        beforeChange: [\n          ({ value }) => {\n            if (!value) {\n              return\n            }\n\n            if (!validateUrl(value)) {\n              return encodeURIComponent(value)\n            }\n            return value\n          },\n        ],\n      },\n      label: ({ t }) => t('fields:enterURL'),\n      required: true,\n      validate: ((value: string, options) => {\n        if ((options?.siblingData as LinkFields)?.linkType === 'internal') {\n          return // no validation needed, as no url should exist for internal links\n        }\n        if (!validateUrlMinimal(value)) {\n          return 'Invalid URL'\n        }\n      }) as TextFieldSingleValidation,\n    },\n  ]\n\n  // Only display internal link-specific fields / options / conditions if there are enabled relations\n  if (enabledRelations?.length) {\n    ;(baseFields[1] as RadioField).options.push({\n      label: ({ t }) => t('fields:internalLink'),\n      value: 'internal',\n    })\n    ;(baseFields[2] as TextField).admin = {\n      condition: (_data, _siblingData) => {\n        return _siblingData.linkType !== 'internal'\n      },\n    }\n\n    baseFields.push({\n      name: 'doc',\n      admin: {\n        condition: (_data, _siblingData) => {\n          return _siblingData.linkType === 'internal'\n        },\n      },\n      // when admin.hidden is a function we need to dynamically call hidden with the user to know if the collection should be shown\n      type: 'relationship',\n      filterOptions:\n        !enabledCollections && !disabledCollections\n          ? ({ relationTo, user }) => {\n              const hidden = config.collections.find(({ slug }) => slug === relationTo)?.admin\n                .hidden\n              if (typeof hidden === 'function' && hidden({ user } as { user: User })) {\n                return false\n              }\n              return true\n            }\n          : null,\n      label: ({ t }) => t('fields:chooseDocumentToLink'),\n      maxDepth,\n      relationTo: enabledRelations,\n      required: true,\n    })\n  }\n\n  baseFields.push({\n    name: 'newTab',\n    type: 'checkbox',\n    label: ({ t }) => t('fields:openInNewTab'),\n  })\n\n  return baseFields\n}\n"],"names":["validateUrl","validateUrlMinimal","getBaseFields","config","enabledCollections","disabledCollections","maxDepth","enabledRelations","collections","filter","slug","includes","map","admin","enableRichTextLink","hidden","baseFields","name","type","label","t","required","description","defaultValue","options","value","hooks","beforeChange","encodeURIComponent","validate","siblingData","linkType","length","push","condition","_data","_siblingData","filterOptions","relationTo","user","find"],"mappings":";;;AAYA,SAASA,WAAW,EAAEC,kBAAkB,QAAQ;;AAEzC,MAAMC,aAAA,GAAgBA,CAC3BC,MAAA,EACAC,kBAAA,EACAC,mBAAA,EACAC,QAAA;IAEA,IAAIC,gBAAA;IAEJ;;;KAIA,IAAIH,kBAAA,EAAoB;QACtBG,gBAAA,GAAmBH,kBAAA;IACrB,OAAO,IAAIC,mBAAA,EAAqB;QAC9BE,gBAAA,GAAmBJ,MAAA,CAAOK,WAAW,CAClCC,MAAM,CAAC,CAAC,EAAEC,IAAAA,EAAM,GAAK,CAACL,mBAAA,CAAoBM,QAAQ,CAACD,IAAA,GACnDE,GAAG,CAAC,CAAC,EAAEF,IAAAA,EAAM,GAAKA,IAAA;IACvB,OAAO;QACLH,gBAAA,GAAmBJ,MAAA,CAAOK,WAAW,CAClCC,MAAM,CAAC,CAAC,EAAEI,KAAA,EAAO,EAAEC,kBAAkB,EAAEC,MAAAA,EAAM,EAAI;YAChD,IAAI,OAAOA,MAAA,KAAW,cAAcA,MAAA,EAAQ;gBAC1C,OAAO;YACT;YACA,OAAOD,kBAAA;QACT,GACCF,GAAG,CAAC,CAAC,EAAEF,IAAAA,EAAM,GAAKA,IAAA;IACvB;IAEA,MAAMM,UAAA,GAAmC;QACvC;YACEC,IAAA,EAAM;YACNC,IAAA,EAAM;YACNC,KAAA,EAAOA,CAAC,EAAEC,CAAAA,EAAG,GAAKA,CAAA,CAAE;YACpBC,QAAA,EAAU;QACZ;QACA;YACEJ,IAAA,EAAM;YACNC,IAAA,EAAM;YACNL,KAAA,EAAO;gBACLS,WAAA,EAAaA,CAAC,EAAEF,CAAAA,EAAG,GAAKA,CAAA,CAAE;YAC5B;YACAG,YAAA,EAAc;YACdJ,KAAA,EAAOA,CAAC,EAAEC,CAAAA,EAAG,GAAKA,CAAA,CAAE;YACpBI,OAAA,EAAS;gBACP;oBACEL,KAAA,EAAOA,CAAC,EAAEC,CAAAA,EAAG,GAAKA,CAAA,CAAE;oBACpBK,KAAA,EAAO;gBACT;aACD;YACDJ,QAAA,EAAU;QACZ;QACA;YACEJ,IAAA,EAAM;YACNC,IAAA,EAAM;YACNQ,KAAA,EAAO;gBACLC,YAAA,EAAc;oBACZ,CAAC,EAAEF,KAAAA,EAAO;wBACR,IAAI,CAACA,KAAA,EAAO;4BACV;wBACF;wBAEA,IAAI,CAACzB,uTAAAA,AAAA,EAAYyB,KAAA,GAAQ;4BACvB,OAAOG,kBAAA,CAAmBH,KAAA;wBAC5B;wBACA,OAAOA,KAAA;oBACT;iBAAA;YAEJ;YACAN,KAAA,EAAOA,CAAC,EAAEC,CAAAA,EAAG,GAAKA,CAAA,CAAE;YACpBC,QAAA,EAAU;YACVQ,QAAA,EAAWA,CAACJ,KAAA,EAAeD,OAAA;gBACzB,IAAIA,OAAC,EAASM,WAAA,EAA4BC,QAAA,KAAa,YAAY;oBACjE,QAAO,kEAAA;gBACT;gBACA,IAAI,0SAAC9B,qBAAAA,AAAA,EAAmBwB,KAAA,GAAQ;oBAC9B,OAAO;gBACT;YACF;QACF;KACD;IAED,mGAAA;IACA,IAAIlB,gBAAA,EAAkByB,MAAA,EAAQ;QAC1BhB,UAAU,CAAC,EAAE,CAAgBQ,OAAO,CAACS,IAAI,CAAC;YAC1Cd,KAAA,EAAOA,CAAC,EAAEC,CAAAA,EAAG,GAAKA,CAAA,CAAE;YACpBK,KAAA,EAAO;QACT;QACET,UAAU,CAAC,EAAE,CAAeH,KAAK,GAAG;YACpCqB,SAAA,EAAWA,CAACC,KAAA,EAAOC,YAAA;gBACjB,OAAOA,YAAA,CAAaL,QAAQ,KAAK;YACnC;QACF;QAEAf,UAAA,CAAWiB,IAAI,CAAC;YACdhB,IAAA,EAAM;YACNJ,KAAA,EAAO;gBACLqB,SAAA,EAAWA,CAACC,KAAA,EAAOC,YAAA;oBACjB,OAAOA,YAAA,CAAaL,QAAQ,KAAK;gBACnC;YACF;YACA,6HAAA;YACAb,IAAA,EAAM;YACNmB,aAAA,EACE,CAACjC,kBAAA,IAAsB,CAACC,mBAAA,GACpB,CAAC,EAAEiC,UAAU,EAAEC,IAAAA,EAAM;gBACnB,MAAMxB,MAAA,GAASZ,MAAA,CAAOK,WAAW,CAACgC,IAAI,CAAC,CAAC,EAAE9B,IAAAA,EAAM,GAAKA,IAAA,KAAS4B,UAAA,GAAazB,KAAA,CACxEE,MAAA;gBACH,IAAI,OAAOA,MAAA,KAAW,cAAcA,MAAA,CAAO;oBAAEwB;gBAAK,IAAsB;oBACtE,OAAO;gBACT;gBACA,OAAO;YACT,IACA;YACNpB,KAAA,EAAOA,CAAC,EAAEC,CAAAA,EAAG,GAAKA,CAAA,CAAE;YACpBd,QAAA;YACAgC,UAAA,EAAY/B,gBAAA;YACZc,QAAA,EAAU;QACZ;IACF;IAEAL,UAAA,CAAWiB,IAAI,CAAC;QACdhB,IAAA,EAAM;QACNC,IAAA,EAAM;QACNC,KAAA,EAAOA,CAAC,EAAEC,CAAAA,EAAG,GAAKA,CAAA,CAAE;IACtB;IAEA,OAAOJ,UAAA;AACT","ignoreList":[0]}},
    {"offset": {"line": 2256, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2262, "column": 0}, "map": {"version":3,"file":"transformExtraFields.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/transformExtraFields.ts"],"sourcesContent":["import type { CollectionSlug, Field, FieldAffectingData, SanitizedConfig } from 'payload'\n\nimport { getBaseFields } from './baseFields.js'\n\n/**\n * This function is run to enrich the basefields which every link has with potential, custom user-added fields.\n */\nexport function transformExtraFields(\n  customFieldSchema:\n    | ((args: {\n        config: SanitizedConfig\n        defaultFields: FieldAffectingData[]\n      }) => (Field | FieldAffectingData)[])\n    | Field[]\n    | null,\n  config: SanitizedConfig,\n  enabledCollections?: CollectionSlug[],\n  disabledCollections?: CollectionSlug[],\n  maxDepth?: number,\n): Field[] {\n  const baseFields: FieldAffectingData[] = getBaseFields(\n    config,\n    enabledCollections,\n    disabledCollections,\n    maxDepth,\n  )\n\n  let fields: (Field | FieldAffectingData)[]\n\n  if (typeof customFieldSchema === 'function') {\n    fields = customFieldSchema({ config, defaultFields: baseFields })\n  } else if (Array.isArray(customFieldSchema)) {\n    fields = customFieldSchema\n  } else {\n    fields = baseFields\n  }\n\n  return fields as Field[]\n}\n"],"names":["getBaseFields","transformExtraFields","customFieldSchema","config","enabledCollections","disabledCollections","maxDepth","baseFields","fields","defaultFields","Array","isArray"],"mappings":";;;AAEA,SAASA,aAAa,QAAQ;;AAKvB,SAASC,qBACdC,iBAMQ,EACRC,MAAuB,EACvBC,kBAAqC,EACrCC,mBAAsC,EACtCC,QAAiB;IAEjB,MAAMC,UAAA,6TAAmCP,gBAAAA,AAAA,EACvCG,MAAA,EACAC,kBAAA,EACAC,mBAAA,EACAC,QAAA;IAGF,IAAIE,MAAA;IAEJ,IAAI,OAAON,iBAAA,KAAsB,YAAY;QAC3CM,MAAA,GAASN,iBAAA,CAAkB;YAAEC,MAAA;YAAQM,aAAA,EAAeF;QAAW;IACjE,OAAO,IAAIG,KAAA,CAAMC,OAAO,CAACT,iBAAA,GAAoB;QAC3CM,MAAA,GAASN,iBAAA;IACX,OAAO;QACLM,MAAA,GAASD,UAAA;IACX;IAEA,OAAOC,MAAA;AACT","ignoreList":[0]}},
    {"offset": {"line": 2282, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2288, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'رابط',\n    loadingWithEllipsis: 'جار التحميل...',\n  },\n  az: {\n    label: 'Keçid',\n    loadingWithEllipsis: 'Yüklənir...',\n  },\n  bg: {\n    label: 'Връзка',\n    loadingWithEllipsis: 'Зарежда се...',\n  },\n  cs: {\n    label: 'Odkaz',\n    loadingWithEllipsis: 'Načítání...',\n  },\n  da: {\n    label: 'Link',\n    loadingWithEllipsis: 'Indlæser...',\n  },\n  de: {\n    label: 'Verknüpfung',\n    loadingWithEllipsis: 'Laden...',\n  },\n  en: {\n    label: 'Link',\n    loadingWithEllipsis: 'Loading...',\n  },\n  es: {\n    label: 'Enlace',\n    loadingWithEllipsis: 'Cargando...',\n  },\n  et: {\n    label: 'Link',\n    loadingWithEllipsis: 'Laadimine...',\n  },\n  fa: {\n    label: 'پیوند',\n    loadingWithEllipsis: 'در حال بارگذاری...',\n  },\n  fr: {\n    label: 'Lien',\n    loadingWithEllipsis: 'Chargement...',\n  },\n  he: {\n    label: 'קישור',\n    loadingWithEllipsis: 'טוען...',\n  },\n  hr: {\n    label: 'Poveznica',\n    loadingWithEllipsis: 'Učitavanje...',\n  },\n  hu: {\n    label: 'Hivatkozás',\n    loadingWithEllipsis: 'Betöltés...',\n  },\n  it: {\n    label: 'Collegamento',\n    loadingWithEllipsis: 'Caricamento...',\n  },\n  ja: {\n    label: 'リンク',\n    loadingWithEllipsis: '読み込み中...',\n  },\n  ko: {\n    label: '링크',\n    loadingWithEllipsis: '로딩 중...',\n  },\n  my: {\n    label: 'လင့်',\n    loadingWithEllipsis: 'ဖွင့်နေသည်...',\n  },\n  nb: {\n    label: 'Lenke',\n    loadingWithEllipsis: 'Laster...',\n  },\n  nl: {\n    label: 'Link',\n    loadingWithEllipsis: 'Laden...',\n  },\n  pl: {\n    label: 'Łącze',\n    loadingWithEllipsis: 'Ładowanie...',\n  },\n  pt: {\n    label: 'Ligação',\n    loadingWithEllipsis: 'Carregando...',\n  },\n  ro: {\n    label: 'Legătură',\n    loadingWithEllipsis: 'Se încarcă...',\n  },\n  rs: {\n    label: 'Веза',\n    loadingWithEllipsis: 'Учитавање...',\n  },\n  'rs-latin': {\n    label: 'Veza',\n    loadingWithEllipsis: 'Učitavanje...',\n  },\n  ru: {\n    label: 'Ссылка',\n    loadingWithEllipsis: 'Загрузка...',\n  },\n  sk: {\n    label: 'Odkaz',\n    loadingWithEllipsis: 'Načítava sa...',\n  },\n  sl: {\n    label: 'Povezava',\n    loadingWithEllipsis: 'Nalaganje...',\n  },\n  sv: {\n    label: 'Länk',\n    loadingWithEllipsis: 'Laddar...',\n  },\n  th: {\n    label: 'ลิงค์',\n    loadingWithEllipsis: 'กำลังโหลด...',\n  },\n  tr: {\n    label: 'Bağlantı',\n    loadingWithEllipsis: 'Yükleniyor...',\n  },\n  uk: {\n    label: 'Посилання',\n    loadingWithEllipsis: 'Завантаження...',\n  },\n  vi: {\n    label: 'Liên kết',\n    loadingWithEllipsis: 'Đang tải...',\n  },\n  zh: {\n    label: '链接',\n    loadingWithEllipsis: '加载中...',\n  },\n  'zh-TW': {\n    label: '連結',\n    loadingWithEllipsis: '載入中...',\n  },\n}\n"],"names":["i18n","ar","label","loadingWithEllipsis","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2433, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2439, "column": 0}, "map": {"version":3,"file":"LinkNode.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/link/nodes/LinkNode.ts"],"sourcesContent":["import type {\n  BaseSelection,\n  DOMConversionMap,\n  DOMConversionOutput,\n  EditorConfig,\n  ElementNode as ElementNodeType,\n  LexicalCommand,\n  LexicalNode,\n  NodeKey,\n  RangeSelection,\n} from 'lexical'\n\nimport { addClassNamesToElement, isHTMLAnchorElement } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport {\n  $applyNodeReplacement,\n  $createTextNode,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  createCommand,\n  ElementNode,\n} from 'lexical'\n\nimport type { LinkPayload } from '../client/plugins/floatingLinkEditor/types.js'\nimport type { LinkFields, SerializedLinkNode } from './types.js'\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:'])\n\n/** @noInheritDoc */\nexport class LinkNode extends ElementNode {\n  __fields: LinkFields\n  __id: string\n\n  constructor({\n    id,\n    fields = {\n      linkType: 'custom',\n      newTab: false,\n    },\n    key,\n  }: {\n    fields: LinkFields\n    id: string\n    key?: NodeKey\n  }) {\n    super(key)\n    this.__fields = fields\n    this.__id = id\n  }\n\n  static override clone(node: LinkNode): LinkNode {\n    return new LinkNode({\n      id: node.__id,\n      fields: node.__fields,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'link'\n  }\n\n  static override importDOM(): DOMConversionMap | null {\n    return {\n      a: (node: Node) => ({\n        conversion: $convertAnchorElement,\n        priority: 1,\n      }),\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedLinkNode): LinkNode {\n    if (\n      serializedNode.version === 1 &&\n      typeof serializedNode.fields?.doc?.value === 'object' &&\n      serializedNode.fields?.doc?.value?.id\n    ) {\n      serializedNode.fields.doc.value = serializedNode.fields.doc.value.id\n      serializedNode.version = 2\n    }\n\n    if (serializedNode.version === 2 && !serializedNode.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const node = $createLinkNode({\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n    })\n    node.setFormat(serializedNode.format)\n    node.setIndent(serializedNode.indent)\n    node.setDirection(serializedNode.direction)\n    return node\n  }\n\n  override canBeEmpty(): false {\n    return false\n  }\n\n  override canInsertTextAfter(): false {\n    return false\n  }\n\n  override canInsertTextBefore(): false {\n    return false\n  }\n\n  override createDOM(config: EditorConfig): HTMLAnchorElement {\n    const element = document.createElement('a')\n    if (this.__fields?.linkType === 'custom') {\n      element.href = this.sanitizeUrl(this.__fields.url ?? '')\n    }\n    if (this.__fields?.newTab ?? false) {\n      element.target = '_blank'\n    }\n\n    if (this.__fields?.newTab === true && this.__fields?.linkType === 'custom') {\n      element.rel = manageRel(element.rel, 'add', 'noopener')\n    }\n\n    addClassNamesToElement(element, config.theme.link)\n    return element\n  }\n\n  override exportJSON(): SerializedLinkNode {\n    const fields = this.getFields()\n\n    if (fields?.linkType === 'internal') {\n      delete fields.url\n    } else if (fields?.linkType === 'custom') {\n      delete fields.doc\n    }\n\n    const returnObject: SerializedLinkNode = {\n      ...super.exportJSON(),\n      type: 'link',\n      fields,\n      version: 3,\n    }\n    const id = this.getID()\n    if (id) {\n      returnObject.id = id\n    }\n    return returnObject\n  }\n\n  override extractWithChild(\n    child: LexicalNode,\n    selection: BaseSelection,\n    destination: 'clone' | 'html',\n  ): boolean {\n    if (!$isRangeSelection(selection)) {\n      return false\n    }\n\n    const anchorNode = selection.anchor.getNode()\n    const focusNode = selection.focus.getNode()\n\n    return (\n      this.isParentOf(anchorNode) &&\n      this.isParentOf(focusNode) &&\n      selection.getTextContent().length > 0\n    )\n  }\n\n  getFields(): LinkFields {\n    return this.getLatest().__fields\n  }\n\n  getID(): string {\n    return this.getLatest().__id\n  }\n\n  override insertNewAfter(\n    selection: RangeSelection,\n    restoreSelection = true,\n  ): ElementNodeType | null {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection)\n    if ($isElementNode(element)) {\n      const linkNode = $createLinkNode({ fields: this.__fields })\n      element.append(linkNode)\n      return linkNode\n    }\n    return null\n  }\n\n  override isInline(): true {\n    return true\n  }\n\n  sanitizeUrl(url: string): string {\n    try {\n      const parsedUrl = new URL(url)\n\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank'\n      }\n    } catch (e) {\n      return 'https://'\n    }\n    return url\n  }\n\n  setFields(fields: LinkFields): void {\n    const writable = this.getWritable()\n    writable.__fields = fields\n  }\n\n  override updateDOM(prevNode: LinkNode, anchor: HTMLAnchorElement, config: EditorConfig): boolean {\n    const url = this.__fields?.url\n    const newTab = this.__fields?.newTab\n    if (url != null && url !== prevNode.__fields?.url && this.__fields?.linkType === 'custom') {\n      anchor.href = url\n    }\n    if (this.__fields?.linkType === 'internal' && prevNode.__fields?.linkType === 'custom') {\n      anchor.removeAttribute('href')\n    }\n\n    // TODO: not 100% sure why we're settign rel to '' - revisit\n    // Start rel config here, then check newTab below\n    if (anchor.rel == null) {\n      anchor.rel = ''\n    }\n\n    if (newTab !== prevNode.__fields?.newTab) {\n      if (newTab ?? false) {\n        anchor.target = '_blank'\n        if (this.__fields?.linkType === 'custom') {\n          anchor.rel = manageRel(anchor.rel, 'add', 'noopener')\n        }\n      } else {\n        anchor.removeAttribute('target')\n        anchor.rel = manageRel(anchor.rel, 'remove', 'noopener')\n      }\n    }\n\n    return false\n  }\n}\n\nfunction $convertAnchorElement(domNode: Node): DOMConversionOutput {\n  let node: LinkNode | null = null\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent\n    if (content !== null && content !== '') {\n      node = $createLinkNode({\n        id: new ObjectID.default().toHexString(),\n        fields: {\n          doc: null,\n          linkType: 'custom',\n          newTab: domNode.getAttribute('target') === '_blank',\n          url: domNode.getAttribute('href') ?? '',\n        },\n      })\n    }\n  }\n  return { node }\n}\n\nexport function $createLinkNode({ id, fields }: { fields: LinkFields; id?: string }): LinkNode {\n  return $applyNodeReplacement(\n    new LinkNode({\n      id: id ?? new ObjectID.default().toHexString(),\n      fields,\n    }),\n  )\n}\n\nexport function $isLinkNode(node: LexicalNode | null | undefined): node is LinkNode {\n  return node instanceof LinkNode\n}\n\nexport const TOGGLE_LINK_COMMAND: LexicalCommand<LinkPayload | null> =\n  createCommand('TOGGLE_LINK_COMMAND')\n\nexport function $toggleLink(payload: ({ fields: LinkFields } & LinkPayload) | null): void {\n  const selection = $getSelection()\n\n  if (!$isRangeSelection(selection) && (payload === null || !payload.selectedNodes?.length)) {\n    return\n  }\n  const nodes = $isRangeSelection(selection)\n    ? selection.extract()\n    : payload === null\n      ? []\n      : payload.selectedNodes\n\n  if (payload === null) {\n    // Remove LinkNodes\n    nodes?.forEach((node) => {\n      const parent = node.getParent()\n\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren()\n\n        children.forEach((child) => {\n          parent.insertBefore(child)\n        })\n\n        parent.remove()\n      }\n    })\n\n    return\n  }\n  // Add or merge LinkNodes\n  if (nodes?.length === 1) {\n    const firstNode = nodes[0]!\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode: LinkNode | null = $isLinkNode(firstNode)\n      ? firstNode\n      : $getLinkAncestor(firstNode)\n    if (linkNode !== null) {\n      linkNode.setFields(payload.fields)\n\n      if (payload.text != null && payload.text !== linkNode.getTextContent()) {\n        // remove all children and add child with new textcontent:\n        linkNode.append($createTextNode(payload.text))\n        linkNode.getChildren().forEach((child) => {\n          if (child !== linkNode.getLastChild()) {\n            child.remove()\n          }\n        })\n      }\n      return\n    }\n  }\n\n  let prevParent: ElementNodeType | LinkNode | null = null\n  let linkNode: LinkNode | null = null\n\n  nodes?.forEach((node) => {\n    const parent = node.getParent()\n\n    if (parent === linkNode || parent === null || ($isElementNode(node) && !node.isInline())) {\n      return\n    }\n\n    if ($isLinkNode(parent)) {\n      linkNode = parent\n      parent.setFields(payload.fields)\n      if (payload.text != null && payload.text !== parent.getTextContent()) {\n        // remove all children and add child with new textcontent:\n        parent.append($createTextNode(payload.text))\n        parent.getChildren().forEach((child) => {\n          if (child !== parent.getLastChild()) {\n            child.remove()\n          }\n        })\n      }\n      return\n    }\n\n    if (!parent.is(prevParent)) {\n      prevParent = parent\n      linkNode = $createLinkNode({ fields: payload.fields })\n\n      if ($isLinkNode(parent)) {\n        if (node.getPreviousSibling() === null) {\n          parent.insertBefore(linkNode)\n        } else {\n          parent.insertAfter(linkNode)\n        }\n      } else {\n        node.insertBefore(linkNode)\n      }\n    }\n\n    if ($isLinkNode(node)) {\n      if (node.is(linkNode)) {\n        return\n      }\n      if (linkNode !== null) {\n        const children = node.getChildren()\n        linkNode.append(...children)\n      }\n\n      node.remove()\n      return\n    }\n\n    if (linkNode !== null) {\n      linkNode.append(node)\n    }\n  })\n}\n\nfunction $getLinkAncestor(node: LexicalNode): LinkNode | null {\n  return $getAncestor(node, (ancestor) => $isLinkNode(ancestor)) as LinkNode\n}\n\nfunction $getAncestor(\n  node: LexicalNode,\n  predicate: (ancestor: LexicalNode) => boolean,\n): LexicalNode | null {\n  let parent: LexicalNode | null = node\n  while (parent !== null) {\n    parent = parent.getParent()\n    if (parent === null || predicate(parent)) {\n      break\n    }\n  }\n  return parent\n}\n\nfunction manageRel(input: string, action: 'add' | 'remove', value: string): string {\n  let result: string\n  let mutableInput = `${input}`\n  if (action === 'add') {\n    // if we somehow got out of sync - clean up\n    if (mutableInput.includes(value)) {\n      const re = new RegExp(value, 'g')\n      mutableInput = mutableInput.replace(re, '').trim()\n    }\n    mutableInput = mutableInput.trim()\n    result = mutableInput.length === 0 ? `${value}` : `${mutableInput} ${value}`\n  } else {\n    const re = new RegExp(value, 'g')\n    result = mutableInput.replace(re, '').trim()\n  }\n  return result\n}\n"],"names":["addClassNamesToElement","isHTMLAnchorElement","ObjectID","$applyNodeReplacement","$createTextNode","$getSelection","$isElementNode","$isRangeSelection","createCommand","ElementNode","SUPPORTED_URL_PROTOCOLS","Set","LinkNode","__fields","__id","constructor","id","fields","linkType","newTab","key","clone","node","__key","getType","importDOM","a","conversion","$convertAnchorElement","priority","importJSON","serializedNode","version","doc","value","default","toHexString","$createLinkNode","setFormat","format","setIndent","indent","setDirection","direction","canBeEmpty","canInsertTextAfter","canInsertTextBefore","createDOM","config","element","document","createElement","href","sanitizeUrl","url","target","rel","manageRel","theme","link","exportJSON","getFields","returnObject","type","getID","extractWithChild","child","selection","destination","anchorNode","anchor","getNode","focusNode","focus","isParentOf","getTextContent","length","getLatest","insertNewAfter","restoreSelection","getParentOrThrow","linkNode","append","isInline","parsedUrl","URL","has","protocol","e","setFields","writable","getWritable","updateDOM","prevNode","removeAttribute","domNode","content","textContent","getAttribute","$isLinkNode","TOGGLE_LINK_COMMAND","$toggleLink","payload","selectedNodes","nodes","extract","forEach","parent","getParent","children","getChildren","insertBefore","remove","firstNode","$getLinkAncestor","text","getLastChild","prevParent","is","getPreviousSibling","insertAfter","$getAncestor","ancestor","predicate","input","action","result","mutableInput","includes","re","RegExp","replace","trim"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2771, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2777, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/link/markdownTransformer.ts"],"sourcesContent":["/**\n * Code taken from https://github.com/facebook/lexical/blob/main/packages/lexical-markdown/src/MarkdownTransformers.ts#L357\n */\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n\nimport { $createTextNode, $isTextNode } from 'lexical'\n\nimport type { TextMatchTransformer } from '../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { $createLinkNode, $isLinkNode, LinkNode } from './nodes/LinkNode.js'\n\n// - then longer tags match (e.g. ** or __ should go before * or _)\nexport const LinkMarkdownTransformer: TextMatchTransformer = {\n  type: 'text-match',\n  dependencies: [LinkNode],\n  export: (_node, exportChildren) => {\n    if (!$isLinkNode(_node)) {\n      return null\n    }\n    const node: LinkNode = _node\n    const { url } = node.getFields()\n\n    const textContent = exportChildren(node)\n\n    const linkContent = `[${textContent}](${url})`\n\n    return linkContent\n  },\n  importRegExp: /\\[([^[]+)\\]\\(([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?\\)/,\n  regExp: /\\[([^[]+)\\]\\(([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?\\)$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl] = match\n    const linkNode = $createLinkNode({\n      fields: {\n        doc: null,\n        linkType: 'custom',\n        newTab: false,\n        url: linkUrl,\n      },\n    })\n    const linkTextNode = $createTextNode(linkText)\n    linkTextNode.setFormat(textNode.getFormat())\n    linkNode.append(linkTextNode)\n    textNode.replace(linkNode)\n\n    return linkTextNode\n  },\n  trigger: ')',\n}\n"],"names":["$createTextNode","$createLinkNode","$isLinkNode","LinkNode","LinkMarkdownTransformer","type","dependencies","export","_node","exportChildren","node","url","getFields","textContent","linkContent","importRegExp","regExp","replace","textNode","match","linkText","linkUrl","linkNode","fields","doc","linkType","newTab","linkTextNode","setFormat","getFormat","append","trigger"],"mappings":"AAAA;;GAAA,CAIA,sCAAA;AACA,EAAA;AACA,mEAAA;;;;AAMA,SAASC,eAAe,EAAEC,WAAW,EAAEC,QAAQ,QAAQ;AAJvD,SAASH,eAAe,QAAqB;;;AAOtC,MAAMI,uBAAA,GAAgD;IAC3DC,IAAA,EAAM;IACNC,YAAA,EAAc;2TAACH,WAAA;KAAS;IACxBI,MAAA,EAAQA,CAACC,KAAA,EAAOC,cAAA;QACd,IAAI,wTAACP,cAAAA,AAAA,EAAYM,KAAA,GAAQ;YACvB,OAAO;QACT;QACA,MAAME,IAAA,GAAiBF,KAAA;QACvB,MAAM,EAAEG,GAAAA,EAAK,GAAGD,IAAA,CAAKE,SAAS;QAE9B,MAAMC,WAAA,GAAcJ,cAAA,CAAeC,IAAA;QAEnC,MAAMI,WAAA,GAAc,CAAA,CAAA,EAAID,WAAA,CAAA,EAAA,EAAgBF,GAAA,CAAA,CAAA,CAAM;QAE9C,OAAOG,WAAA;IACT;IACAC,YAAA,EAAc;IACdC,MAAA,EAAQ;IACRC,OAAA,EAASA,CAACC,QAAA,EAAUC,KAAA;QAClB,MAAM,GAAGC,QAAA,EAAUC,OAAA,CAAQ,GAAGF,KAAA;QAC9B,MAAMG,QAAA,0TAAWrB,kBAAAA,AAAA,EAAgB;YAC/BsB,MAAA,EAAQ;gBACNC,GAAA,EAAK;gBACLC,QAAA,EAAU;gBACVC,MAAA,EAAQ;gBACRf,GAAA,EAAKU;YACP;QACF;QACA,MAAMM,YAAA,yMAAe3B,kBAAAA,AAAA,EAAgBoB,QAAA;QACrCO,YAAA,CAAaC,SAAS,CAACV,QAAA,CAASW,SAAS;QACzCP,QAAA,CAASQ,MAAM,CAACH,YAAA;QAChBT,QAAA,CAASD,OAAO,CAACK,QAAA;QAEjB,OAAOK,YAAA;IACT;IACAI,OAAA,EAAS;AACX","ignoreList":[0]}},
    {"offset": {"line": 2824, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2830, "column": 0}, "map": {"version":3,"file":"AutoLinkNode.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/link/nodes/AutoLinkNode.ts"],"sourcesContent":["import type { ElementNode, LexicalNode, RangeSelection } from 'lexical'\n\nimport { $applyNodeReplacement, $isElementNode } from 'lexical'\n\nimport type { LinkFields, SerializedAutoLinkNode } from './types.js'\n\nimport { LinkNode } from './LinkNode.js'\n\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\n\nexport class AutoLinkNode extends LinkNode {\n  static override clone(node: AutoLinkNode): AutoLinkNode {\n    return new AutoLinkNode({ id: '', fields: node.__fields, key: node.__key })\n  }\n\n  static override getType(): string {\n    return 'autolink'\n  }\n\n  static override importDOM(): null {\n    // TODO: Should link node should handle the import over autolink?\n    return null\n  }\n\n  static override importJSON(serializedNode: SerializedAutoLinkNode): AutoLinkNode {\n    if (\n      serializedNode.version === 1 &&\n      typeof serializedNode.fields?.doc?.value === 'object' &&\n      serializedNode.fields?.doc?.value?.id\n    ) {\n      serializedNode.fields.doc.value = serializedNode.fields.doc.value.id\n      serializedNode.version = 2\n    }\n\n    const node = $createAutoLinkNode({ fields: serializedNode.fields })\n\n    node.setFormat(serializedNode.format)\n    node.setIndent(serializedNode.indent)\n    node.setDirection(serializedNode.direction)\n    return node\n  }\n\n  // @ts-expect-error\n  exportJSON(): SerializedAutoLinkNode {\n    const serialized = super.exportJSON()\n    return {\n      type: 'autolink',\n      children: serialized.children,\n      direction: serialized.direction,\n      fields: serialized.fields,\n      format: serialized.format,\n      indent: serialized.indent,\n      version: 2,\n    }\n  }\n\n  override insertNewAfter(selection: RangeSelection, restoreSelection = true): ElementNode | null {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection)\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode({ fields: this.__fields })\n      element.append(linkNode)\n      return linkNode\n    }\n    return null\n  }\n}\n\nexport function $createAutoLinkNode({ fields }: { fields: LinkFields }): AutoLinkNode {\n  return $applyNodeReplacement(new AutoLinkNode({ id: '', fields }))\n}\nexport function $isAutoLinkNode(node: LexicalNode | null | undefined): node is AutoLinkNode {\n  return node instanceof AutoLinkNode\n}\n"],"names":["$applyNodeReplacement","$isElementNode","LinkNode","AutoLinkNode","clone","node","id","fields","__fields","key","__key","getType","importDOM","importJSON","serializedNode","version","doc","value","$createAutoLinkNode","setFormat","format","setIndent","indent","setDirection","direction","exportJSON","serialized","type","children","insertNewAfter","selection","restoreSelection","element","getParentOrThrow","linkNode","append","$isAutoLinkNode"],"mappings":";;;;;AAEA,SAASA,qBAAqB,EAAEC,cAAc,QAAQ;AAItD,SAASC,QAAQ,QAAQ;;;AAKlB,MAAMC,YAAA,4TAAqBD,WAAA;IAChC,OAAgBE,MAAMC,IAAkB,EAAgB;QACtD,OAAO,IAAIF,YAAA,CAAa;YAAEG,EAAA,EAAI;YAAIC,MAAA,EAAQF,IAAA,CAAKG,QAAQ;YAAEC,GAAA,EAAKJ,IAAA,CAAKK,KAAAA;QAAM;IAC3E;IAEA,OAAgBC,QAAA,EAAkB;QAChC,OAAO;IACT;IAEA,OAAgBC,UAAA,EAAkB;QAChC,iEAAA;QACA,OAAO;IACT;IAEA,OAAgBC,WAAWC,cAAsC,EAAgB;QAC/E,IACEA,cAAA,CAAeC,OAAO,KAAK,KAC3B,OAAOD,cAAA,CAAeP,MAAM,EAAES,GAAA,EAAKC,KAAA,KAAU,YAC7CH,cAAA,CAAeP,MAAM,EAAES,GAAA,EAAKC,KAAA,EAAOX,EAAA,EACnC;YACAQ,cAAA,CAAeP,MAAM,CAACS,GAAG,CAACC,KAAK,GAAGH,cAAA,CAAeP,MAAM,CAACS,GAAG,CAACC,KAAK,CAACX,EAAE;YACpEQ,cAAA,CAAeC,OAAO,GAAG;QAC3B;QAEA,MAAMV,IAAA,GAAOa,mBAAA,CAAoB;YAAEX,MAAA,EAAQO,cAAA,CAAeP,MAAAA;QAAO;QAEjEF,IAAA,CAAKc,SAAS,CAACL,cAAA,CAAeM,MAAM;QACpCf,IAAA,CAAKgB,SAAS,CAACP,cAAA,CAAeQ,MAAM;QACpCjB,IAAA,CAAKkB,YAAY,CAACT,cAAA,CAAeU,SAAS;QAC1C,OAAOnB,IAAA;IACT;IAEA,mBAAA;IACAoB,WAAA,EAAqC;QACnC,MAAMC,UAAA,GAAa,KAAK,CAACD,UAAA;QACzB,OAAO;YACLE,IAAA,EAAM;YACNC,QAAA,EAAUF,UAAA,CAAWE,QAAQ;YAC7BJ,SAAA,EAAWE,UAAA,CAAWF,SAAS;YAC/BjB,MAAA,EAAQmB,UAAA,CAAWnB,MAAM;YACzBa,MAAA,EAAQM,UAAA,CAAWN,MAAM;YACzBE,MAAA,EAAQI,UAAA,CAAWJ,MAAM;YACzBP,OAAA,EAAS;QACX;IACF;IAESc,eAAeC,SAAyB,EAAEC,gBAAA,GAAmB,IAAI,EAAsB;QAC9F,MAAMC,OAAA,GAAU,IAAI,CAACC,gBAAgB,GAAGJ,cAAc,CAACC,SAAA,EAAWC,gBAAA;QAClE,0MAAI9B,iBAAAA,AAAA,EAAe+B,OAAA,GAAU;YAC3B,MAAME,QAAA,GAAWhB,mBAAA,CAAoB;gBAAEX,MAAA,EAAQ,IAAI,CAACC,QAAAA;YAAS;YAC7DwB,OAAA,CAAQG,MAAM,CAACD,QAAA;YACf,OAAOA,QAAA;QACT;QACA,OAAO;IACT;AACF;AAEO,SAAShB,oBAAoB,EAAEX,MAAAA,EAAgC;IACpE,6MAAOP,wBAAAA,AAAA,EAAsB,IAAIG,YAAA,CAAa;QAAEG,EAAA,EAAI;QAAIC;IAAO;AACjE;AACO,SAAS6B,gBAAgB/B,IAAoC;IAClE,OAAOA,IAAA,YAAgBF,YAAA;AACzB","ignoreList":[0]}},
    {"offset": {"line": 2901, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2907, "column": 0}, "map": {"version":3,"file":"validate.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/validate.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nimport { fieldSchemasToFormState } from '@payloadcms/ui/forms/fieldSchemasToFormState'\n\nimport type { NodeValidation } from '../../typesServer.js'\nimport type { SerializedAutoLinkNode, SerializedLinkNode } from '../nodes/types.js'\nimport type { LinkFeatureServerProps } from './index.js'\n\nexport const linkValidation = (\n  props: LinkFeatureServerProps,\n  sanitizedFieldsWithoutText: Field[],\n): NodeValidation<SerializedAutoLinkNode | SerializedLinkNode> => {\n  return async ({\n    node,\n    validation: {\n      options: { id, collectionSlug, data, operation, preferences, req },\n    },\n  }) => {\n    /**\n     * Run fieldSchemasToFormState as that properly validates link fields and link sub-fields\n     */\n\n    const result = await fieldSchemasToFormState({\n      id,\n      collectionSlug,\n      data: node.fields,\n      documentData: data,\n      fields: sanitizedFieldsWithoutText, // Sanitized in feature.server.ts\n      fieldSchemaMap: undefined,\n      initialBlockData: node.fields,\n      operation: operation === 'create' || operation === 'update' ? operation : 'update',\n      permissions: {},\n      preferences,\n      renderAllFields: false,\n      req,\n      schemaPath: '',\n    })\n\n    const errorPathsSet = new Set<string>()\n    for (const fieldKey in result) {\n      if (result[fieldKey].errorPaths?.length) {\n        for (const errorPath of result[fieldKey].errorPaths) {\n          errorPathsSet.add(errorPath)\n        }\n      }\n    }\n    const errorPaths = Array.from(errorPathsSet)\n\n    if (errorPaths.length) {\n      return 'The following fields are invalid: ' + errorPaths.join(', ')\n    }\n\n    return true\n  }\n}\n"],"names":["fieldSchemasToFormState","linkValidation","props","sanitizedFieldsWithoutText","node","validation","options","id","collectionSlug","data","operation","preferences","req","result","fields","documentData","fieldSchemaMap","undefined","initialBlockData","permissions","renderAllFields","schemaPath","errorPathsSet","Set","fieldKey","errorPaths","length","errorPath","add","Array","from","join"],"mappings":";;;AAEA,SAASA,uBAAuB,QAAQ;;AAMjC,MAAMC,cAAA,GAAiBA,CAC5BC,KAAA,EACAC,0BAAA;IAEA,OAAO,OAAO,EACZC,IAAI,EACJC,UAAA,EAAY,EACVC,OAAA,EAAS,EAAEC,EAAE,EAAEC,cAAc,EAAEC,IAAI,EAAEC,SAAS,EAAEC,WAAW,EAAEC,GAAAA,EAAG,EAAE,EAErE;QACC;;OAIA,MAAMC,MAAA,GAAS,uaAAMb,0BAAAA,AAAA,EAAwB;YAC3CO,EAAA;YACAC,cAAA;YACAC,IAAA,EAAML,IAAA,CAAKU,MAAM;YACjBC,YAAA,EAAcN,IAAA;YACdK,MAAA,EAAQX,0BAAA;YACRa,cAAA,EAAgBC,SAAA;YAChBC,gBAAA,EAAkBd,IAAA,CAAKU,MAAM;YAC7BJ,SAAA,EAAWA,SAAA,KAAc,YAAYA,SAAA,KAAc,WAAWA,SAAA,GAAY;YAC1ES,WAAA,EAAa,CAAC;YACdR,WAAA;YACAS,eAAA,EAAiB;YACjBR,GAAA;YACAS,UAAA,EAAY;QACd;QAEA,MAAMC,aAAA,GAAgB,IAAIC,GAAA;QAC1B,IAAK,MAAMC,QAAA,IAAYX,MAAA,CAAQ;YAC7B,IAAIA,MAAM,CAACW,QAAA,CAAS,CAACC,UAAU,EAAEC,MAAA,EAAQ;gBACvC,KAAK,MAAMC,SAAA,IAAad,MAAM,CAACW,QAAA,CAAS,CAACC,UAAU,CAAE;oBACnDH,aAAA,CAAcM,GAAG,CAACD,SAAA;gBACpB;YACF;QACF;QACA,MAAMF,UAAA,GAAaI,KAAA,CAAMC,IAAI,CAACR,aAAA;QAE9B,IAAIG,UAAA,CAAWC,MAAM,EAAE;YACrB,OAAO,uCAAuCD,UAAA,CAAWM,IAAI,CAAC;QAChE;QAEA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2946, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2952, "column": 0}, "map": {"version":3,"file":"recursivelyPopulateFieldsForGraphQL.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/populateGraphQL/recursivelyPopulateFieldsForGraphQL.ts"],"sourcesContent":["import type { Field, JsonObject, PayloadRequest, RequestContext } from 'payload'\n\nimport { afterReadTraverseFields } from 'payload'\n\nimport type { PopulationPromise } from '../features/typesServer.js'\n\ntype NestedRichTextFieldsArgs = {\n  context: RequestContext\n  currentDepth?: number\n  data: unknown\n  depth: number\n  draft: boolean\n  /**\n   * This maps all the population promises to the node types\n   */\n  editorPopulationPromises: Map<string, Array<PopulationPromise>>\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  fields: Field[]\n  findMany: boolean\n  flattenLocales: boolean\n  overrideAccess: boolean\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n}\n\nexport const recursivelyPopulateFieldsForGraphQL = ({\n  context,\n  currentDepth = 0,\n  data,\n  depth,\n  draft,\n  fieldPromises,\n  fields,\n  findMany,\n  flattenLocales,\n  overrideAccess = false,\n  populationPromises,\n  req,\n  showHiddenFields,\n  siblingDoc,\n}: NestedRichTextFieldsArgs): void => {\n  afterReadTraverseFields({\n    collection: null, // Pass from core? This is only needed for hooks, so we can leave this null for now\n    context,\n    currentDepth,\n    depth,\n    doc: data as any, // Looks like it's only needed for hooks and access control, so doesn't matter what we pass here right now\n    draft,\n    fallbackLocale: req.fallbackLocale!,\n    fieldPromises,\n    fields,\n    findMany,\n    flattenLocales,\n    global: null, // Pass from core? This is only needed for hooks, so we can leave this null for now\n    locale: req.locale!,\n    overrideAccess,\n    parentIndexPath: '',\n    parentPath: '',\n    parentSchemaPath: '',\n    populationPromises, // This is not the same as populationPromises passed into this recurseNestedFields. These are just promises resolved at the very end.\n    req,\n    showHiddenFields,\n    siblingDoc,\n    triggerHooks: false,\n  })\n}\n"],"names":["afterReadTraverseFields","recursivelyPopulateFieldsForGraphQL","context","currentDepth","data","depth","draft","fieldPromises","fields","findMany","flattenLocales","overrideAccess","populationPromises","req","showHiddenFields","siblingDoc","collection","doc","fallbackLocale","global","locale","parentIndexPath","parentPath","parentSchemaPath","triggerHooks"],"mappings":";;;AAEA,SAASA,uBAAuB,QAAQ;;AA4BjC,MAAMC,mCAAA,GAAsCA,CAAC,EAClDC,OAAO,EACPC,YAAA,GAAe,CAAC,EAChBC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,aAAa,EACbC,MAAM,EACNC,QAAQ,EACRC,cAAc,EACdC,cAAA,GAAiB,KAAK,EACtBC,kBAAkB,EAClBC,GAAG,EACHC,gBAAgB,EAChBC,UAAAA,EACyB;+cACzBf,0BAAAA,AAAA,EAAwB;QACtBgB,UAAA,EAAY;QACZd,OAAA;QACAC,YAAA;QACAE,KAAA;QACAY,GAAA,EAAKb,IAAA;QACLE,KAAA;QACAY,cAAA,EAAgBL,GAAA,CAAIK,cAAc;QAClCX,aAAA;QACAC,MAAA;QACAC,QAAA;QACAC,cAAA;QACAS,MAAA,EAAQ;QACRC,MAAA,EAAQP,GAAA,CAAIO,MAAM;QAClBT,cAAA;QACAU,eAAA,EAAiB;QACjBC,UAAA,EAAY;QACZC,gBAAA,EAAkB;QAClBX,kBAAA;QACAC,GAAA;QACAC,gBAAA;QACAC,UAAA;QACAS,YAAA,EAAc;IAChB;AACF","ignoreList":[0]}},
    {"offset": {"line": 2983, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2989, "column": 0}, "map": {"version":3,"file":"graphQLPopulationPromise.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/graphQLPopulationPromise.ts"],"sourcesContent":["import type { PopulationPromise } from '../../typesServer.js'\nimport type { SerializedLinkNode } from '../nodes/types.js'\nimport type { LinkFeatureServerProps } from './index.js'\n\nimport { recursivelyPopulateFieldsForGraphQL } from '../../../populateGraphQL/recursivelyPopulateFieldsForGraphQL.js'\n\nexport const linkPopulationPromiseHOC = (\n  props: LinkFeatureServerProps,\n): PopulationPromise<SerializedLinkNode> => {\n  return ({\n    context,\n    currentDepth,\n    depth,\n    draft,\n    editorPopulationPromises,\n    fieldPromises,\n    findMany,\n    flattenLocales,\n    node,\n    overrideAccess,\n    populationPromises,\n    req,\n    showHiddenFields,\n  }) => {\n    if (!props.fields?.length) {\n      return\n    }\n\n    /**\n     * Should populate all fields, including the doc field (for internal links), as it's treated like a normal field\n     */\n    if (Array.isArray(props.fields)) {\n      recursivelyPopulateFieldsForGraphQL({\n        context,\n        currentDepth,\n        data: node.fields,\n        depth,\n        draft,\n        editorPopulationPromises,\n        fieldPromises,\n        fields: props.fields,\n        findMany,\n        flattenLocales,\n        overrideAccess,\n        populationPromises,\n        req,\n        showHiddenFields,\n        siblingDoc: node.fields,\n      })\n    }\n  }\n}\n"],"names":["recursivelyPopulateFieldsForGraphQL","linkPopulationPromiseHOC","props","context","currentDepth","depth","draft","editorPopulationPromises","fieldPromises","findMany","flattenLocales","node","overrideAccess","populationPromises","req","showHiddenFields","fields","length","Array","isArray","data","siblingDoc"],"mappings":";;;AAIA,SAASA,mCAAmC,QAAQ;;AAE7C,MAAMC,wBAAA,IACXC,KAAA;IAEA,OAAO,CAAC,EACNC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,wBAAwB,EACxBC,aAAa,EACbC,QAAQ,EACRC,cAAc,EACdC,IAAI,EACJC,cAAc,EACdC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;QACC,IAAI,CAACb,KAAA,CAAMc,MAAM,EAAEC,MAAA,EAAQ;YACzB;QACF;QAEA;;OAGA,IAAIC,KAAA,CAAMC,OAAO,CAACjB,KAAA,CAAMc,MAAM,GAAG;oVAC/BhB,sCAAAA,AAAA,EAAoC;gBAClCG,OAAA;gBACAC,YAAA;gBACAgB,IAAA,EAAMT,IAAA,CAAKK,MAAM;gBACjBX,KAAA;gBACAC,KAAA;gBACAC,wBAAA;gBACAC,aAAA;gBACAQ,MAAA,EAAQd,KAAA,CAAMc,MAAM;gBACpBP,QAAA;gBACAC,cAAA;gBACAE,cAAA;gBACAC,kBAAA;gBACAC,GAAA;gBACAC,gBAAA;gBACAM,UAAA,EAAYV,IAAA,CAAKK,MAAAA;YACnB;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3022, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3028, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/index.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  Config,\n  Field,\n  FieldAffectingData,\n  FieldSchemaMap,\n  SanitizedConfig,\n} from 'payload'\n\nimport escapeHTML from 'escape-html'\nimport { sanitizeFields } from 'payload'\n\nimport type { ClientProps } from '../client/index.js'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { convertLexicalNodesToHTML } from '../../converters/html/converter/index.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { LinkMarkdownTransformer } from '../markdownTransformer.js'\nimport { AutoLinkNode } from '../nodes/AutoLinkNode.js'\nimport { LinkNode } from '../nodes/LinkNode.js'\nimport { linkPopulationPromiseHOC } from './graphQLPopulationPromise.js'\nimport { i18n } from './i18n.js'\nimport { transformExtraFields } from './transformExtraFields.js'\nimport { linkValidation } from './validate.js'\n\nexport type ExclusiveLinkCollectionsProps =\n  | {\n      /**\n       * The collections that should be disabled for internal linking. Overrides the `enableRichTextLink` property in the collection config.\n       * When this property is set, `enabledCollections` will not be available.\n       **/\n      disabledCollections?: CollectionSlug[]\n\n      // Ensures that enabledCollections is not available when disabledCollections is set\n      enabledCollections?: never\n    }\n  | {\n      // Ensures that disabledCollections is not available when enabledCollections is set\n      disabledCollections?: never\n\n      /**\n       * The collections that should be enabled for internal linking. Overrides the `enableRichTextLink` property in the collection config\n       * When this property is set, `disabledCollections` will not be available.\n       **/\n      enabledCollections?: CollectionSlug[]\n    }\n\nexport type LinkFeatureServerProps = {\n  /**\n   * A function or array defining additional fields for the link feature. These will be\n   * displayed in the link editor drawer.\n   */\n  fields?:\n    | ((args: {\n        config: SanitizedConfig\n        defaultFields: FieldAffectingData[]\n      }) => (Field | FieldAffectingData)[])\n    | Field[]\n  /**\n   * Sets a maximum population depth for the internal doc default field of link, regardless of the remaining depth when the field is reached.\n   * This behaves exactly like the maxDepth properties of relationship and upload fields.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n} & ExclusiveLinkCollectionsProps\n\nexport const LinkFeature = createServerFeature<\n  LinkFeatureServerProps,\n  LinkFeatureServerProps,\n  ClientProps\n>({\n  feature: async ({ config: _config, isRoot, parentIsLocalized, props }) => {\n    if (!props) {\n      props = {}\n    }\n    const validRelationships = _config.collections.map((c) => c.slug) || []\n\n    const _transformedFields = transformExtraFields(\n      props.fields ? props.fields : null,\n      _config,\n      props.enabledCollections,\n      props.disabledCollections,\n      props.maxDepth,\n    )\n\n    const sanitizedFields = await sanitizeFields({\n      config: _config as unknown as Config,\n      fields: _transformedFields,\n      parentIsLocalized,\n      requireFieldLevelRichTextEditor: isRoot,\n      validRelationships,\n    })\n    props.fields = sanitizedFields\n\n    // the text field is not included in the node data.\n    // Thus, for tasks like validation, we do not want to pass it a text field in the schema which will never have data.\n    // Otherwise, it will cause a validation error (field is required).\n    const sanitizedFieldsWithoutText = sanitizedFields.filter(\n      (field) => !('name' in field) || field.name !== 'text',\n    )\n\n    let linkTypeField: Field | null = null\n    let linkURLField: Field | null = null\n\n    for (const field of sanitizedFields) {\n      if ('name' in field && field.name === 'linkType') {\n        linkTypeField = field\n      }\n\n      if ('name' in field && field.name === 'url') {\n        linkURLField = field\n      }\n    }\n\n    const defaultLinkType = linkTypeField\n      ? 'defaultValue' in linkTypeField && typeof linkTypeField.defaultValue === 'string'\n        ? linkTypeField.defaultValue\n        : 'custom'\n      : undefined\n\n    const defaultLinkURL = linkURLField\n      ? 'defaultValue' in linkURLField && typeof linkURLField.defaultValue === 'string'\n        ? linkURLField.defaultValue\n        : 'https://'\n      : undefined\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#LinkFeatureClient',\n      clientFeatureProps: {\n        defaultLinkType,\n        defaultLinkURL,\n        disabledCollections: props.disabledCollections,\n        enabledCollections: props.enabledCollections,\n      } as ClientProps,\n      generateSchemaMap: () => {\n        if (!sanitizedFields || !Array.isArray(sanitizedFields) || sanitizedFields.length === 0) {\n          return null\n        }\n\n        const schemaMap: FieldSchemaMap = new Map()\n        schemaMap.set('fields', {\n          fields: sanitizedFields,\n        })\n\n        return schemaMap\n      },\n      i18n,\n      markdownTransformers: [LinkMarkdownTransformer],\n      nodes: [\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n\n                const rel: string = node.fields.newTab ? ' rel=\"noopener noreferrer\"' : ''\n                const target: string = node.fields.newTab ? ' target=\"_blank\"' : ''\n\n                let href: string = node.fields.url ?? ''\n                if (node.fields.linkType === 'internal') {\n                  href =\n                    typeof node.fields.doc?.value !== 'object'\n                      ? String(node.fields.doc?.value)\n                      : String(node.fields.doc?.value?.id)\n                }\n\n                return `<a href=\"${href}\"${target}${rel}>${childrenText}</a>`\n              },\n              nodeTypes: [AutoLinkNode.getType()],\n            },\n          },\n          node: AutoLinkNode,\n          // Since AutoLinkNodes are just internal links, they need no hooks or graphQL population promises\n          validations: [linkValidation(props, sanitizedFieldsWithoutText)],\n        }),\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n\n                const rel: string = node.fields.newTab ? ' rel=\"noopener noreferrer\"' : ''\n                const target: string = node.fields.newTab ? ' target=\"_blank\"' : ''\n\n                const href: string =\n                  node.fields.linkType === 'custom'\n                    ? escapeHTML(node.fields.url)\n                    : (node.fields.doc?.value as string)\n\n                return `<a href=\"${href}\"${target}${rel}>${childrenText}</a>`\n              },\n              nodeTypes: [LinkNode.getType()],\n            },\n          },\n          getSubFields: () => {\n            return sanitizedFieldsWithoutText\n          },\n          getSubFieldsData: ({ node }) => {\n            return node?.fields\n          },\n          graphQLPopulationPromises: [linkPopulationPromiseHOC(props)],\n          node: LinkNode,\n          validations: [linkValidation(props, sanitizedFieldsWithoutText)],\n        }),\n      ],\n      sanitizedServerFeatureProps: props,\n    }\n  },\n  key: 'link',\n})\n"],"names":["escapeHTML","sanitizeFields","createServerFeature","convertLexicalNodesToHTML","createNode","LinkMarkdownTransformer","AutoLinkNode","LinkNode","linkPopulationPromiseHOC","i18n","transformExtraFields","linkValidation","LinkFeature","feature","config","_config","isRoot","parentIsLocalized","props","validRelationships","collections","map","c","slug","_transformedFields","fields","enabledCollections","disabledCollections","maxDepth","sanitizedFields","requireFieldLevelRichTextEditor","sanitizedFieldsWithoutText","filter","field","name","linkTypeField","linkURLField","defaultLinkType","defaultValue","undefined","defaultLinkURL","ClientFeature","clientFeatureProps","generateSchemaMap","Array","isArray","length","schemaMap","Map","set","markdownTransformers","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","rel","newTab","target","href","url","linkType","doc","value","String","id","nodeTypes","getType","validations","getSubFields","getSubFieldsData","graphQLPopulationPromises","sanitizedServerFeatureProps","key"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3194, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3200, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'العلاقة',\n  },\n  az: {\n    label: 'Münasibət',\n  },\n  bg: {\n    label: 'Връзка',\n  },\n  cs: {\n    label: 'Vztah',\n  },\n  da: {\n    label: 'Forhold',\n  },\n  de: {\n    label: 'Beziehung',\n  },\n  en: {\n    label: 'Relationship',\n  },\n  es: {\n    label: 'Relación',\n  },\n  et: {\n    label: 'Seos',\n  },\n  fa: {\n    label: 'روابط',\n  },\n  fr: {\n    label: 'Relation',\n  },\n  he: {\n    label: 'יחסים',\n  },\n  hr: {\n    label: 'Odnos',\n  },\n  hu: {\n    label: 'Kapcsolat',\n  },\n  it: {\n    label: 'Relazione',\n  },\n  ja: {\n    label: '関係性',\n  },\n  ko: {\n    label: '관계',\n  },\n  my: {\n    label: 'Hubungan',\n  },\n  nb: {\n    label: 'Forhold',\n  },\n  nl: {\n    label: 'Relatie',\n  },\n  pl: {\n    label: 'Relacja',\n  },\n  pt: {\n    label: 'Relacionamento',\n  },\n  ro: {\n    label: 'Relație',\n  },\n  rs: {\n    label: 'Релација',\n  },\n  'rs-latin': {\n    label: 'Relacija',\n  },\n  ru: {\n    label: 'Отношения',\n  },\n  sk: {\n    label: 'Vzťah',\n  },\n  sl: {\n    label: 'Odnos',\n  },\n  sv: {\n    label: 'Relation',\n  },\n  th: {\n    label: 'ความสัมพันธ์',\n  },\n  tr: {\n    label: 'İlişki',\n  },\n  uk: {\n    label: 'Стосунки',\n  },\n  vi: {\n    label: 'Mối quan hệ',\n  },\n  zh: {\n    label: '关系',\n  },\n  'zh-TW': {\n    label: '關係',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 3310, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3316, "column": 0}, "map": {"version":3,"file":"populate.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/populateGraphQL/populate.ts"],"sourcesContent":["import type { PayloadRequest, SelectType } from 'payload'\n\nimport { createDataloaderCacheKey } from 'payload'\n\ntype Arguments = {\n  currentDepth?: number\n  data: unknown\n  depth: number\n  draft: boolean\n  key: number | string\n  overrideAccess: boolean\n  req: PayloadRequest\n  select?: SelectType\n  showHiddenFields: boolean\n}\n\nexport const populate = async ({\n  id,\n  collectionSlug,\n  currentDepth,\n  data,\n  depth,\n  draft,\n  key,\n  overrideAccess,\n  req,\n  select,\n  showHiddenFields,\n}: {\n  collectionSlug: string\n  id: number | string\n} & Arguments): Promise<void> => {\n  const shouldPopulate = depth && currentDepth! <= depth\n  // usually depth is checked within recursivelyPopulateFieldsForGraphQL. But since this populate function can be called outside of that (in rest afterRead node hooks) we need to check here too\n  if (!shouldPopulate) {\n    return\n  }\n\n  const dataRef = data as Record<string, unknown>\n\n  const doc = await req.payloadDataLoader?.load(\n    createDataloaderCacheKey({\n      collectionSlug,\n      currentDepth: currentDepth! + 1,\n      depth,\n      docID: id as string,\n      draft,\n      fallbackLocale: req.fallbackLocale!,\n      locale: req.locale!,\n      overrideAccess,\n      select,\n      showHiddenFields,\n      transactionID: req.transactionID!,\n    }),\n  )\n\n  if (doc) {\n    dataRef[key] = doc\n  } else {\n    dataRef[key] = null\n  }\n}\n"],"names":["createDataloaderCacheKey","populate","id","collectionSlug","currentDepth","data","depth","draft","key","overrideAccess","req","select","showHiddenFields","shouldPopulate","dataRef","doc","payloadDataLoader","load","docID","fallbackLocale","locale","transactionID"],"mappings":";;;AAEA,SAASA,wBAAwB,QAAQ;;AAclC,MAAMC,QAAA,GAAW,MAAAA,CAAO,EAC7BC,EAAE,EACFC,cAAc,EACdC,YAAY,EACZC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,GAAG,EACHC,cAAc,EACdC,GAAG,EACHC,MAAM,EACNC,gBAAAA,EAIW;IACX,MAAMC,cAAA,GAAiBP,KAAA,IAASF,YAAA,IAAiBE,KAAA;IACjD,+LAAA;IACA,IAAI,CAACO,cAAA,EAAgB;QACnB;IACF;IAEA,MAAMC,OAAA,GAAUT,IAAA;IAEhB,MAAMU,GAAA,GAAM,MAAML,GAAA,CAAIM,iBAAiB,EAAEC,IAAA,EACvCjB,mZAAAA,AAAA,EAAyB;QACvBG,cAAA;QACAC,YAAA,EAAcA,YAAA,GAAgB;QAC9BE,KAAA;QACAY,KAAA,EAAOhB,EAAA;QACPK,KAAA;QACAY,cAAA,EAAgBT,GAAA,CAAIS,cAAc;QAClCC,MAAA,EAAQV,GAAA,CAAIU,MAAM;QAClBX,cAAA;QACAE,MAAA;QACAC,gBAAA;QACAS,aAAA,EAAeX,GAAA,CAAIW,aAAAA;IACrB;IAGF,IAAIN,GAAA,EAAK;QACPD,OAAO,CAACN,GAAA,CAAI,GAAGO,GAAA;IACjB,OAAO;QACLD,OAAO,CAACN,GAAA,CAAI,GAAG;IACjB;AACF","ignoreList":[0]}},
    {"offset": {"line": 3347, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3353, "column": 0}, "map": {"version":3,"file":"graphQLPopulationPromise.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/server/graphQLPopulationPromise.ts"],"sourcesContent":["import type { PopulationPromise } from '../../typesServer.js'\nimport type { RelationshipFeatureProps } from './index.js'\nimport type { SerializedRelationshipNode } from './nodes/RelationshipNode.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\n\nexport const relationshipPopulationPromiseHOC = (\n  props: RelationshipFeatureProps,\n): PopulationPromise<SerializedRelationshipNode> => {\n  const relationshipPopulationPromise: PopulationPromise<SerializedRelationshipNode> = ({\n    currentDepth,\n    depth,\n    draft,\n    node,\n    overrideAccess,\n    populationPromises,\n    req,\n    showHiddenFields,\n  }) => {\n    if (node?.value) {\n      // @ts-expect-error\n      const id = node?.value?.id || node?.value // for backwards-compatibility\n\n      const collection = req.payload.collections[node?.relationTo]\n\n      if (collection) {\n        const populateDepth =\n          props?.maxDepth !== undefined && props?.maxDepth < depth ? props?.maxDepth : depth\n\n        populationPromises.push(\n          populate({\n            id,\n            collectionSlug: collection.config.slug,\n            currentDepth,\n            data: node,\n            depth: populateDepth,\n            draft,\n            key: 'value',\n            overrideAccess,\n            req,\n            showHiddenFields,\n          }),\n        )\n      }\n    }\n  }\n\n  return relationshipPopulationPromise\n}\n"],"names":["populate","relationshipPopulationPromiseHOC","props","relationshipPopulationPromise","currentDepth","depth","draft","node","overrideAccess","populationPromises","req","showHiddenFields","value","id","collection","payload","collections","relationTo","populateDepth","maxDepth","undefined","push","collectionSlug","config","slug","data","key"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ;;AAElB,MAAMC,gCAAA,IACXC,KAAA;IAEA,MAAMC,6BAAA,GAA+EA,CAAC,EACpFC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;QACC,IAAIJ,IAAA,EAAMK,KAAA,EAAO;YACf,mBAAA;YACA,MAAMC,EAAA,GAAKN,IAAA,EAAMK,KAAA,EAAOC,EAAA,IAAMN,IAAA,EAAMK,KAAA,CAAM,8BAAA;;YAE1C,MAAME,UAAA,GAAaJ,GAAA,CAAIK,OAAO,CAACC,WAAW,CAACT,IAAA,EAAMU,UAAA,CAAW;YAE5D,IAAIH,UAAA,EAAY;gBACd,MAAMI,aAAA,GACJhB,KAAA,EAAOiB,QAAA,KAAaC,SAAA,IAAalB,KAAA,EAAOiB,QAAA,GAAWd,KAAA,GAAQH,KAAA,EAAOiB,QAAA,GAAWd,KAAA;gBAE/EI,kBAAA,CAAmBY,IAAI,8SACrBrB,WAAAA,AAAA,EAAS;oBACPa,EAAA;oBACAS,cAAA,EAAgBR,UAAA,CAAWS,MAAM,CAACC,IAAI;oBACtCpB,YAAA;oBACAqB,IAAA,EAAMlB,IAAA;oBACNF,KAAA,EAAOa,aAAA;oBACPZ,KAAA;oBACAoB,GAAA,EAAK;oBACLlB,cAAA;oBACAE,GAAA;oBACAC;gBACF;YAEJ;QACF;IACF;IAEA,OAAOR,6BAAA;AACT","ignoreList":[0]}},
    {"offset": {"line": 3384, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3390, "column": 0}, "map": {"version":3,"file":"RelationshipNode.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/server/nodes/RelationshipNode.tsx"],"sourcesContent":["import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  ElementFormatType,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  Spread,\n} from 'lexical'\nimport type { CollectionSlug, DataFromCollectionSlug } from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\n\nexport type RelationshipData = {\n  [TCollectionSlug in CollectionSlug]: {\n    relationTo: TCollectionSlug\n    value: DataFromCollectionSlug<TCollectionSlug> | number | string\n  }\n}[CollectionSlug]\n\nexport type SerializedRelationshipNode = {\n  children?: never // required so that our typed editor state doesn't automatically add children\n  type: 'relationship'\n} & Spread<RelationshipData, SerializedDecoratorBlockNode>\n\nfunction $relationshipElementToServerNode(domNode: HTMLDivElement): DOMConversionOutput | null {\n  const id = domNode.getAttribute('data-lexical-relationship-id')\n  const relationTo = domNode.getAttribute('data-lexical-relationship-relationTo')\n\n  if (id != null && relationTo != null) {\n    const node = $createServerRelationshipNode({\n      relationTo,\n      value: id,\n    })\n    return { node }\n  }\n  return null\n}\n\nexport class RelationshipServerNode extends DecoratorBlockNode {\n  __data: RelationshipData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: RelationshipData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static override clone(node: RelationshipServerNode): RelationshipServerNode {\n    return new this({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'relationship'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {\n      div: (domNode: HTMLDivElement) => {\n        if (\n          !domNode.hasAttribute('data-lexical-relationship-relationTo') ||\n          !domNode.hasAttribute('data-lexical-relationship-id')\n        ) {\n          return null\n        }\n        return {\n          conversion: $relationshipElementToServerNode,\n          priority: 2,\n        }\n      },\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedRelationshipNode): RelationshipServerNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n\n    const importedData: RelationshipData = {\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n    const node = $createServerRelationshipNode(importedData)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  override decorate(_editor: LexicalEditor, _config: EditorConfig): JSX.Element | null {\n    return null\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('div')\n    element.setAttribute(\n      'data-lexical-relationship-id',\n      String(typeof this.__data?.value === 'object' ? this.__data?.value?.id : this.__data?.value),\n    )\n    element.setAttribute('data-lexical-relationship-relationTo', this.__data?.relationTo)\n\n    const text = document.createTextNode(this.getTextContent())\n    element.append(text)\n    return { element }\n  }\n\n  override exportJSON(): SerializedRelationshipNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'relationship',\n      version: 2,\n    }\n  }\n\n  getData(): RelationshipData {\n    return this.getLatest().__data\n  }\n\n  override getTextContent(): string {\n    return `${this.__data?.relationTo} relation to ${typeof this.__data?.value === 'object' ? this.__data?.value?.id : this.__data?.value}`\n  }\n\n  setData(data: RelationshipData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n}\n\nexport function $createServerRelationshipNode(data: RelationshipData): RelationshipServerNode {\n  return new RelationshipServerNode({\n    data,\n  })\n}\n\nexport function $isServerRelationshipNode(\n  node: LexicalNode | null | RelationshipServerNode | undefined,\n): node is RelationshipServerNode {\n  return node instanceof RelationshipServerNode\n}\n"],"names":["DecoratorBlockNode","$relationshipElementToServerNode","domNode","id","getAttribute","relationTo","node","$createServerRelationshipNode","value","RelationshipServerNode","__data","constructor","data","format","key","clone","__format","__key","getType","importDOM","div","hasAttribute","conversion","priority","importJSON","serializedNode","version","importedData","setFormat","isInline","decorate","_editor","_config","exportDOM","element","document","createElement","setAttribute","String","text","createTextNode","getTextContent","append","exportJSON","getData","type","getLatest","setData","writable","getWritable","$isServerRelationshipNode"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3495, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3501, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/server/index.ts"],"sourcesContent":["import type { CollectionSlug } from 'payload'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { relationshipPopulationPromiseHOC } from './graphQLPopulationPromise.js'\nimport { i18n } from './i18n.js'\nimport { RelationshipServerNode } from './nodes/RelationshipNode.js'\n\nexport type ExclusiveRelationshipFeatureProps =\n  | {\n      /**\n       * The collections that should be disabled. Overrides the `enableRichTextRelationship` property in the collection config.\n       * When this property is set, `enabledCollections` will not be available.\n       **/\n      disabledCollections?: CollectionSlug[]\n\n      // Ensures that enabledCollections is not available when disabledCollections is set\n      enabledCollections?: never\n    }\n  | {\n      // Ensures that disabledCollections is not available when enabledCollections is set\n      disabledCollections?: never\n\n      /**\n       * The collections that should be enabled. Overrides the `enableRichTextRelationship` property in the collection config\n       * When this property is set, `disabledCollections` will not be available.\n       **/\n      enabledCollections?: CollectionSlug[]\n    }\n\nexport type RelationshipFeatureProps = {\n  /**\n   * Sets a maximum population depth for this relationship, regardless of the remaining depth when the respective field is reached.\n   * This behaves exactly like the maxDepth properties of relationship and upload fields.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n} & ExclusiveRelationshipFeatureProps\n\nexport const RelationshipFeature = createServerFeature<\n  RelationshipFeatureProps,\n  RelationshipFeatureProps,\n  ExclusiveRelationshipFeatureProps\n>({\n  feature: ({ props }) => {\n    // we don't need to pass maxDepth to the client, it's only used on the server\n    const { maxDepth, ...clientFeatureProps } = props ?? {}\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#RelationshipFeatureClient',\n      clientFeatureProps,\n      i18n,\n      nodes: [\n        createNode({\n          graphQLPopulationPromises: [relationshipPopulationPromiseHOC(props)],\n          hooks: {\n            afterRead: [\n              ({\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                populateArg,\n                populationPromises,\n                req,\n                showHiddenFields,\n              }) => {\n                if (!node?.value) {\n                  return node\n                }\n                const collection = req.payload.collections[node?.relationTo]\n\n                if (!collection) {\n                  return node\n                }\n                // @ts-expect-error\n                const id = node?.value?.id || node?.value // for backwards-compatibility\n\n                const populateDepth = maxDepth !== undefined && maxDepth < depth ? maxDepth : depth\n\n                populationPromises.push(\n                  populate({\n                    id,\n                    collectionSlug: collection.config.slug,\n                    currentDepth,\n                    data: node,\n                    depth: populateDepth,\n                    draft,\n                    key: 'value',\n                    overrideAccess,\n                    req,\n                    select:\n                      populateArg?.[collection.config.slug] ?? collection.config.defaultPopulate,\n                    showHiddenFields,\n                  }),\n                )\n\n                return node\n              },\n            ],\n          },\n          node: RelationshipServerNode,\n        }),\n      ],\n    }\n  },\n  key: 'relationship',\n})\n"],"names":["populate","createServerFeature","createNode","relationshipPopulationPromiseHOC","i18n","RelationshipServerNode","RelationshipFeature","feature","props","maxDepth","clientFeatureProps","ClientFeature","nodes","graphQLPopulationPromises","hooks","afterRead","currentDepth","depth","draft","node","overrideAccess","populateArg","populationPromises","req","showHiddenFields","value","collection","payload","collections","relationTo","id","populateDepth","undefined","push","collectionSlug","config","slug","data","key","select","defaultPopulate"],"mappings":";;;AAGA,SAASC,mBAAmB,QAAQ;AAGpC,SAASG,IAAI,QAAQ;AAFrB,SAASF,UAAU,QAAQ;AAC3B,SAASC,gCAAgC,QAAQ;AAHjD,SAASH,QAAQ,QAAQ;AAKzB,SAASK,sBAAsB,QAAQ;;;;;;;AAkChC,MAAMC,mBAAA,qTAAsBL,sBAAAA,AAAA,EAIjC;IACAM,OAAA,EAASA,CAAC,EAAEC,KAAAA,EAAO;QACjB,6EAAA;QACA,MAAM,EAAEC,QAAQ,EAAE,GAAGC,oBAAoB,GAAGF,KAAA,IAAS,CAAC;QACtD,OAAO;YACLG,aAAA,EAAe;YACfD,kBAAA;0UACAN,OAAA;YACAQ,KAAA,EAAO;2TACLV,aAAAA,AAAA,EAAW;oBACTW,yBAAA,EAA2B;yBAACV,kXAAAA,AAAA,EAAiCK,KAAA;qBAAO;oBACpEM,KAAA,EAAO;wBACLC,SAAA,EAAW;4BACT,CAAC,EACCC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,WAAW,EACXC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;gCACC,IAAI,CAACL,IAAA,EAAMM,KAAA,EAAO;oCAChB,OAAON,IAAA;gCACT;gCACA,MAAMO,UAAA,GAAaH,GAAA,CAAII,OAAO,CAACC,WAAW,CAACT,IAAA,EAAMU,UAAA,CAAW;gCAE5D,IAAI,CAACH,UAAA,EAAY;oCACf,OAAOP,IAAA;gCACT;gCACA,mBAAA;gCACA,MAAMW,EAAA,GAAKX,IAAA,EAAMM,KAAA,EAAOK,EAAA,IAAMX,IAAA,EAAMM,KAAA,CAAM,8BAAA;;gCAE1C,MAAMM,aAAA,GAAgBtB,QAAA,KAAauB,SAAA,IAAavB,QAAA,GAAWQ,KAAA,GAAQR,QAAA,GAAWQ,KAAA;gCAE9EK,kBAAA,CAAmBW,IAAI,8SACrBjC,WAAAA,AAAA,EAAS;oCACP8B,EAAA;oCACAI,cAAA,EAAgBR,UAAA,CAAWS,MAAM,CAACC,IAAI;oCACtCpB,YAAA;oCACAqB,IAAA,EAAMlB,IAAA;oCACNF,KAAA,EAAOc,aAAA;oCACPb,KAAA;oCACAoB,GAAA,EAAK;oCACLlB,cAAA;oCACAG,GAAA;oCACAgB,MAAA,EACElB,WAAA,EAAA,CAAcK,UAAA,CAAWS,MAAM,CAACC,IAAI,CAAC,IAAIV,UAAA,CAAWS,MAAM,CAACK,eAAe;oCAC5EhB;gCACF;gCAGF,OAAOL,IAAA;4BACT;yBAAA;oBAEJ;oBACAA,IAAA,+UAAMd,yBAAAA;gBACR;aAAA;QAEJ;IACF;IACAiC,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 3567, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3573, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/blockquote/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'اقتباس',\n  },\n  az: {\n    label: 'Blokkvota',\n  },\n  bg: {\n    label: 'Цитат',\n  },\n  cs: {\n    label: 'Citace',\n  },\n  da: {\n    label: 'Blokering',\n  },\n  de: {\n    label: 'Blockzitat',\n  },\n  en: {\n    label: 'Blockquote',\n  },\n  es: {\n    label: 'Cita en bloque',\n  },\n  et: {\n    label: 'Tsitaat',\n  },\n  fa: {\n    label: 'نقل قول بلوکی',\n  },\n  fr: {\n    label: 'Citation',\n  },\n  he: {\n    label: 'בלוק ציטוט',\n  },\n  hr: {\n    label: 'Blok citat',\n  },\n  hu: {\n    label: 'Idézetblokk',\n  },\n  it: {\n    label: 'Citazione',\n  },\n  ja: {\n    label: 'ブロッククォート',\n  },\n  ko: {\n    label: '인용구',\n  },\n  my: {\n    label: 'ဒေါင်းချီးခြင်း',\n  },\n  nb: {\n    label: 'Blokksitat',\n  },\n  nl: {\n    label: 'Citaat',\n  },\n  pl: {\n    label: 'Cytat blokowy',\n  },\n  pt: {\n    label: 'Citação em bloco',\n  },\n  ro: {\n    label: 'Citat',\n  },\n  rs: {\n    label: 'Блок цитата',\n  },\n  'rs-latin': {\n    label: 'Blok citata',\n  },\n  ru: {\n    label: 'Цитата',\n  },\n  sk: {\n    label: 'Citát',\n  },\n  sl: {\n    label: 'Citat',\n  },\n  sv: {\n    label: 'Blockcitat',\n  },\n  th: {\n    label: 'ข้อความอ้างอิง',\n  },\n  tr: {\n    label: 'Alıntı',\n  },\n  uk: {\n    label: 'Блокцитата',\n  },\n  vi: {\n    label: 'Trích dẫn',\n  },\n  zh: {\n    label: '块引用',\n  },\n  'zh-TW': {\n    label: '引用塊',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 3683, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3689, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/blockquote/markdownTransformer.ts"],"sourcesContent":["import { $createQuoteNode, $isQuoteNode, QuoteNode } from '@lexical/rich-text'\nimport { $createLineBreakNode } from 'lexical'\n\nimport type { ElementTransformer } from '../../packages/@lexical/markdown/index.js'\n\nexport const MarkdownTransformer: ElementTransformer = {\n  type: 'element',\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null\n    }\n\n    const lines = exportChildren(node).split('\\n')\n    const output: string[] = []\n    for (const line of lines) {\n      output.push('> ' + line)\n    }\n    return output.join('\\n')\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling()\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [\n          $createLineBreakNode(),\n          ...children,\n        ])\n        previousNode.select(0, 0)\n        parentNode.remove()\n        return\n      }\n    }\n\n    const node = $createQuoteNode()\n    node.append(...children)\n    parentNode.replace(node)\n    node.select(0, 0)\n  },\n}\n"],"names":["$createQuoteNode","$isQuoteNode","QuoteNode","$createLineBreakNode","MarkdownTransformer","type","dependencies","export","node","exportChildren","lines","split","output","line","push","join","regExp","replace","parentNode","children","_match","isImport","previousNode","getPreviousSibling","splice","getChildrenSize","select","remove","append"],"mappings":";;;AAAA,SAASA,gBAAgB,EAAEC,YAAY,EAAEC,SAAS,QAAQ;AAC1D,SAASC,oBAAoB,QAAQ;;;AAI9B,MAAMC,mBAAA,GAA0C;IACrDC,IAAA,EAAM;IACNC,YAAA,EAAc;sPAACJ,YAAA;KAAU;IACzBK,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,IAAI,CAACR,iQAAAA,AAAA,EAAaO,IAAA,GAAO;YACvB,OAAO;QACT;QAEA,MAAME,KAAA,GAAQD,cAAA,CAAeD,IAAA,EAAMG,KAAK,CAAC;QACzC,MAAMC,MAAA,GAAmB,EAAE;QAC3B,KAAK,MAAMC,IAAA,IAAQH,KAAA,CAAO;YACxBE,MAAA,CAAOE,IAAI,CAAC,OAAOD,IAAA;QACrB;QACA,OAAOD,MAAA,CAAOG,IAAI,CAAC;IACrB;IACAC,MAAA,EAAQ;IACRC,OAAA,EAASA,CAACC,UAAA,EAAYC,QAAA,EAAUC,MAAA,EAAQC,QAAA;QACtC,IAAIA,QAAA,EAAU;YACZ,MAAMC,YAAA,GAAeJ,UAAA,CAAWK,kBAAkB;YAClD,IAAItB,iQAAAA,AAAA,EAAaqB,YAAA,GAAe;gBAC9BA,YAAA,CAAaE,MAAM,CAACF,YAAA,CAAaG,eAAe,IAAI,GAAG;0NACrDtB,uBAAAA,AAAA,I;uBACGgB,QAAA;iBACJ;gBACDG,YAAA,CAAaI,MAAM,CAAC,GAAG;gBACvBR,UAAA,CAAWS,MAAM;gBACjB;YACF;QACF;QAEA,MAAMnB,IAAA,qPAAOR,mBAAAA,AAAA;QACbQ,IAAA,CAAKoB,MAAM,IAAIT,QAAA;QACfD,UAAA,CAAWD,OAAO,CAACT,IAAA;QACnBA,IAAA,CAAKkB,MAAM,CAAC,GAAG;IACjB;AACF","ignoreList":[0]}},
    {"offset": {"line": 3732, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3738, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/blockquote/server/index.ts"],"sourcesContent":["import type { SerializedQuoteNode as _SerializedQuoteNode } from '@lexical/rich-text'\nimport type { Spread } from 'lexical'\n\nimport { QuoteNode } from '@lexical/rich-text'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { convertLexicalNodesToHTML } from '../../converters/html/converter/index.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { MarkdownTransformer } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport type SerializedQuoteNode = Spread<\n  {\n    type: 'quote'\n  },\n  _SerializedQuoteNode\n>\n\nexport const BlockquoteFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#BlockquoteFeatureClient',\n    clientFeatureProps: null,\n    i18n,\n    markdownTransformers: [MarkdownTransformer],\n    nodes: [\n      createNode({\n        converters: {\n          html: {\n            converter: async ({\n              converters,\n              currentDepth,\n              depth,\n              draft,\n              node,\n              overrideAccess,\n              parent,\n              req,\n              showHiddenFields,\n            }) => {\n              const childrenText = await convertLexicalNodesToHTML({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                lexicalNodes: node.children,\n                overrideAccess,\n                parent: {\n                  ...node,\n                  parent,\n                },\n                req,\n                showHiddenFields,\n              })\n              const style = [\n                node.format ? `text-align: ${node.format};` : '',\n                node.indent > 0 ? `padding-inline-start: ${node.indent * 40}px;` : '',\n              ]\n                .filter(Boolean)\n                .join(' ')\n\n              return `<blockquote${style ? ` style='${style}'` : ''}>${childrenText}</blockquote>`\n            },\n            nodeTypes: [QuoteNode.getType()],\n          },\n        },\n        node: QuoteNode,\n      }),\n    ],\n  },\n  key: 'blockquote',\n})\n"],"names":["QuoteNode","createServerFeature","convertLexicalNodesToHTML","createNode","MarkdownTransformer","i18n","BlockquoteFeature","feature","ClientFeature","clientFeatureProps","markdownTransformers","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","style","format","indent","filter","Boolean","join","nodeTypes","getType","key"],"mappings":";;;AAKA,SAASC,mBAAmB,QAAQ;AAIpC,SAASI,IAAI,QAAQ;AADrB,SAASD,mBAAmB,QAAQ;AADpC,SAASD,UAAU,QAAQ;AAD3B,SAASD,yBAAyB,QAAQ;AAH1C,SAASF,SAAS,QAAQ;;;;;;;AAenB,MAAMM,iBAAA,qTAAoBL,sBAAAA,AAAA,EAAoB;IACnDM,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,kBAAA,EAAoB;oUACpBJ,OAAA;QACAK,oBAAA,EAAsB;uUAACN,sBAAA;SAAoB;QAC3CO,KAAA,EAAO;uTACLR,aAAAA,AAAA,EAAW;gBACTS,UAAA,EAAY;oBACVC,IAAA,EAAM;wBACJC,SAAA,EAAW,MAAAA,CAAO,EAChBF,UAAU,EACVG,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;4BACC,MAAMC,YAAA,GAAe,OAAMrB,iWAAAA,AAAA,EAA0B;gCACnDU,UAAA;gCACAG,YAAA;gCACAC,KAAA;gCACAC,KAAA;gCACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;gCAC3BN,cAAA;gCACAC,MAAA,EAAQ;oCACN,GAAGF,IAAI;oCACPE;gCACF;gCACAC,GAAA;gCACAC;4BACF;4BACA,MAAMI,KAAA,GAAQ;gCACZR,IAAA,CAAKS,MAAM,GAAG,CAAA,YAAA,EAAeT,IAAA,CAAKS,MAAM,CAAA,CAAA,CAAG,GAAG;gCAC9CT,IAAA,CAAKU,MAAM,GAAG,IAAI,CAAA,sBAAA,EAAyBV,IAAA,CAAKU,MAAM,GAAG,GAAA,GAAA,CAAO,GAAG;6BACpE,CACEC,MAAM,CAACC,OAAA,EACPC,IAAI,CAAC;4BAER,OAAO,CAAA,WAAA,EAAcL,KAAA,GAAQ,CAAA,QAAA,EAAWA,KAAA,CAAA,CAAA,CAAQ,GAAG,GAAA,CAAA,EAAMH,YAAA,CAAA,aAAA,CAA2B;wBACtF;wBACAS,SAAA,EAAW;4BAAChC,0PAAA,CAAUiC,OAAO;yBAAA;oBAC/B;gBACF;gBACAf,IAAA,gPAAMlB,YAAAA;YACR;SAAA;IAEJ;IACAkC,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 3797, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3803, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'تحميل',\n  },\n  az: {\n    label: 'Yükləyin',\n  },\n  bg: {\n    label: 'Качване',\n  },\n  cs: {\n    label: 'Nahrát',\n  },\n  da: {\n    label: 'Upload',\n  },\n  de: {\n    label: 'Datei',\n  },\n  en: {\n    label: 'Upload',\n  },\n  es: {\n    label: 'Subir',\n  },\n  et: {\n    label: 'Lae üles',\n  },\n  fa: {\n    label: 'بارگذاری',\n  },\n  fr: {\n    label: 'Télécharger',\n  },\n  he: {\n    label: 'העלה',\n  },\n  hr: {\n    label: 'Prenesi',\n  },\n  hu: {\n    label: 'Feltöltés',\n  },\n  it: {\n    label: 'Carica',\n  },\n  ja: {\n    label: 'アップロード',\n  },\n  ko: {\n    label: '업로드',\n  },\n  my: {\n    label: 'တင်ပြီး',\n  },\n  nb: {\n    label: 'Last opp',\n  },\n  nl: {\n    label: 'Uploaden',\n  },\n  pl: {\n    label: 'Prześlij',\n  },\n  pt: {\n    label: 'Carregar',\n  },\n  ro: {\n    label: 'Încarcă',\n  },\n  rs: {\n    label: 'Отпреми',\n  },\n  'rs-latin': {\n    label: 'Otpremi',\n  },\n  ru: {\n    label: 'Загрузить',\n  },\n  sk: {\n    label: 'Nahrať',\n  },\n  sl: {\n    label: 'Naloži',\n  },\n  sv: {\n    label: 'Ladda upp',\n  },\n  th: {\n    label: 'อัปโหลด',\n  },\n  tr: {\n    label: 'Yükle',\n  },\n  uk: {\n    label: 'Завантажити',\n  },\n  vi: {\n    label: 'Tải lên',\n  },\n  zh: {\n    label: '上传',\n  },\n  'zh-TW': {\n    label: '上傳',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 3913, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3919, "column": 0}, "map": {"version":3,"file":"UploadNode.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/nodes/UploadNode.tsx"],"sourcesContent":["import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  ElementFormatType,\n  LexicalNode,\n  NodeKey,\n  Spread,\n} from 'lexical'\nimport type { CollectionSlug, DataFromCollectionSlug, JsonObject } from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport ObjectID from 'bson-objectid'\nimport { $applyNodeReplacement } from 'lexical'\nimport * as React from 'react'\n\nexport type UploadData<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  [TCollectionSlug in CollectionSlug]: {\n    fields: TUploadExtraFieldsData\n    // Every lexical node that has sub-fields needs to have a unique ID. This is the ID of this upload node, not the ID of the linked upload document\n    id: string\n    relationTo: TCollectionSlug\n    // Value can be just the document ID, or the full, populated document\n    value: DataFromCollectionSlug<TCollectionSlug> | number | string\n  }\n}[CollectionSlug]\n\nexport function isGoogleDocCheckboxImg(img: HTMLImageElement): boolean {\n  return (\n    img.parentElement != null &&\n    img.parentElement.tagName === 'LI' &&\n    img.previousSibling === null &&\n    img.getAttribute('aria-roledescription') === 'checkbox'\n  )\n}\n\nfunction $convertUploadServerElement(domNode: HTMLImageElement): DOMConversionOutput | null {\n  if (\n    domNode.hasAttribute('data-lexical-upload-relation-to') &&\n    domNode.hasAttribute('data-lexical-upload-id')\n  ) {\n    const id = domNode.getAttribute('data-lexical-upload-id')\n    const relationTo = domNode.getAttribute('data-lexical-upload-relation-to')\n\n    if (id != null && relationTo != null) {\n      const node = $createUploadServerNode({\n        data: {\n          fields: {},\n          relationTo,\n          value: id,\n        },\n      })\n      return { node }\n    }\n  }\n  const img = domNode\n  if (img.src.startsWith('file:///') || isGoogleDocCheckboxImg(img)) {\n    return null\n  }\n  // TODO: Auto-upload functionality here!\n  //}\n  return null\n}\n\nexport type SerializedUploadNode = {\n  children?: never // required so that our typed editor state doesn't automatically add children\n  type: 'upload'\n} & Spread<UploadData, SerializedDecoratorBlockNode>\n\nexport class UploadServerNode extends DecoratorBlockNode {\n  __data: UploadData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: UploadData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static override clone(node: UploadServerNode): UploadServerNode {\n    return new this({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'upload'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLImageElement> {\n    return {\n      img: (node) => ({\n        conversion: $convertUploadServerElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedUploadNode): UploadServerNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n    if (serializedNode.version === 2 && !serializedNode?.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const importedData: UploadData = {\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n\n    const node = $createUploadServerNode({ data: importedData })\n    node.setFormat(serializedNode.format)\n\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  override decorate(): JSX.Element {\n    // @ts-expect-error\n    return <RawUploadComponent data={this.__data} format={this.__format} nodeKey={this.getKey()} />\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('img')\n    element.setAttribute('data-lexical-upload-id', String(this.__data?.value))\n    element.setAttribute('data-lexical-upload-relation-to', this.__data?.relationTo)\n\n    return { element }\n  }\n\n  override exportJSON(): SerializedUploadNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'upload',\n      version: 3,\n    }\n  }\n\n  getData(): UploadData {\n    return this.getLatest().__data\n  }\n\n  setData(data: UploadData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n\n  override updateDOM(): false {\n    return false\n  }\n}\n\nexport function $createUploadServerNode({\n  data,\n}: {\n  data: Omit<UploadData, 'id'> & Partial<Pick<UploadData, 'id'>>\n}): UploadServerNode {\n  if (!data?.id) {\n    data.id = new ObjectID.default().toHexString()\n  }\n  return $applyNodeReplacement(new UploadServerNode({ data: data as UploadData }))\n}\n\nexport function $isUploadServerNode(\n  node: LexicalNode | null | undefined,\n): node is UploadServerNode {\n  return node instanceof UploadServerNode\n}\n"],"names":["DecoratorBlockNode","ObjectID","$applyNodeReplacement","React","isGoogleDocCheckboxImg","img","parentElement","tagName","previousSibling","getAttribute","$convertUploadServerElement","domNode","hasAttribute","id","relationTo","node","$createUploadServerNode","data","fields","value","src","startsWith","UploadServerNode","__data","constructor","format","key","clone","__format","__key","getType","importDOM","conversion","priority","importJSON","serializedNode","version","default","toHexString","importedData","setFormat","isInline","decorate","_jsx","RawUploadComponent","nodeKey","getKey","exportDOM","element","document","createElement","setAttribute","String","exportJSON","getData","type","getLatest","setData","writable","getWritable","updateDOM","$isUploadServerNode"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4056, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4062, "column": 0}, "map": {"version":3,"file":"graphQLPopulationPromise.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/graphQLPopulationPromise.ts"],"sourcesContent":["import type { PopulationPromise } from '../../typesServer.js'\nimport type { UploadFeatureProps } from './feature.server.js'\nimport type { SerializedUploadNode } from './nodes/UploadNode.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\nimport { recursivelyPopulateFieldsForGraphQL } from '../../../populateGraphQL/recursivelyPopulateFieldsForGraphQL.js'\n\nexport const uploadPopulationPromiseHOC = (\n  props?: UploadFeatureProps,\n): PopulationPromise<SerializedUploadNode> => {\n  return ({\n    context,\n    currentDepth,\n    depth,\n    draft,\n    editorPopulationPromises,\n    fieldPromises,\n    findMany,\n    flattenLocales,\n    node,\n    overrideAccess,\n    populationPromises,\n    req,\n    showHiddenFields,\n  }) => {\n    if (node?.value) {\n      const collection = req.payload.collections[node?.relationTo]\n\n      if (collection) {\n        // @ts-expect-error\n        const id = node?.value?.id || node?.value // for backwards-compatibility\n\n        const populateDepth =\n          props?.maxDepth !== undefined && props?.maxDepth < depth ? props?.maxDepth : depth\n\n        populationPromises.push(\n          populate({\n            id,\n            collectionSlug: collection.config.slug,\n            currentDepth,\n            data: node,\n            depth: populateDepth,\n            draft,\n            key: 'value',\n            overrideAccess,\n            req,\n            showHiddenFields,\n          }),\n        )\n\n        const collectionFieldSchema = props?.collections?.[node?.relationTo]?.fields\n\n        if (Array.isArray(collectionFieldSchema)) {\n          if (!collectionFieldSchema?.length) {\n            return\n          }\n          recursivelyPopulateFieldsForGraphQL({\n            context,\n            currentDepth,\n            data: node.fields || {},\n            depth,\n            draft,\n            editorPopulationPromises,\n            fieldPromises,\n            fields: collectionFieldSchema,\n            findMany,\n            flattenLocales,\n            overrideAccess,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc: node.fields || {},\n          })\n        }\n      }\n    }\n  }\n}\n"],"names":["populate","recursivelyPopulateFieldsForGraphQL","uploadPopulationPromiseHOC","props","context","currentDepth","depth","draft","editorPopulationPromises","fieldPromises","findMany","flattenLocales","node","overrideAccess","populationPromises","req","showHiddenFields","value","collection","payload","collections","relationTo","id","populateDepth","maxDepth","undefined","push","collectionSlug","config","slug","data","key","collectionFieldSchema","fields","Array","isArray","length","siblingDoc"],"mappings":";;;AAIA,SAASA,QAAQ,QAAQ;AACzB,SAASC,mCAAmC,QAAQ;;;AAE7C,MAAMC,0BAAA,IACXC,KAAA;IAEA,OAAO,CAAC,EACNC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,wBAAwB,EACxBC,aAAa,EACbC,QAAQ,EACRC,cAAc,EACdC,IAAI,EACJC,cAAc,EACdC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;QACC,IAAIJ,IAAA,EAAMK,KAAA,EAAO;YACf,MAAMC,UAAA,GAAaH,GAAA,CAAII,OAAO,CAACC,WAAW,CAACR,IAAA,EAAMS,UAAA,CAAW;YAE5D,IAAIH,UAAA,EAAY;gBACd,mBAAA;gBACA,MAAMI,EAAA,GAAKV,IAAA,EAAMK,KAAA,EAAOK,EAAA,IAAMV,IAAA,EAAMK,KAAA,CAAM,8BAAA;;gBAE1C,MAAMM,aAAA,GACJpB,KAAA,EAAOqB,QAAA,KAAaC,SAAA,IAAatB,KAAA,EAAOqB,QAAA,GAAWlB,KAAA,GAAQH,KAAA,EAAOqB,QAAA,GAAWlB,KAAA;gBAE/EQ,kBAAA,CAAmBY,IAAI,8SACrB1B,WAAAA,AAAA,EAAS;oBACPsB,EAAA;oBACAK,cAAA,EAAgBT,UAAA,CAAWU,MAAM,CAACC,IAAI;oBACtCxB,YAAA;oBACAyB,IAAA,EAAMlB,IAAA;oBACNN,KAAA,EAAOiB,aAAA;oBACPhB,KAAA;oBACAwB,GAAA,EAAK;oBACLlB,cAAA;oBACAE,GAAA;oBACAC;gBACF;gBAGF,MAAMgB,qBAAA,GAAwB7B,KAAA,EAAOiB,WAAA,EAAA,CAAcR,IAAA,EAAMS,UAAA,CAAW,EAAEY,MAAA;gBAEtE,IAAIC,KAAA,CAAMC,OAAO,CAACH,qBAAA,GAAwB;oBACxC,IAAI,CAACA,qBAAA,EAAuBI,MAAA,EAAQ;wBAClC;oBACF;4VACAnC,sCAAAA,AAAA,EAAoC;wBAClCG,OAAA;wBACAC,YAAA;wBACAyB,IAAA,EAAMlB,IAAA,CAAKqB,MAAM,IAAI,CAAC;wBACtB3B,KAAA;wBACAC,KAAA;wBACAC,wBAAA;wBACAC,aAAA;wBACAwB,MAAA,EAAQD,qBAAA;wBACRtB,QAAA;wBACAC,cAAA;wBACAE,cAAA;wBACAC,kBAAA;wBACAC,GAAA;wBACAC,gBAAA;wBACAqB,UAAA,EAAYzB,IAAA,CAAKqB,MAAM,IAAI,CAAC;oBAC9B;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 4117, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4123, "column": 0}, "map": {"version":3,"file":"validate.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/validate.ts"],"sourcesContent":["import { fieldSchemasToFormState } from '@payloadcms/ui/forms/fieldSchemasToFormState'\nimport { isValidID } from 'payload'\n\nimport type { NodeValidation } from '../../typesServer.js'\nimport type { UploadFeatureProps } from './feature.server.js'\nimport type { SerializedUploadNode } from './nodes/UploadNode.js'\n\nexport const uploadValidation = (\n  props: UploadFeatureProps,\n): NodeValidation<SerializedUploadNode> => {\n  return async ({\n    node,\n    validation: {\n      options: {\n        id,\n        data,\n        operation,\n        preferences,\n        req,\n        req: { payload, t },\n      },\n    },\n  }) => {\n    const idType = payload.collections[node.relationTo].customIDType || payload.db.defaultIDType\n    // @ts-expect-error\n    const nodeID = node?.value?.id || node?.value // for backwards-compatibility\n\n    if (!isValidID(nodeID, idType)) {\n      return t('validation:validUploadID')\n    }\n\n    if (!props?.collections) {\n      return true\n    }\n\n    if (Object.keys(props?.collections).length === 0) {\n      return true\n    }\n\n    const collection = props?.collections[node.relationTo]\n\n    if (!collection?.fields?.length) {\n      return true\n    }\n\n    const result = await fieldSchemasToFormState({\n      id,\n      collectionSlug: node.relationTo,\n\n      data: node?.fields ?? {},\n      documentData: data,\n      fields: collection.fields,\n      fieldSchemaMap: undefined,\n      initialBlockData: node?.fields ?? {},\n      operation: operation === 'create' || operation === 'update' ? operation : 'update',\n      permissions: {},\n      preferences,\n      renderAllFields: false,\n      req,\n      schemaPath: '',\n    })\n\n    const errorPathsSet = new Set<string>()\n    for (const fieldKey in result) {\n      if (result[fieldKey].errorPaths?.length) {\n        for (const errorPath of result[fieldKey].errorPaths) {\n          errorPathsSet.add(errorPath)\n        }\n      }\n    }\n    const errorPaths = Array.from(errorPathsSet)\n\n    if (errorPaths.length) {\n      return 'The following fields are invalid: ' + errorPaths.join(', ')\n    }\n\n    return true\n  }\n}\n"],"names":["fieldSchemasToFormState","isValidID","uploadValidation","props","node","validation","options","id","data","operation","preferences","req","payload","t","idType","collections","relationTo","customIDType","db","defaultIDType","nodeID","value","Object","keys","length","collection","fields","result","collectionSlug","documentData","fieldSchemaMap","undefined","initialBlockData","permissions","renderAllFields","schemaPath","errorPathsSet","Set","fieldKey","errorPaths","errorPath","add","Array","from","join"],"mappings":";;;AACA,SAASC,SAAS,QAAQ;AAD1B,SAASD,uBAAuB,QAAQ;;;AAOjC,MAAME,gBAAA,IACXC,KAAA;IAEA,OAAO,OAAO,EACZC,IAAI,EACJC,UAAA,EAAY,EACVC,OAAA,EAAS,EACPC,EAAE,EACFC,IAAI,EACJC,SAAS,EACTC,WAAW,EACXC,GAAG,EACHA,GAAA,EAAK,EAAEC,OAAO,EAAEC,CAAAA,EAAC,EAAE,EACpB,EAEJ;QACC,MAAMC,MAAA,GAASF,OAAA,CAAQG,WAAW,CAACX,IAAA,CAAKY,UAAU,CAAC,CAACC,YAAY,IAAIL,OAAA,CAAQM,EAAE,CAACC,aAAa;QAC5F,mBAAA;QACA,MAAMC,MAAA,GAAShB,IAAA,EAAMiB,KAAA,EAAOd,EAAA,IAAMH,IAAA,EAAMiB,KAAA,CAAM,8BAAA;;QAE9C,IAAI,EAACpB,iYAAAA,AAAA,EAAUmB,MAAA,EAAQN,MAAA,GAAS;YAC9B,OAAOD,CAAA,CAAE;QACX;QAEA,IAAI,CAACV,KAAA,EAAOY,WAAA,EAAa;YACvB,OAAO;QACT;QAEA,IAAIO,MAAA,CAAOC,IAAI,CAACpB,KAAA,EAAOY,WAAA,EAAaS,MAAM,KAAK,GAAG;YAChD,OAAO;QACT;QAEA,MAAMC,UAAA,GAAatB,KAAA,EAAOY,WAAW,CAACX,IAAA,CAAKY,UAAU,CAAC;QAEtD,IAAI,CAACS,UAAA,EAAYC,MAAA,EAAQF,MAAA,EAAQ;YAC/B,OAAO;QACT;QAEA,MAAMG,MAAA,GAAS,OAAM3B,0bAAAA,AAAA,EAAwB;YAC3CO,EAAA;YACAqB,cAAA,EAAgBxB,IAAA,CAAKY,UAAU;YAE/BR,IAAA,EAAMJ,IAAA,EAAMsB,MAAA,IAAU,CAAC;YACvBG,YAAA,EAAcrB,IAAA;YACdkB,MAAA,EAAQD,UAAA,CAAWC,MAAM;YACzBI,cAAA,EAAgBC,SAAA;YAChBC,gBAAA,EAAkB5B,IAAA,EAAMsB,MAAA,IAAU,CAAC;YACnCjB,SAAA,EAAWA,SAAA,KAAc,YAAYA,SAAA,KAAc,WAAWA,SAAA,GAAY;YAC1EwB,WAAA,EAAa,CAAC;YACdvB,WAAA;YACAwB,eAAA,EAAiB;YACjBvB,GAAA;YACAwB,UAAA,EAAY;QACd;QAEA,MAAMC,aAAA,GAAgB,IAAIC,GAAA;QAC1B,IAAK,MAAMC,QAAA,IAAYX,MAAA,CAAQ;YAC7B,IAAIA,MAAM,CAACW,QAAA,CAAS,CAACC,UAAU,EAAEf,MAAA,EAAQ;gBACvC,KAAK,MAAMgB,SAAA,IAAab,MAAM,CAACW,QAAA,CAAS,CAACC,UAAU,CAAE;oBACnDH,aAAA,CAAcK,GAAG,CAACD,SAAA;gBACpB;YACF;QACF;QACA,MAAMD,UAAA,GAAaG,KAAA,CAAMC,IAAI,CAACP,aAAA;QAE9B,IAAIG,UAAA,CAAWf,MAAM,EAAE;YACrB,OAAO,uCAAuCe,UAAA,CAAWK,IAAI,CAAC;QAChE;QAEA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 4179, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4185, "column": 0}, "map": {"version":3,"file":"feature.server.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/feature.server.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  Config,\n  Field,\n  FieldSchemaMap,\n  FileData,\n  FileSize,\n  Payload,\n  TypeWithID,\n} from 'payload'\n\nimport { sanitizeFields } from 'payload'\n\nimport type { UploadFeaturePropsClient } from '../client/feature.client.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { uploadPopulationPromiseHOC } from './graphQLPopulationPromise.js'\nimport { i18n } from './i18n.js'\nimport { UploadServerNode } from './nodes/UploadNode.js'\nimport { uploadValidation } from './validate.js'\n\nexport type UploadFeatureProps = {\n  collections?: {\n    [collection: CollectionSlug]: {\n      fields: Field[]\n    }\n  }\n  /**\n   * Sets a maximum population depth for this upload (not the fields for this upload), regardless of the remaining depth when the respective field is reached.\n   * This behaves exactly like the maxDepth properties of relationship and upload fields.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n}\n\n/**\n * Get the absolute URL for an upload URL by potentially prepending the serverURL\n */\nfunction getAbsoluteURL(url: string, payload: Payload): string {\n  return url?.startsWith('http') ? url : (payload?.config?.serverURL || '') + url\n}\n\nexport const UploadFeature = createServerFeature<\n  UploadFeatureProps,\n  UploadFeatureProps,\n  UploadFeaturePropsClient\n>({\n  feature: async ({ config: _config, isRoot, parentIsLocalized, props }) => {\n    if (!props) {\n      props = { collections: {} }\n    }\n\n    const clientProps: UploadFeaturePropsClient = {\n      collections: {},\n    }\n    if (props.collections) {\n      for (const collection in props.collections) {\n        clientProps.collections[collection] = {\n          hasExtraFields: props.collections[collection]!.fields.length >= 1,\n        }\n      }\n    }\n\n    const validRelationships = _config.collections.map((c) => c.slug) || []\n\n    for (const collectionKey in props.collections) {\n      const collection = props.collections[collectionKey]!\n      if (collection.fields?.length) {\n        collection.fields = await sanitizeFields({\n          config: _config as unknown as Config,\n          fields: collection.fields,\n          parentIsLocalized,\n          requireFieldLevelRichTextEditor: isRoot,\n          validRelationships,\n        })\n      }\n    }\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#UploadFeatureClient',\n      clientFeatureProps: clientProps,\n      generateSchemaMap: ({ props }) => {\n        if (!props?.collections) {\n          return null\n        }\n\n        const schemaMap: FieldSchemaMap = new Map()\n\n        for (const collectionKey in props.collections) {\n          const collection = props.collections[collectionKey]!\n          if (collection.fields?.length) {\n            schemaMap.set(collectionKey, {\n              fields: collection.fields,\n            })\n          }\n        }\n\n        return schemaMap\n      },\n      i18n,\n      nodes: [\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                req,\n                showHiddenFields,\n              }) => {\n                // @ts-expect-error - for backwards-compatibility\n                const id = node?.value?.id || node?.value\n\n                if (req?.payload) {\n                  const uploadDocument: {\n                    value?: FileData & TypeWithID\n                  } = {}\n\n                  try {\n                    await populate({\n                      id,\n                      collectionSlug: node.relationTo,\n                      currentDepth,\n                      data: uploadDocument,\n                      depth,\n                      draft,\n                      key: 'value',\n                      overrideAccess,\n                      req,\n                      showHiddenFields,\n                    })\n                  } catch (ignored) {\n                    // eslint-disable-next-line no-console\n                    console.error(\n                      'Lexical upload node HTML converter: error fetching upload file',\n                      ignored,\n                      'Node:',\n                      node,\n                    )\n                    return `<img />`\n                  }\n\n                  const url = getAbsoluteURL(uploadDocument?.value?.url ?? '', req?.payload)\n\n                  /**\n                   * If the upload is not an image, return a link to the upload\n                   */\n                  if (!uploadDocument?.value?.mimeType?.startsWith('image')) {\n                    return `<a href=\"${url}\" rel=\"noopener noreferrer\">${uploadDocument.value?.filename}</a>`\n                  }\n\n                  /**\n                   * If the upload is a simple image with no different sizes, return a simple img tag\n                   */\n                  if (\n                    !uploadDocument?.value?.sizes ||\n                    !Object.keys(uploadDocument?.value?.sizes).length\n                  ) {\n                    return `<img src=\"${url}\" alt=\"${uploadDocument?.value?.filename}\" width=\"${uploadDocument?.value?.width}\"  height=\"${uploadDocument?.value?.height}\"/>`\n                  }\n\n                  /**\n                   * If the upload is an image with different sizes, return a picture element\n                   */\n                  let pictureHTML = '<picture>'\n\n                  // Iterate through each size in the data.sizes object\n                  for (const size in uploadDocument.value?.sizes) {\n                    const imageSize: {\n                      url?: string\n                    } & FileSize = uploadDocument.value?.sizes[size]\n\n                    // Skip if any property of the size object is null\n                    if (\n                      !imageSize.width ||\n                      !imageSize.height ||\n                      !imageSize.mimeType ||\n                      !imageSize.filesize ||\n                      !imageSize.filename ||\n                      !imageSize.url\n                    ) {\n                      continue\n                    }\n                    const imageSizeURL = getAbsoluteURL(imageSize?.url, req?.payload)\n\n                    pictureHTML += `<source srcset=\"${imageSizeURL}\" media=\"(max-width: ${imageSize.width}px)\" type=\"${imageSize.mimeType}\">`\n                  }\n\n                  // Add the default img tag\n                  pictureHTML += `<img src=\"${url}\" alt=\"Image\" width=\"${uploadDocument.value?.width}\" height=\"${uploadDocument.value?.height}\">`\n                  pictureHTML += '</picture>'\n                  return pictureHTML\n                } else {\n                  return `<img src=\"${id}\" />`\n                }\n              },\n              nodeTypes: [UploadServerNode.getType()],\n            },\n          },\n          getSubFields: ({ node, req }) => {\n            if (!node) {\n              let allSubFields: Field[] = []\n              for (const collection in props?.collections) {\n                allSubFields = allSubFields.concat(props?.collections?.[collection]?.fields)\n              }\n              return allSubFields\n            }\n            const collection = req ? req.payload.collections[node?.relationTo] : null\n\n            if (collection) {\n              const collectionFieldSchema = props?.collections?.[node?.relationTo]?.fields\n\n              if (Array.isArray(collectionFieldSchema)) {\n                if (!collectionFieldSchema?.length) {\n                  return null\n                }\n                return collectionFieldSchema\n              }\n            }\n            return null\n          },\n          getSubFieldsData: ({ node }) => {\n            return node?.fields\n          },\n          graphQLPopulationPromises: [uploadPopulationPromiseHOC(props)],\n          hooks: {\n            afterRead: [\n              ({\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                populateArg,\n                populationPromises,\n                req,\n                showHiddenFields,\n              }) => {\n                if (!node?.value) {\n                  return node\n                }\n                const collection = req.payload.collections[node?.relationTo]\n\n                if (!collection) {\n                  return node\n                }\n                // @ts-expect-error\n                const id = node?.value?.id || node?.value // for backwards-compatibility\n\n                const populateDepth =\n                  props?.maxDepth !== undefined && props?.maxDepth < depth ? props?.maxDepth : depth\n\n                populationPromises.push(\n                  populate({\n                    id,\n                    collectionSlug: collection.config.slug,\n                    currentDepth,\n                    data: node,\n                    depth: populateDepth,\n                    draft,\n                    key: 'value',\n                    overrideAccess,\n                    req,\n                    select:\n                      populateArg?.[collection.config.slug] ?? collection.config.defaultPopulate,\n                    showHiddenFields,\n                  }),\n                )\n\n                return node\n              },\n            ],\n          },\n          node: UploadServerNode,\n          validations: [uploadValidation(props)],\n        }),\n      ],\n      sanitizedServerFeatureProps: props,\n    }\n  },\n  key: 'upload',\n})\n"],"names":["sanitizeFields","populate","createServerFeature","createNode","uploadPopulationPromiseHOC","i18n","UploadServerNode","uploadValidation","getAbsoluteURL","url","payload","startsWith","config","serverURL","UploadFeature","feature","_config","isRoot","parentIsLocalized","props","collections","clientProps","collection","hasExtraFields","fields","length","validRelationships","map","c","slug","collectionKey","requireFieldLevelRichTextEditor","ClientFeature","clientFeatureProps","generateSchemaMap","schemaMap","Map","set","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","req","showHiddenFields","id","value","uploadDocument","collectionSlug","relationTo","data","key","ignored","console","error","mimeType","filename","sizes","Object","keys","width","height","pictureHTML","size","imageSize","filesize","imageSizeURL","nodeTypes","getType","getSubFields","allSubFields","concat","collectionFieldSchema","Array","isArray","getSubFieldsData","graphQLPopulationPromises","hooks","afterRead","populateArg","populationPromises","populateDepth","maxDepth","undefined","push","select","defaultPopulate","validations","sanitizedServerFeatureProps"],"mappings":";;;AAgBA,SAASE,mBAAmB,QAAQ;AALpC,SAASF,cAAc,QAAQ;AAQ/B,SAASK,IAAI,QAAQ;AAFrB,SAASF,UAAU,QAAQ;AAF3B,SAASF,QAAQ,QAAQ;AAKzB,SAASK,gBAAgB,QAAQ;AAFjC,SAASF,0BAA0B,QAAQ;AAG3C,SAASG,gBAAgB,QAAQ;;;;;;;;;AAiBjC;;IAGA,SAASC,eAAeC,GAAW,EAAEC,OAAgB;IACnD,OAAOD,GAAA,EAAKE,UAAA,CAAW,UAAUF,GAAA,GAAM,CAACC,OAAA,EAASE,MAAA,EAAQC,SAAA,IAAa,EAAC,IAAKJ,GAAA;AAC9E;AAEO,MAAMK,aAAA,qTAAgBZ,sBAAAA,AAAA,EAI3B;IACAa,OAAA,EAAS,MAAAA,CAAO,EAAEH,MAAA,EAAQI,OAAO,EAAEC,MAAM,EAAEC,iBAAiB,EAAEC,KAAAA,EAAO;QACnE,IAAI,CAACA,KAAA,EAAO;YACVA,KAAA,GAAQ;gBAAEC,WAAA,EAAa,CAAC;YAAE;QAC5B;QAEA,MAAMC,WAAA,GAAwC;YAC5CD,WAAA,EAAa,CAAC;QAChB;QACA,IAAID,KAAA,CAAMC,WAAW,EAAE;YACrB,IAAK,MAAME,UAAA,IAAcH,KAAA,CAAMC,WAAW,CAAE;gBAC1CC,WAAA,CAAYD,WAAW,CAACE,UAAA,CAAW,GAAG;oBACpCC,cAAA,EAAgBJ,KAAA,CAAMC,WAAW,CAACE,UAAA,CAAW,CAAEE,MAAM,CAACC,MAAM,IAAI;gBAClE;YACF;QACF;QAEA,MAAMC,kBAAA,GAAqBV,OAAA,CAAQI,WAAW,CAACO,GAAG,EAAEC,CAAA,GAAMA,CAAA,CAAEC,IAAI,KAAK,EAAE;QAEvE,IAAK,MAAMC,aAAA,IAAiBX,KAAA,CAAMC,WAAW,CAAE;YAC7C,MAAME,UAAA,GAAaH,KAAA,CAAMC,WAAW,CAACU,aAAA,CAAc;YACnD,IAAIR,UAAA,CAAWE,MAAM,EAAEC,MAAA,EAAQ;gBAC7BH,UAAA,CAAWE,MAAM,GAAG,kYAAMxB,iBAAAA,AAAA,EAAe;oBACvCY,MAAA,EAAQI,OAAA;oBACRQ,MAAA,EAAQF,UAAA,CAAWE,MAAM;oBACzBN,iBAAA;oBACAa,+BAAA,EAAiCd,MAAA;oBACjCS;gBACF;YACF;QACF;QAEA,OAAO;YACLM,aAAA,EAAe;YACfC,kBAAA,EAAoBZ,WAAA;YACpBa,iBAAA,EAAmBA,CAAC,EAAEf,KAAAA,EAAO;gBAC3B,IAAI,CAACA,KAAA,EAAOC,WAAA,EAAa;oBACvB,OAAO;gBACT;gBAEA,MAAMe,SAAA,GAA4B,IAAIC,GAAA;gBAEtC,IAAK,MAAMN,aAAA,IAAiBX,KAAA,CAAMC,WAAW,CAAE;oBAC7C,MAAME,UAAA,GAAaH,KAAA,CAAMC,WAAW,CAACU,aAAA,CAAc;oBACnD,IAAIR,UAAA,CAAWE,MAAM,EAAEC,MAAA,EAAQ;wBAC7BU,SAAA,CAAUE,GAAG,CAACP,aAAA,EAAe;4BAC3BN,MAAA,EAAQF,UAAA,CAAWE,MAAAA;wBACrB;oBACF;gBACF;gBAEA,OAAOW,SAAA;YACT;oUACA9B,OAAA;YACAiC,KAAA,EAAO;2TACLnC,aAAAA,AAAA,EAAW;oBACToC,UAAA,EAAY;wBACVC,IAAA,EAAM;4BACJC,SAAA,EAAW,MAAAA,CAAO,EAChBC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,GAAG,EACHC,gBAAAA,EACD;gCACC,iDAAA;gCACA,MAAMC,EAAA,GAAKJ,IAAA,EAAMK,KAAA,EAAOD,EAAA,IAAMJ,IAAA,EAAMK,KAAA;gCAEpC,IAAIH,GAAA,EAAKrC,OAAA,EAAS;oCAChB,MAAMyC,cAAA,GAEF,CAAC;oCAEL,IAAI;wCACF,mTAAMlD,WAAAA,AAAA,EAAS;4CACbgD,EAAA;4CACAG,cAAA,EAAgBP,IAAA,CAAKQ,UAAU;4CAC/BX,YAAA;4CACAY,IAAA,EAAMH,cAAA;4CACNR,KAAA;4CACAC,KAAA;4CACAW,GAAA,EAAK;4CACLT,cAAA;4CACAC,GAAA;4CACAC;wCACF;oCACF,EAAE,OAAOQ,OAAA,EAAS;wCAChB,sCAAA;wCACAC,OAAA,CAAQC,KAAK,CACX,kEACAF,OAAA,EACA,SACAX,IAAA;wCAEF,OAAO,CAAA,OAAA,CAAS;oCAClB;oCAEA,MAAMpC,GAAA,GAAMD,cAAA,CAAe2C,cAAA,EAAgBD,KAAA,EAAOzC,GAAA,IAAO,IAAIsC,GAAA,EAAKrC,OAAA;oCAElE;;mBAGA,IAAI,CAACyC,cAAA,EAAgBD,KAAA,EAAOS,QAAA,EAAUhD,UAAA,CAAW,UAAU;wCACzD,OAAO,CAAA,SAAA,EAAYF,GAAA,CAAA,4BAAA,EAAkC0C,cAAA,CAAeD,KAAK,EAAEU,QAAA,CAAA,IAAA,CAAc;oCAC3F;oCAEA;;mBAGA,IACE,CAACT,cAAA,EAAgBD,KAAA,EAAOW,KAAA,IACxB,CAACC,MAAA,CAAOC,IAAI,CAACZ,cAAA,EAAgBD,KAAA,EAAOW,KAAA,EAAOpC,MAAM,EACjD;wCACA,OAAO,CAAA,UAAA,EAAahB,GAAA,CAAA,OAAA,EAAa0C,cAAA,EAAgBD,KAAA,EAAOU,QAAA,CAAA,SAAA,EAAoBT,cAAA,EAAgBD,KAAA,EAAOc,KAAA,CAAA,WAAA,EAAmBb,cAAA,EAAgBD,KAAA,EAAOe,MAAA,CAAA,GAAA,CAAW;oCAC1J;oCAEA;;mBAGA,IAAIC,WAAA,GAAc;oCAElB,qDAAA;oCACA,IAAK,MAAMC,IAAA,IAAQhB,cAAA,CAAeD,KAAK,EAAEW,KAAA,CAAO;wCAC9C,MAAMO,SAAA,GAESjB,cAAA,CAAeD,KAAK,EAAEW,KAAK,CAACM,IAAA,CAAK;wCAEhD,kDAAA;wCACA,IACE,CAACC,SAAA,CAAUJ,KAAK,IAChB,CAACI,SAAA,CAAUH,MAAM,IACjB,CAACG,SAAA,CAAUT,QAAQ,IACnB,CAACS,SAAA,CAAUC,QAAQ,IACnB,CAACD,SAAA,CAAUR,QAAQ,IACnB,CAACQ,SAAA,CAAU3D,GAAG,EACd;4CACA;wCACF;wCACA,MAAM6D,YAAA,GAAe9D,cAAA,CAAe4D,SAAA,EAAW3D,GAAA,EAAKsC,GAAA,EAAKrC,OAAA;wCAEzDwD,WAAA,IAAe,CAAA,gBAAA,EAAmBI,YAAA,CAAA,qBAAA,EAAoCF,SAAA,CAAUJ,KAAK,CAAA,WAAA,EAAcI,SAAA,CAAUT,QAAQ,CAAA,EAAA,CAAI;oCAC3H;oCAEA,0BAAA;oCACAO,WAAA,IAAe,CAAA,UAAA,EAAazD,GAAA,CAAA,qBAAA,EAA2B0C,cAAA,CAAeD,KAAK,EAAEc,KAAA,CAAA,UAAA,EAAkBb,cAAA,CAAeD,KAAK,EAAEe,MAAA,CAAA,EAAA,CAAU;oCAC/HC,WAAA,IAAe;oCACf,OAAOA,WAAA;gCACT,OAAO;oCACL,OAAO,CAAA,UAAA,EAAajB,EAAA,CAAA,IAAA,CAAQ;gCAC9B;4BACF;4BACAsB,SAAA,EAAW;gWAACjE,oBAAA,CAAiBkE,OAAO;6BAAA;wBACtC;oBACF;oBACAC,YAAA,EAAcA,CAAC,EAAE5B,IAAI,EAAEE,GAAAA,EAAK;wBAC1B,IAAI,CAACF,IAAA,EAAM;4BACT,IAAI6B,YAAA,GAAwB,EAAE;4BAC9B,IAAK,MAAMpD,UAAA,IAAcH,KAAA,EAAOC,WAAA,CAAa;gCAC3CsD,YAAA,GAAeA,YAAA,CAAaC,MAAM,CAACxD,KAAA,EAAOC,WAAA,EAAA,CAAcE,UAAA,CAAW,EAAEE,MAAA;4BACvE;4BACA,OAAOkD,YAAA;wBACT;wBACA,MAAMpD,UAAA,GAAayB,GAAA,GAAMA,GAAA,CAAIrC,OAAO,CAACU,WAAW,CAACyB,IAAA,EAAMQ,UAAA,CAAW,GAAG;wBAErE,IAAI/B,UAAA,EAAY;4BACd,MAAMsD,qBAAA,GAAwBzD,KAAA,EAAOC,WAAA,EAAA,CAAcyB,IAAA,EAAMQ,UAAA,CAAW,EAAE7B,MAAA;4BAEtE,IAAIqD,KAAA,CAAMC,OAAO,CAACF,qBAAA,GAAwB;gCACxC,IAAI,CAACA,qBAAA,EAAuBnD,MAAA,EAAQ;oCAClC,OAAO;gCACT;gCACA,OAAOmD,qBAAA;4BACT;wBACF;wBACA,OAAO;oBACT;oBACAG,gBAAA,EAAkBA,CAAC,EAAElC,IAAAA,EAAM;wBACzB,OAAOA,IAAA,EAAMrB,MAAA;oBACf;oBACAwD,yBAAA,EAA2B;kWAAC5E,6BAAAA,AAAA,EAA2Be,KAAA;qBAAO;oBAC9D8D,KAAA,EAAO;wBACLC,SAAA,EAAW;4BACT,CAAC,EACCxC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdqC,WAAW,EACXC,kBAAkB,EAClBrC,GAAG,EACHC,gBAAAA,EACD;gCACC,IAAI,CAACH,IAAA,EAAMK,KAAA,EAAO;oCAChB,OAAOL,IAAA;gCACT;gCACA,MAAMvB,UAAA,GAAayB,GAAA,CAAIrC,OAAO,CAACU,WAAW,CAACyB,IAAA,EAAMQ,UAAA,CAAW;gCAE5D,IAAI,CAAC/B,UAAA,EAAY;oCACf,OAAOuB,IAAA;gCACT;gCACA,mBAAA;gCACA,MAAMI,EAAA,GAAKJ,IAAA,EAAMK,KAAA,EAAOD,EAAA,IAAMJ,IAAA,EAAMK,KAAA,CAAM,8BAAA;;gCAE1C,MAAMmC,aAAA,GACJlE,KAAA,EAAOmE,QAAA,KAAaC,SAAA,IAAapE,KAAA,EAAOmE,QAAA,GAAW3C,KAAA,GAAQxB,KAAA,EAAOmE,QAAA,GAAW3C,KAAA;gCAE/EyC,kBAAA,CAAmBI,IAAI,8SACrBvF,WAAAA,AAAA,EAAS;oCACPgD,EAAA;oCACAG,cAAA,EAAgB9B,UAAA,CAAWV,MAAM,CAACiB,IAAI;oCACtCa,YAAA;oCACAY,IAAA,EAAMT,IAAA;oCACNF,KAAA,EAAO0C,aAAA;oCACPzC,KAAA;oCACAW,GAAA,EAAK;oCACLT,cAAA;oCACAC,GAAA;oCACA0C,MAAA,EACEN,WAAA,EAAA,CAAc7D,UAAA,CAAWV,MAAM,CAACiB,IAAI,CAAC,IAAIP,UAAA,CAAWV,MAAM,CAAC8E,eAAe;oCAC5E1C;gCACF;gCAGF,OAAOH,IAAA;4BACT;yBAAA;oBAEJ;oBACAA,IAAA,mUAAMvC,mBAAA;oBACNqF,WAAA,EAAa;kVAACpF,mBAAAA,AAAA,EAAiBY,KAAA;qBAAA;gBACjC;aACD;YACDyE,2BAAA,EAA6BzE;QAC/B;IACF;IACAoC,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 4390, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4396, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'القاعدة الأفقية',\n  },\n  az: {\n    label: 'Üfüqi Xətt',\n  },\n  bg: {\n    label: 'Хоризонтална линия',\n  },\n  cs: {\n    label: 'Vodorovný pravítko',\n  },\n  da: {\n    label: 'Horisontal Regel',\n  },\n  de: {\n    label: 'Trennlinie',\n  },\n  en: {\n    label: 'Horizontal Rule',\n  },\n  es: {\n    label: 'Regla Horizontal',\n  },\n  et: {\n    label: 'Horisontaalne reegel',\n  },\n  fa: {\n    label: 'قاعده افقی',\n  },\n  fr: {\n    label: 'Règle horizontale',\n  },\n  he: {\n    label: 'קו אופקי',\n  },\n  hr: {\n    label: 'Vodoravna linija',\n  },\n  hu: {\n    label: 'Vízszintes vonal',\n  },\n  it: {\n    label: 'Regola Orizzontale',\n  },\n  ja: {\n    label: '水平線',\n  },\n  ko: {\n    label: '수평 규칙',\n  },\n  my: {\n    label: 'Peraturan Mendatar',\n  },\n  nb: {\n    label: 'Horisontal Regel',\n  },\n  nl: {\n    label: 'Horizontale Regel',\n  },\n  pl: {\n    label: 'Pozioma Linia',\n  },\n  pt: {\n    label: 'Regra Horizontal',\n  },\n  ro: {\n    label: 'Linie orizontală',\n  },\n  rs: {\n    label: 'Хоризонтална линија',\n  },\n  'rs-latin': {\n    label: 'Horizontalna linija',\n  },\n  ru: {\n    label: 'Горизонтальная линия',\n  },\n  sk: {\n    label: 'Vodorovná čiara',\n  },\n  sl: {\n    label: 'Vodoravna črta',\n  },\n  sv: {\n    label: 'Horisontell linje',\n  },\n  th: {\n    label: 'เส้นขอบแนวนอน',\n  },\n  tr: {\n    label: 'Yatay Çizgi',\n  },\n  uk: {\n    label: 'Горизонтальна лінія',\n  },\n  vi: {\n    label: 'Quy tắc ngang',\n  },\n  zh: {\n    label: '水平线',\n  },\n  'zh-TW': {\n    label: '水平線',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":";;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 4506, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4512, "column": 0}, "map": {"version":3,"file":"HorizontalRuleNode.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/server/nodes/HorizontalRuleNode.tsx"],"sourcesContent":["import type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalCommand,\n  LexicalNode,\n  SerializedLexicalNode,\n  Spread,\n} from 'lexical'\nimport type * as React from 'react'\n\nimport { addClassNamesToElement } from '@lexical/utils'\nimport { $applyNodeReplacement, createCommand, DecoratorNode } from 'lexical'\n\n/**\n * Serialized representation of a horizontal rule node. Serialized = converted to JSON. This is what is stored in the database / in the lexical editor state.\n */\nexport type SerializedHorizontalRuleNode = Spread<\n  {\n    children?: never // required so that our typed editor state doesn't automatically add children\n    type: 'horizontalrule'\n  },\n  SerializedLexicalNode\n>\n\nexport const INSERT_HORIZONTAL_RULE_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_HORIZONTAL_RULE_COMMAND',\n)\n\n/**\n * This node is a DecoratorNode. DecoratorNodes allow you to render React components in the editor.\n *\n * They need both createDom and decorate functions. createDom => outside of the html. decorate => React Component inside of the html.\n *\n * If we used DecoratorBlockNode instead, we would only need a decorate method\n */\nexport class HorizontalRuleServerNode extends DecoratorNode<null | React.ReactElement> {\n  static override clone(node: HorizontalRuleServerNode): HorizontalRuleServerNode {\n    return new this(node.__key)\n  }\n\n  static override getType(): string {\n    return 'horizontalrule'\n  }\n\n  /**\n   * Defines what happens if you copy an hr element from another page and paste it into the lexical editor\n   *\n   * This also determines the behavior of lexical's internal HTML -> Lexical converter\n   */\n  static override importDOM(): DOMConversionMap | null {\n    return {\n      hr: () => ({\n        conversion: $convertHorizontalRuleElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  /**\n   * The data for this node is stored serialized as JSON. This is the \"load function\" of that node: it takes the saved data and converts it into a node.\n   */\n  static override importJSON(\n    serializedNode: SerializedHorizontalRuleNode,\n  ): HorizontalRuleServerNode {\n    return $createHorizontalRuleServerNode()\n  }\n\n  /**\n   * Determines how the hr element is rendered in the lexical editor. This is only the \"initial\" / \"outer\" HTML element.\n   */\n  override createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('hr')\n    addClassNamesToElement(element, config.theme.hr)\n    return element\n  }\n\n  override decorate(): null | React.ReactElement {\n    return null\n  }\n\n  /**\n   * Opposite of importDOM, this function defines what happens when you copy an hr element from the lexical editor and paste it into another page.\n   *\n   * This also determines the behavior of lexical's internal Lexical -> HTML converter\n   */\n  override exportDOM(): DOMExportOutput {\n    return { element: document.createElement('hr') }\n  }\n  /**\n   * Opposite of importJSON. This determines what data is saved in the database / in the lexical editor state.\n   */\n  override exportJSON(): SerializedLexicalNode {\n    return {\n      type: 'horizontalrule',\n      version: 1,\n    }\n  }\n\n  override getTextContent(): string {\n    return '\\n'\n  }\n\n  override isInline(): false {\n    return false\n  }\n\n  override updateDOM(): boolean {\n    return false\n  }\n}\n\nfunction $convertHorizontalRuleElement(): DOMConversionOutput {\n  return { node: $createHorizontalRuleServerNode() }\n}\n\nexport function $createHorizontalRuleServerNode(): HorizontalRuleServerNode {\n  return $applyNodeReplacement(new HorizontalRuleServerNode())\n}\n\nexport function $isHorizontalRuleServerNode(\n  node: LexicalNode | null | undefined,\n): node is HorizontalRuleServerNode {\n  return node instanceof HorizontalRuleServerNode\n}\n"],"names":["addClassNamesToElement","$applyNodeReplacement","createCommand","DecoratorNode","INSERT_HORIZONTAL_RULE_COMMAND","HorizontalRuleServerNode","clone","node","__key","getType","importDOM","hr","conversion","$convertHorizontalRuleElement","priority","importJSON","serializedNode","$createHorizontalRuleServerNode","createDOM","config","element","document","createElement","theme","decorate","exportDOM","exportJSON","type","version","getTextContent","isInline","updateDOM","$isHorizontalRuleServerNode"],"mappings":";;;;;;AAaA,SAASC,qBAAqB,EAAEC,aAAa,EAAEC,aAAa,QAAQ;AADpE,SAASH,sBAAsB,QAAQ;;;AAchC,MAAMI,8BAAA,yMAAuDF,gBAAAA,AAAA,EAClE;AAUK,MAAMG,wBAAA,2MAAiCF,gBAAA;IAC5C,OAAgBG,MAAMC,IAA8B,EAA4B;QAC9E,OAAO,IAAI,IAAI,CAACA,IAAA,CAAKC,KAAK;IAC5B;IAEA,OAAgBC,QAAA,EAAkB;QAChC,OAAO;IACT;IAEA;;;;KAKA,OAAgBC,UAAA,EAAqC;QACnD,OAAO;YACLC,EAAA,EAAIA,CAAA,GAAA,CAAO;oBACTC,UAAA,EAAYC,6BAAA;oBACZC,QAAA,EAAU;gBACZ,CAAA;QACF;IACF;IAEA;;KAGA,OAAgBC,WACdC,cAA4C,EAClB;QAC1B,OAAOC,+BAAA;IACT;IAEA;;KAGAC,SAASA,CAAUC,MAAoB,EAAe;QACpD,MAAMC,OAAA,GAAUC,QAAA,CAASC,aAAa,CAAC;yPACvCtB,yBAAAA,AAAA,EAAuBoB,OAAA,EAASD,MAAA,CAAOI,KAAK,CAACZ,EAAE;QAC/C,OAAOS,OAAA;IACT;IAESI,SAAA,EAAsC;QAC7C,OAAO;IACT;IAEA;;;;KAKAC,SAASA,CAAA,EAA6B;QACpC,OAAO;YAAEL,OAAA,EAASC,QAAA,CAASC,aAAa,CAAC;QAAM;IACjD;IACA;;KAGAI,UAASA,CAAA,EAAoC;QAC3C,OAAO;YACLC,IAAA,EAAM;YACNC,OAAA,EAAS;QACX;IACF;IAESC,eAAA,EAAyB;QAChC,OAAO;IACT;IAESC,SAAA,EAAkB;QACzB,OAAO;IACT;IAESC,UAAA,EAAqB;QAC5B,OAAO;IACT;AACF;AAEA,SAASlB,8BAAA;IACP,OAAO;QAAEN,IAAA,EAAMU,+BAAA;IAAkC;AACnD;AAEO,SAASA,gCAAA;IACd,6MAAOhB,wBAAAA,AAAA,EAAsB,IAAII,wBAAA;AACnC;AAEO,SAAS2B,4BACdzB,IAAoC;IAEpC,OAAOA,IAAA,YAAgBF,wBAAA;AACzB","ignoreList":[0]}},
    {"offset": {"line": 4595, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4601, "column": 0}, "map": {"version":3,"file":"markdownTransformer.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/server/markdownTransformer.ts"],"sourcesContent":["import type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport {\n  $createHorizontalRuleServerNode,\n  $isHorizontalRuleServerNode,\n  HorizontalRuleServerNode,\n} from './nodes/HorizontalRuleNode.js'\n\nexport const MarkdownTransformer: ElementTransformer = {\n  type: 'element',\n  dependencies: [HorizontalRuleServerNode],\n  export: (node, exportChildren) => {\n    if (!$isHorizontalRuleServerNode(node)) {\n      return null\n    }\n    return '---'\n  },\n  // match ---\n  regExp: /^---\\s*$/,\n  replace: (parentNode) => {\n    const node = $createHorizontalRuleServerNode()\n    if (node) {\n      parentNode.replace(node)\n    }\n  },\n}\n"],"names":["$createHorizontalRuleServerNode","$isHorizontalRuleServerNode","HorizontalRuleServerNode","MarkdownTransformer","type","dependencies","export","node","exportChildren","regExp","replace","parentNode"],"mappings":";;;AAEA,SACEA,+BAA+B,EAC/BC,2BAA2B,EAC3BC,wBAAwB,QACnB;;AAEA,MAAMC,mBAAA,GAA0C;IACrDC,IAAA,EAAM;IACNC,YAAA,EAAc;yVAACH,2BAAA;KAAyB;IACxCI,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,IAAI,sVAACP,8BAAAA,AAAA,EAA4BM,IAAA,GAAO;YACtC,OAAO;QACT;QACA,OAAO;IACT;IACA,YAAA;IACAE,MAAA,EAAQ;IACRC,OAAA,GAAUC,UAAA;QACR,MAAMJ,IAAA,wVAAOP,kCAAAA,AAAA;QACb,IAAIO,IAAA,EAAM;YACRI,UAAA,CAAWD,OAAO,CAACH,IAAA;QACrB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 4626, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4632, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { i18n } from './i18n.js'\nimport { MarkdownTransformer } from './markdownTransformer.js'\nimport { HorizontalRuleServerNode } from './nodes/HorizontalRuleNode.js'\n\nexport const HorizontalRuleFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#HorizontalRuleFeatureClient',\n    i18n,\n    markdownTransformers: [MarkdownTransformer],\n    nodes: [\n      createNode({\n        converters: {\n          html: {\n            converter: () => {\n              return `<hr/>`\n            },\n            nodeTypes: [HorizontalRuleServerNode.getType()],\n          },\n        },\n        node: HorizontalRuleServerNode,\n      }),\n    ],\n  },\n  key: 'horizontalRule',\n})\n"],"names":["createServerFeature","createNode","i18n","MarkdownTransformer","HorizontalRuleServerNode","HorizontalRuleFeature","feature","ClientFeature","markdownTransformers","nodes","converters","html","converter","nodeTypes","getType","node","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;AAEpC,SAASE,IAAI,QAAQ;AACrB,SAASC,mBAAmB,QAAQ;AAFpC,SAASF,UAAU,QAAQ;AAG3B,SAASG,wBAAwB,QAAQ;;;;;;AAElC,MAAMC,qBAAA,qTAAwBL,sBAAAA,AAAA,EAAoB;IACvDM,OAAA,EAAS;QACPC,aAAA,EAAe;cACfL,iUAAA;QACAM,oBAAA,EAAsB;qVAACL,sBAAA;SAAoB;QAC3CM,KAAA,EAAO;uTACLR,aAAA,AAAAA,EAAW;gBACTS,UAAA,EAAY;oBACVC,IAAA,EAAM;wBACJC,SAAA,EAAWA,CAAA;4BACT,OAAO,CAAA,KAAA,CAAO;wBAChB;wBACAC,SAAA,EAAW;4BAACT,4WAAA,CAAyBU,OAAO;yBAAA;oBAC9C;gBACF;gBACAC,IAAA,mVAAMX,2BAAAA;YACR;SAAA;IAEJ;IACAY,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 4670, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4676, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/features/toolbars/inline/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../../utilities/createServerFeature.js'\n\nexport const InlineToolbarFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#InlineToolbarFeatureClient',\n  },\n  key: 'toolbarInline',\n})\n"],"names":["createServerFeature","InlineToolbarFeature","feature","ClientFeature","key"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,oBAAA,qTAAuBD,sBAAAA,AAAA,EAAoB;IACtDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 4687, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4693, "column": 0}, "map": {"version":3,"file":"default.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/lexical/config/server/default.ts"],"sourcesContent":["import type { EditorConfig as LexicalEditorConfig } from 'lexical'\n\nimport type { FeatureProviderServer } from '../../../features/typesServer.js'\nimport type { ServerEditorConfig } from '../types.js'\n\nimport { AlignFeature } from '../../../features/align/server/index.js'\nimport { BlockquoteFeature } from '../../../features/blockquote/server/index.js'\nimport { BoldFeature } from '../../../features/format/bold/feature.server.js'\nimport { InlineCodeFeature } from '../../../features/format/inlineCode/feature.server.js'\nimport { ItalicFeature } from '../../../features/format/italic/feature.server.js'\nimport { StrikethroughFeature } from '../../../features/format/strikethrough/feature.server.js'\nimport { SubscriptFeature } from '../../../features/format/subscript/feature.server.js'\nimport { SuperscriptFeature } from '../../../features/format/superscript/feature.server.js'\nimport { UnderlineFeature } from '../../../features/format/underline/feature.server.js'\nimport { HeadingFeature } from '../../../features/heading/server/index.js'\nimport { HorizontalRuleFeature } from '../../../features/horizontalRule/server/index.js'\nimport { IndentFeature } from '../../../features/indent/server/index.js'\nimport { LinkFeature } from '../../../features/link/server/index.js'\nimport { ChecklistFeature } from '../../../features/lists/checklist/server/index.js'\nimport { OrderedListFeature } from '../../../features/lists/orderedList/server/index.js'\nimport { UnorderedListFeature } from '../../../features/lists/unorderedList/server/index.js'\nimport { ParagraphFeature } from '../../../features/paragraph/server/index.js'\nimport { RelationshipFeature } from '../../../features/relationship/server/index.js'\nimport { InlineToolbarFeature } from '../../../features/toolbars/inline/server/index.js'\nimport { UploadFeature } from '../../../features/upload/server/feature.server.js'\nimport { LexicalEditorTheme } from '../../theme/EditorTheme.js'\n\nexport const defaultEditorLexicalConfig: LexicalEditorConfig = {\n  namespace: 'lexical',\n  theme: LexicalEditorTheme,\n}\n\nexport const defaultEditorFeatures: FeatureProviderServer<any, any, any>[] = [\n  BoldFeature(),\n  ItalicFeature(),\n  UnderlineFeature(),\n  StrikethroughFeature(),\n  SubscriptFeature(),\n  SuperscriptFeature(),\n  InlineCodeFeature(),\n  ParagraphFeature(),\n  HeadingFeature(),\n  AlignFeature(),\n  IndentFeature(),\n  UnorderedListFeature(),\n  OrderedListFeature(),\n  ChecklistFeature(),\n  LinkFeature(),\n  RelationshipFeature(),\n  BlockquoteFeature(),\n  UploadFeature(),\n  HorizontalRuleFeature(),\n  InlineToolbarFeature(),\n]\n\nexport const defaultEditorConfig: ServerEditorConfig = {\n  features: defaultEditorFeatures,\n  lexical: defaultEditorLexicalConfig,\n}\n"],"names":["AlignFeature","BlockquoteFeature","BoldFeature","InlineCodeFeature","ItalicFeature","StrikethroughFeature","SubscriptFeature","SuperscriptFeature","UnderlineFeature","HeadingFeature","HorizontalRuleFeature","IndentFeature","LinkFeature","ChecklistFeature","OrderedListFeature","UnorderedListFeature","ParagraphFeature","RelationshipFeature","InlineToolbarFeature","UploadFeature","LexicalEditorTheme","defaultEditorLexicalConfig","namespace","theme","defaultEditorFeatures","defaultEditorConfig","features","lexical"],"mappings":";;;;;AAyBA,SAASoB,kBAAkB,QAAQ;AAlBnC,SAASlB,WAAW,QAAQ;AAE5B,SAASE,aAAa,QAAQ;AAI9B,SAASI,gBAAgB,QAAQ;AAHjC,SAASH,oBAAoB,QAAQ;AACrC,SAASC,gBAAgB,QAAQ;AACjC,SAASC,kBAAkB,QAAQ;AAJnC,SAASJ,iBAAiB,QAAQ;AAalC,SAASa,gBAAgB,QAAQ;AAPjC,SAASP,cAAc,QAAQ;AAT/B,SAAST,YAAY,QAAQ;AAW7B,SAASW,aAAa,QAAQ;AAI9B,SAASI,oBAAoB,QAAQ;AADrC,SAASD,kBAAkB,QAAQ;AADnC,SAASD,gBAAgB,QAAQ;AADjC,SAASD,WAAW,QAAQ;AAK5B,SAASK,mBAAmB,QAAQ;AAhBpC,SAAShB,iBAAiB,QAAQ;AAkBlC,SAASkB,aAAa,QAAQ;AAT9B,SAAST,qBAAqB,QAAQ;AAQtC,SAASQ,oBAAoB,QAAQ;;;;;;;;;;;;;;;;;;;;;;AAI9B,MAAMG,0BAAA,GAAkD;IAC7DC,SAAA,EAAW;IACXC,KAAA,8SAAOH,sBAAAA;AACT;AAEO,MAAMI,qBAAA,GAAgE;qUAC3EtB,cAAAA,AAAA;uUACAE,gBAAAA,AAAA;KACAI,wVAAAA,AAAA;8UACAH,uBAAAA,AAAA;0UACAC,mBAAA,AAAAA;4UACAC,qBAAAA,AAAA;IACAJ,2VAAAA,AAAA;8TACAa,mBAAAA,AAAA;4TACAP,iBAAAA,AAAA;KACAT,oUAAAA,AAAA;2TACAW,gBAAAA,AAAA;2UACAI,uBAAAA,AAAA;IACAD,0VAAAA,AAAA;uUACAD,mBAAAA,AAAA;yTACAD,cAAAA,AAAA;KACAK,kVAAAA,AAAA;+TACAhB,oBAAAA,AAAA;uUACAkB,gBAAAA,AAAA;mUACAT,wBAAAA,AAAA;uUACAQ,uBAAAA,AAAA;CACD;AAEM,MAAMO,mBAAA,GAA0C;IACrDC,QAAA,EAAUF,qBAAA;IACVG,OAAA,EAASN;AACX","ignoreList":[0]}},
    {"offset": {"line": 4770, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4776, "column": 0}, "map": {"version":3,"file":"loader.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/lexical/config/server/loader.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  FeatureProviderServer,\n  ResolvedServerFeature,\n  ResolvedServerFeatureMap,\n  ServerFeatureProviderMap,\n} from '../../../features/typesServer.js'\nimport type { ServerEditorConfig } from '../types.js'\n\ntype DependencyGraph = {\n  [key: string]: {\n    dependencies: string[]\n    dependenciesPriority: string[]\n    dependenciesSoft: string[]\n    featureProvider: FeatureProviderServer<unknown, unknown, unknown>\n  }\n}\n\nfunction createDependencyGraph(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): DependencyGraph {\n  const graph: DependencyGraph = {}\n  for (const fp of featureProviders) {\n    graph[fp.key] = {\n      dependencies: fp.dependencies || [],\n      dependenciesPriority: fp.dependenciesPriority || [],\n      dependenciesSoft: fp.dependenciesSoft || [],\n      featureProvider: fp,\n    }\n  }\n  return graph\n}\n\nfunction topologicallySortFeatures(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): FeatureProviderServer<unknown, unknown, unknown>[] {\n  const graph = createDependencyGraph(featureProviders)\n  const visited: { [key: string]: boolean } = {}\n  const stack: FeatureProviderServer<unknown, unknown, unknown>[] = []\n\n  for (const key in graph) {\n    if (!visited[key]) {\n      visit(graph, key, visited, stack)\n    }\n  }\n\n  return stack.reverse()\n}\n\nfunction visit(\n  graph: DependencyGraph,\n  key: string,\n  visited: { [key: string]: boolean },\n  stack: FeatureProviderServer<unknown, unknown, unknown>[],\n  currentPath: string[] = [],\n) {\n  if (!graph[key]) {\n    throw new Error(`Feature key ${key} is not present in the dependency graph.`)\n  }\n\n  if (currentPath.includes(key)) {\n    throw new Error(`Circular dependency detected: ${currentPath.join(' -> ')} -> ${key}`)\n  }\n\n  if (visited[key]) {\n    return\n  }\n\n  visited[key] = true\n  currentPath.push(key)\n\n  // First process the hard priority dependencies\n  for (const dep of graph[key].dependenciesPriority) {\n    if (!visited[dep]) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  // Then process the normal dependencies, but make sure to not violate hard dependencies\n  for (const dep of graph[key].dependencies) {\n    if (!visited[dep] && !graph[key].dependenciesPriority.includes(dep)) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  // Then process the soft dependencies. Make sure to not violate hard and normal dependencies.\n  for (const dep of graph[key].dependenciesSoft) {\n    if (\n      graph[dep] &&\n      !visited[dep] &&\n      !graph[key].dependenciesPriority.includes(dep) &&\n      !graph[key].dependencies.includes(dep)\n    ) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  stack.push(graph[key].featureProvider)\n  currentPath.pop()\n}\n\nexport function sortFeaturesForOptimalLoading(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): FeatureProviderServer<unknown, unknown, unknown>[] {\n  return topologicallySortFeatures(featureProviders)\n}\n\nexport async function loadFeatures({\n  config,\n  isRoot,\n  parentIsLocalized,\n  unSanitizedEditorConfig,\n}: {\n  config: SanitizedConfig\n  isRoot?: boolean\n  parentIsLocalized: boolean\n  unSanitizedEditorConfig: ServerEditorConfig\n}): Promise<ResolvedServerFeatureMap> {\n  // First remove all duplicate features. The LAST feature with a given key wins.\n  unSanitizedEditorConfig.features = unSanitizedEditorConfig.features\n    .reverse()\n    .filter((f, i, arr) => {\n      const firstIndex = arr.findIndex((f2) => f2.key === f.key)\n      return firstIndex === i\n    })\n    .reverse()\n\n  unSanitizedEditorConfig.features = sortFeaturesForOptimalLoading(unSanitizedEditorConfig.features)\n\n  const featureProviderMap: ServerFeatureProviderMap = new Map(\n    unSanitizedEditorConfig.features.map(\n      (f) => [f.key, f] as [string, FeatureProviderServer<unknown, unknown, unknown>],\n    ),\n  )\n\n  const resolvedFeatures: ResolvedServerFeatureMap = new Map()\n\n  // Make sure all dependencies declared in the respective features exist\n  let loaded = 0\n  for (const featureProvider of unSanitizedEditorConfig.features) {\n    if (!featureProvider.key) {\n      throw new Error(\n        `A Feature you've added does not have a key. Please add a key to the feature. This is used to uniquely identify the feature.`,\n      )\n    }\n    if (featureProvider.dependencies?.length) {\n      for (const dependencyKey of featureProvider.dependencies) {\n        const found = unSanitizedEditorConfig.features.find((f) => f.key === dependencyKey)\n        if (!found) {\n          throw new Error(\n            `Feature ${featureProvider.key} has a dependency ${dependencyKey} which does not exist.`,\n          )\n        }\n      }\n    }\n\n    if (featureProvider.dependenciesPriority?.length) {\n      for (const priorityDependencyKey of featureProvider.dependenciesPriority) {\n        // look in the resolved features instead of the editorConfig.features, as a dependency requires the feature to be loaded before it, contrary to a soft-dependency\n        const found = resolvedFeatures.get(priorityDependencyKey)\n        if (!found) {\n          const existsInEditorConfig = unSanitizedEditorConfig.features.find(\n            (f) => f.key === priorityDependencyKey,\n          )\n          if (!existsInEditorConfig) {\n            throw new Error(\n              `Feature ${featureProvider.key} has a priority dependency ${priorityDependencyKey} which does not exist.`,\n            )\n          } else {\n            throw new Error(\n              `Feature ${featureProvider.key} has a priority dependency ${priorityDependencyKey} which is not loaded before it.`,\n            )\n          }\n        }\n      }\n    }\n\n    const feature =\n      typeof featureProvider.feature === 'function'\n        ? await featureProvider.feature({\n            config,\n            featureProviderMap,\n            isRoot,\n            parentIsLocalized,\n            resolvedFeatures,\n            unSanitizedEditorConfig,\n          })\n        : featureProvider.feature\n\n    const resolvedFeature: ResolvedServerFeature<any, any> = feature as ResolvedServerFeature<\n      any,\n      any\n    >\n\n    // All these new properties would be added to the feature, as it's mutated. However, this does not cause any damage and allows\n    // us to prevent an unnecessary spread operation.\n    resolvedFeature.key = featureProvider.key\n    resolvedFeature.order = loaded\n    resolvedFeature.dependencies = featureProvider.dependencies!\n    resolvedFeature.dependenciesPriority = featureProvider.dependenciesPriority!\n    resolvedFeature.dependenciesSoft = featureProvider.dependenciesSoft!\n\n    resolvedFeatures.set(featureProvider.key, resolvedFeature)\n\n    loaded++\n  }\n\n  return resolvedFeatures\n}\n"],"names":["createDependencyGraph","featureProviders","graph","fp","key","dependencies","dependenciesPriority","dependenciesSoft","featureProvider","topologicallySortFeatures","visited","stack","visit","reverse","currentPath","Error","includes","join","push","dep","pop","sortFeaturesForOptimalLoading","loadFeatures","config","isRoot","parentIsLocalized","unSanitizedEditorConfig","features","filter","f","i","arr","firstIndex","findIndex","f2","featureProviderMap","Map","map","resolvedFeatures","loaded","length","dependencyKey","found","find","priorityDependencyKey","get","existsInEditorConfig","feature","resolvedFeature","order","set"],"mappings":";;;;AAmBA,SAASA,sBACPC,gBAAoE;IAEpE,MAAMC,KAAA,GAAyB,CAAC;IAChC,KAAK,MAAMC,EAAA,IAAMF,gBAAA,CAAkB;QACjCC,KAAK,CAACC,EAAA,CAAGC,GAAG,CAAC,GAAG;YACdC,YAAA,EAAcF,EAAA,CAAGE,YAAY,IAAI,EAAE;YACnCC,oBAAA,EAAsBH,EAAA,CAAGG,oBAAoB,IAAI,EAAE;YACnDC,gBAAA,EAAkBJ,EAAA,CAAGI,gBAAgB,IAAI,EAAE;YAC3CC,eAAA,EAAiBL;QACnB;IACF;IACA,OAAOD,KAAA;AACT;AAEA,SAASO,0BACPR,gBAAoE;IAEpE,MAAMC,KAAA,GAAQF,qBAAA,CAAsBC,gBAAA;IACpC,MAAMS,OAAA,GAAsC,CAAC;IAC7C,MAAMC,KAAA,GAA4D,EAAE;IAEpE,IAAK,MAAMP,GAAA,IAAOF,KAAA,CAAO;QACvB,IAAI,CAACQ,OAAO,CAACN,GAAA,CAAI,EAAE;YACjBQ,KAAA,CAAMV,KAAA,EAAOE,GAAA,EAAKM,OAAA,EAASC,KAAA;QAC7B;IACF;IAEA,OAAOA,KAAA,CAAME,OAAO;AACtB;AAEA,SAASD,MACPV,KAAsB,EACtBE,GAAW,EACXM,OAAmC,EACnCC,KAAyD,EACzDG,WAAA,GAAwB,EAAE;IAE1B,IAAI,CAACZ,KAAK,CAACE,GAAA,CAAI,EAAE;QACf,MAAM,IAAIW,KAAA,CAAM,CAAA,YAAA,EAAeX,GAAA,CAAA,wCAAA,CAA6C;IAC9E;IAEA,IAAIU,WAAA,CAAYE,QAAQ,CAACZ,GAAA,GAAM;QAC7B,MAAM,IAAIW,KAAA,CAAM,CAAA,8BAAA,EAAiCD,WAAA,CAAYG,IAAI,CAAC,QAAA,IAAA,EAAcb,GAAA,EAAK;IACvF;IAEA,IAAIM,OAAO,CAACN,GAAA,CAAI,EAAE;QAChB;IACF;IAEAM,OAAO,CAACN,GAAA,CAAI,GAAG;IACfU,WAAA,CAAYI,IAAI,CAACd,GAAA;IAEjB,+CAAA;IACA,KAAK,MAAMe,GAAA,IAAOjB,KAAK,CAACE,GAAA,CAAI,CAACE,oBAAoB,CAAE;QACjD,IAAI,CAACI,OAAO,CAACS,GAAA,CAAI,EAAE;YACjBP,KAAA,CAAMV,KAAA,EAAOiB,GAAA,EAAKT,OAAA,EAASC,KAAA,EAAOG,WAAA;QACpC;IACF;IAEA,uFAAA;IACA,KAAK,MAAMK,GAAA,IAAOjB,KAAK,CAACE,GAAA,CAAI,CAACC,YAAY,CAAE;QACzC,IAAI,CAACK,OAAO,CAACS,GAAA,CAAI,IAAI,CAACjB,KAAK,CAACE,GAAA,CAAI,CAACE,oBAAoB,CAACU,QAAQ,CAACG,GAAA,GAAM;YACnEP,KAAA,CAAMV,KAAA,EAAOiB,GAAA,EAAKT,OAAA,EAASC,KAAA,EAAOG,WAAA;QACpC;IACF;IAEA,6FAAA;IACA,KAAK,MAAMK,GAAA,IAAOjB,KAAK,CAACE,GAAA,CAAI,CAACG,gBAAgB,CAAE;QAC7C,IACEL,KAAK,CAACiB,GAAA,CAAI,IACV,CAACT,OAAO,CAACS,GAAA,CAAI,IACb,CAACjB,KAAK,CAACE,GAAA,CAAI,CAACE,oBAAoB,CAACU,QAAQ,CAACG,GAAA,KAC1C,CAACjB,KAAK,CAACE,GAAA,CAAI,CAACC,YAAY,CAACW,QAAQ,CAACG,GAAA,GAClC;YACAP,KAAA,CAAMV,KAAA,EAAOiB,GAAA,EAAKT,OAAA,EAASC,KAAA,EAAOG,WAAA;QACpC;IACF;IAEAH,KAAA,CAAMO,IAAI,CAAChB,KAAK,CAACE,GAAA,CAAI,CAACI,eAAe;IACrCM,WAAA,CAAYM,GAAG;AACjB;AAEO,SAASC,8BACdpB,gBAAoE;IAEpE,OAAOQ,yBAAA,CAA0BR,gBAAA;AACnC;AAEO,eAAeqB,aAAa,EACjCC,MAAM,EACNC,MAAM,EACNC,iBAAiB,EACjBC,uBAAAA,EAMD;IACC,+EAAA;IACAA,uBAAA,CAAwBC,QAAQ,GAAGD,uBAAA,CAAwBC,QAAQ,CAChEd,OAAO,GACPe,MAAM,CAAC,CAACC,CAAA,EAAGC,CAAA,EAAGC,GAAA;QACb,MAAMC,UAAA,GAAaD,GAAA,CAAIE,SAAS,EAAEC,EAAA,GAAOA,EAAA,CAAG9B,GAAG,KAAKyB,CAAA,CAAEzB,GAAG;QACzD,OAAO4B,UAAA,KAAeF,CAAA;IACxB,GACCjB,OAAO;IAEVa,uBAAA,CAAwBC,QAAQ,GAAGN,6BAAA,CAA8BK,uBAAA,CAAwBC,QAAQ;IAEjG,MAAMQ,kBAAA,GAA+C,IAAIC,GAAA,CACvDV,uBAAA,CAAwBC,QAAQ,CAACU,GAAG,EACjCR,CAAA,GAAM;YAACA,CAAA,CAAEzB,GAAG;YAAEyB,CAAA;SAAE;IAIrB,MAAMS,gBAAA,GAA6C,IAAIF,GAAA;IAEvD,uEAAA;IACA,IAAIG,MAAA,GAAS;IACb,KAAK,MAAM/B,eAAA,IAAmBkB,uBAAA,CAAwBC,QAAQ,CAAE;QAC9D,IAAI,CAACnB,eAAA,CAAgBJ,GAAG,EAAE;YACxB,MAAM,IAAIW,KAAA,CACR,CAAA,2HAAA,CAA6H;QAEjI;QACA,IAAIP,eAAA,CAAgBH,YAAY,EAAEmC,MAAA,EAAQ;YACxC,KAAK,MAAMC,aAAA,IAAiBjC,eAAA,CAAgBH,YAAY,CAAE;gBACxD,MAAMqC,KAAA,GAAQhB,uBAAA,CAAwBC,QAAQ,CAACgB,IAAI,EAAEd,CAAA,GAAMA,CAAA,CAAEzB,GAAG,KAAKqC,aAAA;gBACrE,IAAI,CAACC,KAAA,EAAO;oBACV,MAAM,IAAI3B,KAAA,CACR,CAAA,QAAA,EAAWP,eAAA,CAAgBJ,GAAG,CAAA,kBAAA,EAAqBqC,aAAA,CAAA,sBAAA,CAAqC;gBAE5F;YACF;QACF;QAEA,IAAIjC,eAAA,CAAgBF,oBAAoB,EAAEkC,MAAA,EAAQ;YAChD,KAAK,MAAMI,qBAAA,IAAyBpC,eAAA,CAAgBF,oBAAoB,CAAE;gBACxE,iKAAA;gBACA,MAAMoC,KAAA,GAAQJ,gBAAA,CAAiBO,GAAG,CAACD,qBAAA;gBACnC,IAAI,CAACF,KAAA,EAAO;oBACV,MAAMI,oBAAA,GAAuBpB,uBAAA,CAAwBC,QAAQ,CAACgB,IAAI,EAC/Dd,CAAA,GAAMA,CAAA,CAAEzB,GAAG,KAAKwC,qBAAA;oBAEnB,IAAI,CAACE,oBAAA,EAAsB;wBACzB,MAAM,IAAI/B,KAAA,CACR,CAAA,QAAA,EAAWP,eAAA,CAAgBJ,GAAG,CAAA,2BAAA,EAA8BwC,qBAAA,CAAA,sBAAA,CAA6C;oBAE7G,OAAO;wBACL,MAAM,IAAI7B,KAAA,CACR,CAAA,QAAA,EAAWP,eAAA,CAAgBJ,GAAG,CAAA,2BAAA,EAA8BwC,qBAAA,CAAA,+BAAA,CAAsD;oBAEtH;gBACF;YACF;QACF;QAEA,MAAMG,OAAA,GACJ,OAAOvC,eAAA,CAAgBuC,OAAO,KAAK,aAC/B,MAAMvC,eAAA,CAAgBuC,OAAO,CAAC;YAC5BxB,MAAA;YACAY,kBAAA;YACAX,MAAA;YACAC,iBAAA;YACAa,gBAAA;YACAZ;QACF,KACAlB,eAAA,CAAgBuC,OAAO;QAE7B,MAAMC,eAAA,GAAmDD,OAAA;QAKzD,8HAAA;QACA,iDAAA;QACAC,eAAA,CAAgB5C,GAAG,GAAGI,eAAA,CAAgBJ,GAAG;QACzC4C,eAAA,CAAgBC,KAAK,GAAGV,MAAA;QACxBS,eAAA,CAAgB3C,YAAY,GAAGG,eAAA,CAAgBH,YAAY;QAC3D2C,eAAA,CAAgB1C,oBAAoB,GAAGE,eAAA,CAAgBF,oBAAoB;QAC3E0C,eAAA,CAAgBzC,gBAAgB,GAAGC,eAAA,CAAgBD,gBAAgB;QAEnE+B,gBAAA,CAAiBY,GAAG,CAAC1C,eAAA,CAAgBJ,GAAG,EAAE4C,eAAA;QAE1CT,MAAA;IACF;IAEA,OAAOD,gBAAA;AACT","ignoreList":[0]}},
    {"offset": {"line": 4900, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4906, "column": 0}, "map": {"version":3,"file":"sanitize.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/lexical/config/server/sanitize.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  ResolvedServerFeatureMap,\n  SanitizedServerFeatures,\n} from '../../../features/typesServer.js'\nimport type { SanitizedServerEditorConfig, ServerEditorConfig } from '../types.js'\n\nimport { loadFeatures } from './loader.js'\n\nexport const sanitizeServerFeatures = (\n  features: ResolvedServerFeatureMap,\n): SanitizedServerFeatures => {\n  const sanitized: SanitizedServerFeatures = {\n    converters: {\n      html: [],\n    },\n    enabledFeatures: [],\n    generatedTypes: {\n      modifyOutputSchemas: [],\n    },\n    getSubFields: new Map(),\n    getSubFieldsData: new Map(),\n    graphQLPopulationPromises: new Map(),\n    hooks: {\n      afterChange: [],\n      afterRead: [],\n      beforeChange: [],\n      beforeValidate: [],\n    },\n    i18n: {},\n    markdownTransformers: [],\n    nodeHooks: {\n      afterChange: new Map(),\n      afterRead: new Map(),\n      beforeChange: new Map(),\n      beforeValidate: new Map(),\n    },\n    nodes: [],\n\n    validations: new Map(),\n  }\n\n  if (!features?.size) {\n    return sanitized\n  }\n\n  features.forEach((feature) => {\n    if (feature?.generatedTypes?.modifyOutputSchema) {\n      sanitized.generatedTypes.modifyOutputSchemas.push(feature.generatedTypes.modifyOutputSchema)\n    }\n\n    if (feature?.hooks?.beforeValidate?.length) {\n      sanitized.hooks.beforeValidate = sanitized.hooks.beforeValidate?.concat(\n        feature.hooks.beforeValidate,\n      )\n    }\n    if (feature?.hooks?.beforeChange?.length) {\n      sanitized.hooks.beforeChange = sanitized.hooks.beforeChange?.concat(\n        feature.hooks.beforeChange,\n      )\n    }\n    if (feature?.hooks?.afterRead?.length) {\n      sanitized.hooks.afterRead = sanitized.hooks.afterRead?.concat(feature.hooks.afterRead)\n    }\n    if (feature?.hooks?.afterChange?.length) {\n      sanitized.hooks.afterChange = sanitized.hooks.afterChange?.concat(feature.hooks.afterChange)\n    }\n\n    if (feature?.i18n) {\n      for (const lang in feature.i18n) {\n        if (!sanitized.i18n[lang as keyof typeof sanitized.i18n]) {\n          sanitized.i18n[lang as keyof typeof sanitized.i18n] = {\n            lexical: {},\n          }\n        }\n        // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n        sanitized.i18n[lang].lexical[feature.key] = feature.i18n[lang]\n      }\n    }\n\n    if (feature.nodes?.length) {\n      // Do not concat here. We need to keep the object reference of sanitized.nodes so that function markdown transformers of features automatically get the updated nodes\n      for (const node of feature.nodes) {\n        sanitized.nodes.push(node)\n      }\n      feature.nodes.forEach((node) => {\n        const nodeType = 'with' in node.node ? node.node.replace.getType() : node.node.getType() // TODO: Idk if this works for node replacements\n        if (node?.graphQLPopulationPromises?.length) {\n          sanitized.graphQLPopulationPromises.set(nodeType, node.graphQLPopulationPromises)\n        }\n        if (node?.validations?.length) {\n          sanitized.validations.set(nodeType, node.validations)\n        }\n        if (node?.converters?.html) {\n          sanitized.converters.html.push(node.converters.html)\n        }\n        if (node?.hooks?.afterChange) {\n          sanitized.nodeHooks?.afterChange?.set(nodeType, node.hooks.afterChange)\n        }\n        if (node?.hooks?.afterRead) {\n          sanitized.nodeHooks?.afterRead?.set(nodeType, node.hooks.afterRead)\n        }\n        if (node?.hooks?.beforeChange) {\n          sanitized.nodeHooks?.beforeChange?.set(nodeType, node.hooks.beforeChange)\n        }\n        if (node?.hooks?.beforeValidate) {\n          sanitized.nodeHooks?.beforeValidate?.set(nodeType, node.hooks.beforeValidate)\n        }\n        if (node?.getSubFields) {\n          sanitized.getSubFields?.set(nodeType, node.getSubFields)\n        }\n        if (node?.getSubFieldsData) {\n          sanitized.getSubFieldsData?.set(nodeType, node.getSubFieldsData)\n        }\n      })\n    }\n\n    if (feature.markdownTransformers?.length) {\n      // Do not concat here. We need to keep the object reference of feature.markdownTransformers\n\n      for (const transformer of feature.markdownTransformers) {\n        if (typeof transformer === 'function') {\n          sanitized.markdownTransformers.push(\n            transformer({\n              allNodes: sanitized.nodes,\n              allTransformers: sanitized.markdownTransformers,\n            }),\n          )\n        } else {\n          sanitized.markdownTransformers.push(transformer)\n        }\n      }\n    }\n\n    sanitized.enabledFeatures.push(feature.key)\n  })\n\n  return sanitized\n}\n\nexport async function sanitizeServerEditorConfig(\n  editorConfig: ServerEditorConfig,\n  config: SanitizedConfig,\n  parentIsLocalized?: boolean,\n): Promise<SanitizedServerEditorConfig> {\n  const resolvedFeatureMap = await loadFeatures({\n    config,\n    parentIsLocalized: parentIsLocalized!,\n    unSanitizedEditorConfig: editorConfig,\n  })\n\n  return {\n    features: sanitizeServerFeatures(resolvedFeatureMap),\n    lexical: editorConfig.lexical!,\n    resolvedFeatureMap,\n  }\n}\n"],"names":["loadFeatures","sanitizeServerFeatures","features","sanitized","converters","html","enabledFeatures","generatedTypes","modifyOutputSchemas","getSubFields","Map","getSubFieldsData","graphQLPopulationPromises","hooks","afterChange","afterRead","beforeChange","beforeValidate","i18n","markdownTransformers","nodeHooks","nodes","validations","size","forEach","feature","modifyOutputSchema","push","length","concat","lang","lexical","key","node","nodeType","replace","getType","set","transformer","allNodes","allTransformers","sanitizeServerEditorConfig","editorConfig","config","parentIsLocalized","resolvedFeatureMap","unSanitizedEditorConfig"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5037, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5043, "column": 0}, "map": {"version":3,"file":"getDefaultSanitizedEditorConfig.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/getDefaultSanitizedEditorConfig.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport { type SanitizedServerEditorConfig } from './index.js'\nimport { defaultEditorConfig } from './lexical/config/server/default.js'\nimport { sanitizeServerEditorConfig } from './lexical/config/server/sanitize.js'\n\nlet cachedDefaultSanitizedServerEditorConfig:\n  | null\n  | Promise<SanitizedServerEditorConfig>\n  | SanitizedServerEditorConfig = (global as any)\n  ._payload_lexical_defaultSanitizedServerEditorConfig\n\nif (!cachedDefaultSanitizedServerEditorConfig) {\n  cachedDefaultSanitizedServerEditorConfig = (\n    global as any\n  )._payload_lexical_defaultSanitizedServerEditorConfig = null\n}\n\nexport const getDefaultSanitizedEditorConfig = async (args: {\n  config: SanitizedConfig\n  parentIsLocalized: boolean\n}): Promise<SanitizedServerEditorConfig> => {\n  const { config, parentIsLocalized } = args\n\n  if (cachedDefaultSanitizedServerEditorConfig) {\n    return await cachedDefaultSanitizedServerEditorConfig\n  }\n\n  cachedDefaultSanitizedServerEditorConfig = sanitizeServerEditorConfig(\n    defaultEditorConfig,\n    config,\n    parentIsLocalized,\n  )\n  ;(global as any).payload_lexical_defaultSanitizedServerEditorConfig =\n    cachedDefaultSanitizedServerEditorConfig\n\n  cachedDefaultSanitizedServerEditorConfig = await cachedDefaultSanitizedServerEditorConfig\n  ;(global as any).payload_lexical_defaultSanitizedServerEditorConfig =\n    cachedDefaultSanitizedServerEditorConfig\n\n  return cachedDefaultSanitizedServerEditorConfig\n}\n"],"names":["defaultEditorConfig","sanitizeServerEditorConfig","cachedDefaultSanitizedServerEditorConfig","global","_payload_lexical_defaultSanitizedServerEditorConfig","getDefaultSanitizedEditorConfig","args","config","parentIsLocalized","payload_lexical_defaultSanitizedServerEditorConfig"],"mappings":";;;AAIA,SAASC,0BAA0B,QAAQ;AAD3C,SAASD,mBAAmB,QAAQ;;;AAGpC,IAAIE,wCAAA,GAG8BC,MAAC,CAChCC,mDAAmD;AAEtD,IAAI,CAACF,wCAAA,EAA0C;IAC7CA,wCAAA,GAA2CC,MACzC,CACAC,mDAAmD,GAAG;AAC1D;AAEO,MAAMC,+BAAA,GAAkC,OAAOC,IAAA;IAIpD,MAAM,EAAEC,MAAM,EAAEC,iBAAAA,EAAmB,GAAGF,IAAA;IAEtC,IAAIJ,wCAAA,EAA0C;QAC5C,OAAO,MAAMA,wCAAA;IACf;IAEAA,wCAAA,4TAA2CD,6BAAAA,AAAA,sTACzCD,sBAAA,EACAO,MAAA,EACAC,iBAAA;IAEAL,MAAA,CAAeM,kDAAkD,GACjEP,wCAAA;IAEFA,wCAAA,GAA2C,MAAMA,wCAAA;IAC/CC,MAAA,CAAeM,kDAAkD,GACjEP,wCAAA;IAEF,OAAOA,wCAAA;AACT","ignoreList":[0]}},
    {"offset": {"line": 5065, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5071, "column": 0}, "map": {"version":3,"file":"i18n.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    placeholder: \"ابدأ بالكتابة، أو اضغط على '/' للأوامر ...\",\n    slashMenuBasicGroupLabel: 'أساسي',\n    slashMenuListGroupLabel: 'قوائم',\n    toolbarItemsActive: '{{count}} نشط',\n  },\n  az: {\n    placeholder: \"Yazmağa başlayın və ya əmrlər üçün '/' düyməsini basın...\",\n    slashMenuBasicGroupLabel: 'Əsas',\n    slashMenuListGroupLabel: 'Siyahılar',\n    toolbarItemsActive: '{{count}} aktiv',\n  },\n  bg: {\n    placeholder: \"Започнете да пишете или натиснете '/' за команди...\",\n    slashMenuBasicGroupLabel: 'Основен',\n    slashMenuListGroupLabel: 'Списъци',\n    toolbarItemsActive: '{{count}} активни',\n  },\n  cs: {\n    placeholder: \"Začněte psát nebo stiskněte '/' pro příkazy...\",\n    slashMenuBasicGroupLabel: 'Základní',\n    slashMenuListGroupLabel: 'Seznamy',\n    toolbarItemsActive: '{{count}} aktivní',\n  },\n  da: {\n    placeholder: \"Begynd at skrive, eller tryk på '/' for kommandoer...\",\n    slashMenuBasicGroupLabel: 'Grundlæggende',\n    slashMenuListGroupLabel: 'Lister',\n    toolbarItemsActive: '{{count}} aktive',\n  },\n  de: {\n    placeholder: \"Beginne zu tippen oder drücke '/' für Befehle...\",\n    slashMenuBasicGroupLabel: 'Basis',\n    slashMenuListGroupLabel: 'Listen',\n    toolbarItemsActive: '{{count}} aktiv',\n  },\n  en: {\n    placeholder: \"Start typing, or press '/' for commands...\",\n    slashMenuBasicGroupLabel: 'Basic',\n    slashMenuListGroupLabel: 'Lists',\n    toolbarItemsActive: '{{count}} active',\n  },\n  es: {\n    placeholder: \"Comience a escribir, o presione '/' para comandos...\",\n    slashMenuBasicGroupLabel: 'Básico',\n    slashMenuListGroupLabel: 'Listas',\n    toolbarItemsActive: '{{count}} activo',\n  },\n  et: {\n    placeholder: \"Alusta kirjutamist või vajuta '/' käskude jaoks...\",\n    slashMenuBasicGroupLabel: 'Põhiline',\n    slashMenuListGroupLabel: 'Loendid',\n    toolbarItemsActive: '{{count}} aktiivne',\n  },\n  fa: {\n    placeholder: \"شروع به تایپ کنید، یا برای دستورات '/' را فشار دهید ...\",\n    slashMenuBasicGroupLabel: 'پایه',\n    slashMenuListGroupLabel: 'لیست ها',\n    toolbarItemsActive: '{{count}} فعال',\n  },\n  fr: {\n    placeholder: \"Commencez à taper, ou appuyez sur '/' pour les commandes...\",\n    slashMenuBasicGroupLabel: 'De base',\n    slashMenuListGroupLabel: 'Listes',\n    toolbarItemsActive: '{{count}} actif',\n  },\n  he: {\n    placeholder: \"התחיל להקליד, או לחץ על '/' עבור פקודות ...\",\n    slashMenuBasicGroupLabel: 'בסיסי',\n    slashMenuListGroupLabel: 'רשימות',\n    toolbarItemsActive: '{{count}} פעיל',\n  },\n  hr: {\n    placeholder: \"Počnite tipkati, ili pritisnite '/' za naredbe...\",\n    slashMenuBasicGroupLabel: 'Osnovno',\n    slashMenuListGroupLabel: 'Popisi',\n    toolbarItemsActive: '{{count}} aktivno',\n  },\n  hu: {\n    placeholder: \"Kezdje el gépelni, vagy nyomja meg a '/' billentyűt a parancsokhoz...\",\n    slashMenuBasicGroupLabel: 'Alapvető',\n    slashMenuListGroupLabel: 'Listák',\n    toolbarItemsActive: '{{count}} aktív',\n  },\n  it: {\n    placeholder: \"Inizia a digitare, oppure premi '/' per i comandi...\",\n    slashMenuBasicGroupLabel: 'Base',\n    slashMenuListGroupLabel: 'Elenchi',\n    toolbarItemsActive: '{{count}} attivo',\n  },\n  ja: {\n    placeholder: \"入力を開始するか、コマンドのために'/'を押してください…\",\n    slashMenuBasicGroupLabel: '基本的な',\n    slashMenuListGroupLabel: 'リスト',\n    toolbarItemsActive: '{{count}} アクティブ',\n  },\n  ko: {\n    placeholder: \"타이핑을 시작하거나, 명령어를 입력하려면 '/'를 누르세요...\",\n    slashMenuBasicGroupLabel: '기본적인',\n    slashMenuListGroupLabel: '목록',\n    toolbarItemsActive: '{{count}} 활성화된',\n  },\n  my: {\n    placeholder: \"Mula menaip, atau tekan '/' untuk arahan...\",\n    slashMenuBasicGroupLabel: 'အခြေခံ',\n    slashMenuListGroupLabel: 'Senarai',\n    toolbarItemsActive: '{{count}} aktif',\n  },\n  nb: {\n    placeholder: \"Begynn å skrive, eller trykk '/' for kommandoer...\",\n    slashMenuBasicGroupLabel: 'Grunnleggende',\n    slashMenuListGroupLabel: 'Lister',\n    toolbarItemsActive: '{{count}} aktiv',\n  },\n  nl: {\n    placeholder: \"Begin met typen, of druk op '/' voor opdrachten...\",\n    slashMenuBasicGroupLabel: 'Basis',\n    slashMenuListGroupLabel: 'Lijsten',\n    toolbarItemsActive: '{{count}} actief',\n  },\n  pl: {\n    placeholder: \"Rozpocznij pisanie lub naciśnij '/' dla poleceń...\",\n    slashMenuBasicGroupLabel: 'Podstawowy',\n    slashMenuListGroupLabel: 'Listy',\n    toolbarItemsActive: '{{count}} aktywny',\n  },\n  pt: {\n    placeholder: \"Comece a digitar, ou pressione '/' para comandos...\",\n    slashMenuBasicGroupLabel: 'Básico',\n    slashMenuListGroupLabel: 'Listas',\n    toolbarItemsActive: '{{count}} ativo',\n  },\n  ro: {\n    placeholder: \"Începeți să tastați sau apăsați '/' pentru comenzi...\",\n    slashMenuBasicGroupLabel: 'De bază',\n    slashMenuListGroupLabel: 'Liste',\n    toolbarItemsActive: '{{count}} activ',\n  },\n  rs: {\n    placeholder: \"Почните да куцате, или притисните '/' за команде...\",\n    slashMenuBasicGroupLabel: 'Основно',\n    slashMenuListGroupLabel: 'Листе',\n    toolbarItemsActive: '{{count}} активно',\n  },\n  'rs-latin': {\n    placeholder: \"Počnite da kucate, ili pritisnite '/' za komande...\",\n    slashMenuBasicGroupLabel: 'Osnovno',\n    slashMenuListGroupLabel: 'Liste',\n    toolbarItemsActive: '{{count}} aktivan',\n  },\n  ru: {\n    placeholder: \"Начните печатать или нажмите '/' для команд...\",\n    slashMenuBasicGroupLabel: 'Базовый',\n    slashMenuListGroupLabel: 'Списки',\n    toolbarItemsActive: '{{count}} активных',\n  },\n  sk: {\n    placeholder: \"Začnite písať alebo stlačte '/' pre príkazy...\",\n    slashMenuBasicGroupLabel: 'Základný',\n    slashMenuListGroupLabel: 'Zoznamy',\n    toolbarItemsActive: '{{count}} aktívne',\n  },\n  sl: {\n    placeholder: 'Začnite tipkati ali pritisnite \"/\" za ukaze...',\n    slashMenuBasicGroupLabel: 'Osnovno',\n    slashMenuListGroupLabel: 'Seznami',\n    toolbarItemsActive: '{{count}} aktivno',\n  },\n  sv: {\n    placeholder: \"Börja skriva, eller tryck på '/' för kommandon...\",\n    slashMenuBasicGroupLabel: 'Grundläggande',\n    slashMenuListGroupLabel: 'Listor',\n    toolbarItemsActive: '{{count}} aktiv',\n  },\n  th: {\n    placeholder: \"เริ่มพิมพ์หรือกด '/' สำหรับคำสั่ง...\",\n    slashMenuBasicGroupLabel: 'พื้นฐาน',\n    slashMenuListGroupLabel: 'รายการ',\n    toolbarItemsActive: '{{count}} ที่ใช้งานอยู่',\n  },\n  tr: {\n    placeholder: \"Yazmaya başlayın veya komutlar için '/' tuşuna basın...\",\n    slashMenuBasicGroupLabel: 'Temel',\n    slashMenuListGroupLabel: 'Listeler',\n    toolbarItemsActive: '{{count}} aktif',\n  },\n  uk: {\n    placeholder: \"Почніть друкувати, або натисніть '/' для команд...\",\n    slashMenuBasicGroupLabel: 'Базовий',\n    slashMenuListGroupLabel: 'Списки',\n    toolbarItemsActive: '{{count}} активний',\n  },\n  vi: {\n    placeholder: \"Bắt đầu gõ, hoặc nhấn '/' để gọi lệnh...\",\n    slashMenuBasicGroupLabel: 'Cơ bản',\n    slashMenuListGroupLabel: 'Danh sách',\n    toolbarItemsActive: '{{count}} đang hoạt động',\n  },\n  zh: {\n    placeholder: \"开始输入，或按'/'进行命令...\",\n    slashMenuBasicGroupLabel: '基础',\n    slashMenuListGroupLabel: '列表',\n    toolbarItemsActive: '{{count}} 活跃',\n  },\n  'zh-TW': {\n    placeholder: \"開始輸入，或按'/'以使用命令...\",\n    slashMenuBasicGroupLabel: '基本的',\n    slashMenuListGroupLabel: '清單',\n    toolbarItemsActive: '{{count}} 活躍中',\n  },\n}\n"],"names":["i18n","ar","placeholder","slashMenuBasicGroupLabel","slashMenuListGroupLabel","toolbarItemsActive","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","th","tr","uk","vi","zh"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5286, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5292, "column": 0}, "map": {"version":3,"file":"generateImportMap.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/utilities/generateImportMap.tsx"],"sourcesContent":["import type { RichTextAdapter } from 'payload'\n\nimport { genImportMapIterateFields } from 'payload'\n\nimport type { ResolvedServerFeatureMap } from '../features/typesServer.js'\n\nexport const getGenerateImportMap =\n  (args: { resolvedFeatureMap: ResolvedServerFeatureMap }): RichTextAdapter['generateImportMap'] =>\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  ({ addToImportMap, baseDir, config, importMap, imports }) => {\n    addToImportMap('@payloadcms/richtext-lexical/rsc#RscEntryLexicalCell')\n    addToImportMap('@payloadcms/richtext-lexical/rsc#RscEntryLexicalField')\n\n    // iterate just through args.resolvedFeatureMap.values()\n    for (const resolvedFeature of args.resolvedFeatureMap.values()) {\n      if ('componentImports' in resolvedFeature) {\n        if (typeof resolvedFeature.componentImports === 'function') {\n          resolvedFeature.componentImports({\n            addToImportMap,\n            baseDir,\n            config,\n            importMap,\n            imports,\n          })\n        } else if (resolvedFeature.componentImports?.length) {\n          // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n          resolvedFeature.componentImports.forEach((component) => {\n            addToImportMap(component)\n          })\n        }\n      }\n\n      const ClientComponent = resolvedFeature.ClientFeature\n      if (ClientComponent) {\n        addToImportMap(ClientComponent)\n      }\n\n      /*\n        Now run for all possible sub-fields\n       */\n      if (resolvedFeature.nodes?.length) {\n        for (const node of resolvedFeature.nodes) {\n          if (typeof node?.getSubFields !== 'function') {\n            continue\n          }\n          const subFields = node.getSubFields({})\n          if (subFields?.length) {\n            genImportMapIterateFields({\n              addToImportMap,\n              baseDir,\n              config,\n              fields: subFields,\n              importMap,\n              imports,\n            })\n          }\n        }\n      }\n    }\n  }\n"],"names":["genImportMapIterateFields","getGenerateImportMap","args","addToImportMap","baseDir","config","importMap","imports","resolvedFeature","resolvedFeatureMap","values","componentImports","length","forEach","component","ClientComponent","ClientFeature","nodes","node","getSubFields","subFields","fields"],"mappings":";;;AAEA,SAASA,yBAAyB,QAAQ;;AAInC,MAAMC,oBAAA,IACVC,IAAA,GACD,oFAAA;IACA,CAAC,EAAEC,cAAc,EAAEC,OAAO,EAAEC,MAAM,EAAEC,SAAS,EAAEC,OAAAA,EAAS;QACtDJ,cAAA,CAAe;QACfA,cAAA,CAAe;QAEf,wDAAA;QACA,KAAK,MAAMK,eAAA,IAAmBN,IAAA,CAAKO,kBAAkB,CAACC,MAAM,GAAI;YAC9D,IAAI,sBAAsBF,eAAA,EAAiB;gBACzC,IAAI,OAAOA,eAAA,CAAgBG,gBAAgB,KAAK,YAAY;oBAC1DH,eAAA,CAAgBG,gBAAgB,CAAC;wBAC/BR,cAAA;wBACAC,OAAA;wBACAC,MAAA;wBACAC,SAAA;wBACAC;oBACF;gBACF,OAAO,IAAIC,eAAA,CAAgBG,gBAAgB,EAAEC,MAAA,EAAQ;oBACnD,oFAAA;oBACAJ,eAAA,CAAgBG,gBAAgB,CAACE,OAAO,EAAEC,SAAA;wBACxCX,cAAA,CAAeW,SAAA;oBACjB;gBACF;YACF;YAEA,MAAMC,eAAA,GAAkBP,eAAA,CAAgBQ,aAAa;YACrD,IAAID,eAAA,EAAiB;gBACnBZ,cAAA,CAAeY,eAAA;YACjB;YAEA;;OAGA,IAAIP,eAAA,CAAgBS,KAAK,EAAEL,MAAA,EAAQ;gBACjC,KAAK,MAAMM,IAAA,IAAQV,eAAA,CAAgBS,KAAK,CAAE;oBACxC,IAAI,OAAOC,IAAA,EAAMC,YAAA,KAAiB,YAAY;wBAC5C;oBACF;oBACA,MAAMC,SAAA,GAAYF,IAAA,CAAKC,YAAY,CAAC,CAAC;oBACrC,IAAIC,SAAA,EAAWR,MAAA,EAAQ;iaACrBZ,4BAAAA,AAAA,EAA0B;4BACxBG,cAAA;4BACAC,OAAA;4BACAC,MAAA;4BACAgB,MAAA,EAAQD,SAAA;4BACRd,SAAA;4BACAC;wBACF;oBACF;gBACF;YACF;QACF;IACF","ignoreList":[0]}},
    {"offset": {"line": 5345, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5351, "column": 0}, "map": {"version":3,"file":"generateSchemaMap.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/utilities/generateSchemaMap.ts"],"sourcesContent":["import type { RichTextAdapter } from 'payload'\n\nimport { traverseFields } from '@payloadcms/ui/utilities/buildFieldSchemaMap/traverseFields'\n\nimport type { ResolvedServerFeatureMap } from '../features/typesServer.js'\n\nexport const getGenerateSchemaMap =\n  (args: { resolvedFeatureMap: ResolvedServerFeatureMap }): RichTextAdapter['generateSchemaMap'] =>\n  ({ config, field, i18n, schemaMap, schemaPath }) => {\n    for (const [featureKey, resolvedFeature] of args.resolvedFeatureMap.entries()) {\n      if (\n        !('generateSchemaMap' in resolvedFeature) ||\n        typeof resolvedFeature.generateSchemaMap !== 'function'\n      ) {\n        continue\n      }\n      const schemas = resolvedFeature.generateSchemaMap({\n        config,\n        field,\n        i18n,\n        props: resolvedFeature.sanitizedServerFeatureProps,\n        schemaMap,\n        schemaPath,\n      })\n\n      if (schemas) {\n        for (const [schemaKey, field] of schemas.entries()) {\n          if ('fields' in field) {\n            // generate schema map entries for sub-fields using traverseFields\n            traverseFields({\n              config,\n              fields: field.fields,\n              i18n,\n              parentIndexPath: '',\n              parentSchemaPath: `${schemaPath}.lexical_internal_feature.${featureKey}.${schemaKey}`,\n              schemaMap,\n            })\n          }\n\n          schemaMap.set(`${schemaPath}.lexical_internal_feature.${featureKey}.${schemaKey}`, field)\n        }\n      }\n    }\n\n    return schemaMap\n  }\n"],"names":["traverseFields","getGenerateSchemaMap","args","config","field","i18n","schemaMap","schemaPath","featureKey","resolvedFeature","resolvedFeatureMap","entries","generateSchemaMap","schemas","props","sanitizedServerFeatureProps","schemaKey","fields","parentIndexPath","parentSchemaPath","set"],"mappings":";;;AAEA,SAASA,cAAc,QAAQ;;AAIxB,MAAMC,oBAAA,IACVC,IAAA,GACD,CAAC,EAAEC,MAAM,EAAEC,KAAK,EAAEC,IAAI,EAAEC,SAAS,EAAEC,UAAAA,EAAY;QAC7C,KAAK,MAAM,CAACC,UAAA,EAAYC,eAAA,CAAgB,IAAIP,IAAA,CAAKQ,kBAAkB,CAACC,OAAO,GAAI;YAC7E,IACE,CAAA,CAAE,uBAAuBF,eAAc,KACvC,OAAOA,eAAA,CAAgBG,iBAAiB,KAAK,YAC7C;gBACA;YACF;YACA,MAAMC,OAAA,GAAUJ,eAAA,CAAgBG,iBAAiB,CAAC;gBAChDT,MAAA;gBACAC,KAAA;gBACAC,IAAA;gBACAS,KAAA,EAAOL,eAAA,CAAgBM,2BAA2B;gBAClDT,SAAA;gBACAC;YACF;YAEA,IAAIM,OAAA,EAAS;gBACX,KAAK,MAAM,CAACG,SAAA,EAAWZ,KAAA,CAAM,IAAIS,OAAA,CAAQF,OAAO,GAAI;oBAClD,IAAI,YAAYP,KAAA,EAAO;wBACrB,kEAAA;kbACAJ,iBAAAA,AAAA,EAAe;4BACbG,MAAA;4BACAc,MAAA,EAAQb,KAAA,CAAMa,MAAM;4BACpBZ,IAAA;4BACAa,eAAA,EAAiB;4BACjBC,gBAAA,EAAkB,GAAGZ,UAAA,CAAA,0BAAA,EAAuCC,UAAA,CAAA,CAAA,EAAcQ,SAAA,EAAW;4BACrFV;wBACF;oBACF;oBAEAA,SAAA,CAAUc,GAAG,CAAC,GAAGb,UAAA,CAAA,0BAAA,EAAuCC,UAAA,CAAA,CAAA,EAAcQ,SAAA,EAAW,EAAEZ,KAAA;gBACrF;YACF;QACF;QAEA,OAAOE,SAAA;IACT","ignoreList":[0]}},
    {"offset": {"line": 5388, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5394, "column": 0}, "map": {"version":3,"file":"forEachNodeRecursively.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/utilities/forEachNodeRecursively.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\nexport function recurseNodes({\n  callback,\n  nodes,\n}: {\n  callback: (node: SerializedLexicalNode) => void\n  nodes: SerializedLexicalNode[]\n}) {\n  for (const node of nodes) {\n    callback(node)\n\n    if ('children' in node && Array.isArray(node?.children) && node?.children?.length) {\n      recurseNodes({ callback, nodes: node.children as SerializedLexicalNode[] })\n    }\n  }\n}\n\nexport async function recurseNodesAsync({\n  callback,\n  nodes,\n}: {\n  callback: (node: SerializedLexicalNode) => Promise<void>\n  nodes: SerializedLexicalNode[]\n}) {\n  for (const node of nodes) {\n    await callback(node)\n\n    if ('children' in node && Array.isArray(node?.children) && node?.children?.length) {\n      await recurseNodesAsync({ callback, nodes: node.children as SerializedLexicalNode[] })\n    }\n  }\n}\n"],"names":["recurseNodes","callback","nodes","node","Array","isArray","children","length","recurseNodesAsync"],"mappings":";;;;AAEO,SAASA,aAAa,EAC3BC,QAAQ,EACRC,KAAAA,EAID;IACC,KAAK,MAAMC,IAAA,IAAQD,KAAA,CAAO;QACxBD,QAAA,CAASE,IAAA;QAET,IAAI,cAAcA,IAAA,IAAQC,KAAA,CAAMC,OAAO,CAACF,IAAA,EAAMG,QAAA,KAAaH,IAAA,EAAMG,QAAA,EAAUC,MAAA,EAAQ;YACjFP,YAAA,CAAa;gBAAEC,QAAA;gBAAUC,KAAA,EAAOC,IAAA,CAAKG,QAAAA;YAAoC;QAC3E;IACF;AACF;AAEO,eAAeE,kBAAkB,EACtCP,QAAQ,EACRC,KAAAA,EAID;IACC,KAAK,MAAMC,IAAA,IAAQD,KAAA,CAAO;QACxB,MAAMD,QAAA,CAASE,IAAA;QAEf,IAAI,cAAcA,IAAA,IAAQC,KAAA,CAAMC,OAAO,CAACF,IAAA,EAAMG,QAAA,KAAaH,IAAA,EAAMG,QAAA,EAAUC,MAAA,EAAQ;YACjF,MAAMC,iBAAA,CAAkB;gBAAEP,QAAA;gBAAUC,KAAA,EAAOC,IAAA,CAAKG,QAAAA;YAAoC;QACtF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 5420, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5426, "column": 0}, "map": {"version":3,"file":"populateLexicalPopulationPromises.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/populateGraphQL/populateLexicalPopulationPromises.ts"],"sourcesContent":["import type { SerializedEditorState } from 'lexical'\nimport type { RichTextAdapter } from 'payload'\n\nimport type { PopulationPromise } from '../features/typesServer.js'\nimport type { AdapterProps } from '../types.js'\n\nimport { recurseNodes } from '../utilities/forEachNodeRecursively.js'\n\nexport type Args = {\n  editorPopulationPromises: Map<string, Array<PopulationPromise>>\n} & Parameters<\n  NonNullable<RichTextAdapter<SerializedEditorState, AdapterProps>['graphQLPopulationPromises']>\n>[0]\n\n/**\n * Appends all new populationPromises to the populationPromises prop\n */\nexport const populateLexicalPopulationPromises = ({\n  context,\n  currentDepth,\n  depth,\n  draft,\n  editorPopulationPromises,\n  field,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  overrideAccess,\n  populationPromises,\n  req,\n  showHiddenFields,\n  siblingDoc,\n}: Args) => {\n  const shouldPopulate = depth && currentDepth! <= depth\n\n  if (!shouldPopulate) {\n    return\n  }\n\n  recurseNodes({\n    callback: (node) => {\n      const editorPopulationPromisesOfNodeType = editorPopulationPromises?.get(node.type)\n      if (editorPopulationPromisesOfNodeType) {\n        for (const promise of editorPopulationPromisesOfNodeType) {\n          promise({\n            context,\n            currentDepth: currentDepth!,\n            depth,\n            draft,\n            editorPopulationPromises,\n            field,\n            fieldPromises,\n            findMany,\n            flattenLocales,\n            node,\n            overrideAccess: overrideAccess!,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc,\n          })\n        }\n      }\n    },\n\n    nodes: (siblingDoc[field?.name] as SerializedEditorState)?.root?.children ?? [],\n  })\n}\n"],"names":["recurseNodes","populateLexicalPopulationPromises","context","currentDepth","depth","draft","editorPopulationPromises","field","fieldPromises","findMany","flattenLocales","overrideAccess","populationPromises","req","showHiddenFields","siblingDoc","shouldPopulate","callback","node","editorPopulationPromisesOfNodeType","get","type","promise","nodes","name","root","children"],"mappings":";;;AAMA,SAASA,YAAY,QAAQ;;AAWtB,MAAMC,iCAAA,GAAoCA,CAAC,EAChDC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,wBAAwB,EACxBC,KAAK,EACLC,aAAa,EACbC,QAAQ,EACRC,cAAc,EACdC,cAAc,EACdC,kBAAkB,EAClBC,GAAG,EACHC,gBAAgB,EAChBC,UAAAA,EACK;IACL,MAAMC,cAAA,GAAiBZ,KAAA,IAASD,YAAA,IAAiBC,KAAA;IAEjD,IAAI,CAACY,cAAA,EAAgB;QACnB;IACF;yTAEAhB,eAAAA,AAAA,EAAa;QACXiB,QAAA,GAAWC,IAAA;YACT,MAAMC,kCAAA,GAAqCb,wBAAA,EAA0Bc,GAAA,CAAIF,IAAA,CAAKG,IAAI;YAClF,IAAIF,kCAAA,EAAoC;gBACtC,KAAK,MAAMG,OAAA,IAAWH,kCAAA,CAAoC;oBACxDG,OAAA,CAAQ;wBACNpB,OAAA;wBACAC,YAAA,EAAcA,YAAA;wBACdC,KAAA;wBACAC,KAAA;wBACAC,wBAAA;wBACAC,KAAA;wBACAC,aAAA;wBACAC,QAAA;wBACAC,cAAA;wBACAQ,IAAA;wBACAP,cAAA,EAAgBA,cAAA;wBAChBC,kBAAA;wBACAC,GAAA;wBACAC,gBAAA;wBACAC;oBACF;gBACF;YACF;QACF;QAEAQ,KAAA,EAAOR,UAAW,CAACR,KAAA,EAAOiB,IAAA,CAAK,EAA4BC,IAAA,EAAMC,QAAA,IAAY,EAAA;IAC/E;AACF","ignoreList":[0]}},
    {"offset": {"line": 5464, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5470, "column": 0}, "map": {"version":3,"file":"recurseNodeTree.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/utilities/recurseNodeTree.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\n// Initialize both flattenedNodes and nodeIDMap\nexport const recurseNodeTree = ({\n  flattenedNodes,\n  nodeIDMap,\n  nodes,\n}: {\n  flattenedNodes?: SerializedLexicalNode[]\n  nodeIDMap?: {\n    [key: string]: SerializedLexicalNode\n  }\n  nodes: SerializedLexicalNode[]\n}): void => {\n  if (!nodes?.length) {\n    return\n  }\n\n  for (const node of nodes) {\n    if (flattenedNodes) {\n      flattenedNodes.push(node)\n    }\n    if (nodeIDMap) {\n      if (node && 'id' in node && node.id) {\n        nodeIDMap[node.id as string] = node\n      } else if (\n        'fields' in node &&\n        typeof node.fields === 'object' &&\n        node.fields &&\n        'id' in node.fields &&\n        node?.fields?.id\n      ) {\n        nodeIDMap[node.fields.id as string] = node\n      }\n    }\n\n    if ('children' in node && Array.isArray(node?.children) && node?.children?.length) {\n      recurseNodeTree({\n        flattenedNodes,\n        nodeIDMap,\n        nodes: node.children as SerializedLexicalNode[],\n      })\n    }\n  }\n}\n"],"names":["recurseNodeTree","flattenedNodes","nodeIDMap","nodes","length","node","push","id","fields","Array","isArray","children"],"mappings":"AAEA,+CAAA;;;;AACO,MAAMA,eAAA,GAAkBA,CAAC,EAC9BC,cAAc,EACdC,SAAS,EACTC,KAAAA,EAOD;IACC,IAAI,CAACA,KAAA,EAAOC,MAAA,EAAQ;QAClB;IACF;IAEA,KAAK,MAAMC,IAAA,IAAQF,KAAA,CAAO;QACxB,IAAIF,cAAA,EAAgB;YAClBA,cAAA,CAAeK,IAAI,CAACD,IAAA;QACtB;QACA,IAAIH,SAAA,EAAW;YACb,IAAIG,IAAA,IAAQ,QAAQA,IAAA,IAAQA,IAAA,CAAKE,EAAE,EAAE;gBACnCL,SAAS,CAACG,IAAA,CAAKE,EAAE,CAAW,GAAGF,IAAA;YACjC,OAAO,IACL,YAAYA,IAAA,IACZ,OAAOA,IAAA,CAAKG,MAAM,KAAK,YACvBH,IAAA,CAAKG,MAAM,IACX,QAAQH,IAAA,CAAKG,MAAM,IACnBH,IAAA,EAAMG,MAAA,EAAQD,EAAA,EACd;gBACAL,SAAS,CAACG,IAAA,CAAKG,MAAM,CAACD,EAAE,CAAW,GAAGF,IAAA;YACxC;QACF;QAEA,IAAI,cAAcA,IAAA,IAAQI,KAAA,CAAMC,OAAO,CAACL,IAAA,EAAMM,QAAA,KAAaN,IAAA,EAAMM,QAAA,EAAUP,MAAA,EAAQ;YACjFJ,eAAA,CAAgB;gBACdC,cAAA;gBACAC,SAAA;gBACAC,KAAA,EAAOE,IAAA,CAAKM,QAAAA;YACd;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 5498, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5504, "column": 0}, "map": {"version":3,"file":"validateNodes.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/validate/validateNodes.ts"],"sourcesContent":["import type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\nimport type { RichTextField, ValidateOptions } from 'payload'\n\nimport type { NodeValidation } from '../features/typesServer.js'\n\nexport async function validateNodes({\n  nodes,\n  nodeValidations,\n  validation: validationFromProps,\n}: {\n  nodes: SerializedLexicalNode[]\n  nodeValidations: Map<string, Array<NodeValidation>>\n  validation: {\n    options: ValidateOptions<unknown, unknown, RichTextField, SerializedEditorState>\n    value: SerializedEditorState\n  }\n}): Promise<string | true> {\n  for (const node of nodes) {\n    // Validate node\n    const validations = nodeValidations.get(node.type)\n    if (validations) {\n      for (const validation of validations) {\n        const validationResult = await validation({\n          node,\n          nodeValidations,\n          validation: validationFromProps,\n        })\n        if (validationResult !== true) {\n          return `${node.type} node failed to validate: ${validationResult}`\n        }\n      }\n    }\n\n    // Validate node's children\n    if ('children' in node && node?.children) {\n      const childrenValidationResult = await validateNodes({\n        nodes: node.children as SerializedLexicalNode[],\n        nodeValidations,\n        validation: validationFromProps,\n      })\n      if (childrenValidationResult !== true) {\n        return childrenValidationResult\n      }\n    }\n  }\n\n  return true\n}\n"],"names":["validateNodes","nodes","nodeValidations","validation","validationFromProps","node","validations","get","type","validationResult","children","childrenValidationResult"],"mappings":";;;AAKO,eAAeA,cAAc,EAClCC,KAAK,EACLC,eAAe,EACfC,UAAA,EAAYC,mBAAAA,EAQb;IACC,KAAK,MAAMC,IAAA,IAAQJ,KAAA,CAAO;QACxB,gBAAA;QACA,MAAMK,WAAA,GAAcJ,eAAA,CAAgBK,GAAG,CAACF,IAAA,CAAKG,IAAI;QACjD,IAAIF,WAAA,EAAa;YACf,KAAK,MAAMH,UAAA,IAAcG,WAAA,CAAa;gBACpC,MAAMG,gBAAA,GAAmB,MAAMN,UAAA,CAAW;oBACxCE,IAAA;oBACAH,eAAA;oBACAC,UAAA,EAAYC;gBACd;gBACA,IAAIK,gBAAA,KAAqB,MAAM;oBAC7B,OAAO,GAAGJ,IAAA,CAAKG,IAAI,CAAA,0BAAA,EAA6BC,gBAAA,EAAkB;gBACpE;YACF;QACF;QAEA,2BAAA;QACA,IAAI,cAAcJ,IAAA,IAAQA,IAAA,EAAMK,QAAA,EAAU;YACxC,MAAMC,wBAAA,GAA2B,MAAMX,aAAA,CAAc;gBACnDC,KAAA,EAAOI,IAAA,CAAKK,QAAQ;gBACpBR,eAAA;gBACAC,UAAA,EAAYC;YACd;YACA,IAAIO,wBAAA,KAA6B,MAAM;gBACrC,OAAOA,wBAAA;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 5537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5543, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/validate/index.ts"],"sourcesContent":["import type { SerializedEditorState } from 'lexical'\nimport type { RichTextField, Validate } from 'payload'\n\nimport type { SanitizedServerEditorConfig } from '../lexical/config/types.js'\n\nimport { hasText } from './hasText.js'\nimport { validateNodes } from './validateNodes.js'\n\nexport const richTextValidateHOC = ({\n  editorConfig,\n}: {\n  editorConfig: SanitizedServerEditorConfig\n}) => {\n  const richTextValidate: Validate<SerializedEditorState, unknown, unknown, RichTextField> = async (\n    value,\n    options,\n  ) => {\n    const {\n      req: { t },\n      required,\n    } = options\n\n    if (required && hasText(value) === false) {\n      return t('validation:required')\n    }\n\n    // Traverse through nodes and validate them. Just like a node can hook into the population process (e.g. link or relationship nodes),\n    // they can also hook into the validation process. E.g. a block node probably has fields with validation rules.\n\n    const rootNodes = value?.root?.children\n    if (rootNodes && Array.isArray(rootNodes) && rootNodes?.length) {\n      return await validateNodes({\n        nodes: rootNodes,\n        nodeValidations: editorConfig.features.validations,\n        validation: {\n          options,\n          value,\n        },\n      })\n    }\n\n    return true\n  }\n\n  return richTextValidate\n}\n"],"names":["hasText","validateNodes","richTextValidateHOC","editorConfig","richTextValidate","value","options","req","t","required","rootNodes","root","children","Array","isArray","length","nodes","nodeValidations","features","validations","validation"],"mappings":";;;AAKA,SAASA,OAAO,QAAQ;AACxB,SAASC,aAAa,QAAQ;;;AAEvB,MAAMC,mBAAA,GAAsBA,CAAC,EAClCC,YAAAA,EAGD;IACC,MAAMC,gBAAA,GAAqF,MAAAA,CACzFC,KAAA,EACAC,OAAA;QAEA,MAAM,EACJC,GAAA,EAAK,EAAEC,CAAAA,EAAG,EACVC,QAAAA,EACD,GAAGH,OAAA;QAEJ,IAAIG,QAAA,ySAAYT,UAAAA,AAAA,EAAQK,KAAA,MAAW,OAAO;YACxC,OAAOG,CAAA,CAAE;QACX;QAEA,qIAAA;QACA,+GAAA;QAEA,MAAME,SAAA,GAAYL,KAAA,EAAOM,IAAA,EAAMC,QAAA;QAC/B,IAAIF,SAAA,IAAaG,KAAA,CAAMC,OAAO,CAACJ,SAAA,KAAcA,SAAA,EAAWK,MAAA,EAAQ;YAC9D,OAAO,iTAAMd,gBAAAA,AAAA,EAAc;gBACzBe,KAAA,EAAON,SAAA;gBACPO,eAAA,EAAiBd,YAAA,CAAae,QAAQ,CAACC,WAAW;gBAClDC,UAAA,EAAY;oBACVd,OAAA;oBACAD;gBACF;YACF;QACF;QAEA,OAAO;IACT;IAEA,OAAOD,gBAAA;AACT","ignoreList":[0]}},
    {"offset": {"line": 5573, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5579, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/eric/Documents/GitHub/astro-payload-mono/apps/payload/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.23.0_eqwvgicqgksbrwsoebzjhz2hgu/node_modules/%40payloadcms/richtext-lexical/src/index.ts"],"sourcesContent":["import type { JSONSchema4 } from 'json-schema'\nimport type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\n\nimport {\n  afterChangeTraverseFields,\n  afterReadTraverseFields,\n  beforeChangeTraverseFields,\n  beforeValidateTraverseFields,\n  checkDependencies,\n  withNullableJSONSchemaType,\n} from 'payload'\n\nimport type { FeatureProviderServer, ResolvedServerFeatureMap } from './features/typesServer.js'\nimport type { SanitizedServerEditorConfig } from './lexical/config/types.js'\nimport type {\n  AdapterProps,\n  LexicalEditorProps,\n  LexicalRichTextAdapter,\n  LexicalRichTextAdapterProvider,\n} from './types.js'\n\nimport { getDefaultSanitizedEditorConfig } from './getDefaultSanitizedEditorConfig.js'\nimport { i18n } from './i18n.js'\nimport { defaultEditorConfig, defaultEditorFeatures } from './lexical/config/server/default.js'\nimport { loadFeatures } from './lexical/config/server/loader.js'\nimport { sanitizeServerFeatures } from './lexical/config/server/sanitize.js'\nimport { populateLexicalPopulationPromises } from './populateGraphQL/populateLexicalPopulationPromises.js'\nimport { getGenerateImportMap } from './utilities/generateImportMap.js'\nimport { getGenerateSchemaMap } from './utilities/generateSchemaMap.js'\nimport { recurseNodeTree } from './utilities/recurseNodeTree.js'\nimport { richTextValidateHOC } from './validate/index.js'\n\nlet checkedDependencies = false\n\nexport const lexicalTargetVersion = '0.21.0'\n\nexport function lexicalEditor(props?: LexicalEditorProps): LexicalRichTextAdapterProvider {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    process.env.PAYLOAD_DISABLE_DEPENDENCY_CHECKER !== 'true' &&\n    !checkedDependencies\n  ) {\n    checkedDependencies = true\n    void checkDependencies({\n      dependencyGroups: [\n        {\n          name: 'lexical',\n          dependencies: [\n            'lexical',\n            '@lexical/headless',\n            '@lexical/link',\n            '@lexical/list',\n            '@lexical/mark',\n            '@lexical/react',\n            '@lexical/rich-text',\n            '@lexical/selection',\n            '@lexical/utils',\n          ],\n          targetVersion: lexicalTargetVersion,\n        },\n      ],\n    })\n  }\n  return async ({ config, isRoot, parentIsLocalized }) => {\n    let features: FeatureProviderServer<unknown, unknown, unknown>[] = []\n    let resolvedFeatureMap: ResolvedServerFeatureMap\n\n    let finalSanitizedEditorConfig: SanitizedServerEditorConfig // For server only\n    if (!props || (!props.features && !props.lexical)) {\n      finalSanitizedEditorConfig = await getDefaultSanitizedEditorConfig({\n        config,\n        parentIsLocalized,\n      })\n\n      features = defaultEditorFeatures\n\n      resolvedFeatureMap = finalSanitizedEditorConfig.resolvedFeatureMap\n    } else {\n      if (props.features && typeof props.features === 'function') {\n        const rootEditor = config.editor\n        let rootEditorFeatures: FeatureProviderServer<unknown, unknown, unknown>[] = []\n        if (typeof rootEditor === 'object' && 'features' in rootEditor) {\n          rootEditorFeatures = (rootEditor as LexicalRichTextAdapter).features\n        }\n        features = props.features({\n          defaultFeatures: defaultEditorFeatures,\n          rootFeatures: rootEditorFeatures,\n        })\n      } else {\n        features = props.features as FeatureProviderServer<unknown, unknown, unknown>[]\n      }\n\n      if (!features) {\n        features = defaultEditorFeatures\n      }\n\n      const lexical = props.lexical ?? defaultEditorConfig.lexical\n\n      resolvedFeatureMap = await loadFeatures({\n        config,\n        isRoot,\n        parentIsLocalized,\n        unSanitizedEditorConfig: {\n          features,\n          lexical,\n        },\n      })\n\n      finalSanitizedEditorConfig = {\n        features: sanitizeServerFeatures(resolvedFeatureMap),\n        lexical: props.lexical,\n        resolvedFeatureMap,\n      }\n    }\n\n    const featureI18n = finalSanitizedEditorConfig.features.i18n\n    for (const lang in i18n) {\n      if (!featureI18n[lang as keyof typeof featureI18n]) {\n        featureI18n[lang as keyof typeof featureI18n] = {\n          lexical: {},\n        }\n      }\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      featureI18n[lang].lexical.general = i18n[lang]\n    }\n\n    return {\n      CellComponent: {\n        path: '@payloadcms/richtext-lexical/rsc#RscEntryLexicalCell',\n        serverProps: {\n          admin: props?.admin,\n          sanitizedEditorConfig: finalSanitizedEditorConfig,\n        },\n      },\n      editorConfig: finalSanitizedEditorConfig,\n      features,\n      FieldComponent: {\n        path: '@payloadcms/richtext-lexical/rsc#RscEntryLexicalField',\n        serverProps: {\n          admin: props?.admin,\n          sanitizedEditorConfig: finalSanitizedEditorConfig,\n        },\n      },\n      generateImportMap: getGenerateImportMap({\n        resolvedFeatureMap,\n      }),\n      generateSchemaMap: getGenerateSchemaMap({\n        resolvedFeatureMap,\n      }),\n      graphQLPopulationPromises({\n        context,\n        currentDepth,\n        depth,\n        draft,\n        field,\n        fieldPromises,\n        findMany,\n        flattenLocales,\n        overrideAccess,\n        populationPromises,\n        req,\n        showHiddenFields,\n        siblingDoc,\n      }) {\n        // check if there are any features with nodes which have populationPromises for this field\n        if (finalSanitizedEditorConfig?.features?.graphQLPopulationPromises?.size) {\n          populateLexicalPopulationPromises({\n            context,\n            currentDepth: currentDepth ?? 0,\n            depth,\n            draft,\n            editorPopulationPromises: finalSanitizedEditorConfig.features.graphQLPopulationPromises,\n            field,\n            fieldPromises,\n            findMany,\n            flattenLocales,\n            overrideAccess,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc,\n          })\n        }\n      },\n      hooks: {\n        afterChange: [\n          async (args) => {\n            const {\n              collection,\n              context: _context,\n              data,\n              global,\n              indexPath,\n              operation,\n              originalDoc,\n              path,\n              previousDoc,\n              previousValue,\n              req,\n              schemaPath,\n            } = args\n\n            let { value } = args\n            if (finalSanitizedEditorConfig?.features?.hooks?.afterChange?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.afterChange) {\n                value = await hook(args)\n              }\n            }\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n            // TO-DO: We should not use context, as it is intended for external use only\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const context: any = _context\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            const previousNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            /**\n             * Get the originalNodeIDMap from the beforeValidate hook, which is always run before this hook.\n             */\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = context?.internal?.richText?.[path.join('.')]?.originalNodeIDMap\n\n            if (!originalNodeIDMap || !Object.keys(originalNodeIDMap).length || !value) {\n              return value\n            }\n\n            recurseNodeTree({\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            recurseNodeTree({\n              nodeIDMap: previousNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const afterChangeHooks = finalSanitizedEditorConfig.features.nodeHooks?.afterChange\n              const afterChangeHooksForNode = afterChangeHooks?.get(node.type)\n              if (afterChangeHooksForNode) {\n                for (const hook of afterChangeHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(afterChange) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    previousNode: previousNodeIDMap[id]!,\n                    req,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n                const nodeSiblingDoc = subFieldDataFn({ node: originalNodeIDMap[id]!, req }) ?? {}\n                const nodePreviousSiblingDoc =\n                  subFieldDataFn({ node: previousNodeIDMap[id]!, req }) ?? {}\n\n                if (subFields?.length) {\n                  await afterChangeTraverseFields({\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    data: data ?? {},\n                    doc: originalDoc,\n                    fields: subFields,\n                    global,\n                    operation,\n                    parentIndexPath: indexPath.join('-'),\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    previousDoc,\n                    previousSiblingDoc: { ...nodePreviousSiblingDoc },\n                    req,\n                    siblingData: nodeSiblingData || {},\n                    siblingDoc: { ...nodeSiblingDoc },\n                  })\n                }\n              }\n            }\n            return value\n          },\n        ],\n        afterRead: [\n          /**\n           * afterRead hooks do not receive the originalNode. Thus, they can run on all nodes, not just nodes with an ID.\n           */\n          async (args) => {\n            const {\n              collection,\n              context: context,\n              currentDepth,\n              depth,\n              draft,\n              fallbackLocale,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              indexPath,\n              locale,\n              originalDoc,\n              overrideAccess,\n              path,\n              populate,\n              populationPromises,\n              req,\n              schemaPath,\n              showHiddenFields,\n              triggerAccessControl,\n              triggerHooks,\n            } = args\n\n            let { value } = args\n\n            if (finalSanitizedEditorConfig?.features?.hooks?.afterRead?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.afterRead) {\n                value = await hook(args)\n              }\n            }\n\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterRead?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n            const flattenedNodes: SerializedLexicalNode[] = []\n\n            recurseNodeTree({\n              flattenedNodes,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            for (let node of flattenedNodes) {\n              const afterReadHooks = finalSanitizedEditorConfig.features.nodeHooks?.afterRead\n              const afterReadHooksForNode = afterReadHooks?.get(node.type)\n              if (afterReadHooksForNode) {\n                for (const hook of afterReadHooksForNode) {\n                  node = await hook({\n                    context,\n                    currentDepth: currentDepth!,\n                    depth: depth!,\n                    draft: draft!,\n                    fallbackLocale: fallbackLocale!,\n                    fieldPromises: fieldPromises!,\n                    findMany: findMany!,\n                    flattenLocales: flattenLocales!,\n                    locale: locale!,\n                    node,\n                    overrideAccess: overrideAccess!,\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    populateArg: populate,\n                    populationPromises: populationPromises!,\n                    req,\n                    showHiddenFields: showHiddenFields!,\n                    triggerAccessControl: triggerAccessControl!,\n                    triggerHooks: triggerHooks!,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n\n                if (subFields?.length) {\n                  afterReadTraverseFields({\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    currentDepth: currentDepth!,\n                    depth: depth!,\n                    doc: originalDoc,\n                    draft: draft!,\n                    fallbackLocale: fallbackLocale!,\n                    fieldPromises: fieldPromises!,\n                    fields: subFields,\n                    findMany: findMany!,\n                    flattenLocales: flattenLocales!,\n                    global,\n                    locale: locale!,\n                    overrideAccess: overrideAccess!,\n                    parentIndexPath: indexPath.join('-'),\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    populate,\n                    populationPromises: populationPromises!,\n                    req,\n                    showHiddenFields: showHiddenFields!,\n                    siblingDoc: nodeSiblingData,\n                    triggerAccessControl,\n                    triggerHooks,\n                  })\n                }\n              }\n            }\n\n            return value\n          },\n        ],\n        beforeChange: [\n          async (args) => {\n            const {\n              collection,\n              context: _context,\n              data,\n              docWithLocales,\n              errors,\n              field,\n              global,\n              indexPath,\n              mergeLocaleActions,\n              operation,\n              originalDoc,\n              path,\n              previousValue,\n              req,\n              schemaPath,\n              siblingData,\n              siblingDocWithLocales,\n              skipValidation,\n            } = args\n\n            let { value } = args\n\n            if (finalSanitizedEditorConfig?.features?.hooks?.beforeChange?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.beforeChange) {\n                value = await hook(args)\n              }\n            }\n\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n\n            // TO-DO: We should not use context, as it is intended for external use only\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const context: any = _context\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            /**\n             * Get the originalNodeIDMap from the beforeValidate hook, which is always run before this hook.\n             */\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = context?.internal?.richText?.[path.join('.')]?.originalNodeIDMap\n\n            if (!originalNodeIDMap || !Object.keys(originalNodeIDMap).length || !value) {\n              return value\n            }\n            const previousNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n            const originalNodeWithLocalesIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            recurseNodeTree({\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            recurseNodeTree({\n              nodeIDMap: previousNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n            if (field.name && siblingDocWithLocales?.[field.name]) {\n              recurseNodeTree({\n                nodeIDMap: originalNodeWithLocalesIDMap,\n                nodes:\n                  (siblingDocWithLocales[field.name] as SerializedEditorState)?.root?.children ??\n                  [],\n              })\n            }\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const beforeChangeHooks = finalSanitizedEditorConfig.features.nodeHooks?.beforeChange\n              const beforeChangeHooksForNode = beforeChangeHooks?.get(node.type)\n              if (beforeChangeHooksForNode) {\n                for (const hook of beforeChangeHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(beforeChange) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    errors: errors!,\n                    mergeLocaleActions: mergeLocaleActions!,\n                    node,\n                    operation: operation!,\n                    originalNode: originalNodeIDMap[id],\n                    originalNodeWithLocales: originalNodeWithLocalesIDMap[id],\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    previousNode: previousNodeIDMap[id]!,\n                    req,\n                    skipValidation: skipValidation!,\n                  })\n                }\n              }\n\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n                const nodeSiblingDocWithLocales =\n                  subFieldDataFn({\n                    node: originalNodeWithLocalesIDMap[id]!,\n                    req,\n                  }) ?? {}\n                const nodePreviousSiblingDoc =\n                  subFieldDataFn({ node: previousNodeIDMap[id]!, req }) ?? {}\n\n                if (subFields?.length) {\n                  await beforeChangeTraverseFields({\n                    id,\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    data: data ?? {},\n                    doc: originalDoc ?? {},\n                    docWithLocales: docWithLocales ?? {},\n                    errors: errors!,\n                    fields: subFields,\n                    global,\n                    mergeLocaleActions: mergeLocaleActions!,\n                    operation: operation!,\n                    parentIndexPath: indexPath.join('-'),\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    req,\n                    siblingData: nodeSiblingData,\n                    siblingDoc: nodePreviousSiblingDoc,\n                    siblingDocWithLocales: nodeSiblingDocWithLocales ?? {},\n                    skipValidation,\n                  })\n                }\n              }\n            }\n\n            /**\n             * within the beforeChange hook, id's may be re-generated.\n             * Example:\n             * 1. Seed data contains IDs for block feature blocks.\n             * 2. Those are used in beforeValidate\n             * 3. in beforeChange, those IDs are regenerated, because you cannot provide IDs during document creation. See baseIDField beforeChange hook for reasoning\n             * 4. Thus, in order for all post-beforeChange hooks to receive the correct ID, we need to update the originalNodeIDMap with the new ID's, by regenerating the nodeIDMap.\n             * The reason this is not generated for every hook, is to save on performance. We know we only really have to generate it in beforeValidate, which is the first hook,\n             * and in beforeChange, which is where modifications to the provided IDs can occur.\n             */\n            const newOriginalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            const previousOriginalValue = siblingData[field.name!]\n\n            recurseNodeTree({\n              nodeIDMap: newOriginalNodeIDMap,\n              nodes: (previousOriginalValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (!context.internal) {\n              // Add to context, for other hooks to use\n              context.internal = {}\n            }\n            if (!context.internal.richText) {\n              context.internal.richText = {}\n            }\n            context.internal.richText[path.join('.')] = {\n              originalNodeIDMap: newOriginalNodeIDMap,\n            }\n\n            return value\n          },\n        ],\n        beforeValidate: [\n          async (args) => {\n            const {\n              collection,\n              context,\n              data,\n              global,\n              indexPath,\n              operation,\n              originalDoc,\n              overrideAccess,\n              path,\n              previousValue,\n              req,\n              schemaPath,\n            } = args\n\n            let { value } = args\n            if (finalSanitizedEditorConfig?.features?.hooks?.beforeValidate?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.beforeValidate) {\n                value = await hook(args)\n              }\n            }\n\n            // return value if there are NO hooks\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeValidate?.size &&\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterChange?.size &&\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n\n            /**\n             * beforeValidate is the first field hook which runs. This is where we can create the node map, which can then be used in the other hooks.\n             *\n             */\n\n            /**\n             * flattenedNodes contains all nodes in the editor, in the order they appear in the editor. They will be used for the following hooks:\n             * - afterRead\n             *\n             * The other hooks require nodes to have IDs, which is why those are ran only from the nodeIDMap. They require IDs because they have both doc/siblingDoc and data/siblingData, and\n             * thus require a reliable way to match new node data to old node data. Given that node positions can change in between hooks, this is only reliably possible for nodes which are saved with\n             * an ID.\n             */\n            //const flattenedNodes: SerializedLexicalNode[] = []\n\n            /**\n             * Only nodes with id's (so, nodes with hooks added to them) will be added to the nodeIDMap. They will be used for the following hooks:\n             * - afterChange\n             * - beforeChange\n             * - beforeValidate\n             *\n             * Other hooks are handled by the flattenedNodes. All nodes in the nodeIDMap are part of flattenedNodes.\n             */\n\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            recurseNodeTree({\n              nodeIDMap: originalNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (!context.internal) {\n              // Add to context, for other hooks to use\n              context.internal = {}\n            }\n            if (!(context as any).internal.richText) {\n              ;(context as any).internal.richText = {}\n            }\n            ;(context as any).internal.richText[path.join('.')] = {\n              originalNodeIDMap,\n            }\n\n            /**\n             * Now that the maps for all hooks are set up, we can run the validate hook\n             */\n            if (!finalSanitizedEditorConfig.features.nodeHooks?.beforeValidate?.size) {\n              return value\n            }\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n            recurseNodeTree({\n              //flattenedNodes,\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const beforeValidateHooks =\n                finalSanitizedEditorConfig.features.nodeHooks.beforeValidate\n              const beforeValidateHooksForNode = beforeValidateHooks?.get(node.type)\n              if (beforeValidateHooksForNode) {\n                for (const hook of beforeValidateHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(beforeValidate) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    overrideAccess: overrideAccess!,\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    req,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n                const nodeSiblingDoc = subFieldDataFn({ node: originalNodeIDMap[id]!, req }) ?? {}\n\n                if (subFields?.length) {\n                  await beforeValidateTraverseFields({\n                    id,\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    data,\n                    doc: originalDoc,\n                    fields: subFields,\n                    global,\n                    operation,\n                    overrideAccess: overrideAccess!,\n                    parentIndexPath: indexPath.join('-'),\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    req,\n                    siblingData: nodeSiblingData,\n                    siblingDoc: nodeSiblingDoc,\n                  })\n                }\n              }\n            }\n\n            return value\n          },\n        ],\n      },\n      i18n: featureI18n,\n      outputSchema: ({\n        collectionIDFieldTypes,\n        config,\n        field,\n        i18n,\n        interfaceNameDefinitions,\n        isRequired,\n      }) => {\n        let outputSchema: JSONSchema4 = {\n          // This schema matches the SerializedEditorState type so far, that it's possible to cast SerializedEditorState to this schema without any errors.\n          // In the future, we should\n          // 1) allow recursive children\n          // 2) Pass in all the different types for every node added to the editorconfig. This can be done with refs in the schema.\n          type: withNullableJSONSchemaType('object', isRequired),\n          properties: {\n            root: {\n              type: 'object',\n              additionalProperties: false,\n              properties: {\n                type: {\n                  type: 'string',\n                },\n                children: {\n                  type: 'array',\n                  items: {\n                    type: 'object',\n                    additionalProperties: true,\n                    properties: {\n                      type: {\n                        type: 'string',\n                      },\n                      version: {\n                        type: 'integer',\n                      },\n                    },\n                    required: ['type', 'version'],\n                  },\n                },\n                direction: {\n                  oneOf: [\n                    {\n                      enum: ['ltr', 'rtl'],\n                    },\n                    {\n                      type: 'null',\n                    },\n                  ],\n                },\n                format: {\n                  type: 'string',\n                  enum: ['left', 'start', 'center', 'right', 'end', 'justify', ''], // ElementFormatType, since the root node is an element\n                },\n                indent: {\n                  type: 'integer',\n                },\n                version: {\n                  type: 'integer',\n                },\n              },\n              required: ['children', 'direction', 'format', 'indent', 'type', 'version'],\n            },\n          },\n          required: ['root'],\n        }\n        for (const modifyOutputSchema of finalSanitizedEditorConfig.features.generatedTypes\n          .modifyOutputSchemas) {\n          outputSchema = modifyOutputSchema({\n            collectionIDFieldTypes,\n            config,\n            currentSchema: outputSchema,\n            field,\n            i18n,\n            interfaceNameDefinitions,\n            isRequired,\n          })\n        }\n\n        return outputSchema\n      },\n      validate: richTextValidateHOC({\n        editorConfig: finalSanitizedEditorConfig,\n      }),\n    }\n  }\n}\n\nexport { AlignFeature } from './features/align/server/index.js'\nexport { BlockquoteFeature } from './features/blockquote/server/index.js'\nexport { BlocksFeature, type BlocksFeatureProps } from './features/blocks/server/index.js'\nexport {\n  $createServerBlockNode,\n  $isServerBlockNode,\n  type BlockFields,\n  ServerBlockNode,\n} from './features/blocks/server/nodes/BlocksNode.js'\n\nexport { LinebreakHTMLConverter } from './features/converters/html/converter/converters/linebreak.js'\nexport { ParagraphHTMLConverter } from './features/converters/html/converter/converters/paragraph.js'\n\nexport { TabHTMLConverter } from './features/converters/html/converter/converters/tab.js'\n\nexport { TextHTMLConverter } from './features/converters/html/converter/converters/text.js'\nexport { defaultHTMLConverters } from './features/converters/html/converter/defaultConverters.js'\nexport {\n  convertLexicalNodesToHTML,\n  convertLexicalToHTML,\n} from './features/converters/html/converter/index.js'\n\nexport type { HTMLConverter } from './features/converters/html/converter/types.js'\nexport { consolidateHTMLConverters, lexicalHTML } from './features/converters/html/field/index.js'\nexport {\n  HTMLConverterFeature,\n  type HTMLConverterFeatureProps,\n} from './features/converters/html/index.js'\nexport { TestRecorderFeature } from './features/debug/testRecorder/server/index.js'\nexport { TreeViewFeature } from './features/debug/treeView/server/index.js'\nexport { EXPERIMENTAL_TableFeature } from './features/experimental_table/server/index.js'\nexport { BoldFeature } from './features/format/bold/feature.server.js'\nexport { InlineCodeFeature } from './features/format/inlineCode/feature.server.js'\nexport { ItalicFeature } from './features/format/italic/feature.server.js'\n\nexport { StrikethroughFeature } from './features/format/strikethrough/feature.server.js'\nexport { SubscriptFeature } from './features/format/subscript/feature.server.js'\nexport { SuperscriptFeature } from './features/format/superscript/feature.server.js'\nexport { UnderlineFeature } from './features/format/underline/feature.server.js'\nexport { HeadingFeature, type HeadingFeatureProps } from './features/heading/server/index.js'\nexport { HorizontalRuleFeature } from './features/horizontalRule/server/index.js'\nexport { IndentFeature } from './features/indent/server/index.js'\n\nexport { AutoLinkNode } from './features/link/nodes/AutoLinkNode.js'\n\nexport { LinkNode } from './features/link/nodes/LinkNode.js'\nexport type { LinkFields } from './features/link/nodes/types.js'\nexport { LinkFeature, type LinkFeatureServerProps } from './features/link/server/index.js'\nexport { ChecklistFeature } from './features/lists/checklist/server/index.js'\nexport { OrderedListFeature } from './features/lists/orderedList/server/index.js'\nexport { UnorderedListFeature } from './features/lists/unorderedList/server/index.js'\n\nexport type {\n  SlateNode,\n  SlateNodeConverter,\n} from './features/migrations/slateToLexical/converter/types.js'\n\nexport { ParagraphFeature } from './features/paragraph/server/index.js'\nexport {\n  RelationshipFeature,\n  type RelationshipFeatureProps,\n} from './features/relationship/server/index.js'\nexport {\n  type RelationshipData,\n  RelationshipServerNode,\n} from './features/relationship/server/nodes/RelationshipNode.js'\n\nexport { FixedToolbarFeature } from './features/toolbars/fixed/server/index.js'\nexport { InlineToolbarFeature } from './features/toolbars/inline/server/index.js'\n\nexport type { ToolbarGroup, ToolbarGroupItem } from './features/toolbars/types.js'\nexport type {\n  BaseClientFeatureProps,\n  ClientFeature,\n  ClientFeatureProviderMap,\n  FeatureProviderClient,\n  FeatureProviderProviderClient,\n  PluginComponent,\n  PluginComponentWithAnchor,\n  ResolvedClientFeature,\n  ResolvedClientFeatureMap,\n  SanitizedClientFeatures,\n  SanitizedPlugin,\n} from './features/typesClient.js'\nexport type {\n  AfterChangeNodeHook,\n  AfterChangeNodeHookArgs,\n  AfterReadNodeHook,\n  AfterReadNodeHookArgs,\n  BaseNodeHookArgs,\n  BeforeChangeNodeHook,\n  BeforeChangeNodeHookArgs,\n  BeforeValidateNodeHook,\n  BeforeValidateNodeHookArgs,\n  FeatureProviderProviderServer,\n  FeatureProviderServer,\n  NodeValidation,\n  NodeWithHooks,\n  PopulationPromise,\n  ResolvedServerFeature,\n  ResolvedServerFeatureMap,\n  SanitizedServerFeatures,\n  ServerFeature,\n  ServerFeatureProviderMap,\n} from './features/typesServer.js'\n\nexport { createNode } from './features/typeUtilities.js' // Only useful in feature.server.ts\n\nexport { UploadFeature } from './features/upload/server/feature.server.js'\n\nexport type { UploadFeatureProps } from './features/upload/server/feature.server.js'\nexport { type UploadData, UploadServerNode } from './features/upload/server/nodes/UploadNode.js'\n\nexport type { EditorConfigContextType } from './lexical/config/client/EditorConfigProvider.js'\nexport {\n  defaultEditorConfig,\n  defaultEditorFeatures,\n  defaultEditorLexicalConfig,\n} from './lexical/config/server/default.js'\n\nexport { loadFeatures, sortFeaturesForOptimalLoading } from './lexical/config/server/loader.js'\nexport {\n  sanitizeServerEditorConfig,\n  sanitizeServerFeatures,\n} from './lexical/config/server/sanitize.js'\n\nexport type {\n  ClientEditorConfig,\n  SanitizedClientEditorConfig,\n  SanitizedServerEditorConfig,\n  ServerEditorConfig,\n} from './lexical/config/types.js'\nexport { getEnabledNodes, getEnabledNodesFromServerNodes } from './lexical/nodes/index.js'\nexport type { AdapterProps }\n\nexport type {\n  SlashMenuGroup,\n  SlashMenuItem,\n} from './lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/types.js'\n\nexport {\n  DETAIL_TYPE_TO_DETAIL,\n  DOUBLE_LINE_BREAK,\n  ELEMENT_FORMAT_TO_TYPE,\n  ELEMENT_TYPE_TO_FORMAT,\n  IS_ALL_FORMATTING,\n  LTR_REGEX,\n  NodeFormat,\n  NON_BREAKING_SPACE,\n  RTL_REGEX,\n  TEXT_MODE_TO_TYPE,\n  TEXT_TYPE_TO_FORMAT,\n  TEXT_TYPE_TO_MODE,\n} from './lexical/utils/nodeFormat.js'\nexport { sanitizeUrl, validateUrl } from './lexical/utils/url.js'\n\nexport type * from './nodeTypes.js'\n\nexport { $convertFromMarkdownString } from './packages/@lexical/markdown/index.js'\n\nexport { defaultRichTextValue } from './populateGraphQL/defaultValue.js'\nexport { populate } from './populateGraphQL/populate.js'\nexport type { LexicalEditorProps, LexicalRichTextAdapter } from './types.js'\n\nexport { createServerFeature } from './utilities/createServerFeature.js'\n\nexport type { FieldsDrawerProps } from './utilities/fieldsDrawer/Drawer.js'\nexport { extractPropsFromJSXPropsString } from './utilities/jsx/extractPropsFromJSXPropsString.js'\nexport {\n  extractFrontmatter,\n  frontmatterToObject,\n  objectToFrontmatter,\n  propsToJSXString,\n} from './utilities/jsx/jsx.js'\nexport { upgradeLexicalData } from './utilities/upgradeLexicalData/index.js'\n"],"names":["afterChangeTraverseFields","afterReadTraverseFields","beforeChangeTraverseFields","beforeValidateTraverseFields","checkDependencies","withNullableJSONSchemaType","getDefaultSanitizedEditorConfig","i18n","defaultEditorConfig","defaultEditorFeatures","loadFeatures","sanitizeServerFeatures","populateLexicalPopulationPromises","getGenerateImportMap","getGenerateSchemaMap","recurseNodeTree","richTextValidateHOC","checkedDependencies","lexicalTargetVersion","lexicalEditor","props","process","env","NODE_ENV","PAYLOAD_DISABLE_DEPENDENCY_CHECKER","dependencyGroups","name","dependencies","targetVersion","config","isRoot","parentIsLocalized","features","resolvedFeatureMap","finalSanitizedEditorConfig","lexical","rootEditor","editor","rootEditorFeatures","defaultFeatures","rootFeatures","unSanitizedEditorConfig","featureI18n","lang","general","CellComponent","path","serverProps","admin","sanitizedEditorConfig","editorConfig","FieldComponent","generateImportMap","generateSchemaMap","graphQLPopulationPromises","context","currentDepth","depth","draft","field","fieldPromises","findMany","flattenLocales","overrideAccess","populationPromises","req","showHiddenFields","siblingDoc","size","editorPopulationPromises","hooks","afterChange","args","collection","_context","data","global","indexPath","operation","originalDoc","previousDoc","previousValue","schemaPath","value","length","hook","nodeHooks","getSubFields","nodeIDMap","previousNodeIDMap","originalNodeIDMap","internal","richText","join","Object","keys","nodes","root","children","id","node","entries","afterChangeHooks","afterChangeHooksForNode","get","type","console","warn","originalNode","parentRichTextFieldPath","parentRichTextFieldSchemaPath","previousNode","subFieldFn","subFieldDataFn","getSubFieldsData","subFields","nodeSiblingData","nodeSiblingDoc","nodePreviousSiblingDoc","blockData","doc","fields","parentIndexPath","parentPath","parentSchemaPath","previousSiblingDoc","siblingData","afterRead","fallbackLocale","locale","populate","triggerAccessControl","triggerHooks","flattenedNodes","afterReadHooks","afterReadHooksForNode","populateArg","beforeChange","docWithLocales","errors","mergeLocaleActions","siblingDocWithLocales","skipValidation","originalNodeWithLocalesIDMap","beforeChangeHooks","beforeChangeHooksForNode","originalNodeWithLocales","nodeSiblingDocWithLocales","newOriginalNodeIDMap","previousOriginalValue","beforeValidate","beforeValidateHooks","beforeValidateHooksForNode","outputSchema","collectionIDFieldTypes","interfaceNameDefinitions","isRequired","properties","additionalProperties","items","version","required","direction","oneOf","enum","format","indent","modifyOutputSchema","generatedTypes","modifyOutputSchemas","currentSchema","validate","AlignFeature","BlockquoteFeature","BlocksFeature","$createServerBlockNode","$isServerBlockNode","ServerBlockNode","LinebreakHTMLConverter","ParagraphHTMLConverter","TabHTMLConverter","TextHTMLConverter","defaultHTMLConverters","convertLexicalNodesToHTML","convertLexicalToHTML","consolidateHTMLConverters","lexicalHTML","HTMLConverterFeature","TestRecorderFeature","TreeViewFeature","EXPERIMENTAL_TableFeature","BoldFeature","InlineCodeFeature","ItalicFeature","StrikethroughFeature","SubscriptFeature","SuperscriptFeature","UnderlineFeature","HeadingFeature","HorizontalRuleFeature","IndentFeature","AutoLinkNode","LinkNode","LinkFeature","ChecklistFeature","OrderedListFeature","UnorderedListFeature","ParagraphFeature","RelationshipFeature","RelationshipServerNode","FixedToolbarFeature","InlineToolbarFeature","createNode","UploadFeature","UploadServerNode","defaultEditorLexicalConfig","sortFeaturesForOptimalLoading","sanitizeServerEditorConfig","getEnabledNodes","getEnabledNodesFromServerNodes","DETAIL_TYPE_TO_DETAIL","DOUBLE_LINE_BREAK","ELEMENT_FORMAT_TO_TYPE","ELEMENT_TYPE_TO_FORMAT","IS_ALL_FORMATTING","LTR_REGEX","NodeFormat","NON_BREAKING_SPACE","RTL_REGEX","TEXT_MODE_TO_TYPE","TEXT_TYPE_TO_FORMAT","TEXT_TYPE_TO_MODE","sanitizeUrl","validateUrl","$convertFromMarkdownString","defaultRichTextValue","createServerFeature","extractPropsFromJSXPropsString","extractFrontmatter","frontmatterToObject","objectToFrontmatter","propsToJSXString","upgradeLexicalData"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6338, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}